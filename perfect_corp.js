webpackJsonpYMK([14],{

/***/ 1011:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1012);
module.exports = __webpack_require__(9).Math.log2;


/***/ }),

/***/ 1012:
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(22);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),

/***/ 1097:
/***/ (function(module, exports, __webpack_require__) {

var createRound = __webpack_require__(200);

/**
 * Computes `number` rounded up to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round up.
 * @param {number} [precision=0] The precision to round up to.
 * @returns {number} Returns the rounded up number.
 * @example
 *
 * _.ceil(4.006);
 * // => 5
 *
 * _.ceil(6.004, 2);
 * // => 6.01
 *
 * _.ceil(6040, -2);
 * // => 6100
 */
var ceil = createRound('ceil');

module.exports = ceil;


/***/ }),

/***/ 1250:
/***/ (function(module, exports, __webpack_require__) {

var baseSum = __webpack_require__(1251),
    identity = __webpack_require__(64);

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

module.exports = sum;


/***/ }),

/***/ 1251:
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

module.exports = baseSum;


/***/ }),

/***/ 1988:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _AbstractMediaSource2 = __webpack_require__(817);

var _AbstractMediaSource3 = _interopRequireDefault(_AbstractMediaSource2);

var _settings = __webpack_require__(39);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _currenteffectsholder = __webpack_require__(23);

var _currenteffectsholder2 = _interopRequireDefault(_currenteffectsholder);

var _tfjsUtils = __webpack_require__(105);

var _tfjsUtils2 = _interopRequireDefault(_tfjsUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_LOOKS = 4;
var FINGER_NUM = 5;
var FINGERS = ['thumb', 'index_finger', 'middle_finger', 'ring_finger', 'little_finger'];

var MediaSource = function (_AbstractMediaSource) {
  (0, _inherits3.default)(MediaSource, _AbstractMediaSource);

  function MediaSource(params) {
    var _this2 = this;

    (0, _classCallCheck3.default)(this, MediaSource);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MediaSource.__proto__ || (0, _getPrototypeOf2.default)(MediaSource)).call(this, params));

    _this.isChooseModel = function () {
      return false;
    };

    _this.getEyebrowPoints = function () {
      return false;
    };

    _this.setEyebrowPoints = function () {};

    _this.getLandmarks = function () {
      return [];
    };

    _this.getConvertedZoomRatio = function () {
      switch (_this.zoomLevel) {
        case 3:
          return 1.3;
        case 2:
          return 1.2;
        case 1:
          return 1.1;
        default:
          return 1.0;
      }
    };

    _this.update = function () {};

    _this.splitFourWay = function () {
      _this.zoomLevel = 0;
    };

    _this.splitFourWayOff = function () {};

    _this.isComparing = function () {
      return _this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE];
    };

    _this.compare = function () {
      _this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE] = true;
      _this.m_feature_enable_arrays[1][_featureenum2.default.FEATURE_COMPARE] = true;
      if (_this.settings.compareMode === _settings.compareModes.split) {
        _this.compareIndicator.style.display = 'block';
      }
      _this.throttledUpdate ? _this.throttledUpdate() : _this.update();
    };

    _this.compareOff = function () {
      _this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE] = false;
      _this.m_feature_enable_arrays[1][_featureenum2.default.FEATURE_COMPARE] = false;
      _this.compareIndicator.style.display = 'none';
    };

    _this.zoom = function (zoomLevel) {
      _this.zoomLevel = zoomLevel;
      _this.zoomWebGLRender(_mediaUtils2.default.getZoomRatio(zoomLevel));
      _this.dragCompareIndicator(_this.x);
      _this.throttledUpdate ? _this.throttledUpdate() : _this.update();
    };

    _this.dragCompareIndicator = function () {};

    _this.pause = function () {};

    _this.record = new _promise2.default(function (resolve) {
      return resolve(false);
    });

    _this.resume = function () {};

    _this.drawPoints = _mediaUtils2.default.drawPoints;

    _this.createVectorInt = function () {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _this.YMKModule.CreateVector_int(_this.YMKModule.MAX_DETECTED_FACE_COUNT, value);
    };

    _this.createVectorBool = function () {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return _this.YMKModule.CreateVector_BOOL(_this.YMKModule.MAX_DETECTED_FACE_COUNT, value);
    };

    _this.is_prev_hand_small = function () {
      return _this.hand_ar_metadata.detection_result === _this.YMKModule.VN_VTO_RESULT.VTO_FAIL_HAND_TOO_SMALL;
    };

    _this._trackNail1stPassWithROI = function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(width, height, frame_buffer) {
        var roi_x, roi_y, roi_width, roi_height, _ref2, heatmap_array, size_array, heatmap_width, heatmap_height, visible_array, input_buffer, input_width, input_height, heatmap_buffer, size_buffer, visible_buffer, segment_size, segment_resize_ratio, segment_width, segment_height;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                roi_x = new _this.YMKModule.IntObject();
                roi_y = new _this.YMKModule.IntObject();
                roi_width = new _this.YMKModule.IntObject();
                roi_height = new _this.YMKModule.IntObject();

                _this.venus_makeup_live.GetNailDetectROI1stPass(width, height, roi_x, roi_y, roi_width, roi_height);

                if (!(roi_width.value < 64 || roi_height.value < 64)) {
                  _context.next = 13;
                  break;
                }

                roi_x.delete();
                roi_y.delete();
                roi_width.delete();
                roi_height.delete();
                _context.next = 12;
                return _this._trackNail1stPass(width, height, frame_buffer);

              case 12:
                return _context.abrupt('return', _context.sent);

              case 13:
                _context.next = 15;
                return _this.handTrackingManager.detectNail1stPass(_this._cropFrameBilinear, width, height, roi_x.value, roi_y.value, roi_width.value, roi_height.value);

              case 15:
                _ref2 = _context.sent;
                heatmap_array = _ref2.heatmap_array;
                size_array = _ref2.size_array;
                heatmap_width = _ref2.heatmap_width;
                heatmap_height = _ref2.heatmap_height;
                visible_array = _ref2.visible_array;
                input_buffer = _ref2.input_buffer;
                input_width = _ref2.input_width;
                input_height = _ref2.input_height;
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);

                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);

                visible_buffer = _this.YMKModule._malloc(visible_array.length * visible_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(visible_array, visible_buffer >> 2);

                segment_size = 512.0;
                segment_resize_ratio = Math.sqrt(segment_size * segment_size / (width * height));
                segment_width = Math.max(Math.round(width * segment_resize_ratio) & ~63, 64);
                segment_height = Math.max(Math.round(height * segment_resize_ratio) & ~63, 64);

                _this.venus_makeup_live.ProcessNailDetection1stPassWithROI(heatmap_buffer, heatmap_width, heatmap_height, size_buffer, visible_buffer, frame_buffer, width, height, segment_width, segment_height, roi_x.value, roi_y.value, roi_width.value, roi_height.value);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(size_buffer);
                _this.YMKModule._free(visible_buffer);
                _this.YMKModule._free(input_buffer);
                roi_x.delete();
                roi_y.delete();
                roi_width.delete();
                roi_height.delete();

              case 43:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));

      return function (_x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }();

    _this._trackNail1stPass4RingSize = function () {
      var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(width, height, frame_buffer) {
        var _ref4, heatmap_array, size_array, heatmap_width, heatmap_height, visible_array, input_buffer, segment_width, segment_height, heatmap_buffer, size_buffer, visible_buffer;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this.handTrackingManager.detectNail4RingSize(_this._cropFrameBilinear, width, height);

              case 2:
                _ref4 = _context2.sent;
                heatmap_array = _ref4.heatmap_array;
                size_array = _ref4.size_array;
                heatmap_width = _ref4.heatmap_width;
                heatmap_height = _ref4.heatmap_height;
                visible_array = _ref4.visible_array;
                input_buffer = _ref4.input_buffer;
                segment_width = _ref4.segment_width;
                segment_height = _ref4.segment_height;
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);

                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);

                visible_buffer = _this.YMKModule._malloc(visible_array.length * visible_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(visible_array, visible_buffer >> 2);
                _this.venus_makeup_live.ProcessNailDetection1stPassForRingSize(heatmap_buffer, heatmap_width, heatmap_height, size_buffer, visible_buffer, frame_buffer, _this.getWidth(), _this.getHeight(), segment_width, segment_height);

                _this.YMKModule._free(input_buffer);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(size_buffer);
                _this.YMKModule._free(visible_buffer);

              case 22:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this2);
      }));

      return function (_x6, _x7, _x8) {
        return _ref3.apply(this, arguments);
      };
    }();

    _this._trackNail1stPass = function () {
      var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(width, height, frame_buffer) {
        var _ref6, heatmap_array, size_array, heatmap_width, heatmap_height, visible_array, input_buffer, input_width, input_height, heatmap_buffer, size_buffer, visible_buffer, segment_size, segment_resize_ratio, segment_width, segment_height;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this.handTrackingManager.detectNail1stPass(_this._cropFrameBilinear, width, height);

              case 2:
                _ref6 = _context3.sent;
                heatmap_array = _ref6.heatmap_array;
                size_array = _ref6.size_array;
                heatmap_width = _ref6.heatmap_width;
                heatmap_height = _ref6.heatmap_height;
                visible_array = _ref6.visible_array;
                input_buffer = _ref6.input_buffer;
                input_width = _ref6.input_width;
                input_height = _ref6.input_height;
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);

                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);

                visible_buffer = _this.YMKModule._malloc(visible_array.length * visible_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(visible_array, visible_buffer >> 2);

                segment_size = 512.0;
                segment_resize_ratio = Math.sqrt(segment_size * segment_size / (width * height));
                segment_width = Math.max(Math.round(width * segment_resize_ratio) & ~63, 64);
                segment_height = Math.max(Math.round(height * segment_resize_ratio) & ~63, 64);

                _this.venus_makeup_live.ProcessNailDetection1stPass(heatmap_buffer, heatmap_width, heatmap_height, size_buffer, visible_buffer, frame_buffer, width, height, segment_width, segment_height);
                _this.venus_makeup_live.GetWebHandARReferenceLuma(input_buffer, input_buffer, input_width, input_height);

                input_buffer && _this.YMKModule._free(input_buffer);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(size_buffer);
                _this.YMKModule._free(visible_buffer);
                _this.YMKModule._free(input_buffer);

              case 28:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, _this2);
      }));

      return function (_x9, _x10, _x11) {
        return _ref5.apply(this, arguments);
      };
    }();

    _this._trackNail2ndPass = function () {
      var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(width, height) {
        var patch_size, input_width, _ref8, output_0_array, output_1_array, output_2_array, input_buffer, input_height, output_0_buffer, output_1_buffer, output_2_buffer, half_direction, heat_count;

        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                patch_size = new _this.YMKModule.IntObject();

                _this.venus_makeup_live.GetNailPatchSize(patch_size);
                input_width = patch_size.value;

                patch_size.delete();

                _context4.next = 6;
                return _this.handTrackingManager.detectNail2ndPass(_this._cropFrame4Nail2ndDetect, width, height, input_width);

              case 6:
                _ref8 = _context4.sent;
                output_0_array = _ref8.output_0_array;
                output_1_array = _ref8.output_1_array;
                output_2_array = _ref8.output_2_array;
                input_buffer = _ref8.input_buffer;
                input_height = _ref8.input_height;
                output_0_buffer = _this.YMKModule._malloc(output_0_array.length * output_0_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_0_array, output_0_buffer >> 2);
                output_1_buffer = _this.YMKModule._malloc(output_1_array.length * output_1_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_1_array, output_1_buffer >> 2);
                output_2_buffer = _this.YMKModule._malloc(output_2_array.length * output_2_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_2_array, output_2_buffer >> 2);
                half_direction = true;
                heat_count = 2;

                _this.venus_makeup_live.ProcessNailDetection2ndPass(input_buffer, output_0_buffer, output_1_buffer, output_2_buffer, width, height, half_direction, heat_count);
                _this.YMKModule._free(input_buffer);
                _this.YMKModule._free(output_0_buffer);
                _this.YMKModule._free(output_1_buffer);
                _this.YMKModule._free(output_2_buffer);

              case 25:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, _this2);
      }));

      return function (_x12, _x13) {
        return _ref7.apply(this, arguments);
      };
    }();

    _this._trackNail2ndPassR6d = function () {
      var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(width, height) {
        var patch_size, input_width, _ref10, output_0_array, output_1_array, output_2_array, output_3_array, input_buffer, input_height, output_0_buffer, output_1_buffer, output_2_buffer, output_3_buffer, half_direction, heat_count;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                patch_size = new _this.YMKModule.IntObject();

                _this.venus_makeup_live.GetNailPatchSize(patch_size);
                input_width = patch_size.value;

                patch_size.delete();

                _context5.next = 6;
                return _this.handTrackingManager.detectNail2ndPassR6d(_this._cropFrame4Nail2ndDetect, width, height, input_width);

              case 6:
                _ref10 = _context5.sent;
                output_0_array = _ref10.output_0_array;
                output_1_array = _ref10.output_1_array;
                output_2_array = _ref10.output_2_array;
                output_3_array = _ref10.output_3_array;
                input_buffer = _ref10.input_buffer;
                input_height = _ref10.input_height;
                output_0_buffer = _this.YMKModule._malloc(output_0_array.length * output_0_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_0_array, output_0_buffer >> 2);
                output_1_buffer = _this.YMKModule._malloc(output_1_array.length * output_1_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_1_array, output_1_buffer >> 2);
                output_2_buffer = _this.YMKModule._malloc(output_2_array.length * output_2_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_2_array, output_2_buffer >> 2);
                output_3_buffer = _this.YMKModule._malloc(output_3_array.length * output_3_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_3_array, output_3_buffer >> 2);
                half_direction = false;
                heat_count = 2;

                _this.venus_makeup_live.ProcessNailDetection2ndPassR6d(input_buffer, output_0_buffer, output_1_buffer, output_2_buffer, output_3_buffer, width, height, half_direction, heat_count, true);
                _this.YMKModule._free(input_buffer);
                _this.YMKModule._free(output_0_buffer);
                _this.YMKModule._free(output_1_buffer);
                _this.YMKModule._free(output_2_buffer);
                _this.YMKModule._free(output_3_buffer);

              case 29:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, _this2);
      }));

      return function (_x14, _x15) {
        return _ref9.apply(this, arguments);
      };
    }();

    _this._isFrontCamera = function () {
      if (!_browserUtils2.default.isMobile() && _this.settings.videoTestingFacingMode !== 'environment') {
        return true;
      }
      if (!_this.webcam) {
        return false;
      }
      return _this.webcam.facingMode === 'user';
    };

    _this.isRingApplied = function () {
      return (0, _get3.default)(_this.effectsHolder.get(), 'ring');
    };

    _this.isWatchApplied = function () {
      return (0, _get3.default)(_this.effectsHolder.get(), 'watch');
    };

    _this.isBraceletApplied = function () {
      return (0, _get3.default)(_this.effectsHolder.get(), 'bracelet');
    };

    _this.isWristTryonEnableOnRingFeature = function () {
      return _this.settings.isWristTryonEnableOnRingFeature();
    };

    _this._needToDetectPalm = function () {
      if (_this._isFrontCamera()) {
        return true;
      }

      var is_prev_hand_small_object = new _this.YMKModule.BoolObject();
      _this.venus_makeup_live.GetIsPrevSmallHand(is_prev_hand_small_object);
      var is_prev_hand_small = is_prev_hand_small_object.value;
      is_prev_hand_small_object.delete();
      return is_prev_hand_small;
    };

    _this._trackNailPalm = function () {
      var _ref11 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(width, height, is_detect_palm) {
        var _ref12, heatmap_array, flag_array, size_array, input_width, input_height, input_buffer, heatmap_buffer, flag_buffer, size_buffer;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (is_detect_palm) {
                  _context6.next = 3;
                  break;
                }

                _this.venus_makeup_live.ProcessNailPalmDetection(0, 0, 0, 0, 0, width, height, is_detect_palm, false);
                return _context6.abrupt('return');

              case 3:
                _context6.next = 5;
                return _this.handTrackingManager.detectNailPalm(_this._cropFrameBilinear, width, height);

              case 5:
                _ref12 = _context6.sent;
                heatmap_array = _ref12.heatmap_array;
                flag_array = _ref12.flag_array;
                size_array = _ref12.size_array;
                input_width = _ref12.input_width;
                input_height = _ref12.input_height;
                input_buffer = _ref12.input_buffer;
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);
                flag_buffer = _this.YMKModule._malloc(flag_array.length * flag_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(flag_array, flag_buffer >> 2);
                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);
                _this.venus_makeup_live.ProcessNailPalmDetection(heatmap_buffer, flag_buffer, size_buffer, input_width, input_height, width, height, true, false);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(flag_buffer);
                _this.YMKModule._free(size_buffer);
                _this.YMKModule._free(input_buffer);

              case 23:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, _this2);
      }));

      return function (_x16, _x17, _x18) {
        return _ref11.apply(this, arguments);
      };
    }();

    _this._trackRingPalm = function () {
      var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(width, height) {
        var _ref14, heatmap_array, flag_array, size_array, input_width, input_height, input_buffer, heatmap_buffer, flag_buffer, size_buffer;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this.handTrackingManager.detectRingPalm(_this._cropFrameBilinear, width, height);

              case 2:
                _ref14 = _context7.sent;
                heatmap_array = _ref14.heatmap_array;
                flag_array = _ref14.flag_array;
                size_array = _ref14.size_array;
                input_width = _ref14.input_width;
                input_height = _ref14.input_height;
                input_buffer = _ref14.input_buffer;
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);
                flag_buffer = _this.YMKModule._malloc(flag_array.length * flag_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(flag_array, flag_buffer >> 2);
                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);
                _this.venus_makeup_live.ProcessRingPalmDetection(heatmap_buffer, flag_buffer, size_buffer, input_width, input_height, width, height, true, false);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(flag_buffer);
                _this.YMKModule._free(size_buffer);
                _this.YMKModule._free(input_buffer);

              case 20:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, _this2);
      }));

      return function (_x19, _x20) {
        return _ref13.apply(this, arguments);
      };
    }();

    _this._trackHandPalm = function () {
      var _ref15 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(width, height) {
        var is_wrist_prev_roi_valid, m_prev_is_wrist_prev_roi_valid, _ref16, flag_array, size_array, heatmap_array, handseg_array, input_width, input_height, input_buffer, handseg_buffer, heatmap_buffer, flag_buffer, size_buffer;

        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                is_wrist_prev_roi_valid = new _this.YMKModule.IntObject();

                _this.venus_makeup_live.GetIsWristPrevROIValid(is_wrist_prev_roi_valid);
                //const m_prev_is_wrist_prev_roi_valid = is_wrist_prev_roi_valid.value;
                m_prev_is_wrist_prev_roi_valid = false;

                is_wrist_prev_roi_valid.delete();
                _context8.next = 6;
                return _this.handTrackingManager.detectHandPalm(_this._cropFrameBilinear, width, height, false, _this._isFrontCamera());

              case 6:
                _ref16 = _context8.sent;
                flag_array = _ref16.flag_array;
                size_array = _ref16.size_array;
                heatmap_array = _ref16.heatmap_array;
                handseg_array = _ref16.handseg_array;
                input_width = _ref16.input_width;
                input_height = _ref16.input_height;
                input_buffer = _ref16.input_buffer;
                handseg_buffer = _this.YMKModule._malloc(handseg_array.length * handseg_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(handseg_array, handseg_buffer >> 2);
                heatmap_buffer = _this.YMKModule._malloc(heatmap_array.length * heatmap_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array, heatmap_buffer >> 2);
                flag_buffer = _this.YMKModule._malloc(flag_array.length * flag_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(flag_array, flag_buffer >> 2);
                size_buffer = _this.YMKModule._malloc(size_array.length * size_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(size_array, size_buffer >> 2);
                _this.venus_makeup_live.ProcessHandDetection(handseg_buffer, input_width, input_height, input_width, input_height);
                _this.venus_makeup_live.GetWebHandARReferenceLuma(input_buffer, handseg_buffer, input_width, input_height);
                _this.venus_makeup_live.ProcessWristPointDetection(heatmap_buffer, flag_buffer, size_buffer, input_width / 2, input_height / 2, width, height, true, false, _this._isFrontCamera());
                _this.venus_makeup_live.GetWebHandARReferenceLumaAndColor(input_buffer, input_width, input_height);
                //this.venus_makeup_live.ProcessWristPointDetection(heatmap_buffer, flag_buffer, size_buffer, input_width / 2, input_height / 2, width, height, true, m_prev_is_wrist_prev_roi_valid);

                _this.YMKModule._free(input_buffer);
                _this.YMKModule._free(handseg_buffer);
                _this.YMKModule._free(heatmap_buffer);
                _this.YMKModule._free(flag_buffer);
                _this.YMKModule._free(size_buffer);

              case 31:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, _this2);
      }));

      return function (_x21, _x22) {
        return _ref15.apply(this, arguments);
      };
    }();

    _this._trackHand = function () {
      var _ref17 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(width, height) {
        var _ref18, output_array, input_width, input_height, input_buffer, output_buffer;

        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return _this.handTrackingManager.detectHand(_this._cropFrame, width, height);

              case 2:
                _ref18 = _context9.sent;
                output_array = _ref18.output_array;
                input_width = _ref18.input_width;
                input_height = _ref18.input_height;
                input_buffer = _ref18.input_buffer;
                output_buffer = _this.YMKModule._malloc(output_array.length * output_array.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(output_array, output_buffer >> 2);
                _this.venus_makeup_live.ProcessHandDetection(output_buffer, input_width, input_height, width, height);
                _this.venus_makeup_live.GetWebHandARReferenceLuma(input_buffer, output_buffer, input_width, input_height);
                _this.YMKModule._free(output_buffer);
                _this.YMKModule._free(input_buffer);

              case 13:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, _this2);
      }));

      return function (_x23, _x24) {
        return _ref17.apply(this, arguments);
      };
    }();

    _this._trackWrist = function () {
      var _ref19 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10(width, height, frame_buffer) {
        var _ref20, heatmap_array_0, heatmap_array_1, a, bx, by, input_buffer, is_mnn, heatmap_buffer_0, heatmap_buffer_1;

        return _regenerator2.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return _this.handTrackingManager.detectWrist(_this._cropFrame4Wrist, _this._isFrontCamera());

              case 2:
                _ref20 = _context10.sent;
                heatmap_array_0 = _ref20.heatmap_array_0;
                heatmap_array_1 = _ref20.heatmap_array_1;
                a = _ref20.a;
                bx = _ref20.bx;
                by = _ref20.by;
                input_buffer = _ref20.input_buffer;
                is_mnn = _ref20.is_mnn;
                heatmap_buffer_0 = _this.YMKModule._malloc(heatmap_array_0.length * heatmap_array_0.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array_0, heatmap_buffer_0 >> 2);
                heatmap_buffer_1 = _this.YMKModule._malloc(heatmap_array_1.length * heatmap_array_1.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array_1, heatmap_buffer_1 >> 2);
                if (is_mnn) {
                  _this.venus_makeup_live.ProcessWristDetectionHeatMap(heatmap_buffer_0, heatmap_buffer_1, frame_buffer, width, height, a, bx, by);
                } else {
                  _this.venus_makeup_live.ProcessWristDetection(heatmap_buffer_0, heatmap_buffer_1, frame_buffer, width, height, a, bx, by);
                }
                _this.YMKModule._free(heatmap_buffer_0);
                _this.YMKModule._free(heatmap_buffer_1);
                _this.YMKModule._free(input_buffer);

              case 18:
              case 'end':
                return _context10.stop();
            }
          }
        }, _callee10, _this2);
      }));

      return function (_x25, _x26, _x27) {
        return _ref19.apply(this, arguments);
      };
    }();

    _this._trackWristPose = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
      return _regenerator2.default.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt('return', _this.venus_makeup_live.ProcessWristPoseNetEstimator());

            case 1:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee11, _this2);
    }));

    _this._trackRing = function () {
      var _ref22 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(width, height, frame_buffer, ringFingerType) {
        var _ref23, heatmap_array_0, heatmap_array_1, heatmap_array_2, input_buffer, is_mnn, heatmap_buffer_0, heatmap_buffer_1, heatmap_buffer_2;

        return _regenerator2.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _this.handTrackingManager.detectRing(_this._cropFrame4Ring, _this._isFrontCamera(), ringFingerType);

              case 2:
                _ref23 = _context12.sent;
                heatmap_array_0 = _ref23.heatmap_array_0;
                heatmap_array_1 = _ref23.heatmap_array_1;
                heatmap_array_2 = _ref23.heatmap_array_2;
                input_buffer = _ref23.input_buffer;
                is_mnn = _ref23.is_mnn;
                heatmap_buffer_0 = _this.YMKModule._malloc(heatmap_array_0.length * heatmap_array_0.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array_0, heatmap_buffer_0 >> 2);
                heatmap_buffer_1 = _this.YMKModule._malloc(heatmap_array_1.length * heatmap_array_1.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array_1, heatmap_buffer_1 >> 2);

                heatmap_buffer_2 = null;

                if (heatmap_array_2) {
                  heatmap_buffer_2 = _this.YMKModule._malloc(heatmap_array_2.length * heatmap_array_2.BYTES_PER_ELEMENT);
                  _this.YMKModule.HEAPF32.set(heatmap_array_2, heatmap_buffer_2 >> 2);
                }
                if (!is_mnn) {
                  _this.venus_makeup_live.ProcessRingDetection(heatmap_buffer_0, heatmap_buffer_1, heatmap_buffer_2, frame_buffer, width, height);
                } else {
                  if (heatmap_array_2) {
                    _this.venus_makeup_live.ProcessRingDetectionHeatMapWithFlag(heatmap_buffer_0, heatmap_buffer_1, heatmap_buffer_2, frame_buffer, width, height);
                  } else {
                    _this.venus_makeup_live.ProcessRingDetectionHeatMap(heatmap_buffer_0, heatmap_buffer_1, frame_buffer, width, height);
                  }
                }

                _this.YMKModule._free(heatmap_buffer_0);
                _this.YMKModule._free(heatmap_buffer_1);
                if (heatmap_buffer_2) {
                  _this.YMKModule._free(heatmap_buffer_2);
                }
                _this.YMKModule._free(input_buffer);

              case 19:
              case 'end':
                return _context12.stop();
            }
          }
        }, _callee12, _this2);
      }));

      return function (_x28, _x29, _x30, _x31) {
        return _ref22.apply(this, arguments);
      };
    }();

    _this._trackRingPatch = function () {
      var _ref24 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13(frame_buffer, with_mask) {
        var _ref25, heatmap_array_1, input_buffer, heatmap_buffer_1;

        return _regenerator2.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _this.handTrackingManager.detectRingPatch(_this._cropFrame4RingPatch, with_mask);

              case 2:
                _ref25 = _context13.sent;
                heatmap_array_1 = _ref25.heatmap_array_1;
                input_buffer = _ref25.input_buffer;
                heatmap_buffer_1 = _this.YMKModule._malloc(heatmap_array_1.length * heatmap_array_1.BYTES_PER_ELEMENT);

                _this.YMKModule.HEAPF32.set(heatmap_array_1, heatmap_buffer_1 >> 2);
                _this.venus_makeup_live.ProcessRingPatchDetectionHeatMap(heatmap_buffer_1, frame_buffer, _this.getWidth(), _this.getHeight());
                _this.YMKModule._free(heatmap_buffer_1);
                _this.YMKModule._free(input_buffer);

              case 10:
              case 'end':
                return _context13.stop();
            }
          }
        }, _callee13, _this2);
      }));

      return function (_x32, _x33) {
        return _ref24.apply(this, arguments);
      };
    }();

    _this._trackRingPose = function () {
      var _ref26 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(width, height, frame_buffer) {
        return _regenerator2.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _this.venus_makeup_live.ProcessRingPoseNetEstimator();
                _this.venus_makeup_live.RefineTranslationByCenterPoint(frame_buffer, width, height);

              case 2:
              case 'end':
                return _context14.stop();
            }
          }
        }, _callee14, _this2);
      }));

      return function (_x34, _x35, _x36) {
        return _ref26.apply(this, arguments);
      };
    }();

    _this.trackHand4Nail = function () {
      var _ref27 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(width, height, frame_buffer) {
        var begin, b;
        return _regenerator2.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _this.hand_ar_metadata.frame_width = _this.camera_width;
                _this.hand_ar_metadata.frame_height = _this.camera_height;
                _this.hand_ar_metadata.vto_mode = _this.nail_vto_mode;
                _this.venus_makeup_live.SetIsSmoothNailAnchors(true);
                _this.hand_ar_metadata.is_camera_front = _this._isFrontCamera();
                _this.venus_makeup_live.SetWebHandARMetadataValues(_this.hand_ar_metadata);

                if (!_this.isFirstTrackHand) {
                  _context15.next = 30;
                  break;
                }

                begin = performance.now();

                _this.isFirstTrackHand = false;
                _this.emitter.trigger(_events2.default.loading, [81]);
                _context15.next = 12;
                return _browserUtils2.default.sleep(0);

              case 12:
                b = performance.now();
                _context15.next = 15;
                return _this._trackNail1stPassWithROI(width, height, frame_buffer);

              case 15:
                _this.emitter.trigger(_events2.default.engineLoading, ['nail-1st-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [82]);
                _context15.next = 19;
                return _browserUtils2.default.sleep(0);

              case 19:
                b = performance.now();
                _context15.next = 22;
                return _this._trackNail2ndPass(width, height);

              case 22:
                _context15.next = 24;
                return _this._trackNail2ndPassR6d(width, height);

              case 24:
                _this.venus_makeup_live.GetWebHandARReferenceLuma(frame_buffer, frame_buffer, width, width);
                _this.emitter.trigger(_events2.default.engineLoading, ['nail-2nd-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [84]);
                _context15.next = 29;
                return _browserUtils2.default.sleep(0);

              case 29:
                _this.warmUpTime = performance.now() - begin;

              case 30:
                _context15.next = 32;
                return _this._trackNail1stPassWithROI(width, height, frame_buffer);

              case 32:
                if (!(_this.nail_vto_mode == _this.YMKModule.VN_VTOMode.NAIL_TIP)) {
                  _context15.next = 37;
                  break;
                }

                _context15.next = 35;
                return _this._trackNail2ndPassR6d(width, height);

              case 35:
                _context15.next = 39;
                break;

              case 37:
                _context15.next = 39;
                return _this._trackNail2ndPass(width, height);

              case 39:
                _this.venus_makeup_live.GetWebHandARReferenceLuma(frame_buffer, frame_buffer, width, width);
                _this.venus_makeup_live.GetWebHandARMetadata(_this.hand_ar_metadata);
                _this.makeup_live_filter.SetHandARMetadata(_this.hand_ar_metadata);
                _this.hasFace = _this.hand_ar_metadata.detection_result.value !== 2 && _this.hand_ar_metadata.detection_result.value !== 4;
                _this.faceDetectionDetail = {
                  nailsTooSmall: _this.hand_ar_metadata.detection_result.value === 4
                };

              case 44:
              case 'end':
                return _context15.stop();
            }
          }
        }, _callee15, _this2);
      }));

      return function (_x37, _x38, _x39) {
        return _ref27.apply(this, arguments);
      };
    }();

    _this.trackHand4Watch = function () {
      var _ref28 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(width, height, frame_buffer) {
        var begin, b;
        return _regenerator2.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _this.hand_ar_metadata.frame_width = _this.camera_width;
                _this.hand_ar_metadata.frame_height = _this.camera_height;
                _this.venus_makeup_live.SetWristSize(_this.settings.getWristSize() / 10.0);
                _this.hand_ar_metadata.vto_mode = _this.YMKModule.VN_VTOMode.WRIST_VTO;
                //this.hand_ar_metadata.is_watch_mode = this.is_watch_mode;
                //this.hand_ar_metadata.is_wrist_ratio_adjustable = this.is_wrist_ratio_adjustable;
                _this.hand_ar_metadata.object_position_offset = _this.object_position_offset;
                _this.hand_ar_metadata.is_camera_front = _this._isFrontCamera();
                _this.hand_ar_metadata.is_watch_mirror_mode = _this._isFrontCamera();
                _this.venus_makeup_live.SetWebHandARMetadataValues(_this.hand_ar_metadata);

                if (!_this.isFirstTrackHand) {
                  _context16.next = 29;
                  break;
                }

                _this.isFirstTrackHand = false;
                begin = performance.now();

                _this.emitter.trigger(_events2.default.loading, [81]);
                _context16.next = 14;
                return _browserUtils2.default.sleep(0);

              case 14:
                b = performance.now();
                _context16.next = 17;
                return _this._trackHandPalm(width, height);

              case 17:
                _this.emitter.trigger(_events2.default.engineLoading, ['hand-palm-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [82]);
                _context16.next = 21;
                return _browserUtils2.default.sleep(0);

              case 21:
                b = performance.now();
                _context16.next = 24;
                return _this._trackWrist(width, height, frame_buffer);

              case 24:
                _this.emitter.trigger(_events2.default.engineLoading, ['wrist-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [83]);
                _context16.next = 28;
                return _browserUtils2.default.sleep(0);

              case 28:
                _this.warmUpTime = performance.now() - begin;

              case 29:
                _context16.next = 31;
                return _this._trackHandPalm(width, height);

              case 31:
                _context16.next = 33;
                return _this._trackWrist(width, height, frame_buffer);

              case 33:
                _context16.next = 35;
                return _this._trackWristPose();

              case 35:
                _this.venus_makeup_live.GetWebHandARMetadata(_this.hand_ar_metadata);
                _this.makeup_live_filter.SetObjectIntensity(1.0);
                _this.makeup_live_filter.SetHandARMetadata(_this.hand_ar_metadata);

                if ((0, _get3.default)(_this, 'settings.enableWristAutoZoom') && !_this._isFrontCamera()) {
                  _this.makeup_live_filter.SetZoomRatio(_this.hand_ar_metadata.wrist_zoom_scale);
                }
                _this.hasFace = _this.hand_ar_metadata.is_wrist_detected;
                _this.faceDetectionDetail = {
                  tooClose: _this.hand_ar_metadata.detection_result.value === 1
                };

              case 41:
              case 'end':
                return _context16.stop();
            }
          }
        }, _callee16, _this2);
      }));

      return function (_x40, _x41, _x42) {
        return _ref28.apply(this, arguments);
      };
    }();

    _this.trackHand4WatchOnRingFeature = function () {
      var _ref29 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(width, height, frame_buffer) {
        var begin, b;
        return _regenerator2.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _this.wrist_hand_ar_metadata.frame_width = _this.camera_width;
                _this.wrist_hand_ar_metadata.frame_height = _this.camera_height;
                _this.venus_makeup_live.SetWristSize(_this.settings.getWristSize() / 10.0);
                _this.wrist_hand_ar_metadata.vto_mode = _this.YMKModule.VN_VTOMode.WRIST_VTO;
                //this.hand_ar_metadata.is_watch_mode = this.is_watch_mode;
                //this.hand_ar_metadata.is_wrist_ratio_adjustable = this.is_wrist_ratio_adjustable;
                _this.wrist_hand_ar_metadata.object_position_offset = _this.object_position_offset;
                _this.wrist_hand_ar_metadata.is_camera_front = _this._isFrontCamera();
                _this.wrist_hand_ar_metadata.is_watch_mirror_mode = _this._isFrontCamera();
                _this.venus_makeup_live.SetWebHandARMetadataValues(_this.wrist_hand_ar_metadata);

                if (!_this.isFirstTrackHand) {
                  _context17.next = 29;
                  break;
                }

                _this.isFirstTrackHand = false;
                begin = performance.now();

                _this.emitter.trigger(_events2.default.loading, [81]);
                _context17.next = 14;
                return _browserUtils2.default.sleep(0);

              case 14:
                b = performance.now();
                _context17.next = 17;
                return _this._trackHandPalm(width, height);

              case 17:
                _this.emitter.trigger(_events2.default.engineLoading, ['hand-palm-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [82]);
                _context17.next = 21;
                return _browserUtils2.default.sleep(0);

              case 21:
                b = performance.now();
                _context17.next = 24;
                return _this._trackWrist(width, height, frame_buffer);

              case 24:
                _this.emitter.trigger(_events2.default.engineLoading, ['wrist-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [83]);
                _context17.next = 28;
                return _browserUtils2.default.sleep(0);

              case 28:
                _this.warmUpTime = performance.now() - begin;

              case 29:
                _context17.next = 31;
                return _this._trackHandPalm(width, height);

              case 31:
                _context17.next = 33;
                return _this._trackWrist(width, height, frame_buffer);

              case 33:
                _context17.next = 35;
                return _this._trackWristPose();

              case 35:
                _this.venus_makeup_live.GetWebHandARMetadata(_this.wrist_hand_ar_metadata);
                _this.makeup_live_filter.SetObjectIntensity(1.0);
                _this.makeup_live_filter.SetHandARMetadata(_this.wrist_hand_ar_metadata, 1);
                if (!_this.hasFace) {
                  _this.hasFace = _this.wrist_hand_ar_metadata.is_wrist_detected && _this.wrist_hand_ar_metadata.is_wrist_valid;
                }

              case 39:
              case 'end':
                return _context17.stop();
            }
          }
        }, _callee17, _this2);
      }));

      return function (_x43, _x44, _x45) {
        return _ref29.apply(this, arguments);
      };
    }();

    _this.trackHand4Ring = function () {
      var _ref30 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(width, height, frame_buffer) {
        var begin, b, with_mask, _with_mask;

        return _regenerator2.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _this.hand_ar_metadata.frame_width = _this.camera_width;
                _this.hand_ar_metadata.frame_height = _this.camera_height;
                _this.hand_ar_metadata.vto_mode = _this.YMKModule.VN_VTOMode.RING_VTO;
                _this.hand_ar_metadata.is_camera_front = _this._isFrontCamera();
                _this.venus_makeup_live.SetWebHandARMetadataValues(_this.hand_ar_metadata);

                if (!_this.isFirstTrackHand) {
                  _context18.next = 46;
                  break;
                }

                begin = performance.now();

                _this.isFirstTrackHand = false;
                _this.emitter.trigger(_events2.default.loading, [81]);
                _context18.next = 11;
                return _browserUtils2.default.sleep(0);

              case 11:
                b = performance.now();
                _context18.next = 14;
                return _this._trackRingPalm(width, height, _this.is_prev_hand_small());

              case 14:
                _this.emitter.trigger(_events2.default.engineLoading, ['palm-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [82]);
                _context18.next = 18;
                return _browserUtils2.default.sleep(0);

              case 18:
                b = performance.now();
                _context18.next = 21;
                return _this._trackRingHand(width, height);

              case 21:
                _this.emitter.trigger(_events2.default.engineLoading, ['hand-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [83]);
                _context18.next = 25;
                return _browserUtils2.default.sleep(0);

              case 25:
                b = performance.now();

                if (!_this.settings.enableRingFingerTypeChange) {
                  _context18.next = 35;
                  break;
                }

                _context18.next = 29;
                return _this._trackRing(width, height, frame_buffer, _settings.ringFingerTypes.ring);

              case 29:
                _context18.next = 31;
                return _this._trackRing(width, height, frame_buffer, _settings.ringFingerTypes.index);

              case 31:
                _context18.next = 33;
                return _this._trackRing(width, height, frame_buffer, _settings.ringFingerTypes.middle);

              case 33:
                _context18.next = 37;
                break;

              case 35:
                _context18.next = 37;
                return _this._trackRing(width, height, frame_buffer, _this.ringFingerType || _this.settings.ringFingerType);

              case 37:
                if (!_this.settings.isAutoRingSizerEnabled()) {
                  _context18.next = 43;
                  break;
                }

                _context18.next = 40;
                return _this._trackNail1stPass4RingSize(width, height, frame_buffer);

              case 40:
                with_mask = false;
                _context18.next = 43;
                return _this._trackRingPatch(frame_buffer, with_mask);

              case 43:
                _this.emitter.trigger(_events2.default.engineLoading, ['ring-model', b, performance.now()]);
                _this.emitter.trigger(_events2.default.loading, [84]);
                _this.warmUpTime = performance.now() - begin;

              case 46:
                _context18.next = 48;
                return _this._trackRingPalm(width, height, _this.is_prev_hand_small());

              case 48:
                _context18.next = 50;
                return _this._trackRingHand(width, height);

              case 50:
                _context18.next = 52;
                return _this._trackRing(width, height, frame_buffer, _this.ringFingerType || _this.settings.ringFingerType);

              case 52:
                if (!_this.settings.isAutoRingSizerEnabled()) {
                  _context18.next = 58;
                  break;
                }

                _context18.next = 55;
                return _this._trackNail1stPass4RingSize(width, height, frame_buffer);

              case 55:
                _with_mask = false;
                _context18.next = 58;
                return _this._trackRingPatch(frame_buffer, _with_mask);

              case 58:
                _context18.next = 60;
                return _this._trackRingPose(width, height, frame_buffer);

              case 60:
                _this.makeup_live_filter.SetHandARFingerOccluder(true);
                _this.venus_makeup_live.GetWebHandARMetadata(_this.hand_ar_metadata);
                _this.makeup_live_filter.SetHandARMetadata(_this.hand_ar_metadata, 0);
                _this.hasFace = _this.hand_ar_metadata.is_palm_detected;
                _this.faceDetectionDetail = {
                  tooClose: _this.hand_ar_metadata.detection_result == _this.YMKModule.VN_VTO_RESULT.VTO_FAIL_HAND_TOO_CLOSE
                };

              case 65:
              case 'end':
                return _context18.stop();
            }
          }
        }, _callee18, _this2);
      }));

      return function (_x46, _x47, _x48) {
        return _ref30.apply(this, arguments);
      };
    }();

    _this.isWatchFeature = function () {
      return _this.settings.isWatch();
    };

    _this.isRingFeature = function () {
      return _this.settings.isRing();
    };

    _this.isNailFeature = function () {
      return _this.settings.isNail();
    };

    _this.trackHand = function () {
      var _ref31 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(width, height, frame_buffer) {
        return _regenerator2.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!_this.terminalized) {
                  _context19.next = 2;
                  break;
                }

                return _context19.abrupt('return');

              case 2:
                if (_this.handTrackingManager) {
                  _context19.next = 4;
                  break;
                }

                return _context19.abrupt('return');

              case 4:
                if (_this.handTrackingManager.initialized) {
                  _context19.next = 7;
                  break;
                }

                _context19.next = 7;
                return _this.handTrackingManager.init();

              case 7:
                if (!_this.disableTracking) {
                  _context19.next = 9;
                  break;
                }

                return _context19.abrupt('return');

              case 9:
                _context19.prev = 9;

                if (!_this.isWristTryonEnableOnRingFeature()) {
                  _context19.next = 21;
                  break;
                }

                if (!_this.isRingApplied()) {
                  _context19.next = 14;
                  break;
                }

                _context19.next = 14;
                return _this.trackHand4Ring(width, height, frame_buffer);

              case 14:
                if (!(!_this.isWatchApplied() && !_this.isBraceletApplied() && !_this.isRingApplied())) {
                  _context19.next = 17;
                  break;
                }

                _context19.next = 17;
                return _this.trackHand4Ring(width, height, frame_buffer);

              case 17:
                if (!(_this.isWatchApplied() || _this.isBraceletApplied())) {
                  _context19.next = 20;
                  break;
                }

                _context19.next = 20;
                return _this.trackHand4WatchOnRingFeature(width, height, frame_buffer);

              case 20:
                return _context19.abrupt('return');

              case 21:
                if (!_this.isWatchFeature()) {
                  _context19.next = 26;
                  break;
                }

                _context19.next = 24;
                return _this.trackHand4Watch(width, height, frame_buffer);

              case 24:
                _context19.next = 34;
                break;

              case 26:
                if (!_this.isRingFeature()) {
                  _context19.next = 31;
                  break;
                }

                _context19.next = 29;
                return _this.trackHand4Ring(width, height, frame_buffer);

              case 29:
                _context19.next = 34;
                break;

              case 31:
                if (!_this.isNailFeature()) {
                  _context19.next = 34;
                  break;
                }

                _context19.next = 34;
                return _this.trackHand4Nail(width, height, frame_buffer);

              case 34:
                _context19.next = 39;
                break;

              case 36:
                _context19.prev = 36;
                _context19.t0 = _context19['catch'](9);

                console.log({ err: _context19.t0 });

              case 39:
              case 'end':
                return _context19.stop();
            }
          }
        }, _callee19, _this2, [[9, 36]]);
      }));

      return function (_x49, _x50, _x51) {
        return _ref31.apply(this, arguments);
      };
    }();

    _this.AllocateResources = function () {
      // if (this.faceTrackingManager) {
      //   const cropBufferSize = this.faceTrackingManager && this.faceTrackingManager.getCropBufferSize();
      //   this.venus_crop_buffer = this.YMKModule._malloc(cropBufferSize);
      //   this.web_crop_buffer = new Uint8Array(this.YMKModule.HEAPU8.buffer, this.venus_crop_buffer, cropBufferSize);
      // }
      if (!_this.controller.engine_pointer) {
        var t = new _this.YMKModule.ValObject();
        _this.YMKModule.CreateVenusLiveObject(_this.YMKModule.IID_VENUS_MAKEUP_LIVE, t);
        _this.controller.engine_pointer = t.value;
      }
      _this.venus_makeup_live = _this.controller.engine_pointer;
      _this.metadata_buffers = _this.createMetadataBuffers();
      if (_this.isWristTryonEnableOnRingFeature()) {
        _this.wrist_metadata_buffers = _this.createMetadataBuffers();
        _this.wrist_hand_ar_metadata = new _this.YMKModule.WebHandARMetadata();
        _this.wrist_hand_ar_metadata.SetMatrixInputValues(_this.wrist_metadata_buffers.p_transform_matrices, _this.wrist_metadata_buffers.p_normal_matrices, _this.wrist_metadata_buffers.p_camera_matrices);
        _this.wrist_hand_ar_metadata.SetHandInputValues(_this.wrist_metadata_buffers.hand_mask_buffer);
        _this.wrist_hand_ar_metadata.SetOccluderMatrixInputValues(_this.wrist_metadata_buffers.p_occluder_transform_matrices, _this.wrist_metadata_buffers.p_occluder_normal_matrices);
        _this.wrist_hand_ar_metadata.SetMVBlockDataInputValues(_this.wrist_metadata_buffers.mv_block_buffer, _this.wrist_metadata_buffers.mv_prev_block_buffer);
        _this.wrist_hand_ar_metadata.SetMVBlockDataInputValues(_this.wrist_metadata_buffers.mv_block_buffer, _this.wrist_metadata_buffers.mv_prev_block_buffer);
        _this.wrist_hand_ar_metadata.SetWristTrapezoidMatrixInputValues(_this.wrist_metadata_buffers.p_wrist_trapezoid_matrices);
        _this.wrist_hand_ar_metadata.SetWatchTimeComponentTransformMatrixInputValues(_this.wrist_metadata_buffers.watch_time_component_buffer);
      }
      _this.hand_ar_model_settings_var = new _this.YMKModule.CreateVector_WebHandARModelSetting(1);
      _this.hand_ar_metadata = new _this.YMKModule.WebHandARMetadata();
      _this.hand_ar_metadata.SetMatrixInputValues(_this.metadata_buffers.p_transform_matrices, _this.metadata_buffers.p_normal_matrices, _this.metadata_buffers.p_camera_matrices);
      if (_this.isNailFeature()) {
        _this.hand_ar_metadata.SetNailArtInputValues(_this.metadata_buffers.nail_art_buffer);
        _this.hand_ar_metadata.SetNailTipInputValues(_this.metadata_buffers.nail_tip_buffer);
        _this.hand_ar_metadata.SetNailArtMatrixInputValues(_this.metadata_buffers.p_nail_art_transform_matrices, _this.metadata_buffers.p_nail_art_normal_matrices);
        _this.hand_ar_metadata.SetNailInputValues(_this.metadata_buffers.nail_mask_first3_buffer, _this.metadata_buffers.nail_mask_last3_buffer, _this.metadata_buffers.nail_light_mask_buffer, _this.metadata_buffers.nail_env_map_buffer);
      }
      _this.hand_ar_metadata.SetHandInputValues(_this.metadata_buffers.hand_mask_buffer);
      _this.hand_ar_metadata.SetOccluderMatrixInputValues(_this.metadata_buffers.p_occluder_transform_matrices, _this.metadata_buffers.p_occluder_normal_matrices);
      _this.hand_ar_metadata.SetMVBlockDataInputValues(_this.metadata_buffers.mv_block_buffer, _this.metadata_buffers.mv_prev_block_buffer);
      if (_this.isRingFeature() || _this.isWatchFeature()) {
        _this.hand_ar_metadata.SetMVBlockDataInputValues(_this.metadata_buffers.mv_block_buffer, _this.metadata_buffers.mv_prev_block_buffer);
      }
      if (_this.isWatchFeature()) {
        _this.hand_ar_metadata.SetWristTrapezoidMatrixInputValues(_this.metadata_buffers.p_wrist_trapezoid_matrices);
        _this.hand_ar_metadata.SetWatchTimeComponentTransformMatrixInputValues(_this.metadata_buffers.watch_time_component_buffer);
      }
      if (_this.isNailFeature()) {
        _this.nail_model_buffers = _this.createMetadataBuffers();
        _this.nail_model_metadata = new _this.YMKModule.WebHandARMetadata();
        _this.nail_model_metadata.SetMatrixInputValues(_this.nail_model_buffers.p_transform_matrices, _this.nail_model_buffers.p_normal_matrices, _this.nail_model_buffers.p_camera_matrices);
        _this.nail_model_metadata.SetNailArtInputValues(_this.nail_model_buffers.nail_art_buffer);
        _this.nail_model_metadata.SetNailArtMatrixInputValues(_this.nail_model_buffers.p_nail_art_transform_matrices, _this.nail_model_buffers.p_nail_art_normal_matrices);
        _this.nail_model_metadata.SetNailTipInputValues(_this.nail_model_buffers.nail_tip_buffer);
        _this.nail_model_metadata.SetNailInputValues(_this.nail_model_buffers.nail_mask_first3_buffer, _this.nail_model_buffers.nail_mask_last3_buffer, _this.nail_model_buffers.nail_light_mask_buffer, _this.nail_model_buffers.nail_env_map_buffer);
      }

      _this.hand_ar_parameters = new _this.YMKModule.WebHandARParameters();
      _this.nail_art_image_vec = _this.YMKModule.CreateVector_WebVN_Image(MAX_LOOKS * FINGER_NUM);
      _this.nail_tip_shape_vec = _this.YMKModule.CreateVector_WebVN_Image(MAX_LOOKS * FINGER_NUM);
      _this.is_nail_art_image_changed_vec = _this.YMKModule.CreateVector_BOOL(MAX_LOOKS * FINGER_NUM, true);
      _this.is_nail_tip_shape_changed_vec = _this.YMKModule.CreateVector_BOOL(MAX_LOOKS * FINGER_NUM, true);
    };

    _this.isUserNailReplacement = function () {
      return false;
    };

    _this.SetHandARParameters = function () {
      _this.hand_ar_parameters.hand_ar_model_settings = _this.hand_ar_model_settings_var;
      if (_this.mediaSource === 'choosemodel') {
        _this.hand_ar_parameters.skin_smooth_intensity = 0;
        _this.hand_ar_parameters.skin_smooth_color_intensity = 0;
      } else {
        _this.hand_ar_parameters.skin_smooth_intensity = _this.settings.skinSmoothStrength;
        _this.hand_ar_parameters.skin_smooth_color_intensity = _this.settings.skinSmoothColorIntensity;
      }
      if (_this.isNailFeature()) {
        _this.hand_ar_parameters.is_four_way = _this.splitFourWayEnabled;
        _this.hand_ar_parameters.is_nail_art_image_changed = _this.is_nail_art_image_changed_vec;
        _this.hand_ar_parameters.is_nail_tip_shape_changed = _this.is_nail_tip_shape_changed_vec;
        _this.hand_ar_parameters.is_replace_user_polish = _this.isUserNailReplacement();
        _this.setNailParameters4PbrFIngers();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(FINGERS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var finger = _step.value;

            var finish = _this.YMKModule.CreateVector_NailFinish(MAX_LOOKS);
            for (var i = 0; i < MAX_LOOKS; i++) {
              finish.set(i, _this.fingers[i][finger]);
            }
            _this.hand_ar_parameters[finger] = finish;
            finish.delete();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(FINGERS), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _finger = _step2.value;

            var _finish = _this.YMKModule.CreateVector_NailTipParameter(MAX_LOOKS);
            for (var _i = 0; _i < MAX_LOOKS; _i++) {
              _finish.set(_i, _this.tip_fingers[_i][_finger]);
            }
            _this.hand_ar_parameters[_finger + '_tip'] = _finish;
            _finish.delete();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      _this.hand_ar_parameters.nail_pbr_mode = _this.nail_pbr_mode;
      _this.venus_makeup_live.SetWebHandARParameters(_this.hand_ar_parameters);

      if (_this.isNailFeature()) {
        for (var _i2 = 0; _i2 < 4 * 5; _i2++) {
          _this.is_nail_art_image_changed_vec.set(_i2, false);
        }
        for (var _i3 = 0; _i3 < 4 * 5; _i3++) {
          _this.is_nail_tip_shape_changed_vec.set(_i3, false);
        }
      }
    };

    _this.setNailParameters4PbrFIngers = function () {
      for (var i = 0; i < MAX_LOOKS; i++) {
        for (var j = 0; j < FINGER_NUM; j++) {
          _this.setNailParameter(i, j, _this.pbr_fingers[i][FINGERS[j]]);
        }
      }
    };

    _this.setNailParameter = function (lookIndex, finger, finish) {
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_CREAM) {
        _this.venus_makeup_live.SetPbrCreamParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_JELLY) {
        _this.venus_makeup_live.SetPbrJellyParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHEER) {
        _this.venus_makeup_live.SetPbrSheerParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_MATTE) {
        _this.venus_makeup_live.SetPbrMatteParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_METALLIC) {
        _this.venus_makeup_live.SetPbrMetallicParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.contrast, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_PEARL) {
        _this.venus_makeup_live.SetPbrPearlParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.shimmer_opacity, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_TEXTURED) {
        _this.venus_makeup_live.SetPbrTexturedParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.textured_granularity, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHIMMER_COARSE) {
        _this.venus_makeup_live.SetPbrShimmerCoarseParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.shimmer_granularity, finish.is_enabled, finish.is_nail_art);
        return;
      }
      if (finish.finish_type == _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHIMMER_FINE) {
        _this.venus_makeup_live.SetPbrShimmerFineParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.shimmer_granularity, finish.is_enabled, finish.is_nail_art);
        return;
      }
      _this.venus_makeup_live.SetPbrCreamParameter(lookIndex, finger, finish.color.r, finish.color.g, finish.color.b, finish.roughness, finish.reflection, finish.transparency, finish.contrast, finish.is_enabled, finish.is_nail_art);
    };

    _this.setWristSize = function (size) {
      _this.venus_makeup_live.SetWristSize(size);
    };

    _this.createMetadataBuffers = function () {
      var max_nail_width_info = new _this.YMKModule.IntObject();
      var max_nail_height_info = new _this.YMKModule.IntObject();
      _this.venus_makeup_live.GetMaxNailMaskSize(max_nail_width_info, max_nail_height_info);

      var max_nail_art_width_info = new _this.YMKModule.IntObject();
      var max_nail_art_height_info = new _this.YMKModule.IntObject();
      _this.venus_makeup_live.GetMaxNailArtImageSize(max_nail_art_width_info, max_nail_art_height_info);

      var max_nail_tip_width_info = new _this.YMKModule.IntObject();
      var max_nail_tip_height_info = new _this.YMKModule.IntObject();
      _this.venus_makeup_live.GetMaxNailArtImageSize(max_nail_tip_width_info, max_nail_tip_height_info);

      var max_nail_env_map_width_info = new _this.YMKModule.IntObject();
      var max_nail_env_map_height_info = new _this.YMKModule.IntObject();
      _this.venus_makeup_live.GetMaxNailEnvMapSize(max_nail_env_map_width_info, max_nail_env_map_height_info);

      var max_hand_width_info = new _this.YMKModule.IntObject();
      var max_hand_height_info = new _this.YMKModule.IntObject();
      _this.venus_makeup_live.GetMaxHandMaskSize(max_hand_width_info, max_hand_height_info);

      var sizeof_float = 4;
      var buffers = {
        p_transform_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * _this.YMKModule.VN_HANDAR_MAX_PART_AMOUNT * 12),
        p_normal_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * _this.YMKModule.VN_HANDAR_MAX_PART_AMOUNT * 16),
        p_camera_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 9),
        p_occluder_transform_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 12),
        p_occluder_normal_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 16),
        p_nail_art_transform_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 12),
        p_nail_art_normal_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 16),
        p_wrist_trapezoid_matrices: _this.YMKModule._malloc(sizeof_float * _this.YMKModule.VN_HANDAR_MAX_AMOUNT * 9),

        nail_mask_first3_buffer: _this.YMKModule._malloc(max_nail_width_info.value * max_nail_height_info.value * 4),
        nail_mask_last3_buffer: _this.YMKModule._malloc(max_nail_width_info.value * max_nail_height_info.value * 4),
        nail_light_mask_buffer: _this.YMKModule._malloc(max_nail_width_info.value * max_nail_height_info.value),

        hand_mask_buffer: _this.YMKModule._malloc(max_hand_width_info.value * max_hand_height_info.value)
      };
      if (_this.isNailFeature()) {
        var nail_art_buffer_vector = _this.YMKModule.CreateVector_VN_DATA_POINTER(4 * 5);
        var nail_tip_buffer_vector = _this.YMKModule.CreateVector_VN_DATA_POINTER(4 * 5);
        var nail_env_map_buffer_vector = _this.YMKModule.CreateVector_VN_DATA_POINTER(4 * 5);
        for (var i = 0; i < 4 * 5; i++) {
          nail_art_buffer_vector.set(i, _this.YMKModule._malloc(max_nail_art_width_info.value * max_nail_art_height_info.value * 4));
          nail_tip_buffer_vector.set(i, _this.YMKModule._malloc(max_nail_tip_width_info.value * max_nail_tip_height_info.value * 4));
          nail_env_map_buffer_vector.set(i, _this.YMKModule._malloc(max_nail_env_map_width_info.value * max_nail_env_map_height_info.value * 4));
        }
        buffers.nail_art_buffer = nail_art_buffer_vector;
        buffers.nail_tip_buffer = nail_tip_buffer_vector;
        buffers.nail_env_map_buffer = nail_env_map_buffer_vector;
      }

      if (_this.isWatchFeature() || _this.isWristTryonEnableOnRingFeature()) {
        var watch_time_component_vector = _this.YMKModule.CreateVector_WatchTimeComponentTransformMatrices(5);
        for (var _i4 = 0; _i4 < 5; _i4++) {
          var matrix_buffers = {
            p_second_transform_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_second_normal_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_minute_transform_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_minute_normal_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_hour_transform_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_hour_normal_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_day_transform_matrix: _this.YMKModule._malloc(sizeof_float * 16),
            p_day_normal_matrix: _this.YMKModule._malloc(sizeof_float * 16)
          };
          watch_time_component_vector.set(_i4, matrix_buffers);
        }
        buffers.watch_time_component_buffer = watch_time_component_vector;
      }

      if (_this.isRingFeature() || _this.isWatchFeature()) {
        var max_mv_block_width_info = new _this.YMKModule.IntObject();
        var max_mv_block_height_info = new _this.YMKModule.IntObject();
        _this.venus_makeup_live.GetRingMaxMVBlockDataSize(max_mv_block_width_info, max_mv_block_height_info);
        buffers.mv_block_buffer = _this.YMKModule._malloc(max_mv_block_width_info.value * max_mv_block_height_info.value);
        buffers.mv_prev_block_buffer = _this.YMKModule._malloc(max_mv_block_width_info.value * max_mv_block_height_info.value);
        max_mv_block_width_info.delete();
        max_mv_block_height_info.delete();
      } else if (_this.isNailFeature()) {
        var _max_mv_block_width_info = new _this.YMKModule.IntObject();
        var _max_mv_block_height_info = new _this.YMKModule.IntObject();
        _this.venus_makeup_live.GetNailMaxMVBlockDataSize(_max_mv_block_width_info, _max_mv_block_height_info);
        buffers.mv_block_buffer = _this.YMKModule._malloc(_max_mv_block_width_info.value * _max_mv_block_height_info.value);
        buffers.mv_prev_block_buffer = _this.YMKModule._malloc(_max_mv_block_width_info.value * _max_mv_block_height_info.value);
        _max_mv_block_width_info.delete();
        _max_mv_block_height_info.delete();
      }

      if (_this.isNailFeature()) {
        max_nail_width_info.delete();
        max_nail_height_info.delete();
        max_nail_art_width_info.delete();
        max_nail_art_height_info.delete();
        max_nail_tip_width_info.delete();
        max_nail_tip_height_info.delete();
        max_nail_env_map_width_info.delete();
        max_nail_env_map_height_info.delete();
      }
      max_hand_width_info.delete();
      max_hand_height_info.delete();

      return buffers;
    };

    _this.FreeResources = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20() {
      var i, t, _i5, _t;

      return _regenerator2.default.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              if (!(_this.venus_makeup_live == null)) {
                _context20.next = 2;
                break;
              }

              return _context20.abrupt('return');

            case 2:
              if (_this.hand_ar_metadata) {
                _this.hand_ar_metadata.delete();
                _this.hand_ar_metadata = null;
              }
              if (_this.wrist_hand_ar_metadata) {
                _this.wrist_hand_ar_metadata.delete();
                _this.wrist_hand_ar_metadata = null;
              }
              if (_this.nail_model_metadata) {
                _this.nail_model_metadata.delete();
                _this.nail_model_metadata = null;
              }
              if (_this.hand_ar_parameters) {
                _this.hand_ar_parameters.delete();
                _this.hand_ar_parameters = null;
              }
              if (_this.hand_ar_model_settings_var) {
                _this.hand_ar_model_settings_var.delete();
                _this.hand_ar_model_settings_var = null;
              }
              for (i = 0; i < MAX_LOOKS * FINGER_NUM; i++) {
                t = _this.nail_art_image_vec.get(i);

                if (t.p_data != null) {
                  _this.YMKModule._free(t.p_data);
                }
              }
              if (_this.nail_art_image_vec) {
                _this.nail_art_image_vec.delete();
                _this.nail_art_image_vec = null;
              }
              for (_i5 = 0; _i5 < MAX_LOOKS * FINGER_NUM; _i5++) {
                _t = _this.nail_tip_shape_vec.get(_i5);

                if (_t.p_data != null) {
                  _this.YMKModule._free(_t.p_data);
                }
              }
              if (_this.nail_tip_shape_vec) {
                _this.nail_tip_shape_vec.delete();
                _this.nail_tip_shape_vec = null;
              }
              if (_this.is_nail_art_image_changed_vec) {
                _this.is_nail_art_image_changed_vec.delete();
                _this.is_nail_art_image_changed_vec = null;
              }
              if (_this.is_nail_tip_shape_changed_vec) {
                _this.is_nail_tip_shape_changed_vec.delete();
                _this.is_nail_tip_shape_changed_vec = null;
              }
              _this.freeMetadataBuffers(_this.metadata_buffers);
              if (_this.wrist_metadata_buffers) {
                _this.freeMetadataBuffers(_this.wrist_metadata_buffers);
              }
              if (_this.nail_model_buffers) {
                _this.freeMetadataBuffers(_this.nail_model_buffers);
              }
              _this.venus_makeup_live = null;

              // if (!!this.engine_pointer) {
              //   this.YMKModule.ReleaseVenusLiveObject(this.engine_pointer);
              //   this.engine_pointer.delete();
              //   this.engine_pointer = null;
              // }
              if (_this.lastValidImageData) {
                _this.lastValidImageData = null;
              }

              _this.cleanUp();

            case 19:
            case 'end':
              return _context20.stop();
          }
        }
      }, _callee20, _this2);
    }));

    _this.cleanUp = function () {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(_this)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;

          if (!!_this[key]) {
            _this[key] = null;
            delete _this[key];
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    };

    _this.freeMetadataBuffers = function (b) {
      if (!b) {
        return;
      }
      if (b.p_transform_matrices) {
        _this.YMKModule._free(b.p_transform_matrices);
        b.p_transform_matrices = null;
      }
      if (b.p_normal_matrices) {
        _this.YMKModule._free(b.p_normal_matrices);
        b.p_normal_matrices = null;
      }
      if (b.p_camera_matrices) {
        _this.YMKModule._free(b.p_camera_matrices);
        b.p_camera_matrices = null;
      }
      if (b.p_occluder_transform_matrices) {
        _this.YMKModule._free(b.p_occluder_transform_matrices);
        b.p_occluder_transform_matrices = null;
      }
      if (b.p_occluder_normal_matrices) {
        _this.YMKModule._free(b.p_occluder_normal_matrices);
        b.p_occluder_normal_matrices = null;
      }
      if (b.p_nail_art_transform_matrices) {
        _this.YMKModule._free(b.p_nail_art_transform_matrices);
        b.p_nail_art_transform_matrices = null;
      }
      if (b.p_nail_art_normal_matrices) {
        _this.YMKModule._free(b.p_nail_art_normal_matrices);
        b.p_nail_art_normal_matrices = null;
      }
      if (b.p_wrist_trapezoid_matrices) {
        _this.YMKModule._free(b.p_wrist_trapezoid_matrices);
        b.p_wrist_trapezoid_matrices = null;
      }
      if (b.nail_mask_first3_buffer) {
        _this.YMKModule._free(b.nail_mask_first3_buffer);
        b.nail_mask_first3_buffer = null;
      }
      if (b.nail_mask_last3_buffer) {
        _this.YMKModule._free(b.nail_mask_last3_buffer);
        b.nail_mask_last3_buffer = null;
      }
      if (b.nail_light_mask_buffer) {
        _this.YMKModule._free(b.nail_light_mask_buffer);
        b.nail_light_mask_buffer = null;
      }

      if (b.mv_block_buffer) {
        b.mv_block_buffer && _this.YMKModule._free(b.mv_block_buffer);
        b.mv_block_buffer = null;
      }

      if (b.mv_prev_block_buffer) {
        b.mv_prev_block_buffer && _this.YMKModule._free(b.mv_prev_block_buffer);
        b.mv_prev_block_buffer = null;
      }

      if (_this.isNailFeature()) {
        for (var i = 0; i < 4 * 5; i++) {
          _this.YMKModule._free(b.nail_art_buffer.get(i));
          _this.YMKModule._free(b.nail_tip_buffer.get(i));
          _this.YMKModule._free(b.nail_env_map_buffer.get(i));
        }
        if (b.nail_art_buffer) {
          b.nail_art_buffer.delete();
          b.nail_art_buffer = null;
        }
        if (b.nail_tip_buffer) {
          b.nail_tip_buffer.delete();
          b.nail_tip_buffer = null;
        }
        if (b.nail_env_map_buffer) {
          b.nail_env_map_buffer.delete();
          b.nail_env_map_buffer = null;
        }
      }

      if (b.hand_mask_buffer) {
        _this.YMKModule._free(b.hand_mask_buffer);
        b.hand_mask_buffer = null;
      }

      if (b.watch_time_component_buffer) {
        for (var _i6 = 0; _i6 < 5; _i6++) {
          var matrix_buffers = b.watch_time_component_buffer.get(_i6);
          _this.YMKModule._free(matrix_buffers.p_second_transform_matrix);
          _this.YMKModule._free(matrix_buffers.p_second_normal_matrix);
          _this.YMKModule._free(matrix_buffers.p_minute_transform_matrix);
          _this.YMKModule._free(matrix_buffers.p_minute_normal_matrix);
          _this.YMKModule._free(matrix_buffers.p_hour_transform_matrix);
          _this.YMKModule._free(matrix_buffers.p_hour_normal_matrix);
          _this.YMKModule._free(matrix_buffers.p_day_transform_matrix);
          _this.YMKModule._free(matrix_buffers.p_day_normal_matrix);
        }
        b.watch_time_component_buffer.delete();
        b.watch_time_component_buffer = null;
      }
    };

    _this._cropFrame4Nail2ndDetect = function (input_width, input_height) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var input_size = input_width * input_height * 3;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.GetInputBufferOf2ndPass(_this.getFrameBuffer(), width, height, input_width, input_buffer);
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      return { input_array: input_array, input_buffer: input_buffer };
    };

    _this._cropFrameBilinear = function (input_width, input_height, x, y, w, h) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var input_size = input_width * input_height * 3;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.CropResizeBilinear(_this.frame_rgb_buffer, width, height, x || 0, y || 0, w || width, h || height, 3, input_width, input_height, input_buffer);
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      // this.YMKModule._free(input_buffer);
      return { input_array: input_array, input_buffer: input_buffer };
    };

    _this._cropFrame = function (input_width, input_height, x, y, w, h) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var input_size = input_width * input_height * 3;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.CropResize(_this.frame_rgb_buffer, width, height, x || 0, y || 0, w || width, h || height, 3, input_width, input_height, input_buffer);
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      // this.YMKModule._free(input_buffer);
      return { input_array: input_array, input_buffer: input_buffer };
    };

    _this._cropFrame4RingPatch = function (input_width, input_height, input_channel, with_mask) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var input_size = input_width * input_height * input_channel;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.CropResizeForRingPatch(_this.frame_rgb_buffer, width, height, 3, input_width, input_height, input_channel, input_buffer, with_mask);
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      return { input_array: input_array, input_buffer: input_buffer };
    };

    _this._cropFrame4Ring = function (input_width, input_height, input_channel) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var input_size = input_width * input_height * input_channel;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.CropResizeForRing(_this.frame_rgb_buffer, width, height, 3, input_width, input_height, input_channel, input_buffer);
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      return { input_array: input_array, input_buffer: input_buffer };
    };

    _this._cropFrame4Wrist = function (input_width, input_height) {
      var width = _this.getWidth();
      var height = _this.getHeight();
      var roi_x = new _this.YMKModule.IntObject();
      var roi_y = new _this.YMKModule.IntObject();
      var roi_width = new _this.YMKModule.IntObject();
      var roi_height = new _this.YMKModule.IntObject();
      var a = new _this.YMKModule.FloatObject();
      var bx = new _this.YMKModule.FloatObject();
      var by = new _this.YMKModule.FloatObject();
      _this.venus_makeup_live.GetWristDetectROIAndTransformationParameter(width, height, roi_x, roi_y, roi_width, roi_height, a, bx, by);
      var av = a.value;
      var bxv = bx.value;
      var byv = by.value;

      var input_size = input_width * input_height * 3;
      var input_buffer = _this.YMKModule._malloc(input_size);
      _this.venus_makeup_live.CropResizeForWrist(_this.frame_rgb_buffer, width, height, roi_x.value, roi_y.value, roi_width.value, roi_height.value, 3, input_width, input_height, input_buffer);
      roi_x.delete();
      roi_y.delete();
      roi_width.delete();
      roi_height.delete();
      a.delete();
      bx.delete();
      by.delete();
      var input_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, input_buffer, input_size);
      // this.YMKModule._free(input_buffer);
      return { input_array: input_array, input_buffer: input_buffer, a: av, bx: bxv, by: byv };
    };

    _this.GetModelVersionString = function (model_version_buffer, model_version_length) {
      var model_version_array = new Uint8Array(_this.YMKModule.HEAPU8.buffer, model_version_buffer, model_version_length);
      var str = '';
      for (var i = 0; i < model_version_length; i++) {
        str += String.fromCharCode(model_version_array[i]);
      }
      return str;
    };

    _this.isFaceQualityCheckerOpened = function () {
      return _this.faceQualityChecker && _this.faceQualityChecker.opened;
    };

    _this.saveBlob = function () {};

    _this.setRingFingerType = function () {};

    _this.delay = 0;
    _this.savePhotoFlag = false;
    _this.makeup_parameter_var = {};
    _this.web_frame_buffer = undefined;
    _this.m_feature_enable_arrays = [[], []];
    _this.maxLooks = 1;
    _this.splitFourWayEnabled = false;
    _this.splitFourWayBlobs = [];
    _this.marginLeft = 0;
    _this.isFirstTrackHand = true;
    _this.effectsHolder = new _currenteffectsholder2.default(params.emitter, _events2.default);
    _this.disableTracking = false;
    _this.is_wrist_ratio_adjustable = false;
    _this.object_position_offset = 0.0;
    _this.is_nail_pbr = false;
    _this.fingers = [{}, {}, {}, {}];
    for (var i = 0; i < MAX_LOOKS; i++) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)(FINGERS), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var finger = _step4.value;

          _this.fingers[i][finger] = {
            is_enabled: false,
            is_nail_art: false,
            color: { r: 0, g: 0, b: 0 },
            transparency: 0,
            light_intensity: 0,
            diffuse: 0
          };
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    _this.pbr_fingers = [{}, {}, {}, {}];
    for (var _i7 = 0; _i7 < MAX_LOOKS; _i7++) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)(FINGERS), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _finger2 = _step5.value;

          _this.pbr_fingers[_i7][_finger2] = {
            finish_type: 0,
            is_enabled: false,
            color: { r: 0, g: 0, b: 0 },
            transparency: 0,
            light_intensity: 0,
            roughness: 0,
            reflection: 0,
            metallic: 0,
            contrast: 50,
            is_nail_art: false,
            textured_granularity: 0,
            shimmer_opacity: 0,
            shimmer_granularity: 0
          };
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    _this.tip_fingers = [{}, {}, {}, {}];
    for (var _i8 = 0; _i8 < MAX_LOOKS; _i8++) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = (0, _getIterator3.default)(FINGERS), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _finger3 = _step6.value;

          _this.tip_fingers[_i8][_finger3] = {
            m_aspect_ratio: 1.3,
            m_aspect_ratio_adjuster: 1.0,
            m_nail_tip_mode: _this.YMKModule.VN_NailTipMode.NAIL_TIP_DEFAULT
          };
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
    _this.zoomLevel = 1.0;
    _this.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_NONE;
    _this.nail_vto_mode = _this.YMKModule.VN_VTOMode.NAIL_POLISH;
    _this.ringFingerType = '';
    return _this;
  }

  return MediaSource;
}(_AbstractMediaSource3.default);

exports.default = MediaSource;
module.exports = exports['default'];

/***/ }),

/***/ 3338:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MobileVideoSource = __webpack_require__(3339);

var _MobileVideoSource2 = _interopRequireDefault(_MobileVideoSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  load: function load(params) {
    return new _MobileVideoSource2.default(params);
  }
};
module.exports = exports['default'];

/***/ }),

/***/ 3339:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _toConsumableArray2 = __webpack_require__(184);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _VideoSource2 = __webpack_require__(3340);

var _VideoSource3 = _interopRequireDefault(_VideoSource2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_ZOOM_RATIO = 1.0;

var MobileVideoSource = function (_VideoSource) {
  (0, _inherits3.default)(MobileVideoSource, _VideoSource);

  function MobileVideoSource() {
    var _ref,
        _this2 = this;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, MobileVideoSource);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = MobileVideoSource.__proto__ || (0, _getPrototypeOf2.default)(MobileVideoSource)).call.apply(_ref, [this].concat(args))), _this), _this._render = function () {
      var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(imageData) {
        var checkFaceQualityResult;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (imageData) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return');

              case 2:
                if (!_this.isWatchFeature() && !_this.isRingFeature()) {
                  _this.venus_makeup_live.SetIsEditingMode(false);
                }

                if (!_this.isRingFeature()) {
                  _context.next = 7;
                  break;
                }

                _context.next = 6;
                return _this.checkFaceQuality(imageData);

              case 6:
                checkFaceQualityResult = _context.sent;

              case 7:
                // process on cpu
                _this.web_frame_buffer.set(imageData.data);
                _this.makeup_live_filter.SetFeatureEnableArray(_this.adjustFeatures(_this.m_feature_enable_arrays[0]));
                _this.SetHandARParameters();
                if (_this.isRingFeature()) {
                  _this.venus_makeup_live.SetRingRefinedByHandMaskEnable(true);
                }
                _this.venus_makeup_live.RGBAToRGB(_this.venus_frame_buffer, _this.camera_width, _this.camera_height, false, _this.frame_rgb_buffer);
                _context.next = 14;
                return _this.trackHand(_this.camera_width, _this.camera_height, _this.venus_frame_buffer);

              case 14:
                _this.makeup_live_filter.SetFeatureEnableArray(_this.adjustFeatures(_this.m_feature_enable_arrays[0]), 0);
                if (_this.isWristTryonEnableOnRingFeature()) {
                  _this.makeup_live_filter.SetFeatureEnableArray(_this.adjustFeatures(_this.m_feature_enable_arrays[1]), 1);
                }
                _this.makeup_live_filter.SetIsFrontCamera(_this._isFrontCamera());
                _this.makeup_live_filter.SetProcessRange(0.0, 1.0);
                if (_this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE]) {
                  if (_this._isFrontCamera()) {
                    _this.makeup_live_filter.SetProcessRange(0.0, Math.abs(1 - _this.m_compare_parameter));
                  } else {
                    _this.makeup_live_filter.SetProcessRange(_this.m_compare_parameter, 1.0);
                  }
                }
                _this.makeup_live_filter.SetBypassMode(false);
                if (_this.isWatchFeature()) {
                  if (!(0, _get3.default)(_this, 'settings.enableWristAutoZoom')) {
                    _this.makeup_live_filter.SetZoomRatio(_this.zoomRatio);
                  }
                  if (_this._isFrontCamera()) {
                    _this.makeup_live_filter.SetZoomRatio(_this.zoomRatio);
                  }
                } else if (_this.isRingFeature()) {
                  if (_this.isFaceQualityCheckerOpened()) {
                    _this.makeup_live_filter.SetZoomRatio(DEFAULT_ZOOM_RATIO);
                  } else {
                    _this.makeup_live_filter.SetZoomRatio(_this.zoomRatio);
                  }
                  _this.makeup_live_filter.SetObjectIntensity(1.0);
                }
                // upload to gpu
                _this.videoTexture.image.data = _this.web_frame_buffer;
                _this.videoTexture.needsUpdate = true;
                _this.makeup_live_filter.RenderFrame();
                if (_this.savePhotoFlag) {
                  _this.blob = _mediaUtils2.default.result2Blob(_this.renderer);
                }

              case 25:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }(), _this.adjustFeatures = function (v) {
      var vv = [].concat((0, _toConsumableArray3.default)(v));
      if ((_this.isWatchFeature() || _this.isRingFeature()) && _browserUtils2.default.isMobile() && _this.settings.facingMode === 'environment') {
        vv[_featureenum2.default.FEATURE_UPSCALE] = true;
      }

      if (_this.isRingFeature() && _this.isFaceQualityCheckerOpened()) {
        vv[_featureenum2.default.FEATURE_OBJECT3D] = false;
        return vv;
      }

      if (_this.isRingFeature() && vv[_featureenum2.default.FEATURE_OBJECT3D] && !_this.isWristTryonEnableOnRingFeature()) {
        vv[_featureenum2.default.FEATURE_OBJECT3D] = _this.hand_ar_metadata.detection_result == _this.YMKModule.VN_VTO_RESULT.VTO_SUCCESS;
        return vv;
      }

      if (_this.settings.disableNailsTakePhotoMode) {
        return vv;
      }
      if (_this.isPaused) {
        return vv;
      }
      if (_browserUtils2.default.isMobile()) {
        return vv;
      }
      if (!_this.isWatchFeature() && !_this.isRingFeature()) {
        vv[_featureenum2.default.FEATURE_OBJECT3D] = false;
      }
      return vv;
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  return MobileVideoSource;
}(_VideoSource3.default);

exports.default = MobileVideoSource;
module.exports = exports['default'];

/***/ }),

/***/ 3340:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _three = __webpack_require__(705);

var _media = __webpack_require__(1988);

var _media2 = _interopRequireDefault(_media);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _isNaN2 = __webpack_require__(135);

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _mixwith = __webpack_require__(786);

var _VideoOperations = __webpack_require__(829);

var _VideoOperations2 = _interopRequireDefault(_VideoOperations);

var _settings = __webpack_require__(39);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _throttle2 = __webpack_require__(25);

var _throttle3 = _interopRequireDefault(_throttle2);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_ZOOM_RATIO_RING = 1.35;
var DEFAULT_ZOOM_RATIO_WATCH = 1.5;
var VENUS_FRAME_BUFFER = void 0;
var FRAME_RGB_BUFFER = void 0;
var WIDTH = void 0;
var HEIGHT = void 0;

var VideoSource = function (_mix$with) {
  (0, _inherits3.default)(VideoSource, _mix$with);

  function VideoSource(params) {
    var _this2 = this;

    (0, _classCallCheck3.default)(this, VideoSource);

    var _this = (0, _possibleConstructorReturn3.default)(this, (VideoSource.__proto__ || (0, _getPrototypeOf2.default)(VideoSource)).call(this, params));

    _this.init = function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(callback) {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this.m_compare_parameter = _this.settings.compareMode === _settings.compareModes.split ? 0.5 : 1.0;
                _this.zoomLevel = 0;
                _this.videoContext = _this.canvas.getContext('2d');
                _this.getFrameDocument(_this.document, _this.frameId).getElementById(_this.outputId).innerHTML = '';
                _this.getFrameDocument(_this.document, _this.frameId).getElementById(_this.outputId).appendChild(_this.renderer.domElement);
                _this.AllocateResources();
                _context.t0 = callback;

                if (!_context.t0) {
                  _context.next = 10;
                  break;
                }

                _context.next = 10;
                return callback();

              case 10:
                _this.last_valid_face_rect_data = null;
                _this.splitFourWayEnabled = false;
                _this.resized = false;
                _this.videoWidth = 0;
                _this.videoHeight = 0;
                _this.isPaused = false;
                _this.x = 0;
                _this.lastValidImageData = null;
                if (_this.isWatchFeature()) {
                  _this._setZoomRatio(!(0, _isUndefined3.default)(_this.settings.zoomRatio) ? _this.settings.zoomRatio : DEFAULT_ZOOM_RATIO_WATCH);
                }
                if (_this.isRingFeature()) {
                  _this._setZoomRatio(!(0, _isUndefined3.default)(_this.settings.zoomRatio) ? _this.settings.zoomRatio : DEFAULT_ZOOM_RATIO_RING);
                }
                setTimeout(_this.render, 100);
                _this.emitter.on(_events2.default.cameraFlipped, _this.handleCameraFlipped);
                if (_this.isWatchFeature() || _this.isRingFeature()) {
                  _this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_UPSCALE] = true;
                }
                if (!_this.isWatchFeature() && !_this.isRingFeature()) {
                  _this.venus_makeup_live.ResetNailDetectionSmooth();
                }
                _this.is_watch_mode = false;
                if (_this.isRingFeature() && _this.settings.enableRingFingerTypeChange) {
                  _this.venus_makeup_live.SetRingFingerType(_this.ringFingerType || _this.settings.ringFingerType);
                }

              case 26:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    _this._setZoomRatio = function (input) {
      var v = parseFloat(input);
      _this.zoomRatio = Math.min(2.0, Math.max(1.0, v));
      if (_this.isPaused) {
        _this.update();
      }
    };

    _this.splitFourWay = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this.zoomLevel = 0;
              _this.comparing = false;
              _this.splitFourWayEnabled = true;

              if (!_this.isPaused) {
                _context2.next = 10;
                break;
              }

              _context2.next = 6;
              return _browserUtils2.default.sleep();

            case 6:
              _context2.next = 8;
              return _this.update();

            case 8:
              _context2.next = 10;
              return _this.update();

            case 10:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this2);
    }));
    _this.splitFourWayOff = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _this.comparing = false;
              _this.splitFourWayEnabled = false;

              if (!_this.isPaused) {
                _context3.next = 9;
                break;
              }

              _context3.next = 5;
              return _browserUtils2.default.sleep();

            case 5:
              _context3.next = 7;
              return _this.update();

            case 7:
              _context3.next = 9;
              return _this.update();

            case 9:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this2);
    }));
    _this.saveBlob = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return _this._prerender();

            case 3:
              _this.blob = _mediaUtils2.default.result2Blob(_this.renderer);
              _context4.next = 9;
              break;

            case 6:
              _context4.prev = 6;
              _context4.t0 = _context4['catch'](0);

              console.log(_context4.t0);

            case 9:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, _this2, [[0, 6]]);
    }));

    _this.update = function () {
      try {
        _this._prerender().then(function () {
          _this.blob = _mediaUtils2.default.result2Blob(_this.renderer);
        });
      } catch (err) {
        console.log({ err: err });
      }
    };

    _this.dragCompareIndicator = function (x) {
      if ((0, _isNaN3.default)(x)) {
        return;
      }
      if (_this.settings.compareMode === _settings.compareModes.replace) {
        return;
      }
      _this.x = x;
      var w = _this.display_width * _mediaUtils2.default.getZoomRatio(_this.zoomLevel);
      _this.m_compare_parameter = (x + w / 2) / w;
      if (!_this.timer) {
        _this.throttledPrerender();
      }
    };

    _this.isHairDyeEnabled = function () {
      return _this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_HAIR_DYE];
    };

    _this.savePhoto = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
      var _after, after, tempFeatures, before;

      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!(_this.settings.savePhotoType === 'watermark')) {
                _context5.next = 7;
                break;
              }

              _this.pauseTimer();
              _context5.next = 4;
              return _this._prerender();

            case 4:
              _after = _mediaUtils2.default.result2Blob(_this.renderer, 'image/png');

              _this.resumeTimer();
              return _context5.abrupt('return', {
                after: _after,
                width: _this.camera_height * _this.display_width / _this.display_height,
                height: _this.camera_height
              });

            case 7:
              _this.pauseTimer();
              _context5.next = 10;
              return _this._prerender();

            case 10:
              after = _mediaUtils2.default.result2Blob(_this.renderer, 'image/png');
              tempFeatures = (0, _extends3.default)({}, _this.m_feature_enable_arrays);

              _this.controller.reset(null, 0, false);
              _context5.next = 15;
              return _this._prerender();

            case 15:
              before = _mediaUtils2.default.result2Blob(_this.renderer, 'image/png');

              _this.m_feature_enable_arrays = tempFeatures;
              _context5.next = 19;
              return _this._prerender();

            case 19:
              _this.resumeTimer();
              return _context5.abrupt('return', {
                before: before,
                after: after,
                width: _this.camera_height * _this.display_width / _this.display_height,
                height: _this.camera_height
              });

            case 21:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this2);
    }));

    _this._AllocateFrameBuffer = function (width, height) {
      if (width === 0 || !height) {
        return;
      }
      var viewport = new _three.Vector4(0, 0, _this.camera_width, _this.camera_height);
      _this.makeup_live_filter.SetViewport(viewport);
      _this.renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);

      if (WIDTH !== width || HEIGHT !== height) {
        WIDTH = width;
        HEIGHT = height;
        if (VENUS_FRAME_BUFFER) {
          _this.YMKModule._free(VENUS_FRAME_BUFFER);
        }
        VENUS_FRAME_BUFFER = _this.YMKModule._malloc(width * height * 4);
        if (FRAME_RGB_BUFFER) {
          _this.YMKModule._free(FRAME_RGB_BUFFER);
        }
        FRAME_RGB_BUFFER = _this.YMKModule._malloc(width * height * 4);
      }
      _this.venus_frame_buffer = VENUS_FRAME_BUFFER;
      _this.web_frame_buffer = new Uint8ClampedArray(_this.YMKModule.HEAPU8.buffer, _this.venus_frame_buffer, width * height * 4);
      _this.frame_rgb_buffer = FRAME_RGB_BUFFER;
    };

    _this.freeResources = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _this.terminalized = true;
              _this.pause(true);
              _this.emitter.off(_events2.default.cameraFlipped, _this.handleCameraFlipped);
              _this.hasFace = false;
              _this.isLoadEngineCompleteTriggered = false;
              if (_this.videoTexture && _this.videoTexture.image && _this.videoTexture.image.data) {
                delete _this.videoTexture.image.data;
                delete _this.videoTexture.image;
              }
              if (_this.web_frame_buffer) {
                _this.web_frame_buffer = null;
              }
              // if (!!this.venus_frame_buffer) {
              //   this.YMKModule._free(this.venus_frame_buffer);
              //   this.venus_frame_buffer = null;
              //   this.web_frame_buffer = null;
              // }
              // if (this.frame_rgb_buffer) {
              //   this.YMKModule._free(this.frame_rgb_buffer);
              //   this.frame_rgb_buffer = null;
              // }
              if (_this.streamCanvas) {
                _mediaUtils2.default.releaseCanvas(_this.streamCanvas);
              }
              if (_this.blob) {
                _this.blob = null;
              }
              if (!!_this.faceQualityCHecker) {
                (0, _isFunction3.default)(_this.faceQualityChecker.cleanUp) && _this.faceQualityChecker.cleanUp();
              }
              _context6.next = 12;
              return _this.FreeResources();

            case 12:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, _this2);
    }));

    _this.getWidth = function () {
      return _this.camera_width;
    };

    _this.getHeight = function () {
      return _this.camera_height;
    };

    _this.getFrameBuffer = function () {
      return _this.venus_frame_buffer;
    };

    _this.isUserNailReplacement = function () {
      return _this.settings.enableUserNailReplacement;
    };

    _this.setRingFingerType = function (ringFingerType) {
      if (!_this.isRingFeature()) {
        return;
      }
      if (!_this.settings.enableRingFingerTypeChange) {
        return;
      }
      if (!_settings.ringFingerTypes[ringFingerType]) {
        return;
      }
      _this.ringFingerType = _settings.ringFingerTypes[ringFingerType] || _this.settings.ringFingerType;
      _this.venus_makeup_live.SetRingFingerType(_settings.ringFingerTypes[ringFingerType]);
    };

    _this.maxLooks = 2;
    _this.detectFace = true;
    _this.setZoomRatio = (0, _throttle3.default)(_this._setZoomRatio, 300, { leading: false });
    return _this;
  }

  return VideoSource;
}((0, _mixwith.mix)(_media2.default).with(_VideoOperations2.default));

exports.default = VideoSource;
module.exports = exports['default'];

/***/ }),

/***/ 3341:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x53e6=['m_object3D_filter_array','SetShowHandMask','FEATURE_OBJECT3D','FEATURE_SMOOTH','createImageTexture','setScissorTest','RING_VTO','GetMeasureResultInPixel','max_upsample_factor\x20should\x20be\x201,\x202\x20or\x204\x20(got\x20%d)','m_is_photo_mode','minFilter','YMKModule','push','createVideoTexture','log','m_input_texture','width','m_is_four_way','SetSkinSmoothColorIntensity','crop_width','m_flip_filter','substring','__esModule','setViewport','m_height','m_feature_enable_arrays','exports','settings','DataTexture','SetObject3DViewerBackgroundColor','call','SetZoomRatio','SetHintViewTexture','m_is_vto_valid','crop_height','SetShowHintView','SetGemBloomThreshold','SetFeatureEnableArray\x20wrong\x20array\x20size,\x20%d','is_four_way','FEATURE_SIZE','renderLists','SetMeasurePosition','material','SetGemBloomParameters','start_xy','length','m_crop_filter','SetObject3DViewerMetadata','VN_VTOMode','error','SetViewport','SetPBRTextureMap','SetHandARFingerOccluder','dispose','m_upscale_filter','getSize','RenderFrame','FEATURE_UPSCALE','SetPBRTextureMapIntensity','SetFresnelIntensity','setClearColor','m_hint_view_filter','is_palm_detected','is_ring_valid','skin_smooth_intensity','m_bypass_mode','m_viewport','SetInputTexture','SetPBRTextureMapTransform','GetAnimationEnd','SetObject3DViewerMode','fill','SetRenderCenter','m_target','m_width','SetGemBloomSharpness','Destroy','m_renderer','value','isPbr','Vector2','SetPBREnvMapParameters','end_xy','clear','SetIsFrontCamera','SetPBRHDRIEnvMap','SetGemParameters','uniforms','SetHintViewEffect','magFilter','max_upsample_factor','SetAlgorithmIndex','SetIsZoomSrcEnabled','SetProcessRange',')\x20and\x20render_data_vecs\x20(','ResetWidthHeight','SetIsEstimateLeftHand','texture','m_skin_smooth_filter_array','default','SetWatchTimeComponentParameters','SetCropWidth','is_wrist_valid','SetSkinSmoothStrength','SetFourWayInfo','vto_mode','SetHandARMetadata','LinearFilter','setBackgroundColor','defineProperty','SetGemBloomIntensity','setGetBloomIntensityRatioFunc','max','height','SetIsNailDebug','SetIsGem','SetObjectIntensity','SetShowOccluder','SetObject3DRenderData','SetBypassMode','SetHintViewType','min','setScissor','skin_smooth_color_intensity','m_mesh'];(function(_0xa926b,_0x53e67b){var _0x301aa5=function(_0x4104ba){while(--_0x4104ba){_0xa926b['push'](_0xa926b['shift']());}};_0x301aa5(++_0x53e67b);}(_0x53e6,0x66));var _0x301a=function(_0xa926b,_0x53e67b){_0xa926b=_0xa926b-0x0;var _0x301aa5=_0x53e6[_0xa926b];return _0x301aa5;};'use strict';Object[_0x301a('0x7')](exports,_0x301a('0x2d'),{'value':!![]}),exports[_0x301a('0x7a')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_object3dfilter=__webpack_require__(3342),_object3dfilter2=_interopRequireDefault(_object3dfilter),_skinsmoothfilter=__webpack_require__(3363),_skinsmoothfilter2=_interopRequireDefault(_skinsmoothfilter),_cropfilter=__webpack_require__(3369),_cropfilter2=_interopRequireDefault(_cropfilter),_upscalefilter=__webpack_require__(3371),_upscalefilter2=_interopRequireDefault(_upscalefilter),_flipfilter=__webpack_require__(3373),_flipfilter2=_interopRequireDefault(_flipfilter),_featureenum=__webpack_require__(733),_featureenum2=_interopRequireDefault(_featureenum),_hintviewfilter=__webpack_require__(3375),_hintviewfilter2=_interopRequireDefault(_hintviewfilter);function _interopRequireDefault(_0x91cc3f){return _0x91cc3f&&_0x91cc3f[_0x301a('0x2d')]?_0x91cc3f:{'default':_0x91cc3f};}var MAX_LOOK_COUNT=0x2,MakeupLiveFilter=(_temp=_class=function MakeupLiveFilter(_0x1c5a08,_0x26634c,_0x3f416b,_0x2e29da,_0x5ac615,_0x1c69db,_0x31bf8d){(0x0,_classCallCheck3[_0x301a('0x7a')])(this,MakeupLiveFilter),_initialiseProps[_0x301a('0x35')](this),this[_0x301a('0x32')]=_0x1c69db,this[_0x301a('0x22')]=_0x5ac615;var _0x2bcfc2=_0x1c69db[_0x301a('0x71')]||0x2;_0x2bcfc2!=0x1&&_0x2bcfc2!=0x2&&_0x2bcfc2!=0x4&&(console[_0x301a('0x48')](_0x301a('0x1f'),_0x2bcfc2),_0x2bcfc2=0x2);this[_0x301a('0x17')]=[],this[_0x301a('0x79')]=[],this[_0x301a('0x38')]=[];for(var _0xb3ff54=0x0;_0xb3ff54<MAX_LOOK_COUNT;_0xb3ff54++){this[_0x301a('0x17')][_0x301a('0x23')](new _object3dfilter2[(_0x301a('0x7a'))](_0x1c5a08,_0x26634c,_0x2bcfc2,_0x5ac615)),this[_0x301a('0x79')][_0x301a('0x23')](new _skinsmoothfilter2[(_0x301a('0x7a'))](_0x1c5a08,_0x26634c)),this[_0x301a('0x38')][_0x301a('0x23')](![]);}this[_0x301a('0x64')]=_0x2e29da,this[_0x301a('0x45')]=new _cropfilter2['default'](_0x1c5a08,_0x26634c),this['m_upscale_filter']=new _upscalefilter2[(_0x301a('0x7a'))](_0x1c5a08,_0x26634c),this[_0x301a('0x2b')]=new _flipfilter2['default'](_0x1c5a08,_0x26634c),this[_0x301a('0x54')]=new _hintviewfilter2[(_0x301a('0x7a'))](_0x1c5a08,_0x26634c,0x0);var _0x2039c7=this[_0x301a('0x64')][_0x301a('0x4e')]();this[_0x301a('0x64')]['setSize'](Math[_0x301a('0x13')](_0x1c5a08,_0x2039c7[_0x301a('0x27')]),Math['min'](_0x26634c,_0x2039c7['height']));this['settings'][_0x301a('0x66')]()&&this[_0x301a('0x64')][_0x301a('0x53')](0xffffff,0x0);this[_0x301a('0x61')]=_0x1c5a08,this[_0x301a('0x2f')]=_0x26634c,this[_0x301a('0x20')]=_0x3f416b,this[_0x301a('0x2a')]=0x0,this[_0x301a('0x5f')](0.5),this[_0x301a('0x26')]=null,this['m_bypass_mode']=![],this['m_is_valid_metadata']=[![],![]],this[_0x301a('0x28')]=![],this[_0x301a('0x30')]=[[],[]];for(var _0x19ebcc=0x0;_0x19ebcc<_featureenum2['default'][_0x301a('0x3e')];_0x19ebcc++){this[_0x301a('0x30')][0x0][_0x301a('0x23')](![]),this[_0x301a('0x30')][0x1][_0x301a('0x23')](![]);}},_initialiseProps=function _initialiseProps(){var _0x1b521f=this;this[_0x301a('0x76')]=function(_0x15f14f,_0x393f17){_0x1b521f['m_crop_filter']['ResetWidthHeight'](_0x15f14f,_0x393f17),_0x1b521f[_0x301a('0x4d')][_0x301a('0x76')](_0x15f14f,_0x393f17),_0x1b521f[_0x301a('0x2b')][_0x301a('0x76')](_0x15f14f,_0x393f17),_0x1b521f[_0x301a('0x54')][_0x301a('0x76')](_0x15f14f,_0x393f17);for(var _0x203191=0x0;_0x203191<MAX_LOOK_COUNT;_0x203191++){_0x1b521f[_0x301a('0x17')][_0x203191][_0x301a('0x76')](_0x15f14f,_0x393f17),_0x1b521f[_0x301a('0x79')][_0x203191]['ResetWidthHeight'](_0x15f14f,_0x393f17);}var _0x18115f=_0x1b521f[_0x301a('0x64')][_0x301a('0x4e')]();_0x1b521f[_0x301a('0x64')]['setSize'](Math[_0x301a('0x13')](_0x15f14f,_0x18115f[_0x301a('0x27')]),Math[_0x301a('0x13')](_0x393f17,_0x18115f[_0x301a('0xb')])),_0x1b521f['m_width']=_0x15f14f,_0x1b521f[_0x301a('0x2f')]=_0x393f17,_0x1b521f[_0x301a('0x2a')]=(_0x1b521f['m_width']-_0x18115f[_0x301a('0x27')])/0x4,_0x1b521f[_0x301a('0x39')]=(_0x1b521f[_0x301a('0x2f')]-_0x18115f['height'])/0x4,_0x1b521f[_0x301a('0x5f')](0.5);},this[_0x301a('0x5a')]=function(_0x1b596b){return _0x1b521f[_0x301a('0x26')]=_0x1b596b;},this[_0x301a('0x37')]=function(_0x152ea3,_0x937388,_0x33e4d9,_0x5dda6f,_0x569da5,_0x26ef3d,_0xf7d15b,_0x312b4b,_0xb3dcf8,_0x579586){return _0x1b521f[_0x301a('0x54')][_0x301a('0x37')](_0x152ea3,_0x937388,_0x33e4d9,_0x5dda6f,_0x569da5,_0x26ef3d,_0xf7d15b,_0x312b4b,_0xb3dcf8,_0x579586);},this[_0x301a('0x6f')]=function(_0xc38ff2,_0x2b9fce,_0x4004c7,_0x50d0b4,_0x5f2fe8,_0x4cc186,_0xa26dc7){return _0x1b521f['m_hint_view_filter']['SetHintViewEffect'](_0xc38ff2,_0x2b9fce,_0x4004c7,_0x50d0b4,_0x5f2fe8,_0x4cc186,_0xa26dc7);},this[_0x301a('0x3a')]=function(_0x5b2d05,_0x3c6e7a){return _0x1b521f[_0x301a('0x54')][_0x301a('0x3a')](_0x5b2d05,_0x3c6e7a);},this['SetMeasurePosition']=function(_0x1e80ef,_0x228e96){return _0x1b521f[_0x301a('0x54')][_0x301a('0x40')](_0x1e80ef,_0x228e96);},this['ResetMeasurePosition']=function(){return _0x1b521f['m_hint_view_filter']['ResetMeasurePosition']();},this['GetMeasureResultInPixel']=function(_0x1cfb01){return _0x1b521f['m_hint_view_filter'][_0x301a('0x1e')](_0x1cfb01);},this[_0x301a('0x77')]=function(_0x835f42){return _0x1b521f[_0x301a('0x54')][_0x301a('0x77')](_0x835f42);},this[_0x301a('0x11')]=function(_0x2bc28e){return _0x1b521f[_0x301a('0x58')]=_0x2bc28e;},this['SetFeatureEnableArray']=function(_0x477d75){var _0x1dcccf=arguments[_0x301a('0x44')]>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;if(_0x477d75['length']==_0x1b521f[_0x301a('0x30')][0x0][_0x301a('0x44')]&&_featureenum2[_0x301a('0x7a')][_0x301a('0x3e')]==_0x1b521f[_0x301a('0x30')][0x0]['length'])for(var _0x27136f=0x0;_0x27136f<_featureenum2[_0x301a('0x7a')]['FEATURE_SIZE'];_0x27136f++){_0x1b521f[_0x301a('0x30')][_0x1dcccf][_0x27136f]=_0x477d75[_0x27136f];}else{console[_0x301a('0x25')](_0x301a('0x3c'),_0x477d75[_0x301a('0x44')]);for(var _0x2a7e5d=0x0;_0x2a7e5d<_featureenum2[_0x301a('0x7a')][_0x301a('0x3e')];_0x2a7e5d++){_0x1b521f[_0x301a('0x30')][_0x1dcccf][_0x2a7e5d]=![];}}},this[_0x301a('0x4f')]=function(){_0x1b521f[_0x301a('0x64')][_0x301a('0x6a')]();var _0x3a68da=[];!_0x1b521f[_0x301a('0x58')]&&(_0x1b521f[_0x301a('0x30')][0x0][_featureenum2['default'][_0x301a('0x1a')]]&&_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x79')][0x0]));if(!_0x1b521f[_0x301a('0x58')]){var _0x2ef9ee=![],_0x549f73=![];for(var _0x1a3486=0x0;_0x1a3486<MAX_LOOK_COUNT;_0x1a3486++){_0x1b521f[_0x301a('0x38')][_0x1a3486]&&_0x1b521f[_0x301a('0x30')][_0x1a3486][_featureenum2[_0x301a('0x7a')][_0x301a('0x19')]]&&(_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x17')][_0x1a3486]),_0x2ef9ee=!![],_0x1b521f[_0x301a('0x17')][_0x1a3486][_0x301a('0x73')](_0x549f73==![]),_0x549f73=!![]);}_0x2ef9ee==![]&&_0x1b521f[_0x301a('0x30')][0x0][_featureenum2[_0x301a('0x7a')]['FEATURE_UPSCALE']]&&_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x4d')]);}else _0x1b521f[_0x301a('0x30')][0x0][_featureenum2[_0x301a('0x7a')][_0x301a('0x50')]]&&_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x4d')]);if(!_0x1b521f[_0x301a('0x20')])_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x45')]);_0x3a68da['push'](_0x1b521f[_0x301a('0x2b')]),_0x3a68da[_0x301a('0x23')](_0x1b521f[_0x301a('0x54')]);var _0x14fccc=_0x3a68da[_0x301a('0x44')];if(_0x14fccc>0x0){_0x3a68da[0x0][_0x301a('0x5a')](_0x1b521f[_0x301a('0x26')]);for(var _0x551045=0x1;_0x551045<_0x14fccc;_0x551045++){_0x3a68da[_0x551045][_0x301a('0x5a')](_0x3a68da[_0x551045-0x1][_0x301a('0x60')][_0x301a('0x78')]);}}if(!_0x1b521f[_0x301a('0x28')])for(var _0x1b4f1c=0x0;_0x1b4f1c<_0x14fccc;_0x1b4f1c++){_0x3a68da[_0x1b4f1c][_0x301a('0x2')](![],0x0);var _0x43b220=_0x1b4f1c!=_0x14fccc-0x1;_0x3a68da[_0x1b4f1c][_0x301a('0x4f')](_0x1b521f[_0x301a('0x64')],_0x43b220);}else{_0x1b521f[_0x301a('0x64')]['setScissorTest'](!![]);for(var _0x383278=0x0;_0x383278<0x4;_0x383278++){for(var _0x55abd2=0x0;_0x55abd2<_0x14fccc;_0x55abd2++){if(_0x55abd2==_0x14fccc-0x1){if(_0x383278==0x0)_0x1b521f[_0x301a('0x64')]['setViewport'](_0x1b521f[_0x301a('0x59')]['x']+_0x1b521f[_0x301a('0x2a')],_0x1b521f[_0x301a('0x59')]['y'],_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2),_0x1b521f[_0x301a('0x64')][_0x301a('0x14')](_0x1b521f[_0x301a('0x59')]['x']+_0x1b521f[_0x301a('0x2a')],_0x1b521f[_0x301a('0x59')]['y'],_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2);else{if(_0x383278==0x1)_0x1b521f[_0x301a('0x64')][_0x301a('0x2e')](_0x1b521f[_0x301a('0x59')]['x']-_0x1b521f['crop_width']+_0x1b521f['m_viewport']['z']/0x2,_0x1b521f[_0x301a('0x59')]['y'],_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2),_0x1b521f[_0x301a('0x64')][_0x301a('0x14')](_0x1b521f[_0x301a('0x59')]['x']+_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['y'],_0x1b521f['m_viewport']['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2);else{if(_0x383278==0x2)_0x1b521f[_0x301a('0x64')][_0x301a('0x2e')](_0x1b521f[_0x301a('0x59')]['x']+_0x1b521f[_0x301a('0x2a')],_0x1b521f[_0x301a('0x59')]['y']+_0x1b521f[_0x301a('0x59')]['w']/0x2,_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2),_0x1b521f[_0x301a('0x64')][_0x301a('0x14')](_0x1b521f[_0x301a('0x59')]['x']+_0x1b521f['crop_width'],_0x1b521f['m_viewport']['y']+_0x1b521f['m_viewport']['w']/0x2,_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2);else _0x383278==0x3&&(_0x1b521f['m_renderer'][_0x301a('0x2e')](_0x1b521f['m_viewport']['x']-_0x1b521f[_0x301a('0x2a')]+_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['y']+_0x1b521f[_0x301a('0x59')]['w']/0x2,_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2),_0x1b521f[_0x301a('0x64')][_0x301a('0x14')](_0x1b521f['m_viewport']['x']+_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['y']+_0x1b521f[_0x301a('0x59')]['w']/0x2,_0x1b521f[_0x301a('0x59')]['z']/0x2,_0x1b521f[_0x301a('0x59')]['w']/0x2));}}}_0x3a68da[_0x55abd2][_0x301a('0x2')](!![],_0x383278);var _0x505845=_0x55abd2!=_0x14fccc-0x1;_0x3a68da[_0x55abd2][_0x301a('0x4f')](_0x1b521f[_0x301a('0x64')],_0x505845);}}_0x1b521f[_0x301a('0x64')]['setViewport'](_0x1b521f['m_viewport']['x'],_0x1b521f[_0x301a('0x59')]['y'],_0x1b521f[_0x301a('0x59')]['z'],_0x1b521f[_0x301a('0x59')]['w']),_0x1b521f['m_renderer'][_0x301a('0x1c')](![]);}for(var _0x3b5f33=0x0;_0x3b5f33<_0x14fccc;_0x3b5f33++){_0x3a68da[_0x3b5f33]['DisposeTexture']();}},this[_0x301a('0x6b')]=function(_0x5106d3){return _0x1b521f[_0x301a('0x2b')][_0x301a('0x6b')](_0x5106d3);},this[_0x301a('0x5f')]=function(_0x2ec53c){var _0x5651ec=_0x1b521f[_0x301a('0x61')],_0x1f15bf=_0x1b521f['m_height'],_0x1c3357=_0x1b521f['m_renderer'][_0x301a('0x4e')](),_0x3f6ba4=Math['min'](_0x1c3357[_0x301a('0x27')],_0x5651ec),_0x58aaaa=Math[_0x301a('0x13')](_0x1c3357[_0x301a('0xb')],_0x1f15bf),_0x2e0bae=(_0x5651ec-_0x3f6ba4)*0.5/_0x5651ec,_0x234c2f=Math[_0x301a('0x13')](Math[_0x301a('0xa')](_0x2ec53c,0.5-_0x2e0bae),0.5+_0x2e0bae),_0x108da2=_0x3f6ba4*0.5/_0x5651ec,_0x490567=Math[_0x301a('0xa')](_0x234c2f-_0x108da2,0x0),_0x502c72=Math[_0x301a('0x13')](_0x234c2f+_0x108da2,0x1);_0x1b521f['m_crop_filter'][_0x301a('0x16')][_0x301a('0x41')]['uniforms']['crop_start_end_x'][_0x301a('0x65')]=new _three[(_0x301a('0x67'))](_0x490567,_0x502c72);},this[_0x301a('0x10')]=function(_0x285093,_0x4dc869,_0x23d284,_0x384e5c,_0xe6e3f0){var _0x154b5b=arguments['length']>0x5&&arguments[0x5]!==undefined?arguments[0x5]:![],_0x305d1b=arguments[_0x301a('0x44')]>0x6&&arguments[0x6]!==undefined?arguments[0x6]:0x0,_0xd2180d=arguments[_0x301a('0x44')]>0x7&&arguments[0x7]!==undefined?arguments[0x7]:null;_0x1b521f[_0x301a('0x64')][_0x301a('0x3f')][_0x301a('0x4c')](),_0xd2180d==null&&(_0xd2180d=Array(_0x285093[_0x301a('0x44')])[_0x301a('0x5e')](!![])),console['log'](_0xd2180d),_0xd2180d[_0x301a('0x44')]!=_0x285093[_0x301a('0x44')]&&console[_0x301a('0x48')]('mismatch\x20length\x20between\x20is_update_array\x20('+_0xd2180d[_0x301a('0x44')]+_0x301a('0x75')+_0x285093[_0x301a('0x44')]+')'),_0x1b521f[_0x301a('0x17')][_0x305d1b]['SetObject3DRenderData'](_0x285093,_0x4dc869,_0x23d284,_0x384e5c,_0xe6e3f0,_0x154b5b,_0xd2180d);},this['SetObject3DShowOccluder']=function(_0x311e94){for(var _0x1fb5fa=0x0;_0x1fb5fa<MAX_LOOK_COUNT;_0x1fb5fa++){_0x1b521f[_0x301a('0x17')][_0x1fb5fa][_0x301a('0xf')](_0x311e94);}},this[_0x301a('0x63')]=function(){for(var _0xd71973=0x0;_0xd71973<MAX_LOOK_COUNT;_0xd71973++){_0x1b521f[_0x301a('0x17')][_0xd71973][_0x301a('0x63')](),_0x1b521f[_0x301a('0x79')][_0xd71973][_0x301a('0x63')]();}_0x1b521f[_0x301a('0x45')][_0x301a('0x63')](),_0x1b521f[_0x301a('0x4d')][_0x301a('0x63')](),_0x1b521f[_0x301a('0x2b')][_0x301a('0x63')](),_0x1b521f[_0x301a('0x54')][_0x301a('0x63')]();},this['SetHandARMetadata']=function(_0x4a0354){var _0x4071da=arguments['length']>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;_0x1b521f[_0x301a('0x38')][_0x4071da]=_0x4a0354[_0x301a('0x3')]==_0x1b521f[_0x301a('0x22')][_0x301a('0x47')][_0x301a('0x1d')]?_0x4a0354[_0x301a('0x55')]&&_0x4a0354[_0x301a('0x56')]:_0x4a0354['is_palm_detected']||_0x4a0354['is_wrist_detected']&&_0x4a0354[_0x301a('0x0')],_0x1b521f['m_object3D_filter_array'][_0x4071da][_0x301a('0x4')](_0x4a0354),_0x1b521f[_0x301a('0x79')][0x0][_0x301a('0x1')](_0x4a0354[_0x301a('0x57')]),_0x1b521f[_0x301a('0x79')][0x0][_0x301a('0x29')](_0x4a0354[_0x301a('0x15')]),_0x1b521f['m_skin_smooth_filter_array'][0x0]['UpdateSkinSmoothUniforms'](),_0x1b521f[_0x301a('0x28')]=_0x4a0354[_0x301a('0x3d')];},this[_0x301a('0x4b')]=function(_0xf48332){var _0xc8a26e=arguments[_0x301a('0x44')]>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;return _0x1b521f[_0x301a('0x17')][_0xc8a26e]['SetRingFingerOccluder'](_0xf48332);},this[_0x301a('0xc')]=function(_0x375dcc){return _0x1b521f[_0x301a('0x17')][0x0]['SetIsNailDebug'](_0x375dcc);},this[_0x301a('0x36')]=function(_0x413195){var _0x132799=_0x1b521f[_0x301a('0x61')]/_0x413195,_0x22f1a4=_0x1b521f[_0x301a('0x2f')]/_0x413195,_0x3af129=(_0x1b521f[_0x301a('0x61')]-_0x132799)*0.5,_0x134e5a=(_0x1b521f[_0x301a('0x2f')]-_0x22f1a4)*0.5,_0x270284=_0x3af129/_0x1b521f['m_width'],_0x3a2d4e=_0x134e5a/_0x1b521f[_0x301a('0x2f')],_0x4bf21a=(_0x3af129+_0x132799)/_0x1b521f[_0x301a('0x61')],_0x3f114f=(_0x134e5a+_0x22f1a4)/_0x1b521f[_0x301a('0x2f')];_0x1b521f[_0x301a('0x4d')][_0x301a('0x16')][_0x301a('0x41')][_0x301a('0x6e')][_0x301a('0x43')][_0x301a('0x65')]=new _three['Vector2'](_0x270284,_0x3a2d4e),_0x1b521f['m_upscale_filter'][_0x301a('0x16')][_0x301a('0x41')]['uniforms'][_0x301a('0x69')][_0x301a('0x65')]=new _three['Vector2'](_0x4bf21a,_0x3f114f);for(var _0x349a2d=0x0;_0x349a2d<MAX_LOOK_COUNT;_0x349a2d++){_0x1b521f[_0x301a('0x17')][_0x349a2d]['SetZoomRatio'](_0x413195);}},this[_0x301a('0x49')]=function(_0x20f319){return _0x1b521f[_0x301a('0x59')]=_0x20f319;},this[_0x301a('0x7b')]=function(_0x55b1cc,_0x51c0ae){return _0x1b521f['m_object3D_filter_array'][0x0][_0x301a('0x7b')](_0x55b1cc,_0x51c0ae);},this[_0x301a('0x7c')]=function(_0x472165){return _0x1b521f[_0x301a('0x2a')]=_0x472165;},this[_0x301a('0x74')]=function(_0x35492c,_0x21384e){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x74')](_0x35492c,_0x21384e,0x0,0x1);},this[_0x301a('0x46')]=function(_0x42233e){var _0x32c296=arguments[_0x301a('0x44')]>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;_0x1b521f['m_is_vto_valid'][_0x32c296]=!![],_0x1b521f[_0x301a('0x17')][_0x32c296][_0x301a('0x46')](_0x42233e);},this[_0x301a('0x5d')]=function(_0x2c4a9c){var _0x20be11=arguments['length']>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;_0x1b521f[_0x301a('0x17')][_0x20be11][_0x301a('0x5d')](_0x2c4a9c);},this[_0x301a('0xe')]=function(_0xfdd5){var _0x533593=arguments[_0x301a('0x44')]>0x1&&arguments[0x1]!==undefined?arguments[0x1]:0x0;return _0x1b521f['m_object3D_filter_array'][0x0][_0x301a('0xe')](_0xfdd5,_0x533593);},this[_0x301a('0x52')]=function(_0x3e68d6,_0x320b50){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x52')](_0x3e68d6,_0x320b50);},this[_0x301a('0x68')]=function(_0x1704ef,_0x123b98,_0xb917c2,_0x5ebf91,_0x5ed8dc){var _0x5d5997=arguments[_0x301a('0x44')]>0x5&&arguments[0x5]!==undefined?arguments[0x5]:0x0;return _0x1b521f['m_object3D_filter_array'][0x0]['SetPBREnvMapParameters'](_0x1704ef,_0x123b98,_0xb917c2,_0x5ebf91,_0x5ed8dc,_0x5d5997);},this[_0x301a('0x6c')]=function(_0x3af7b4,_0x228f59,_0x284b65){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x6c')](_0x3af7b4,_0x228f59,_0x284b65);},this[_0x301a('0x4a')]=function(_0x1f2ee9,_0x111d34,_0x40d466){var _0x23a748=arguments[_0x301a('0x44')]>0x3&&arguments[0x3]!==undefined?arguments[0x3]:0x0;return _0x1b521f[_0x301a('0x17')][0x0]['SetPBRTextureMap'](_0x1f2ee9,_0x111d34,_0x40d466,_0x23a748);},this[_0x301a('0x51')]=function(_0x503c01,_0x3d2146,_0x536a69){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x51')](_0x503c01,_0x3d2146,_0x536a69);},this[_0x301a('0x5b')]=function(_0x49ce72,_0x56c501,_0x44c806,_0x4d2e18,_0x39de8c){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x5b')](_0x49ce72,_0x56c501,_0x44c806,_0x4d2e18,_0x39de8c);},this[_0x301a('0x18')]=function(_0x167874){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x18')](_0x167874);},this[_0x301a('0x42')]=function(_0x3d91a1,_0x5974aa,_0x2a77fe,_0x5c21c7){_0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x8')](_0x3d91a1),_0x1b521f[_0x301a('0x17')][0x0]['SetGemBloomScale'](_0x5974aa),_0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x62')](_0x5c21c7),_0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x3b')](_0x2a77fe);},this['SetGemParameters']=function(_0x50ae0a,_0x29052d,_0x21952c,_0x2cdfe3){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0x6d')](_0x50ae0a,_0x29052d,_0x21952c,_0x2cdfe3);},this[_0x301a('0xd')]=function(_0x361cfd,_0xca3e6){return _0x1b521f[_0x301a('0x17')][0x0][_0x301a('0xd')](_0x361cfd,_0xca3e6);},this['SetAlgorithmIndex']=function(_0xe28859){for(var _0x53b02e=0x0;_0x53b02e<MAX_LOOK_COUNT;_0x53b02e++){_0x1b521f['m_object3D_filter_array'][_0x53b02e][_0x301a('0x72')](_0xe28859);}},this[_0x301a('0x5c')]=function(){return _0x1b521f[_0x301a('0x54')]['GetAnimationEnd']();},this[_0x301a('0x12')]=function(_0x5e4c3a){return _0x1b521f['m_hint_view_filter'][_0x301a('0x12')](_0x5e4c3a);},this[_0x301a('0x6')]=function(_0x5c9439){var _0x567b3f=0x0;_0x5c9439&&_0x5c9439[_0x301a('0x44')]===0x7&&(_0x567b3f=parseInt(_0x5c9439[_0x301a('0x2c')](0x1),0x10)),_0x1b521f[_0x301a('0x64')][_0x301a('0x53')](_0x567b3f,0x0);},this[_0x301a('0x34')]=function(_0x28942e,_0x4e73ff,_0x138230,_0x930a2e){var _0x55f218=arguments[_0x301a('0x44')]>0x4&&arguments[0x4]!==undefined?arguments[0x4]:0x0;_0x1b521f[_0x301a('0x17')][_0x55f218][_0x301a('0x34')](_0x28942e,_0x4e73ff,_0x138230,_0x930a2e);},this[_0x301a('0x9')]=function(_0xf6a5a9){for(var _0x236116=0x0;_0x236116<MAX_LOOK_COUNT;_0x236116++){_0x1b521f['m_object3D_filter_array'][_0x236116][_0x301a('0x9')](_0xf6a5a9);}},this[_0x301a('0x24')]=function(_0x5383a1,_0x494ce8){var _0x4929e8=new _three[(_0x301a('0x33'))]([],_0x5383a1,_0x494ce8);return _0x4929e8[_0x301a('0x21')]=_three[_0x301a('0x5')],_0x4929e8[_0x301a('0x70')]=_three[_0x301a('0x5')],_0x4929e8;},this[_0x301a('0x1b')]=function(_0x5c2908,_0x577881){return new _three[(_0x301a('0x33'))]([],_0x5c2908,_0x577881);};},_temp);exports['default']=MakeupLiveFilter,module[_0x301a('0x31')]=exports[_0x301a('0x7a')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3342:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x2c3e=[',\x20still\x20have\x20GL\x20error.','gemPosShift','Upsample\x20','SetFourWayInfo','m_max_upsample_factor','SetWristOccluderTexture','getObjectByName','updateCubeMap','SetPBREnvMapParameters','SetShowOccluder','setGetBloomIntensityRatioFunc','cube_camera_position','__proto__','m_bloom_roi_downscale_filter','m_cube_to_equirect_filter','m_height','SetInputTexture','is_pbr','normal_pnp_matrices','SetPBRTextureMap','non_occluder_mesh_name_array','inputImageTexture2','is_valid','opaque_pos_shift','SetGemBloomIntensity','SetBloomTexture','call','SetIsZoomSrcEnabled','\x20x\x20','m_target_opaque_object_arrays','RenderFrame','is_viewer','bloom_threshold','setMetadata','bloom_intensity','SetHandARMetadata','buffer','default','Upsample\x201,\x20size\x20','VN_OBJECT3D_TYPE_AMOUNT','material','SetRingFingerOccluderData','CubeCamera','m_bloom_filter','m_width','SetGemParameters','visible','is_flip','Destroy','pnp_matrices','size','magFilter','SetObjectIntensity','max','SetShadowSmoothTexture','vto_mode','m_mesh','LinearFilter','dispose','IsNailPbr','m_target_norm_arrays','SetPBRTextureMapTransform','HEAPF32','SetDebugGemMeshEnvMap','SetIsGem','SetIsNailDebug','m_cube_camera','m_is_update_gem_mesh_env_maps','m_target_nail_art','m_normal_matrix','DisposeTexture','SetIsNailPbr','SetProcessRange','renderTarget','SetObject3DViewerBackgroundColor','m_scene_array','SetBloomThreshold','m_first_object3d_filter','m_second_object3d_filter','exports','format','getError','\x20->\x20','SetPBRTextureMapIntensity','RGBAFormat','m_bloom_scale','m_project_matrix','m_upsample_factor','uniforms','SetAlgorithmIndex','SetGemBloomSharpness','frame_width','SetBloomSharpness','\x20,\x20size\x20','render','m_target','texture','SetFrameSetting','SetNailArtTexture','SetObject3DViewerMetadata','SetBloomIntensity','SetIsUseROI','mesh_name_array','frame_height','VN_VTOMode','m_target_wrist_occluder','m_camera','value','SetWatchTimeComponentParameters','gemCenter','SetwristObjectMaskTexture','SetRingFingerOccluder','gemPosScale','get','SetUserPupilDistance','children','SetGemBloomScale','m_scene_norm_arrays','m_projected_scale','defineProperty','m_scene','NO_ERROR','set','bbox_start','m_is_metadata_valid','minFilter','length','SetPBRHDRIEnvMap','__esModule','ResetWidthHeight','opaque_pos_scale','RING_VTO','bbox_end','NearestFilter','m_scene_pos_arrays','SetObject3DRenderData','m_downscale_filter','projected_scale','m_bloom_intensity','SetShowHandMask','getContext','SetSilhouetteTexture','min','is_render_opaque_object_env','is_render_opaque_pos_env','camera_matrix','SetIsUseSilhouette','SetROITexture','m_gem_mesh_env_filter','error','bloom_scale','SetFresnelIntensity','m_target_wrist_occluder_object','YMKModule','m_bloom_roi_dilate_filter','m_target_pos_arrays','m_target_opaque_pos_arrays','SetZoomRatio'];(function(_0x17072d,_0x2c3e1f){var _0x270fc5=function(_0x5527c7){while(--_0x5527c7){_0x17072d['push'](_0x17072d['shift']());}};_0x270fc5(++_0x2c3e1f);}(_0x2c3e,0xc4));var _0x270f=function(_0x17072d,_0x2c3e1f){_0x17072d=_0x17072d-0x0;var _0x270fc5=_0x2c3e[_0x17072d];return _0x270fc5;};'use strict';Object[_0x270f('0x51')](exports,_0x270f('0x5a'),{'value':!![]}),exports['default']=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_object3dfirstfilter=__webpack_require__(3344),_object3dfirstfilter2=_interopRequireDefault(_object3dfirstfilter),_object3dsecondfilter=__webpack_require__(3349),_object3dsecondfilter2=_interopRequireDefault(_object3dsecondfilter),_object3ddownscalefilter=__webpack_require__(3351),_object3ddownscalefilter2=_interopRequireDefault(_object3ddownscalefilter),_object3dbloomfilter=__webpack_require__(3353),_object3dbloomfilter2=_interopRequireDefault(_object3dbloomfilter),_object3dgemmeshenvfilter=__webpack_require__(3355),_object3dgemmeshenvfilter2=_interopRequireDefault(_object3dgemmeshenvfilter),_object3dcubetoequirect=__webpack_require__(3357),_object3dcubetoequirect2=_interopRequireDefault(_object3dcubetoequirect),_object3dbloomroidilatefilter=__webpack_require__(3359),_object3dbloomroidilatefilter2=_interopRequireDefault(_object3dbloomroidilatefilter),_object3dbloomroidownscalefilter=__webpack_require__(3361),_object3dbloomroidownscalefilter2=_interopRequireDefault(_object3dbloomroidownscalefilter);function _interopRequireDefault(_0x221c81){return _0x221c81&&_0x221c81[_0x270f('0x5a')]?_0x221c81:{'default':_0x221c81};}var Object3DFilter=(_temp=_class=function(_0x57081c){(0x0,_inherits3[_0x270f('0x9d')])(_0x3e7ad5,_0x57081c);function _0x3e7ad5(_0x17691c,_0x11f322,_0x3c5618,_0x56c765){(0x0,_classCallCheck3['default'])(this,_0x3e7ad5);var _0x17329e=(0x0,_possibleConstructorReturn3['default'])(this,(_0x3e7ad5[_0x270f('0x84')]||(0x0,_getPrototypeOf2[_0x270f('0x9d')])(_0x3e7ad5))[_0x270f('0x92')](this,_0x17691c,_0x11f322));return _initialiseProps['call'](_0x17329e),_0x17329e[_0x270f('0x73')]=_0x56c765,_0x17329e[_0x270f('0x6')]=_0x17691c,_0x17329e['m_height']=_0x11f322,_0x17329e[_0x270f('0x7c')]=_0x3c5618,_0x17329e[_0x270f('0x31')]=_0x17329e[_0x270f('0x7c')],_0x17329e[_0x270f('0x2f')]=0x1,_0x17329e[_0x270f('0x1d')]=![],_0x17329e[_0x270f('0x27')]=new _object3dfirstfilter2['default'](_0x17691c*_0x17329e[_0x270f('0x31')],_0x11f322*_0x17329e[_0x270f('0x31')],_0x17329e['m_upsample_factor'],_0x56c765),_0x17329e[_0x270f('0x27')][_0x270f('0x35')]=_0x17691c,_0x17329e[_0x270f('0x27')]['frame_height']=_0x11f322,_0x17329e[_0x270f('0x6e')]=new _object3dgemmeshenvfilter2[(_0x270f('0x9d'))](_0x17691c,_0x11f322,_0x56c765),_0x17329e[_0x270f('0x86')]=new _object3dcubetoequirect2[(_0x270f('0x9d'))](_0x17691c,_0x11f322),_0x17329e['m_downscale_filter']=new _object3ddownscalefilter2[(_0x270f('0x9d'))](_0x17691c,_0x11f322),_0x17329e[_0x270f('0x85')]=new _object3dbloomroidownscalefilter2['default'](_0x17691c,_0x11f322),_0x17329e[_0x270f('0x74')]=new _object3dbloomroidilatefilter2[(_0x270f('0x9d'))](_0x17691c,_0x11f322,_0x17329e[_0x270f('0x2f')]),_0x17329e['m_bloom_filter']=new _object3dbloomfilter2[(_0x270f('0x9d'))](_0x17691c,_0x11f322),_0x17329e[_0x270f('0x4e')](_0x17329e[_0x270f('0x2f')]),_0x17329e['m_second_object3d_filter']=new _object3dsecondfilter2['default'](_0x17691c,_0x11f322,_0x56c765),_0x17329e['m_second_object3d_filter'][_0x270f('0x35')]=_0x17691c,_0x17329e['m_second_object3d_filter'][_0x270f('0x41')]=_0x11f322,_0x17329e[_0x270f('0x39')]=_0x17329e[_0x270f('0x28')][_0x270f('0x39')],_0x17329e;}return _0x3e7ad5;}(_basefilter2[_0x270f('0x9d')]),_initialiseProps=function _initialiseProps(){var _0x2adeef=this;this['SetInputTexture']=function(_0x3f953d){_0x2adeef[_0x270f('0x62')][_0x270f('0x88')](_0x2adeef[_0x270f('0x27')][_0x270f('0x39')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x62')][_0x270f('0x67')](_0x2adeef[_0x270f('0x27')][_0x270f('0x43')][_0x270f('0x3a')]),_0x2adeef['m_bloom_roi_downscale_filter'][_0x270f('0x67')](_0x2adeef[_0x270f('0x27')]['m_target_wrist_occluder'][_0x270f('0x3a')]),_0x2adeef['m_bloom_roi_dilate_filter']['SetInputTexture'](_0x2adeef[_0x270f('0x85')][_0x270f('0x39')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x5')][_0x270f('0x88')](_0x2adeef[_0x270f('0x62')][_0x270f('0x39')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x5')][_0x270f('0x6d')](_0x2adeef[_0x270f('0x74')]['m_target'][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x27')]['SetRootSourceTexture'](_0x3f953d),_0x2adeef[_0x270f('0x28')][_0x270f('0x12')][_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x8d')][_0x270f('0x45')]=_0x3f953d,_0x2adeef[_0x270f('0x28')][_0x270f('0x88')](_0x2adeef[_0x270f('0x27')]['m_target'][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x3c')](_0x2adeef[_0x270f('0x27')]['m_target_nail_art'][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x7d')](_0x2adeef[_0x270f('0x27')][_0x270f('0x43')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x48')](_0x2adeef[_0x270f('0x27')][_0x270f('0x72')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x10')](_0x2adeef[_0x270f('0x27')]['m_target_shadow_smooth'][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x91')](_0x2adeef[_0x270f('0x5')][_0x270f('0x39')]['texture']);},this[_0x270f('0x96')]=function(_0x112205,_0x428bf4){var _0x43bd1e=_0x112205[_0x270f('0x66')]();while(_0x43bd1e['getError']()!=_0x43bd1e['NO_ERROR']){}if(!_0x2adeef['m_is_update_gem_mesh_env_maps'])_0x2adeef[_0x270f('0x1c')]&&_0x2adeef[_0x270f('0x1c')][_0x270f('0x97')]==![]&&(_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')][_0x270f('0x14')](),_0x2adeef[_0x270f('0x1c')]=null);else{var _0x5f2136=_0x2adeef[_0x270f('0x6e')][_0x270f('0x4f')],_0x59ccff=_0x2adeef[_0x270f('0x6e')][_0x270f('0x60')],_0x17a4ab=_0x2adeef[_0x270f('0x86')]['m_target_norm_arrays'],_0x126d12=_0x2adeef[_0x270f('0x86')][_0x270f('0x75')],_0x243a82=_0x2adeef[_0x270f('0x86')][_0x270f('0x95')],_0x48d750=_0x2adeef[_0x270f('0x86')][_0x270f('0x76')];for(var _0x20dcc0=0x0;_0x20dcc0<_0x5f2136[_0x270f('0x58')];_0x20dcc0++){for(var _0x54a4b0=0x0;_0x54a4b0<_0x5f2136[_0x20dcc0][_0x270f('0x58')];_0x54a4b0++){if(_0x5f2136[_0x20dcc0][_0x54a4b0]==null)continue;_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')][_0x270f('0x3a')]['minFilter']=_three[_0x270f('0x5f')],_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')][_0x270f('0x3a')][_0x270f('0xd')]=_three[_0x270f('0x5f')],_0x2adeef[_0x270f('0x1c')][_0x270f('0x7f')](_0x112205,_0x5f2136[_0x20dcc0][_0x54a4b0]),_0x112205[_0x270f('0x38')](_0x2adeef[_0x270f('0x86')]['m_scene'],_0x2adeef[_0x270f('0x86')][_0x270f('0x44')],_0x17a4ab[_0x20dcc0][_0x54a4b0],!![]),_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')][_0x270f('0x3a')][_0x270f('0x57')]=_three[_0x270f('0x13')],_0x2adeef['m_cube_camera'][_0x270f('0x23')][_0x270f('0x3a')][_0x270f('0xd')]=_three[_0x270f('0x13')],_0x2adeef[_0x270f('0x1c')][_0x270f('0x7f')](_0x112205,_0x59ccff[_0x20dcc0][_0x54a4b0]),_0x112205[_0x270f('0x38')](_0x2adeef['m_cube_to_equirect_filter']['m_scene'],_0x2adeef[_0x270f('0x86')][_0x270f('0x44')],_0x126d12[_0x20dcc0][_0x54a4b0],!![]);var _0x1f5ae6=_0x2adeef[_0x270f('0x27')][_0x270f('0x40')][_0x20dcc0][_0x270f('0x58')]-_0x2adeef[_0x270f('0x27')][_0x270f('0x8c')][_0x20dcc0][_0x270f('0x58')],_0x2ddb02=_0x2adeef[_0x270f('0x27')]['m_scene_array'][_0x20dcc0][_0x270f('0x4d')][_0x1f5ae6+_0x54a4b0];if(_0x2ddb02['is_pbr']==![])continue;_0x2ddb02[_0x270f('0x8')]=![];for(var _0x280242=0x0;_0x280242<_0x2adeef['m_first_object3d_filter'][_0x270f('0x40')][_0x20dcc0][_0x270f('0x58')];_0x280242++){var _0x48de2b=_0x2adeef[_0x270f('0x27')][_0x270f('0x25')][_0x20dcc0][_0x270f('0x7e')](_0x2adeef[_0x270f('0x27')][_0x270f('0x40')][_0x20dcc0][_0x280242]);_0x48de2b[_0x270f('0x89')]?(_0x48de2b[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x83')][_0x270f('0x45')]=_0x2ddb02[_0x270f('0x2')]['uniforms'][_0x270f('0x47')][_0x270f('0x45')],_0x48de2b['material'][_0x270f('0x32')][_0x270f('0x69')][_0x270f('0x45')]=0x1,_0x48de2b['material'][_0x270f('0x32')][_0x270f('0x6a')][_0x270f('0x45')]=0x0):_0x48de2b[_0x270f('0x8')]=![];}_0x2adeef[_0x270f('0x1c')][_0x270f('0x7f')](_0x112205,_0x2adeef[_0x270f('0x27')][_0x270f('0x25')][_0x20dcc0]),_0x112205[_0x270f('0x38')](_0x2adeef[_0x270f('0x86')][_0x270f('0x52')],_0x2adeef[_0x270f('0x86')][_0x270f('0x44')],_0x243a82[_0x20dcc0][_0x54a4b0],!![]);for(var _0x3d6065=0x0;_0x3d6065<_0x2adeef[_0x270f('0x27')][_0x270f('0x40')][_0x20dcc0]['length'];_0x3d6065++){var _0x130cbb=_0x2adeef[_0x270f('0x27')][_0x270f('0x25')][_0x20dcc0][_0x270f('0x7e')](_0x2adeef['m_first_object3d_filter']['mesh_name_array'][_0x20dcc0][_0x3d6065]);_0x130cbb[_0x270f('0x89')]&&(_0x130cbb[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x69')][_0x270f('0x45')]=0x0,_0x130cbb[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x6a')][_0x270f('0x45')]=0x1,_0x130cbb[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x5c')][_0x270f('0x45')]=_0x2ddb02[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x4a')][_0x270f('0x45')],_0x130cbb[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x8f')][_0x270f('0x45')]=_0x2ddb02[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x79')][_0x270f('0x45')]);}_0x2adeef['m_cube_camera'][_0x270f('0x7f')](_0x112205,_0x2adeef[_0x270f('0x27')]['m_scene_array'][_0x20dcc0]),_0x112205[_0x270f('0x38')](_0x2adeef[_0x270f('0x86')][_0x270f('0x52')],_0x2adeef['m_cube_to_equirect_filter']['m_camera'],_0x48d750[_0x20dcc0][_0x54a4b0],!![]);for(var _0x56de8a=0x0;_0x56de8a<_0x2adeef[_0x270f('0x27')][_0x270f('0x40')][_0x20dcc0][_0x270f('0x58')];_0x56de8a++){var _0x4f8995=_0x2adeef[_0x270f('0x27')]['m_scene_array'][_0x20dcc0][_0x270f('0x7e')](_0x2adeef['m_first_object3d_filter'][_0x270f('0x40')][_0x20dcc0][_0x56de8a]);_0x4f8995[_0x270f('0x89')]?(_0x4f8995[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x69')][_0x270f('0x45')]=0x0,_0x4f8995[_0x270f('0x2')][_0x270f('0x32')][_0x270f('0x6a')][_0x270f('0x45')]=0x0):_0x4f8995[_0x270f('0x8')]=!![];}_0x2ddb02[_0x270f('0x8')]=!![];}}_0x2adeef['m_is_update_gem_mesh_env_maps']=![];}_0x2adeef[_0x270f('0x27')][_0x270f('0x96')](_0x112205,!![]);var _0x2d929d=_0x43bd1e[_0x270f('0x2b')]();while(_0x2d929d!=_0x43bd1e[_0x270f('0x53')]){var _0x6f911e=_0x2adeef[_0x270f('0x27')]['frame_width'],_0x31b1e7=_0x2adeef['m_first_object3d_filter'][_0x270f('0x41')];if(_0x2adeef['m_upsample_factor']>0x1){_0x2adeef[_0x270f('0x31')]/=0x2,console['log'](_0x270f('0x7a')+_0x2adeef[_0x270f('0x31')]*0x2+_0x270f('0x2c')+_0x2adeef['m_upsample_factor']+_0x270f('0x37')+_0x6f911e*_0x2adeef[_0x270f('0x31')]+'\x20x\x20'+_0x31b1e7*_0x2adeef[_0x270f('0x31')]);while(_0x43bd1e[_0x270f('0x2b')]()!=_0x43bd1e[_0x270f('0x53')]){}_0x2adeef[_0x270f('0x27')][_0x270f('0x5b')](_0x6f911e*_0x2adeef[_0x270f('0x31')],_0x31b1e7*_0x2adeef[_0x270f('0x31')]),_0x2adeef[_0x270f('0x27')][_0x270f('0x96')](_0x112205,!![]),_0x2adeef[_0x270f('0x62')]['SetInputTexture'](_0x2adeef[_0x270f('0x27')][_0x270f('0x39')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x62')][_0x270f('0x67')](_0x2adeef[_0x270f('0x27')][_0x270f('0x43')][_0x270f('0x3a')]),_0x2adeef['m_bloom_roi_downscale_filter'][_0x270f('0x67')](_0x2adeef[_0x270f('0x27')][_0x270f('0x43')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x88')](_0x2adeef[_0x270f('0x27')][_0x270f('0x39')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x3c')](_0x2adeef[_0x270f('0x27')][_0x270f('0x1e')]['texture']),_0x2adeef[_0x270f('0x28')]['SetWristOccluderTexture'](_0x2adeef[_0x270f('0x27')][_0x270f('0x43')][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x48')](_0x2adeef['m_first_object3d_filter'][_0x270f('0x72')]['texture']),_0x2adeef[_0x270f('0x28')][_0x270f('0x10')](_0x2adeef[_0x270f('0x27')]['m_target_shadow_smooth'][_0x270f('0x3a')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x91')](_0x2adeef[_0x270f('0x5')][_0x270f('0x39')]['texture']),_0x2d929d=_0x43bd1e['getError']();}else{console[_0x270f('0x6f')](_0x270f('0x0')+_0x6f911e+_0x270f('0x94')+_0x31b1e7+_0x270f('0x78'));break;}}var _0x52fa3b=_0x2adeef[_0x270f('0x27')][_0x270f('0x15')]();_0x2adeef['m_bloom_filter'][_0x270f('0x64')]>0x0&&(_0x2adeef[_0x270f('0x62')]['RenderFrame'](_0x112205,_0x428bf4),_0x2adeef[_0x270f('0x85')][_0x270f('0x96')](_0x112205,_0x428bf4),_0x2adeef[_0x270f('0x74')][_0x270f('0x96')](_0x112205,_0x428bf4),_0x2adeef[_0x270f('0x5')]['RenderFrame'](_0x112205,_0x428bf4)),_0x2adeef[_0x270f('0x28')][_0x270f('0x21')](_0x52fa3b),_0x2adeef[_0x270f('0x28')][_0x270f('0x96')](_0x112205,_0x428bf4);},this[_0x270f('0x5b')]=function(_0x34b630,_0x30e650){_0x2adeef[_0x270f('0x6')]=_0x34b630,_0x2adeef[_0x270f('0x87')]=_0x30e650,_0x2adeef[_0x270f('0x31')]=_0x2adeef[_0x270f('0x7c')],_0x2adeef[_0x270f('0x27')][_0x270f('0x5b')](_0x34b630*_0x2adeef['m_upsample_factor'],_0x30e650*_0x2adeef['m_upsample_factor'],_0x2adeef[_0x270f('0x31')]),_0x2adeef[_0x270f('0x27')][_0x270f('0x35')]=_0x34b630,_0x2adeef[_0x270f('0x27')][_0x270f('0x41')]=_0x30e650,_0x2adeef[_0x270f('0x4e')](_0x2adeef[_0x270f('0x2f')]),_0x2adeef[_0x270f('0x62')][_0x270f('0x5b')](_0x34b630,_0x30e650,_0x2adeef['m_bloom_scale']),_0x2adeef[_0x270f('0x5')][_0x270f('0x5b')](_0x34b630,_0x30e650,_0x2adeef[_0x270f('0x2f')]),_0x2adeef[_0x270f('0x28')][_0x270f('0x5b')](_0x34b630,_0x30e650),_0x2adeef[_0x270f('0x28')][_0x270f('0x35')]=_0x34b630,_0x2adeef['m_second_object3d_filter'][_0x270f('0x41')]=_0x30e650,_0x2adeef[_0x270f('0x39')]=_0x2adeef[_0x270f('0x28')]['m_target'];},this[_0x270f('0x7b')]=function(_0x5871bd,_0x4c3062){_0x2adeef[_0x270f('0x27')][_0x270f('0x7b')](_0x5871bd,_0x4c3062),_0x2adeef['m_second_object3d_filter'][_0x270f('0x7b')](_0x5871bd,_0x4c3062);},this[_0x270f('0x99')]=function(_0x3d5888){_0x2adeef[_0x270f('0x27')]['frameRotation']=0x0,_0x2adeef['m_first_object3d_filter'][_0x270f('0x9')]=_0x3d5888[_0x270f('0x9')],_0x2adeef[_0x270f('0x27')][_0x270f('0x30')]=_0x3d5888[_0x270f('0x6b')];var _0x1d516f=new Float32Array(_0x2adeef[_0x270f('0x73')][_0x270f('0x18')][_0x270f('0x9c')],_0x3d5888[_0x270f('0xb')],_0x2adeef['YMKModule'][_0x270f('0x1')]*0xc);_0x2adeef['m_first_object3d_filter']['m_transform_matrix']=_0x1d516f;var _0x465792=new Float32Array(_0x2adeef['YMKModule']['HEAPF32'][_0x270f('0x9c')],_0x3d5888[_0x270f('0x8a')],_0x2adeef['YMKModule'][_0x270f('0x1')]*0x10);_0x2adeef[_0x270f('0x27')][_0x270f('0x1f')]=_0x465792,_0x2adeef[_0x270f('0x28')][_0x270f('0x56')]=_0x3d5888[_0x270f('0x8e')];},this[_0x270f('0x61')]=function(_0x4c506e,_0xd68dc,_0x4513b9,_0xb5ed60,_0x3445cb,_0x53a4f8,_0x5444bb){if(_0x53a4f8)for(var _0x20f083=0x0;_0x20f083<_0x4c506e[_0x270f('0x58')];_0x20f083++){var _0x44b9ef=_0x4c506e[_0x20f083],_0x4a9848=_0x44b9ef[_0x270f('0xc')]();for(var _0xdce407=0x0;_0xdce407<_0x4a9848;_0xdce407++){var _0x3bb862=_0x44b9ef[_0x270f('0x4b')](_0xdce407);_0x3bb862[_0x270f('0x89')]=!![],_0x44b9ef[_0x270f('0x54')](_0xdce407,_0x3bb862);}}var _0x162db7=-0x1,_0xae884c=-0x1,_0x262342=-0x1,_0x46e852={'x':0x270f,'y':0x270f,'z':0x270f},_0xe1e933={'x':-0x270f,'y':-0x270f,'z':-0x270f};for(var _0x5667c8=0x0;_0x5667c8<_0x4c506e[_0x270f('0x58')];_0x5667c8++){var _0x185ac5=_0x4c506e[_0x5667c8],_0x2739c0=_0x185ac5[_0x270f('0xc')]();for(var _0x58d152=0x0;_0x58d152<_0x2739c0;_0x58d152++){var _0x1252b8=_0x185ac5[_0x270f('0x4b')](_0x58d152);_0x162db7<0x0&&_0x1252b8[_0x270f('0x70')]>=0x0&&(_0x162db7=_0x1252b8[_0x270f('0x70')]),_0xae884c<0x0&&_0x1252b8[_0x270f('0x9a')]>=0x0&&(_0xae884c=_0x1252b8[_0x270f('0x9a')]),_0x262342<0x0&&_0x1252b8[_0x270f('0x98')]>=0x0&&(_0x262342=_0x1252b8['bloom_threshold']),_0x46e852['x']=Math['min'](_0x46e852['x'],_0x1252b8[_0x270f('0x55')]['x']),_0x46e852['y']=Math[_0x270f('0x68')](_0x46e852['y'],_0x1252b8[_0x270f('0x55')]['y']),_0x46e852['z']=Math[_0x270f('0x68')](_0x46e852['z'],_0x1252b8[_0x270f('0x55')]['z']),_0xe1e933['x']=Math['max'](_0xe1e933['x'],_0x1252b8[_0x270f('0x5e')]['x']),_0xe1e933['y']=Math[_0x270f('0xf')](_0xe1e933['y'],_0x1252b8[_0x270f('0x5e')]['y']),_0xe1e933['z']=Math[_0x270f('0xf')](_0xe1e933['z'],_0x1252b8[_0x270f('0x5e')]['z']);}}_0xae884c=_0xae884c<0x0?0x0:_0xae884c,_0x262342=_0x262342<0x0?0x6:_0x262342,_0x2adeef['m_bloom_scale']=_0x162db7<0x0?0x1:_0x162db7,_0x2adeef[_0x270f('0x5')][_0x270f('0x3e')](_0xae884c),_0x2adeef[_0x270f('0x5')][_0x270f('0x26')](_0x262342),_0x2adeef['m_bloom_filter']['m_bbox_size']=Math['max'](Math['max'](_0xe1e933['x']-_0x46e852['x'],_0xe1e933['y']-_0x46e852['y']),_0xe1e933['z']-_0x46e852['z']),_0x2adeef['SetGemBloomScale'](_0x2adeef[_0x270f('0x2f')]);var _0x3bb33e=_0x53a4f8?0x200:0x100;_0x2adeef['m_cube_camera']=new _three[(_0x270f('0x4'))](0.001,0x64,_0x3bb33e),_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')][_0x270f('0x3a')][_0x270f('0x2a')]=_three[_0x270f('0x2e')],_0x2adeef[_0x270f('0x1c')][_0x270f('0x97')]=_0x53a4f8,_0x2adeef[_0x270f('0x6e')][_0x270f('0x61')](_0x4c506e,_0x53a4f8,_0x5444bb),_0x2adeef[_0x270f('0x86')]['SetObject3DRenderDataAndCubemap'](_0x4c506e,_0x2adeef[_0x270f('0x1c')][_0x270f('0x23')]['texture'],_0x53a4f8,_0x5444bb),_0x2adeef[_0x270f('0x1d')]=!![],_0x2adeef[_0x270f('0x27')][_0x270f('0x61')](_0x4c506e,_0xd68dc,_0x4513b9,_0xb5ed60,_0x3445cb,_0x2adeef['m_cube_to_equirect_filter'][_0x270f('0x16')],_0x2adeef[_0x270f('0x86')][_0x270f('0x75')],_0x2adeef[_0x270f('0x86')][_0x270f('0x95')],_0x2adeef[_0x270f('0x86')][_0x270f('0x76')],_0xae884c>0x0,_0x53a4f8,_0x5444bb),_0x2adeef[_0x270f('0x28')]['SetObject3DRenderData'](_0x4c506e[0x0],_0xd68dc,_0x4513b9,_0xb5ed60,_0x3445cb),_0x2adeef['m_cube_to_equirect_filter'][_0x270f('0x95')][0x0][0x0]!=null&&_0x2adeef[_0x270f('0x28')][_0x270f('0x19')](_0x2adeef[_0x270f('0x86')]['m_target_opaque_object_arrays'][0x0][0x0]['texture']);},this[_0x270f('0x71')]=function(_0x5ec517,_0xbe6497){_0x2adeef[_0x270f('0x27')][_0x270f('0x71')](_0x5ec517,_0xbe6497),_0x2adeef[_0x270f('0x1d')]=!![];},this[_0x270f('0x90')]=function(_0x237f2a){return _0x2adeef['m_bloom_filter'][_0x270f('0x3e')](_0x237f2a);},this[_0x270f('0x4e')]=function(_0x153c0c){_0x2adeef[_0x270f('0x62')][_0x270f('0x5b')](_0x2adeef[_0x270f('0x6')],_0x2adeef[_0x270f('0x87')]),_0x2adeef[_0x270f('0x74')][_0x270f('0x5b')](_0x2adeef[_0x270f('0x6')],_0x2adeef[_0x270f('0x87')],_0x153c0c),_0x2adeef[_0x270f('0x5')][_0x270f('0x5b')](_0x2adeef[_0x270f('0x6')],_0x2adeef[_0x270f('0x87')],_0x153c0c);},this[_0x270f('0x34')]=function(_0x25790d){return _0x2adeef[_0x270f('0x5')][_0x270f('0x36')](_0x25790d);},this['SetGemBloomThreshold']=function(_0x2e8cd7){return _0x2adeef[_0x270f('0x5')][_0x270f('0x26')](_0x2e8cd7);},this[_0x270f('0x7')]=function(_0x1d2e51,_0x19b3dd,_0x1828cc,_0xa33606){return _0x2adeef[_0x270f('0x27')][_0x270f('0x7')](_0x1d2e51,_0x19b3dd,_0x1828cc,_0xa33606);},this['SetIsGem']=function(_0x2f6701,_0x371c97){return _0x2adeef[_0x270f('0x27')][_0x270f('0x1a')](_0x2f6701,_0x371c97);},this[_0x270f('0x80')]=function(_0x162467,_0xde278a,_0x502815,_0x24aad9,_0x1ff4c0){var _0x565394=arguments[_0x270f('0x58')]>0x5&&arguments[0x5]!==undefined?arguments[0x5]:0x0;_0x2adeef[_0x270f('0x27')][_0x270f('0x80')](_0x162467,_0xde278a,_0x502815,_0x24aad9,_0x1ff4c0,_0x565394),_0x2adeef[_0x270f('0x1d')]=!![];},this[_0x270f('0x59')]=function(_0x39b8d2,_0x14ef81){var _0x5e4dc9=arguments[_0x270f('0x58')]>0x2&&arguments[0x2]!==undefined?arguments[0x2]:0x0;_0x2adeef[_0x270f('0x27')]['SetPBRHDRIEnvMap'](_0x39b8d2,_0x14ef81,_0x5e4dc9),_0x2adeef[_0x270f('0x1d')]=!![];},this[_0x270f('0x8b')]=function(_0x10d5ca,_0x11df0e,_0x5a29c0){var _0x5e2d8c=arguments[_0x270f('0x58')]>0x3&&arguments[0x3]!==undefined?arguments[0x3]:0x0;_0x2adeef[_0x270f('0x27')][_0x270f('0x8b')](_0x10d5ca,_0x11df0e,_0x5a29c0,_0x5e2d8c),_0x2adeef['m_is_update_gem_mesh_env_maps']=!![];},this[_0x270f('0x2d')]=function(_0x1dbfa1,_0x1da7cc,_0x2fde82){_0x2adeef[_0x270f('0x27')]['SetPBRTextureMapIntensity'](_0x1dbfa1,_0x1da7cc,_0x2fde82),_0x2adeef[_0x270f('0x1d')]=!![];},this['SetPBRTextureMapTransform']=function(_0x42f4f9,_0x41e00a,_0x5e6540,_0x312823,_0x573ef9){_0x2adeef[_0x270f('0x27')][_0x270f('0x17')](_0x42f4f9,_0x41e00a,_0x5e6540,_0x312823,_0x573ef9),_0x2adeef[_0x270f('0x1d')]=!![];},this[_0x270f('0x4c')]=function(_0x46222d){return _0x2adeef[_0x270f('0x27')][_0x270f('0x4c')](_0x46222d);},this['DisposeTexture']=function(){_0x2adeef[_0x270f('0x27')][_0x270f('0x20')](),_0x2adeef[_0x270f('0x28')][_0x270f('0x20')]();},this[_0x270f('0x22')]=function(_0x1d8065,_0x5c1cb5,_0x8f4c5a,_0x1182db){return _0x2adeef[_0x270f('0x28')]['SetProcessRange'](_0x1d8065,_0x5c1cb5,_0x8f4c5a,_0x1182db);},this[_0x270f('0x81')]=function(_0x457bb2){return _0x2adeef[_0x270f('0x27')][_0x270f('0x81')](_0x457bb2);},this['SetLensSetting']=function(_0x45a5b9){return _0x2adeef[_0x270f('0x27')]['SetLensSetting'](_0x45a5b9);},this[_0x270f('0x3b')]=function(_0x59b1dd){return _0x2adeef['m_first_object3d_filter'][_0x270f('0x3b')](_0x59b1dd);},this[_0x270f('0x9b')]=function(_0xfdf0f9){_0x2adeef['m_first_object3d_filter'][_0x270f('0x9b')](_0xfdf0f9),_0x2adeef[_0x270f('0x27')]['m_is_nail_mode']?(_0x2adeef[_0x270f('0x62')][_0x270f('0x6c')](![]),_0x2adeef[_0x270f('0x5')][_0x270f('0x3f')](![])):(_0x2adeef[_0x270f('0x62')][_0x270f('0x6c')](!![]),_0x2adeef[_0x270f('0x5')][_0x270f('0x3f')](!![])),_0x2adeef[_0x270f('0x28')][_0x270f('0x9b')](_0xfdf0f9),_0x2adeef[_0x270f('0x5')][_0x270f('0x50')]=_0xfdf0f9['projected_scale'],_0xfdf0f9[_0x270f('0x11')]==_0x2adeef['YMKModule'][_0x270f('0x42')][_0x270f('0x5d')]&&_0x2adeef['m_second_object3d_filter'][_0x270f('0x3')](_0x2adeef[_0x270f('0x27')]['GetRingFingerOccluderData'](_0xfdf0f9));},this['SetObject3DViewerMetadata']=function(_0x1f0967){_0x2adeef['m_first_object3d_filter'][_0x270f('0x3d')](_0x1f0967),_0x2adeef[_0x270f('0x28')][_0x270f('0x3d')](),_0x2adeef[_0x270f('0x5')][_0x270f('0x50')]=_0x1f0967[_0x270f('0x63')];},this['SetIsNailDebug']=function(_0xee9070){_0x2adeef[_0x270f('0x27')][_0x270f('0x1b')](_0xee9070),_0x2adeef[_0x270f('0x28')][_0x270f('0x1b')](_0xee9070);},this[_0x270f('0x49')]=function(_0xddd51a){return _0x2adeef[_0x270f('0x27')][_0x270f('0x49')](_0xddd51a);},this['SetRingMountOccludeDistance']=function(_0x2858bb){return _0x2adeef['m_first_object3d_filter']['SetRingMountOccludeDistance'](_0x2858bb);},this[_0x270f('0x46')]=function(_0x4f9560,_0x332371){return _0x2adeef[_0x270f('0x27')][_0x270f('0x46')](_0x4f9560,_0x332371);},this[_0x270f('0x77')]=function(_0x4adde4){_0x2adeef[_0x270f('0x27')]['SetZoomRatio'](_0x4adde4),_0x2adeef[_0x270f('0x28')][_0x270f('0x77')](_0x4adde4);},this[_0x270f('0xe')]=function(_0x11ba09){return _0x2adeef[_0x270f('0x28')][_0x270f('0xe')](_0x11ba09);},this['SetShowHandMask']=function(_0x2cf0f4){return _0x2adeef[_0x270f('0x28')][_0x270f('0x65')](_0x2cf0f4);},this[_0x270f('0x33')]=function(_0x43f58f){_0x2adeef[_0x270f('0x27')][_0x270f('0x33')](_0x43f58f),_0x2adeef[_0x270f('0x28')]['SetAlgorithmIndex'](_0x43f58f);},this[_0x270f('0x82')]=function(_0x18d061){return _0x2adeef[_0x270f('0x5')][_0x270f('0x82')](_0x18d061);},this[_0x270f('0xa')]=function(){_0x2adeef['m_first_object3d_filter'][_0x270f('0xa')](),_0x2adeef[_0x270f('0x6e')][_0x270f('0xa')](),_0x2adeef[_0x270f('0x86')][_0x270f('0xa')](),_0x2adeef[_0x270f('0x62')]['Destroy'](),_0x2adeef[_0x270f('0x85')][_0x270f('0xa')](),_0x2adeef[_0x270f('0x74')][_0x270f('0xa')](),_0x2adeef[_0x270f('0x5')][_0x270f('0xa')](),_0x2adeef[_0x270f('0x28')][_0x270f('0xa')]();},this[_0x270f('0x93')]=function(_0x10da68){return _0x2adeef['m_second_object3d_filter'][_0x270f('0x93')](_0x10da68);},this[_0x270f('0x24')]=function(_0x27b718,_0x163439,_0x3b762f,_0x2eb015){return _0x2adeef[_0x270f('0x28')][_0x270f('0x24')](_0x27b718,_0x163439,_0x3b762f,_0x2eb015);};},_temp);exports[_0x270f('0x9d')]=Object3DFilter,module[_0x270f('0x29')]=exports[_0x270f('0x9d')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3343:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x317d=['input_uniforms','void\x20main()\x20{','join','vec4\x20cur\x20=\x20texture2D(inputImageTexture,\x20textureCoordinate);','varying\x20vec2\x20textureCoordinate;','exports','__esModule','gl_FragColor\x20=\x20vec4(cur.rgb,1.0);','default','vertexShader'];(function(_0xebc3b7,_0x317d68){var _0x1b62bc=function(_0x50075d){while(--_0x50075d){_0xebc3b7['push'](_0xebc3b7['shift']());}};_0x1b62bc(++_0x317d68);}(_0x317d,0xa1));var _0x1b62=function(_0xebc3b7,_0x317d68){_0xebc3b7=_0xebc3b7-0x0;var _0x1b62bc=_0x317d[_0xebc3b7];return _0x1b62bc;};'use strict';Object['defineProperty'](exports,_0x1b62('0x5'),{'value':!![]}),exports[_0x1b62('0x7')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x47433c){return _0x47433c&&_0x47433c[_0x1b62('0x5')]?_0x47433c:{'default':_0x47433c};}var BaseShader=function BaseShader(){(0x0,_classCallCheck3[_0x1b62('0x7')])(this,BaseShader),this[_0x1b62('0x9')]={'inputImageTexture':{'type':'t','value':null}},this[_0x1b62('0x8')]=[_0x1b62('0x3'),_0x1b62('0x0'),'textureCoordinate\x20=\x20uv;','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','}'][_0x1b62('0x1')]('\x0a'),this['fragmentShader']=['uniform\x20sampler2D\x20inputImageTexture;',_0x1b62('0x3'),'void\x20main()\x20{',_0x1b62('0x2'),_0x1b62('0x6'),'}'][_0x1b62('0x1')]('\x0a');};exports[_0x1b62('0x7')]=BaseShader,module[_0x1b62('0x4')]=exports[_0x1b62('0x7')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3344:
/***/ (function(module, exports, __webpack_require__) {

var _0x39a7=['METALLIC','Vector2','p_tangent_array','is_nail_art_changed','customShimmerScale','customTransparency','specularTexture','NAIL_FINISH_JELLY','SetHandARMetadata','nail_rect','matrix_count','referenced_small_gem_maps','test','finish_type','getDay','get','ambient','Update3DPBRObject','AddEquation','onload','m_is_four_way','floor','m_target','NAIL_TIP','m_camera','isAmbientTexture','m_is_ring_mode','environmentIntensity','frustumCulled','m_is_show_occluder','SetInputTextureWristOccluderShift','small_gem_id','watch_digital_time_component_parameter','zoom_scale_ratio','object3d_occluder_','vertOrienCos','opacity\x20and\x20albedo\x20maps\x20do\x20not\x20have\x20the\x20same\x20size:\x20opa\x20%dx%d,\x20albedo\x20%dx%d','SetFresnelIntensity','Mesh','SetPBRTextureMapIntensity','SrcAlphaFactor','forEach','is_nail_debug','SetShadowOffsetKernelRatio','transmission_filter','setByteHistogramTextureUniform','RenderFrame','brdf_lut_width','nailMaskLast3Texture','m_target_nail_art','WATCH_OBJECT_TIME_COMPONENT_HOUR','getImageDataByUrl','m_is_nail_valid','CustomBlending','is_replace_user_polish','watch_time_component_parameter','referencing_small_gem_id','GetFittedProjectMatrix','getLength','drawImage','m_is_replace_user_polish','ring_visible_interval','dynamic_range_compress_environment','environmentTexture','is_nail_tip','substr','cos','little_finger_pbr','environment_weight','isLightingAngleClipping','onDrawArraysPostPassSilhouette','DataTexture','WRIST_VTO','nail_env_maps','p_second_normal_matrix','fillStyle','nail_valid','setRenderTarget','texture_granularity','nailMaskFirst3Texture','normalMapTexture','max_luma_for_hand','gem_color','transparency','#define\x20IS_NAIL\x0a','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_SECOND_UNITS','is_trans_map_set','luma_ratio_for_hand','indexOf','SetAlgorithmIndex','m_is_nail_env_map_changed','apply','gemPosShift','is_time_component','m_occluder_transform_matrices','p_nail_art_normal_matrices','m_occluder_normal_matrices','m_cached_orm_map','reflection','m_scene_object_array','p_small_gem_norm_map','ShaderMaterial','SetPBRHDRIEnvMap2','uniforms','#define\x20IS_GEM\x0a','m_scene_glass_array','freeTextureHashMap','hand_ar_matrix_index','buffer','onDrawArraysPrePassSilhouette','VN_WatchObjectDigitalTimeComponentType','SetObject3DViewerMetadata','tangent_array_size','m_is_nail_tip','nail_env_map_width','p_camera_matrices','NAIL_FINISH_SHIMMER_COARSE','isAlbedoTexture','customNormalScale','NAIL_PBR_CUSTOMIZED','horiOrien','pos','VN_VTO_FINGER_OCCLUDE_TYPE','gem_pos_shift','Update3DObject','m_ring_shift_y_for_shadow','default','addAttribute','customReflection','width','environment_tile_x','getObjectByName','watchTextureCoordinateOffset','m_ring_mount_occlude_left_distances','push','onDrawArraysPrePass1','is_enabled','isEnableMirrorHDR','texcoord_array_size','frame_height','prev','m_filter_normal_matrix','next','SetOutputTexture','normal','BufferGeometry','m_target_shadow_smooth','m_algorithm_index','material','p_minute_transform_matrix','thumb_pbr','NAIL_PBR_DEFAULT','m_is_bloom','customWeight','opa','nail_segment_width','UpdateShaderParametersPassWristOccluderShift','textureImageCache','small_gem_rotation_mat','roughness_intensity','ORM','m_env_map_shift_x','m_four_way_middle_finger_pbr','m_is_nail_art_changed','m_target_wrist_occluder_shift','VN_HANDAR_MAX_AMOUNT','environment_intensity','ring_mount_occlude_distance','isDiffuseTexture','m_hand_normal_matrices','ring_mount_occlude_right_distance','originSilhouetteValue','VN_NailPbrMode','p_normal_matrices','environmentShiftX','m_filter_project_matrix','ao_transform','height','isSmallGem','WATCH_OBJECT_TIME_COMPONENT_SECOND','WebGLRenderTarget','NORMAL','object3d_geometry_count','onDrawArraysPrePassSilhouetteShift','m_original_albedo_texture','NAIL_FINISH_PEARL','Vector3','digital_watch_time_component_time_system','isBrdfLutTexture','middle_finger_pbr','clearSceneArrays','m_dynamic_range_offset_environment','normal_array_size','m_project_matrix','watch_time_component_transform_matrix','UpdateShaderParametersPass1','isEnvironmentTexture','clearScene','error','Float32BufferAttribute','ambientColor','NAIL_FINISH_MATTE','m_nail_right_vec','environmentTileY','environment_tile_y','m_nail_top_vec','ring_mount_occlude_left_distances','map','length','m_normal_matrix','max','ormTexture','clearDepth','NAIL_POLISH','MirroredRepeatWrapping','releaseCanvas','environmentWeightTexture','isNailMode','pop','ring_finger_occlude_type','specular','IsNailPbr','specularColor','setIndex','m_data_texture_hash_map','m_dynamic_range_compress','vertexShader','ring_finger_pbr','SetRootSourceTexture','brdf','m_watch_time_component_transform_matrices','gem_pos_scale','matrix_index','src','m_color_ratio_for_hand','sqrt','image','Matrix3','nail_art_image_height','sent','transparent','m_width','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_DAY_UNITS','m_dynamic_range_compress_environment','NAIL_FINISH_METALLIC','min','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_MONTH_UNITS','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_HOUR_UNITS','SetRingFingerOccluder','SetWatchTimeComponentParameters','p_nail_art_transform_matrices','slice','m_target_wrist_occluder_object','small_gem_norm_map_width','RGBAFormat','ResetWidthHeight','albedo','p_vertex_array','isEnvironmentWeightTexture','silhouetteValue','customGlitterOpacity','stop','nail_glitter','is_palm_detected','ambientTexture','brdfLutTexture','m_is_nail_mode','getHours','SetLensSetting','splice','p_small_gem_pos_map','trans','m_is_ring_finger_occluder','m_nail_mask_last3','is_dynamic_range','dynamic_range_offset_environment','small_gem_norm_map_height','m_nail_art_normal_matrices','m_upsample_factor','m_nail_left_vec','maxLuma','is_nail_art','environmentMode','HEAPU8','color_ratio_for_hand','is_pbr','clone','remove','m_four_way_little_finger_pbr','exposure','m_nail_env_map_array','p_occluder_normal_matrices','m_height','SetGemParameters2','m_static_diffuse_texture','wrapS','text_count','gemIOR','m_nail_art_image_array','m_transform_matrix','size','OneFactor','bloom_scale','gem_dispersion','m_is_nail_debug','GetDefaultProjectMatrix','crossOrigin','customLightIntensity','NAIL_FINISH_SHIMMER_FINE','ring_mount_occlude_left_distance','m_four_way_thumb_pbr','light_intensity','lastIndexOf','isRenderSilhouette','is_first_nail_object','UnsignedByteType','isNormalMapTexture','frame_width','glass\x20name\x20not\x20found!','p_hour_normal_matrix','ao_intensity','is_gem','WATCH_OBJECT_TIME_COMPONENT_MINUTE','m_is_nail_pbr','environmentShiftY','env','ring_shift_y_for_shadow','wrap','OCCLUDE_BASED_ON_CENTER','component_type','m_scene_array','minFilter','silhouetteChannel','ring_visible_interval_boundary_point','VN_WatchObjectTimeComponentType','getImageDataByHexCode','LinearMipMapLinearFilter','getMonth','nail_segment_height','bloom_intensity','dynamic_range_offset','SetObject3DRenderData','getSeconds','isOrmTexture','small_gem_pos_map_height','Compute3DTransformMatrix','dynamic_range_compress','p_index_array','blendSrc','ring_mount_occlude_right_distances','fresnelIntensity','m_is_viewer_mode','p_second_transform_matrix','environment','set','finger','m_env_map_shift_y','isGem','Matrix4','canvas','LinearFilter','name','position','DoubleSide','gemPosScale','p_day_transform_matrix','m_natural_adjust_intensity','enable_adjusting_color','p_minute_normal_matrix','is_nail_tip_changed','ring_object_number','ambient_data','Scene','brdf_lut_height','UpdateShaderParametersPassWristOccluder','sin','gem_center','diffuse_data','gemCenter','digital_watch_time_component_text_offset_array','projectMatrix','diffuseColor','HEAPF32','UpdateShaderParametersPassWristOccluderObject','environmentWidth','albedoTexture','nail_art_images','SetIsGem2','getImageData','nail_rect_left_ratio','hori_orien','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_HOUR_TENS','value','magFilter','gemDispersion','nailGlitter','ALBEDO','lumaRatio','getDate','is_digital_watch_time_component','RING_VTO','shadow_offset','is_glass','nail_art_image_width','ROUGHNESS','diffuseTexture','SetPBRTextureMap','transmissionFilter','normalTransformMatrix','m_filter_transform_matrix','getDataTexture','onUpdate','getContext','vertex_array_size','m_zoom_scale_ratio','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_SECOND_TENS','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_MINUTE_UNITS','isColorRatio','vert_orien','customMetallic','colorRatio3','m_hand_transform_matrices','VN_NailFinishType','SetUserPupilDistance','nail_rect_bottom_ratio','isOccluder','tangent','delete','p_texcoord_array','vto_mode','SetIsNailDebug','render','frameHeight','clear','opaquePosTexture','digital_watch_time_component_text_count','non_occluder_mesh_name_array','environment_mode','VN_HANDAR_MAX_PART_AMOUNT','visible','m_luma_ratio_for_hand','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_MONTH_TENS','nail_type_id','return','is_flip','normal_map','index_array_size','m_original_nail_albedo_texture_array','m_small_gem_norm_map','m_dynamic_range_offset','ZeroFactor','onUpload','colorRatio2','m_target_opaque_copy','digital_watch_time_component_type','m_nail_art_transform_matrices','generateMipmaps','autoClear','Vector4','inputTextureCoordinate','vertOrien','mesh_name_array','modelViewProjMatrix','m_target_wrist_occluder','m_small_gem_pos_map','dissolve','p_nail_mask_last3','metallic_intensity','albedo_intensity','m_nail_pbr_mode','nail_env_map_height','end','roughness','contrast','m_noraml_pnp_step','is_watch_time_component','VN_VTOMode','NAIL_FINISH_SHEER','transmission\x20and\x20orm\x20maps\x20do\x20not\x20have\x20the\x20same\x20size:\x20trans\x20%dx%d,\x20orm\x20%dx%d','call','is_enable_mirror_hdr','SetIsGlass','rootSourceTexture','is_small_gem','m_nail_art_image_height','m_four_way_index','m_ring_mount_occlude_distances','m_ring_mount_occlude_right_distances','inputImageTexture','abrupt','p_camera_matrix','m_root_source_texture','p_normal_array','m_four_way_index_finger_pbr','frameWidth','colorRatio0','m_is_wrist_mode','image_array','customContrast','p_day_normal_matrix','anonymous','p_nail_mask_first3','m_shadow_smooth_filter','SetIsGem','albedo_transform','m_shadow_offset_ratio','YMKModule','gemColor','onerror','m_pnp_step','m_nail_bottom_vec','AlphaFormat','normal_transform','frameRotation','nail_color','array','color','customNormalWeight','isHDREnvMap','nailIndex','gemAbsorption','m_ring_object_number','input_uniforms','m_nail_art_image_width','smallGemRotationMatrix','m_nail_art_texture','inverse_tone_mapping','m_smooth_shadow_size_factor','m_nail_mask_first3','watch_time_component_type','ring_visible_points','GetFittedNDCMatrix','dispose','data','transmission_transform','texture','SetPBRHDRIEnvMap','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_MONTH_ALPHABET','specular_data','WATCH_OBJECT_TIME_COMPONENT_DAY','m_gem_norm_env_maps','diffuse','fragmentShader','p_transform_matrices','onDrawArraysPrePassSilhouetteObject','WATCH_OBJECT_DIGITAL_TIME_COMPONENT_WEEK_DAY_ALPHABET','add','shimmer_granularity','m_enable_adjusting_color','m_gem_pos_env_maps','m_max_luma_for_hand','dataRGBE','cameraRotation','dataTextureCache','SetFrameSetting','p_occluder_transform_matrices','createElement','min_luma_for_hand','TRANSMISSION','p_text_offset_array','glass_name_array','orm','SetPBREnvMapParameters','impossible!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!','m_hand_camera_matrices','SetShowOccluder','isNailArt','needsUpdate','transmission_intensity','m_is_nail_art_array','UpdateShaderParametersPassPostWristOccluder','m_shadow_size_factor','OneMinusSrcAlphaFactor','NAIL_FINISH_TEXTURED','small_gem_pos_map_width','p_hour_transform_matrix','m_four_way_ring_finger_pbr','blendDst','object3d_','wrapT','unexpected\x20map\x20type:\x20'];(function(_0x3d9701,_0x39a73f){var _0x34f8be=function(_0x52b73f){while(--_0x52b73f){_0x3d9701['push'](_0x3d9701['shift']());}};_0x34f8be(++_0x39a73f);}(_0x39a7,0x74));var _0x34f8=function(_0x3d9701,_0x39a73f){_0x3d9701=_0x3d9701-0x0;var _0x34f8be=_0x39a7[_0x3d9701];return _0x34f8be;};'use strict';Object['defineProperty'](exports,'__esModule',{'value':!![]}),exports['default']=undefined;var _regenerator=__webpack_require__(5),_regenerator2=_interopRequireDefault(_regenerator),_asyncToGenerator2=__webpack_require__(6),_asyncToGenerator3=_interopRequireDefault(_asyncToGenerator2),_promise=__webpack_require__(14),_promise2=_interopRequireDefault(_promise),_from=__webpack_require__(309),_from2=_interopRequireDefault(_from),_keys=__webpack_require__(33),_keys2=_interopRequireDefault(_keys),_getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_shadowsmoothfilter=__webpack_require__(3345),_shadowsmoothfilter2=_interopRequireDefault(_shadowsmoothfilter),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader3=__webpack_require__(3347),_shader4=_interopRequireDefault(_shader3),_pbr=__webpack_require__(3348),_pbr2=_interopRequireDefault(_pbr),_browserUtils=__webpack_require__(8),_browserUtils2=_interopRequireDefault(_browserUtils),_mediaUtils=__webpack_require__(74),_mediaUtils2=_interopRequireDefault(_mediaUtils);function _interopRequireDefault(_0x32dbfb){return _0x32dbfb&&_0x32dbfb['__esModule']?_0x32dbfb:{'default':_0x32dbfb};}var PBRTextureMapEnum={'ALBEDO':0x0,'AO':0x1,'METALLIC':0x2,'NORMAL':0x3,'ROUGHNESS':0x4,'TRANSMISSION':0x5,'ORM':0x6},Object3DFirstFilter=(_temp=_class=function(_0x5d4c40){(0x0,_inherits3['default'])(_0x55c122,_0x5d4c40);function _0x55c122(_0x48ec18,_0x3a9d91,_0x4daada,_0x2b9d0a){(0x0,_classCallCheck3[_0x34f8('0xa')])(this,_0x55c122);var _0x30169b=(0x0,_possibleConstructorReturn3[_0x34f8('0xa')])(this,(_0x55c122['__proto__']||(0x0,_getPrototypeOf2[_0x34f8('0xa')])(_0x55c122))['call'](this,_0x48ec18,_0x3a9d91));return _initialiseProps[_0x34f8('0x16b')](_0x30169b),_0x30169b[_0x34f8('0x186')]=_0x2b9d0a,_0x30169b['m_scene_array']=[],_0x30169b[_0x34f8('0x234')]=[],_0x30169b[_0x34f8('0x23a')]=[],_0x30169b['mesh_name_array']=[],_0x30169b[_0x34f8('0x140')]=[],_0x30169b[_0x34f8('0x1bc')]=[],_0x30169b[_0x34f8('0xa2')]=_0x4daada,_0x30169b['m_shadow_size_factor']=0x1,_0x30169b[_0x34f8('0x19b')]=0x1,_0x30169b[_0x34f8('0x29')]={},_0x30169b[_0x34f8('0x202')]=new _three[(_0x34f8('0x40'))](_0x48ec18,_0x3a9d91,{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x30169b[_0x34f8('0x15b')]=new _three[(_0x34f8('0x40'))](_0x48ec18/_0x30169b['m_upsample_factor'],_0x3a9d91/_0x30169b[_0x34f8('0xa2')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x30169b[_0x34f8('0x30')]=new _three[(_0x34f8('0x40'))](_0x48ec18/_0x30169b['m_upsample_factor']*_0x30169b[_0x34f8('0x1c7')],_0x3a9d91/_0x30169b[_0x34f8('0xa2')]*_0x30169b[_0x34f8('0x1c7')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x30169b[_0x34f8('0x88')]=new _three[(_0x34f8('0x40'))](_0x48ec18/_0x30169b[_0x34f8('0xa2')]*_0x30169b[_0x34f8('0x1c7')],_0x3a9d91/_0x30169b[_0x34f8('0xa2')]*_0x30169b['m_shadow_size_factor'],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three['RGBAFormat']}),_0x30169b[_0x34f8('0x151')]=new _three[(_0x34f8('0x40'))](_0x48ec18,_0x3a9d91,{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x30169b[_0x34f8('0x182')]=new _shadowsmoothfilter2[(_0x34f8('0xa'))](_0x48ec18,_0x3a9d91,_0x4daada),_0x30169b[_0x34f8('0x182')][_0x34f8('0xc9')]=_0x48ec18,_0x30169b['m_shadow_smooth_filter'][_0x34f8('0x17')]=_0x3a9d91,_0x30169b[_0x34f8('0x1e')]=new _three[(_0x34f8('0x40'))](_0x48ec18/_0x30169b['m_upsample_factor']*_0x30169b['m_smooth_shadow_size_factor'],_0x3a9d91/_0x30169b['m_upsample_factor']*_0x30169b[_0x34f8('0x19b')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x30169b[_0x34f8('0x185')]=0x1,_0x30169b[_0x34f8('0x42')]=0x0,_0x30169b['m_is_show_occluder']=![],_0x30169b[_0x34f8('0x96')]=!![],_0x30169b[_0x34f8('0xcf')]=![],_0x30169b['m_is_nail_tip']=![],_0x30169b['m_is_nail_art_array']=null,_0x30169b['m_nail_left_vec']=null,_0x30169b['m_nail_right_vec']=null,_0x30169b[_0x34f8('0x59')]=null,_0x30169b['m_nail_bottom_vec']=null,_0x30169b[_0x34f8('0xc2')]=null,_0x30169b[_0x34f8('0x179')]=null,_0x30169b[_0x34f8('0x2e')]=null,_0x30169b[_0x34f8('0x1cc')]=null,_0x30169b[_0x34f8('0xac')]=null,_0x30169b[_0x34f8('0x17c')]=![],_0x30169b[_0x34f8('0x1eb')]=![],_0x30169b[_0x34f8('0xeb')]=![],_0x30169b[_0x34f8('0x9')]=0x0,_0x30169b[_0x34f8('0x195')]=0x1,_0x30169b['m_is_nail_valid']=[![],![],![],![],![]],_0x30169b[_0x34f8('0x18d')]=0x0,_0x30169b[_0x34f8('0x148')]=![],_0x30169b[_0x34f8('0x2d')]=0x0,_0x30169b[_0x34f8('0xf0')]=0x0,_0x30169b[_0x34f8('0xae')]=null,_0x30169b[_0x34f8('0xb6')]=null,_0x30169b[_0x34f8('0x197')]=0x0,_0x30169b[_0x34f8('0x170')]=0x0,_0x30169b[_0x34f8('0xb2')]=null,_0x30169b[_0x34f8('0x199')]=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],_0x30169b[_0x34f8('0x19c')]=null,_0x30169b[_0x34f8('0x9d')]=null,_0x30169b[_0x34f8('0x44')]=null,_0x30169b['m_original_nail_albedo_texture_array']=[null,null,null,null,null,null,null,null,null],_0x30169b[_0x34f8('0x177')]=null,_0x30169b['m_dynamic_range_compress']=0x1,_0x30169b['m_dynamic_range_offset']=0x0,_0x30169b[_0x34f8('0x7f')]=0x1,_0x30169b[_0x34f8('0x4b')]=0x0,_0x30169b[_0x34f8('0xfa')]=0.8,_0x30169b['m_max_luma_for_hand']=0x1,_0x30169b[_0x34f8('0x144')]=[0x1,0x1,0x1,0x1],_0x30169b[_0x34f8('0x76')]=[0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1],_0x30169b[_0x34f8('0x1b0')]=![],_0x30169b[_0x34f8('0x9c')]=!![],_0x30169b[_0x34f8('0x172')]=[],_0x30169b[_0x34f8('0x11')]=[],_0x30169b[_0x34f8('0x173')]=[],_0x30169b[_0x34f8('0x12a')]=0x1,_0x30169b[_0x34f8('0xbc')]=0x0,_0x30169b[_0x34f8('0x232')]=null,_0x30169b[_0x34f8('0x6c')]={},_0x30169b['dataTextureCache']={},_0x30169b[_0x34f8('0x1f')]=0x0,_0x30169b;}return _0x55c122;}(_basefilter2[_0x34f8('0xa')]),_initialiseProps=function _initialiseProps(){var _0x1a2a2e=this;this[_0x34f8('0x13')]=function(_0x142093,_0x5654fd,_0x12f9d0,_0x5f0957){return _0x1a2a2e['UpdateShaderParametersPass1'](_0x142093,_0x5654fd,_0x12f9d0,_0x5f0957);},this[_0x34f8('0x23e')]=function(_0x411fb4){return _0x1a2a2e['UpdateShaderParametersPassWristOccluder'](_0x411fb4);},this[_0x34f8('0x43')]=function(_0xc7bd33){return _0x1a2a2e[_0x34f8('0x28')](_0xc7bd33);},this[_0x34f8('0x1ac')]=function(_0x3098dd){return _0x1a2a2e[_0x34f8('0x10b')](_0x3098dd);},this[_0x34f8('0x217')]=function(_0xc8e6fc){return _0x1a2a2e['UpdateShaderParametersPassPostWristOccluder'](_0xc8e6fc);},this[_0x34f8('0x4f')]=function(_0x37cc0e,_0x33e3a8,_0x343ca6,_0x4b8186){if(!_0x1a2a2e[_0x34f8('0x96')]&&!_0x1a2a2e[_0x34f8('0x17c')]&&!_0x1a2a2e['m_is_ring_mode'])_0x1a2a2e[_0x34f8('0xe5')]();for(var _0x11c871=0x0;_0x11c871<_0x33e3a8['length'];_0x11c871++){var _0x4bd253=_0x37cc0e[_0x34f8('0xf')](_0x33e3a8[_0x11c871]);_0x4bd253[_0x34f8('0xa9')]==!![]&&(_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x65')][_0x34f8('0x114')]=0x0,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x25')][_0x34f8('0x114')]=0x0,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x17a')][_0x34f8('0x114')]=parseFloat(_0x1a2a2e[_0x34f8('0x7d')]),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['frameHeight'][_0x34f8('0x114')]=parseFloat(_0x1a2a2e[_0x34f8('0xb0')]),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x16e')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x151')]['texture']);_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10')][_0x34f8('0x114')]=new _three['Vector2'](0x0,0x0);if(_0x1a2a2e[_0x34f8('0x96')]){_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1c2')]['value']=_0x343ca6?0x1:0x0;var _0x48a14f=_0x4bd253[_0x34f8('0xef')],_0x2fbf19=_0x343ca6?_0x1a2a2e['m_nail_art_transform_matrices']:_0x1a2a2e[_0x34f8('0x131')];if(_0x343ca6)_0x1a2a2e[_0x34f8('0xb7')]=_0x2fbf19[_0x34f8('0x87')](_0x48a14f*0xc,_0x48a14f*0xc+0xc);else _0x1a2a2e[_0x34f8('0xb7')]=_0x2fbf19[_0x34f8('0x87')](_0x48a14f*_0x1a2a2e[_0x34f8('0x189')],_0x48a14f*_0x1a2a2e[_0x34f8('0x189')]+0xc);var _0xb0d851=_0x1a2a2e[_0x34f8('0xc2')]['get'](_0x1a2a2e[_0x34f8('0x171')]),_0x4e5e29=_0x1a2a2e[_0x34f8('0x179')]['get'](_0x1a2a2e[_0x34f8('0x171')]),_0xf4c5ae=_0x1a2a2e[_0x34f8('0x2e')][_0x34f8('0x1e0')](_0x1a2a2e['m_four_way_index']),_0x3bd706=_0x1a2a2e[_0x34f8('0x1cc')][_0x34f8('0x1e0')](_0x1a2a2e[_0x34f8('0x171')]),_0x1c67a7=_0x1a2a2e['m_four_way_little_finger_pbr']['get'](_0x1a2a2e[_0x34f8('0x171')]),_0x2145f4=[_0xb0d851,_0x4e5e29,_0xf4c5ae,_0x3bd706,_0x1c67a7],_0x2f0ed3=_0x2145f4[_0x48a14f],_0x446ab3=![],_0xb62319=!![],_0x5163fa=![],_0x4722db=0x5,_0x1df245=0x0,_0x3430cb=0x1,_0x5a1dc2=0x2,_0x1f2d8c=0x3,_0x4f71e1=0x4,_0x3cfe4a=0x5,_0x295aef=0x6,_0x5ccef3=0x7,_0x30513d=0x8,_0xb9fe0b=Math['floor'](_0x11c871/_0x4722db);if(_0x4bd253[_0x34f8('0xa9')]==!![]){(_0x1a2a2e[_0x34f8('0x161')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x38')]['NAIL_PBR_CUSTOMIZED']||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x45')][_0x34f8('0x114')]||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x1c9')][_0x34f8('0x114')]||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')]['VN_NailFinishType'][_0x34f8('0x0')][_0x34f8('0x114')]||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0xc0')][_0x34f8('0x114')])&&(_0x446ab3=!![]);var _0x52d41d=_0xb9fe0b==_0x1df245,_0x3ca22b=_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')]['NAIL_FINISH_CREAM'][_0x34f8('0x114')]||_0x2f0ed3['finish_type'][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x1d8')][_0x34f8('0x114')]||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x169')][_0x34f8('0x114')]||_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x55')][_0x34f8('0x114')],_0x45b98a=_0xb9fe0b==_0x3430cb,_0x5c70fc=_0x2f0ed3[_0x34f8('0x1de')]['value']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x80')]['value'];_0x5163fa=_0x5c70fc;var _0x1d4c85=_0xb9fe0b==_0x5a1dc2||_0xb9fe0b==_0x1f2d8c,_0x1145c5=_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e['YMKModule']['VN_NailFinishType'][_0x34f8('0x45')][_0x34f8('0x114')],_0x383980=_0xb9fe0b==_0x4f71e1,_0x5b93cb=_0x2f0ed3['finish_type'][_0x34f8('0x114')]==_0x1a2a2e['YMKModule'][_0x34f8('0x132')][_0x34f8('0x1c9')]['value'],_0x502c0b=_0xb9fe0b==_0x3cfe4a||_0xb9fe0b==_0x295aef,_0x296342=_0x2f0ed3['finish_type'][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')][_0x34f8('0x0')][_0x34f8('0x114')],_0x432175=_0xb9fe0b==_0x5ccef3||_0xb9fe0b==_0x30513d,_0x213aad=_0x2f0ed3['finish_type'][_0x34f8('0x114')]==_0x1a2a2e['YMKModule'][_0x34f8('0x132')][_0x34f8('0xc0')][_0x34f8('0x114')];_0xb62319=_0x52d41d&&_0x3ca22b||_0x45b98a&&_0x5c70fc||_0x1d4c85&&_0x1145c5||_0x383980&&_0x5b93cb||_0x502c0b&&_0x296342||_0x432175&&_0x213aad||_0x1a2a2e[_0x34f8('0x161')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x38')]['NAIL_PBR_CUSTOMIZED'];}!_0x2f0ed3[_0x34f8('0x14')]&&_0x1a2a2e[_0x34f8('0x161')]===_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x38')][_0x34f8('0x23')]&&(_0xb62319=![]);if(_0x1a2a2e[_0x34f8('0x205')][_0x48a14f]==![]||_0xb62319==![])for(var _0x5fff12=0x0;_0x5fff12<0xc;_0x5fff12++){_0x1a2a2e[_0x34f8('0xb7')][_0x5fff12]=0x0;}var _0x4f41b0=_0x343ca6?_0x1a2a2e['m_nail_art_normal_matrices']:_0x1a2a2e[_0x34f8('0x35')];_0x1a2a2e[_0x34f8('0x5d')]=_0x4f41b0[_0x34f8('0x87')](_0x48a14f*_0x1a2a2e[_0x34f8('0x166')],_0x48a14f*_0x1a2a2e[_0x34f8('0x166')]+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')]['slice'](_0x48a14f*0x9,_0x48a14f*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();if(_0x4bd253[_0x34f8('0xa9')]==![]){var _0x1acb85=_0x1a2a2e['m_four_way_index']*0x5+_0x48a14f;!_0x343ca6?(_0x1a2a2e['m_static_diffuse_texture'][_0x34f8('0x1c3')]=!![],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['diffuseTexture'][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0xb2')]):(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x121')]['value']!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['diffuseTexture'][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x121')]['value']=null),_0x1a2a2e[_0x34f8('0x199')][_0x1acb85]!=null&&(_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x121')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x199')][_0x1acb85]));_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]['dispose'](),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=null);var _0x4026dd=new _three[(_0x34f8('0x218'))](_0x1a2a2e[_0x34f8('0xae')][_0x1acb85],0x280,0x140,_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x4026dd[_0x34f8('0x154')]=!![],_0x4026dd[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x4026dd[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x4026dd[_0x34f8('0x1c3')]=!![],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=_0x4026dd;}_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x220')][_0x34f8('0x114')]!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x220')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['nailMaskFirst3Texture'][_0x34f8('0x114')]=null);_0x4bd253[_0x34f8('0x20')]['uniforms']['nailMaskLast3Texture']['value']!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x201')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x201')][_0x34f8('0x114')]=null);_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['nailMaskFirst3Texture']['value']=_0x1a2a2e[_0x34f8('0x19c')],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x201')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x9d')],_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x193')][_0x34f8('0x114')]=_0x48a14f,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x17a')][_0x34f8('0x114')]=parseFloat(_0x1a2a2e[_0x34f8('0x7d')]),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x13c')][_0x34f8('0x114')]=parseFloat(_0x1a2a2e[_0x34f8('0xb0')]),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x1fb')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0xbc')];var _0x3450d4=_0x1a2a2e[_0x34f8('0xa3')][_0x34f8('0x1e0')](_0x48a14f),_0x317835=_0x1a2a2e['m_nail_right_vec'][_0x34f8('0x1e0')](_0x48a14f),_0x38dc19=_0x1a2a2e[_0x34f8('0x59')][_0x34f8('0x1e0')](_0x48a14f),_0x418bd0=_0x1a2a2e[_0x34f8('0x18a')]['get'](_0x48a14f);_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1da')][_0x34f8('0x114')]=new _three['Vector4'](_0x3450d4,_0x317835,_0x38dc19,_0x418bd0),_0x1a2a2e[_0x34f8('0xcf')]=![];if(_0x4bd253[_0x34f8('0xa9')]==!![]){_0x1a2a2e[_0x34f8('0xcf')]=!![];var _0x40bb20=_0x2f0ed3[_0x34f8('0xa5')],_0x19a926=_0xb9fe0b==_0x1f2d8c||_0xb9fe0b==_0x295aef||_0xb9fe0b==_0x30513d;_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['customRoughness'][_0x34f8('0x114')]=_0x2f0ed3[_0x34f8('0x1de')][_0x34f8('0x114')]==_0x1a2a2e[_0x34f8('0x186')]['VN_NailFinishType'][_0x34f8('0x1c9')][_0x34f8('0x114')]?0x0:_0x2f0ed3[_0x34f8('0x164')]*0.005,_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x191')][_0x34f8('0x114')]=_0x2f0ed3['finish_type'][_0x34f8('0x114')]==_0x1a2a2e['YMKModule'][_0x34f8('0x132')]['NAIL_FINISH_TEXTURED'][_0x34f8('0x114')]?_0x2f0ed3['roughness']*0.01:0.5,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x12f')][_0x34f8('0x114')]=_0x2f0ed3['finish_type']['value']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x132')]['NAIL_FINISH_METALLIC'][_0x34f8('0x114')]?0x1:0x0,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x17e')][_0x34f8('0x114')]=_0x2f0ed3[_0x34f8('0x165')]*0.01,_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0xbf')][_0x34f8('0x114')]=_0x2f0ed3[_0x34f8('0xc3')]*0.01,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xc')][_0x34f8('0x114')]=_0x2f0ed3[_0x34f8('0x233')]*0.01,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1d6')][_0x34f8('0x114')]=_0x19a926?0x0:_0x2f0ed3[_0x34f8('0x224')]*0.01,_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x2')]['value']=Math['min'](Math[_0x34f8('0x5e')](_0x2f0ed3[_0x34f8('0x21f')]*0.01+0.5,0.5),1.5),_0x4bd253['material']['uniforms'][_0x34f8('0x1d5')]['value']=Math[_0x34f8('0x81')](Math[_0x34f8('0x5e')](_0x2f0ed3['shimmer_granularity']*0.01+0.5,0.5),1.5),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x90')][_0x34f8('0x114')]=_0x2f0ed3['glitter_opacity']*0.01*Math['min'](Math[_0x34f8('0x5e')](_0x2f0ed3[_0x34f8('0x1af')]*0.02,0.01),0x1),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x25')][_0x34f8('0x114')]=_0x1a2a2e['m_is_nail_tip']||_0x1a2a2e[_0x34f8('0x161')]==_0x1a2a2e[_0x34f8('0x186')]['VN_NailPbrMode'][_0x34f8('0x3')]?0x0:0x1,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x211')]['value']=_0x1a2a2e['m_is_nail_tip']?0x1:0x0,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x65')][_0x34f8('0x114')]=0x1,_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x1c2')]['value']=_0x40bb20?0x1:0x0,_0x4bd253['material'][_0x34f8('0x238')]['isNailMetallic'][_0x34f8('0x114')]=_0x5163fa?0x1:0x0,_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['is_nail_design'][_0x34f8('0x114')]=_0x446ab3?0x1:0x0;var _0x46e5a4=_0x2f0ed3[_0x34f8('0x190')]['r']/0xff,_0x23a186=_0x2f0ed3[_0x34f8('0x190')]['g']/0xff,_0x2553f1=_0x2f0ed3[_0x34f8('0x190')]['b']/0xff;_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x18e')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x46e5a4,_0x23a186,_0x2553f1),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x207')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x20d')]?0x1:0x0;_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['rootSourceTexture'][_0x34f8('0x114')]!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x16e')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x16e')][_0x34f8('0x114')]=null);_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x16e')][_0x34f8('0x114')]=_0x4bd253['is_first_nail_object']||_0xb9fe0b>=0x0?_0x1a2a2e[_0x34f8('0x177')]:_0x1a2a2e[_0x34f8('0x151')][_0x34f8('0x1a3')];if(_0x1a2a2e[_0x34f8('0x161')]!=_0x1a2a2e[_0x34f8('0x186')]['VN_NailPbrMode'][_0x34f8('0x3')]&&!_0x19a926){_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]['dispose'](),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['albedoTexture'][_0x34f8('0x114')]=null);if(_0x40bb20||_0x1a2a2e[_0x34f8('0x242')]){var _0x1cc713=_0x1a2a2e[_0x34f8('0x171')]*0x5+_0x48a14f;_0x1a2a2e[_0x34f8('0x199')][_0x1cc713]!=null&&(_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x199')][_0x1cc713]);}else _0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x14b')][_0xb9fe0b];}}}if(_0x1a2a2e['m_is_wrist_mode']){if(_0x33e3a8[_0x11c871][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){var _0x1d45bd=_0x4b8186,_0x267576=0x0,_0x41333c=0x0;if(_0x4bd253[_0x34f8('0x167')]){var _0x32d7ee=_0x1a2a2e[_0x34f8('0x72')][_0x34f8('0x1e0')](_0x1d45bd);if(_0x4bd253['watch_time_component_type']==_0x1a2a2e[_0x34f8('0x186')]['VN_WatchObjectTimeComponentType'][_0x34f8('0x3f')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0xec')],0xc),_0x1a2a2e['m_normal_matrix']=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')]['buffer'],_0x32d7ee[_0x34f8('0x21b')],0x10);else{if(_0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0xce')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e['YMKModule'][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0x21')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0xfc')],0x10);else{if(_0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e['YMKModule']['VN_WatchObjectTimeComponentType'][_0x34f8('0x203')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')]['buffer'],_0x32d7ee[_0x34f8('0x1cb')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0xcb')],0xc);else _0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0x1a7')]&&(_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0xf9')],0xc),_0x1a2a2e['m_normal_matrix']=new Float32Array(_0x1a2a2e['YMKModule']['HEAPF32'][_0x34f8('0x23d')],_0x32d7ee[_0x34f8('0x17f')],0xc));}}}else{if(_0x4bd253[_0x34f8('0x11b')]){var _0x46d9da=_0x4bd253['digital_watch_time_component_text_offset_array'],_0x16e174=new Date(),_0x559a9a=_0x16e174[_0x34f8('0xdd')]()+0x1,_0x2ad14f=_0x16e174[_0x34f8('0x11a')](),_0x489d52=_0x16e174[_0x34f8('0x97')](),_0x42ab6e=_0x16e174['getMinutes'](),_0x200b52=_0x16e174[_0x34f8('0xe2')](),_0x27d564=_0x16e174[_0x34f8('0x1df')](),_0x59450b=0x0;if(_0x4bd253[_0x34f8('0x47')]==0xc){if(_0x489d52>=0xc){if(_0x489d52>0xc)_0x489d52=_0x489d52-0xc;_0x59450b=0x2;}else{if(_0x489d52==0x0)_0x489d52=0xc;_0x59450b=0x1;}}if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')]['VN_WatchObjectDigitalTimeComponentType'][_0x34f8('0x12b')]){var _0x2f2174=Math[_0x34f8('0x1e6')](_0x200b52/0xa);_0x267576=_0x46d9da[_0x2f2174*0x2+0x0],_0x41333c=_0x46d9da[_0x2f2174*0x2+0x1];}else{if(_0x4bd253['digital_watch_time_component_type']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x226')]){var _0x35088a=_0x200b52%0xa;_0x267576=_0x46d9da[_0x35088a*0x2+0x0],_0x41333c=_0x46d9da[_0x35088a*0x2+0x1];}else{if(_0x4bd253['digital_watch_time_component_type']==_0x1a2a2e['YMKModule'][_0x34f8('0x23f')]['WATCH_OBJECT_DIGITAL_TIME_COMPONENT_MINUTE_TENS']){var _0xedab43=Math[_0x34f8('0x1e6')](_0x42ab6e/0xa);_0x267576=_0x46d9da[_0xedab43*0x2+0x0],_0x41333c=_0x46d9da[_0xedab43*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x12c')]){var _0x450d84=_0x42ab6e%0xa;_0x267576=_0x46d9da[_0x450d84*0x2+0x0],_0x41333c=_0x46d9da[_0x450d84*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x113')]){var _0x2b2bbb=Math[_0x34f8('0x1e6')](_0x489d52/0xa);_0x267576=_0x46d9da[_0x2b2bbb*0x2+0x0],_0x41333c=_0x46d9da[_0x2b2bbb*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x83')]){var _0x1b1d5c=_0x489d52%0xa;_0x267576=_0x46d9da[_0x1b1d5c*0x2+0x0],_0x41333c=_0x46d9da[_0x1b1d5c*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')]['VN_WatchObjectDigitalTimeComponentType'][_0x34f8('0x1ad')])_0x267576=_0x46d9da[_0x27d564*0x2+0x0],_0x41333c=_0x46d9da[_0x27d564*0x2+0x1];else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x1a5')])_0x267576=_0x46d9da[(_0x559a9a-0x1)*0x2+0x0],_0x41333c=_0x46d9da[(_0x559a9a-0x1)*0x2+0x1];else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e['YMKModule'][_0x34f8('0x23f')][_0x34f8('0x145')]){var _0x4df8ae=Math[_0x34f8('0x1e6')](_0x559a9a/0xa);_0x267576=_0x46d9da[_0x4df8ae*0x2+0x0],_0x41333c=_0x46d9da[_0x4df8ae*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')]['VN_WatchObjectDigitalTimeComponentType'][_0x34f8('0x82')]){var _0x1c393c=_0x559a9a%0xa;_0x267576=_0x46d9da[_0x1c393c*0x2+0x0],_0x41333c=_0x46d9da[_0x1c393c*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')]['WATCH_OBJECT_DIGITAL_TIME_COMPONENT_DAY_TENS']){var _0x14acea=Math[_0x34f8('0x1e6')](_0x2ad14f/0xa);_0x267576=_0x46d9da[_0x14acea*0x2+0x0],_0x41333c=_0x46d9da[_0x14acea*0x2+0x1];}else{if(_0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')][_0x34f8('0x7e')]){var _0x40cde5=_0x2ad14f%0xa;_0x267576=_0x46d9da[_0x40cde5*0x2+0x0],_0x41333c=_0x46d9da[_0x40cde5*0x2+0x1];}else _0x4bd253[_0x34f8('0x152')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x23f')]['WATCH_OBJECT_DIGITAL_TIME_COMPONENT_AM_PM_ALPHABET']&&(_0x267576=_0x46d9da[_0x59450b*0x2+0x0],_0x41333c=_0x46d9da[_0x59450b*0x2+0x1]);}}}}}}}}}}}_0x1a2a2e['m_transform_matrix']=_0x1a2a2e['m_hand_transform_matrices'][_0x34f8('0x87')](_0x1d45bd*_0x1a2a2e[_0x34f8('0x189')],_0x1d45bd*_0x1a2a2e[_0x34f8('0x189')]+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x35')][_0x34f8('0x87')](_0x1d45bd*_0x1a2a2e[_0x34f8('0x166')],_0x1d45bd*_0x1a2a2e[_0x34f8('0x166')]+0x10);}else{var _0x58acef=!!_0x4bd253[_0x34f8('0x74')]?_0x4bd253[_0x34f8('0x74')]:0x0,_0xd94498=_0x1d45bd*_0x1a2a2e[_0x34f8('0x189')]+_0x58acef*0xc,_0x4a60d4=_0x1d45bd*_0x1a2a2e['m_noraml_pnp_step']+_0x58acef*0x10;_0x1a2a2e['m_transform_matrix']=_0x1a2a2e[_0x34f8('0x131')][_0x34f8('0x87')](_0xd94498,_0xd94498+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x35')][_0x34f8('0x87')](_0x4a60d4,_0x4a60d4+0x10);}}_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x1d45bd*0x9,_0x1d45bd*0x9+0x9),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['watchTextureCoordinateOffset'][_0x34f8('0x114')]=new _three[(_0x34f8('0x1d2'))](_0x267576,_0x41333c),_0x1a2a2e[_0x34f8('0xe5')]();}else{var _0x4afaf3=_0x4b8186;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e[_0x34f8('0x22f')][_0x34f8('0x87')](_0x4afaf3*0xc,_0x4afaf3*0xc+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e['m_occluder_normal_matrices'][_0x34f8('0x87')](_0x4afaf3*0x10,_0x4afaf3*0x10+0x10),_0x1a2a2e['m_project_matrix']=_0x1a2a2e['m_hand_camera_matrices'][_0x34f8('0x87')](_0x4afaf3*0x9,_0x4afaf3*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}if(_0x4bd253[_0x34f8('0xa9')]==![]&&_0x4bd253[_0x34f8('0xcd')]==![]){_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x9e')][_0x34f8('0x114')]=0x1;var _0x39703f=_0x1a2a2e['m_dynamic_range_compress'],_0x52b775=_0x1a2a2e[_0x34f8('0x14d')],_0x47ed00=_0x1a2a2e[_0x34f8('0x7f')],_0x7ea3ce=_0x1a2a2e[_0x34f8('0x4b')];_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['dynamic_range_compress'][_0x34f8('0x114')]=new _three['Vector3'](_0x39703f,_0x39703f,_0x39703f),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0xe0')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x52b775,_0x52b775,_0x52b775),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x20f')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x47ed00,_0x47ed00,_0x47ed00),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x9f')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x7ea3ce,_0x7ea3ce,_0x7ea3ce);}}if(_0x1a2a2e[_0x34f8('0x1eb')]){if(_0x33e3a8[_0x11c871][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){var _0x356df7=_0x4b8186;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e['m_hand_transform_matrices'][_0x34f8('0x87')](_0x356df7*_0x1a2a2e[_0x34f8('0x189')],_0x356df7*_0x1a2a2e['m_pnp_step']+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e['m_hand_normal_matrices']['slice'](_0x356df7*_0x1a2a2e[_0x34f8('0x166')],_0x356df7*_0x1a2a2e[_0x34f8('0x166')]+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x356df7*0x9,_0x356df7*0x9+0x9),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x33')]['value']=_0x1a2a2e[_0x34f8('0x172')][_0x356df7],_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0xc1')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x11')][_0x356df7],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x36')][_0x34f8('0x114')]=_0x1a2a2e['m_ring_mount_occlude_right_distances'][_0x356df7],_0x1a2a2e[_0x34f8('0xe5')]();}else{var _0x1e15ef=_0x4b8186;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e[_0x34f8('0x22f')][_0x34f8('0x87')](_0x1e15ef*0xc,_0x1e15ef*0xc+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x231')][_0x34f8('0x87')](_0x1e15ef*0x10,_0x1e15ef*0x10+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x1e15ef*0x9,_0x1e15ef*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}if(_0x4bd253[_0x34f8('0xa9')]==![]&&_0x4bd253['is_gem']==![]){_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x9e')][_0x34f8('0x114')]=0x1;var _0x2257c9=_0x1a2a2e[_0x34f8('0x6d')],_0x1a70d1=_0x1a2a2e[_0x34f8('0x14d')],_0x15e6cf=_0x1a2a2e[_0x34f8('0x7f')],_0x511865=_0x1a2a2e[_0x34f8('0x4b')];_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0xe6')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x2257c9,_0x2257c9,_0x2257c9),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xe0')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x1a70d1,_0x1a70d1,_0x1a70d1),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x20f')]['value']=new _three[(_0x34f8('0x46'))](_0x15e6cf,_0x15e6cf,_0x15e6cf),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x9f')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x511865,_0x511865,_0x511865);}}if(_0x1a2a2e[_0x34f8('0xeb')]){if(_0x4bd253[_0x34f8('0x167')]==![])_0x1a2a2e[_0x34f8('0xe5')]();else{var _0x5314d1=_0x1a2a2e['m_transform_matrix']['slice'](),_0x2d8065=_0x1a2a2e[_0x34f8('0x5d')][_0x34f8('0x87')](),_0x17cb0e=_0x1a2a2e[_0x34f8('0x72')][_0x34f8('0x1e0')](0x0);if(_0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0x3f')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x17cb0e[_0x34f8('0xec')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')]['buffer'],_0x17cb0e[_0x34f8('0x21b')],0x10);else{if(_0x4bd253['watch_time_component_type']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0xce')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x17cb0e[_0x34f8('0x21')],0xc),_0x1a2a2e['m_normal_matrix']=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')]['buffer'],_0x17cb0e[_0x34f8('0xfc')],0x10);else{if(_0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0x203')])_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x17cb0e[_0x34f8('0x1cb')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e['YMKModule'][_0x34f8('0x10a')]['buffer'],_0x17cb0e[_0x34f8('0xcb')],0xc);else _0x4bd253[_0x34f8('0x19d')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xda')][_0x34f8('0x1a7')]&&(_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e['YMKModule'][_0x34f8('0x10a')]['buffer'],_0x17cb0e[_0x34f8('0xf9')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x17cb0e[_0x34f8('0x17f')],0x10));}}_0x1a2a2e[_0x34f8('0xe5')](),_0x1a2a2e[_0x34f8('0xb7')]=_0x5314d1,_0x1a2a2e[_0x34f8('0x5d')]=_0x2d8065;}}var _0x3d9bb2=new _three[(_0x34f8('0xf2'))]();_0x3d9bb2[_0x34f8('0xee')](_0x1a2a2e['m_filter_transform_matrix'][0x0],_0x1a2a2e[_0x34f8('0x125')][0x4],_0x1a2a2e[_0x34f8('0x125')][0x8],_0x1a2a2e[_0x34f8('0x125')][0xc],_0x1a2a2e[_0x34f8('0x125')][0x1],_0x1a2a2e[_0x34f8('0x125')][0x5],_0x1a2a2e[_0x34f8('0x125')][0x9],_0x1a2a2e[_0x34f8('0x125')][0xd],_0x1a2a2e[_0x34f8('0x125')][0x2],_0x1a2a2e[_0x34f8('0x125')][0x6],_0x1a2a2e[_0x34f8('0x125')][0xa],_0x1a2a2e['m_filter_transform_matrix'][0xe],_0x1a2a2e['m_filter_transform_matrix'][0x3],_0x1a2a2e['m_filter_transform_matrix'][0x7],_0x1a2a2e[_0x34f8('0x125')][0xb],_0x1a2a2e[_0x34f8('0x125')][0xf]),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')]['modelViewProjMatrix']['value']=_0x3d9bb2;var _0x21ef58=new _three[(_0x34f8('0xf2'))]();_0x21ef58[_0x34f8('0xee')](_0x1a2a2e['m_filter_normal_matrix'][0x0],_0x1a2a2e[_0x34f8('0x19')][0x4],_0x1a2a2e[_0x34f8('0x19')][0x8],_0x1a2a2e[_0x34f8('0x19')][0xc],_0x1a2a2e[_0x34f8('0x19')][0x1],_0x1a2a2e[_0x34f8('0x19')][0x5],_0x1a2a2e[_0x34f8('0x19')][0x9],_0x1a2a2e[_0x34f8('0x19')][0xd],_0x1a2a2e[_0x34f8('0x19')][0x2],_0x1a2a2e[_0x34f8('0x19')][0x6],_0x1a2a2e['m_filter_normal_matrix'][0xa],_0x1a2a2e[_0x34f8('0x19')][0xe],_0x1a2a2e[_0x34f8('0x19')][0x3],_0x1a2a2e[_0x34f8('0x19')][0x7],_0x1a2a2e[_0x34f8('0x19')][0xb],_0x1a2a2e[_0x34f8('0x19')][0xf]),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x124')][_0x34f8('0x114')]=_0x21ef58;var _0x1ade82=new _three[(_0x34f8('0xf2'))]();_0x1ade82['set'](_0x1a2a2e[_0x34f8('0x3b')][0x0],_0x1a2a2e[_0x34f8('0x3b')][0x4],_0x1a2a2e[_0x34f8('0x3b')][0x8],_0x1a2a2e[_0x34f8('0x3b')][0xc],_0x1a2a2e[_0x34f8('0x3b')][0x1],_0x1a2a2e[_0x34f8('0x3b')][0x5],_0x1a2a2e[_0x34f8('0x3b')][0x9],_0x1a2a2e[_0x34f8('0x3b')][0xd],_0x1a2a2e[_0x34f8('0x3b')][0x2],_0x1a2a2e[_0x34f8('0x3b')][0x6],_0x1a2a2e[_0x34f8('0x3b')][0xa],_0x1a2a2e[_0x34f8('0x3b')][0xe],_0x1a2a2e[_0x34f8('0x3b')][0x3],_0x1a2a2e[_0x34f8('0x3b')][0x7],_0x1a2a2e[_0x34f8('0x3b')][0xb],_0x1a2a2e[_0x34f8('0x3b')][0xf]),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x108')][_0x34f8('0x114')]=_0x1ade82;if(_0x4bd253[_0x34f8('0xa9')]==![]&&_0x4bd253[_0x34f8('0xcd')]==![]){if(_0x33e3a8[_0x11c871][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){var _0x215a9a=0x1;_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x216')]['value']=_0x215a9a;}_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x3a')]['value']=_0x1a2a2e['m_env_map_shift_x'],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd0')][_0x34f8('0x114')]=_0x1a2a2e['m_env_map_shift_y'];}else _0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xa4')][_0x34f8('0x114')]=Math[_0x34f8('0x5e')](0.55,_0x1a2a2e[_0x34f8('0x1b2')]),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x12d')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x1b0')],_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x17b')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x1a2a2e[_0x34f8('0x76')][0x0],_0x1a2a2e[_0x34f8('0x76')][0x1],_0x1a2a2e[_0x34f8('0x76')][0x2]),_0x4bd253[_0x34f8('0x20')]['uniforms']['colorRatio1'][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x1a2a2e['m_color_ratio_for_hand'][0x3],_0x1a2a2e['m_color_ratio_for_hand'][0x4],_0x1a2a2e[_0x34f8('0x76')][0x5]),_0x4bd253[_0x34f8('0x20')]['uniforms'][_0x34f8('0x150')]['value']=new _three[(_0x34f8('0x46'))](_0x1a2a2e[_0x34f8('0x76')][0x6],_0x1a2a2e[_0x34f8('0x76')][0x7],_0x1a2a2e[_0x34f8('0x76')][0x8]),_0x4bd253['material'][_0x34f8('0x238')][_0x34f8('0x130')]['value']=new _three[(_0x34f8('0x46'))](_0x1a2a2e[_0x34f8('0x76')][0x9],_0x1a2a2e[_0x34f8('0x76')][0xa],_0x1a2a2e[_0x34f8('0x76')][0xb]),_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x119')]['value']=new _three[(_0x34f8('0x156'))](_0x1a2a2e[_0x34f8('0x144')][0x0],_0x1a2a2e[_0x34f8('0x144')][0x1],_0x1a2a2e['m_luma_ratio_for_hand'][0x2],_0x1a2a2e['m_luma_ratio_for_hand'][0x3]);var _0x3faba4=0x1;if(_0x1a2a2e['m_is_wrist_mode'])_0x3faba4=0.95;_0x4bd253[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1f2')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x12a')]*_0x3faba4;}},this[_0x34f8('0x102')]=function(_0x58efac){if(!_0x1a2a2e['m_is_nail_mode']&&!_0x1a2a2e['m_is_wrist_mode']&&!_0x1a2a2e[_0x34f8('0x1eb')])_0x1a2a2e[_0x34f8('0xe5')]();for(var _0x562947=0x0;_0x562947<_0x1a2a2e[_0x34f8('0x159')][_0x58efac][_0x34f8('0x5c')];_0x562947++){var _0x153919=_0x1a2a2e[_0x34f8('0xd6')][_0x58efac][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x159')][_0x58efac][_0x562947]);_0x153919[_0x34f8('0x11e')]&&(_0x153919[_0x34f8('0x143')]=![]);_0x153919[_0x34f8('0x20')]['uniforms']['isRenderSilhouette'][_0x34f8('0x114')]=0x1;if(_0x1a2a2e[_0x34f8('0xeb')])_0x153919[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=0x1,_0x1a2a2e[_0x34f8('0xe5')]();else{if(_0x1a2a2e[_0x34f8('0x159')][_0x58efac][_0x562947][_0x34f8('0xc4')]('object3d_occluder_',0x0)!=0x0){_0x153919[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=0x1;var _0x4529be=_0x58efac,_0x5108a1=!!_0x153919[_0x34f8('0x74')]?_0x153919[_0x34f8('0x74')]:0x0,_0x4c00c0=_0x4529be*_0x1a2a2e[_0x34f8('0x189')]+_0x5108a1*0xc,_0x4be677=_0x4529be*_0x1a2a2e[_0x34f8('0x166')]+_0x5108a1*0x10;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e[_0x34f8('0x131')][_0x34f8('0x87')](_0x4c00c0,_0x4c00c0+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x35')][_0x34f8('0x87')](_0x4be677,_0x4be677+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x4529be*0x9,_0x4529be*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}else{_0x153919['material'][_0x34f8('0xe8')]=_three[_0x34f8('0xb9')],_0x153919[_0x34f8('0x20')][_0x34f8('0x1cd')]=_three['OneMinusSrcAlphaFactor'],_0x153919[_0x34f8('0x20')][_0x34f8('0x238')]['silhouetteChannel'][_0x34f8('0x114')]=0x2;var _0x2cf9cb=_0x58efac;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e[_0x34f8('0x22f')][_0x34f8('0x87')](_0x2cf9cb*0xc,_0x2cf9cb*0xc+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x231')][_0x34f8('0x87')](_0x2cf9cb*0x10,_0x2cf9cb*0x10+0x10),_0x1a2a2e['m_project_matrix']=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x2cf9cb*0x9,_0x2cf9cb*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}}var _0x372642=new _three['Matrix4']();_0x372642[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x125')][0x0],_0x1a2a2e[_0x34f8('0x125')][0x4],_0x1a2a2e[_0x34f8('0x125')][0x8],_0x1a2a2e[_0x34f8('0x125')][0xc],_0x1a2a2e[_0x34f8('0x125')][0x1],_0x1a2a2e[_0x34f8('0x125')][0x5],_0x1a2a2e[_0x34f8('0x125')][0x9],_0x1a2a2e[_0x34f8('0x125')][0xd],_0x1a2a2e[_0x34f8('0x125')][0x2],_0x1a2a2e[_0x34f8('0x125')][0x6],_0x1a2a2e['m_filter_transform_matrix'][0xa],_0x1a2a2e['m_filter_transform_matrix'][0xe],_0x1a2a2e[_0x34f8('0x125')][0x3],_0x1a2a2e[_0x34f8('0x125')][0x7],_0x1a2a2e[_0x34f8('0x125')][0xb],_0x1a2a2e[_0x34f8('0x125')][0xf]),_0x153919['material']['uniforms'][_0x34f8('0x15a')][_0x34f8('0x114')]=_0x372642;var _0x4ffbdf=new _three[(_0x34f8('0xf2'))]();_0x4ffbdf[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x19')][0x0],_0x1a2a2e[_0x34f8('0x19')][0x4],_0x1a2a2e[_0x34f8('0x19')][0x8],_0x1a2a2e[_0x34f8('0x19')][0xc],_0x1a2a2e[_0x34f8('0x19')][0x1],_0x1a2a2e[_0x34f8('0x19')][0x5],_0x1a2a2e[_0x34f8('0x19')][0x9],_0x1a2a2e[_0x34f8('0x19')][0xd],_0x1a2a2e[_0x34f8('0x19')][0x2],_0x1a2a2e[_0x34f8('0x19')][0x6],_0x1a2a2e[_0x34f8('0x19')][0xa],_0x1a2a2e[_0x34f8('0x19')][0xe],_0x1a2a2e[_0x34f8('0x19')][0x3],_0x1a2a2e[_0x34f8('0x19')][0x7],_0x1a2a2e[_0x34f8('0x19')][0xb],_0x1a2a2e[_0x34f8('0x19')][0xf]),_0x153919[_0x34f8('0x20')][_0x34f8('0x238')]['normalTransformMatrix'][_0x34f8('0x114')]=_0x4ffbdf;var _0x225a08=new _three['Matrix4']();_0x225a08[_0x34f8('0xee')](_0x1a2a2e['m_filter_project_matrix'][0x0],_0x1a2a2e[_0x34f8('0x3b')][0x4],_0x1a2a2e[_0x34f8('0x3b')][0x8],_0x1a2a2e[_0x34f8('0x3b')][0xc],_0x1a2a2e[_0x34f8('0x3b')][0x1],_0x1a2a2e[_0x34f8('0x3b')][0x5],_0x1a2a2e[_0x34f8('0x3b')][0x9],_0x1a2a2e[_0x34f8('0x3b')][0xd],_0x1a2a2e[_0x34f8('0x3b')][0x2],_0x1a2a2e[_0x34f8('0x3b')][0x6],_0x1a2a2e[_0x34f8('0x3b')][0xa],_0x1a2a2e[_0x34f8('0x3b')][0xe],_0x1a2a2e['m_filter_project_matrix'][0x3],_0x1a2a2e[_0x34f8('0x3b')][0x7],_0x1a2a2e[_0x34f8('0x3b')][0xb],_0x1a2a2e[_0x34f8('0x3b')][0xf]),_0x153919[_0x34f8('0x20')]['uniforms'][_0x34f8('0x108')][_0x34f8('0x114')]=_0x225a08;if(_0x153919[_0x34f8('0xa9')]==![]&&_0x153919[_0x34f8('0xcd')]==![]){if(_0x1a2a2e[_0x34f8('0x159')][_0x58efac][_0x562947][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){var _0x2d488b=0x1;_0x153919[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x216')][_0x34f8('0x114')]=_0x2d488b;}_0x153919[_0x34f8('0x20')]['uniforms'][_0x34f8('0x3a')][_0x34f8('0x114')]=_0x1a2a2e['m_env_map_shift_x'],_0x153919[_0x34f8('0x20')][_0x34f8('0x238')]['environmentShiftY']['value']=_0x1a2a2e[_0x34f8('0xf0')];}}},this[_0x34f8('0x28')]=function(_0xcf63ab){if(!_0x1a2a2e[_0x34f8('0x96')]&&!_0x1a2a2e[_0x34f8('0x17c')]&&!_0x1a2a2e[_0x34f8('0x1eb')])_0x1a2a2e[_0x34f8('0xe5')]();for(var _0x162b38=0x0;_0x162b38<_0x1a2a2e[_0x34f8('0x159')][_0xcf63ab][_0x34f8('0x5c')];_0x162b38++){var _0x5288d6=_0x1a2a2e[_0x34f8('0xd6')][_0xcf63ab]['getObjectByName'](_0x1a2a2e['mesh_name_array'][_0xcf63ab][_0x162b38]);_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')]['isRenderSilhouette'][_0x34f8('0x114')]=0x1,_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x8f')][_0x34f8('0x114')]=0x1;if(_0x1a2a2e[_0x34f8('0x159')][_0xcf63ab][_0x162b38][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){_0x5288d6['material'][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=0x0;var _0x4d010f=_0xcf63ab,_0x3a64ce=!!_0x5288d6['matrix_index']?_0x5288d6['matrix_index']:0x0,_0x3cd05c=_0x4d010f*_0x1a2a2e[_0x34f8('0x189')]+_0x3a64ce*0xc,_0x41eaab=_0x4d010f*_0x1a2a2e[_0x34f8('0x166')]+_0x3a64ce*0x10;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e['m_hand_transform_matrices']['slice'](_0x3cd05c,_0x3cd05c+0xc),_0x1a2a2e['m_transform_matrix'][0x7]+=_0x1a2a2e[_0x34f8('0x9')]*_0x1a2a2e[_0x34f8('0x185')],_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x35')][_0x34f8('0x87')](_0x41eaab,_0x41eaab+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e['m_hand_camera_matrices'][_0x34f8('0x87')](_0x4d010f*0x9,_0x4d010f*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}else{_0x5288d6[_0x34f8('0x20')][_0x34f8('0xe8')]=_three['OneMinusSrcAlphaFactor'],_0x5288d6[_0x34f8('0x20')]['blendDst']=_three[_0x34f8('0x1f9')],_0x5288d6['material'][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=0x2;var _0x181ac7=_0xcf63ab;_0x1a2a2e['m_transform_matrix']=_0x1a2a2e[_0x34f8('0x22f')]['slice'](_0x181ac7*0xc,_0x181ac7*0xc+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x231')][_0x34f8('0x87')](_0x181ac7*0x10,_0x181ac7*0x10+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x181ac7*0x9,_0x181ac7*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}var _0x22ff34=new _three['Matrix4']();_0x22ff34[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x125')][0x0],_0x1a2a2e[_0x34f8('0x125')][0x4],_0x1a2a2e[_0x34f8('0x125')][0x8],_0x1a2a2e['m_filter_transform_matrix'][0xc],_0x1a2a2e[_0x34f8('0x125')][0x1],_0x1a2a2e[_0x34f8('0x125')][0x5],_0x1a2a2e[_0x34f8('0x125')][0x9],_0x1a2a2e[_0x34f8('0x125')][0xd],_0x1a2a2e['m_filter_transform_matrix'][0x2],_0x1a2a2e[_0x34f8('0x125')][0x6],_0x1a2a2e[_0x34f8('0x125')][0xa],_0x1a2a2e['m_filter_transform_matrix'][0xe],_0x1a2a2e[_0x34f8('0x125')][0x3],_0x1a2a2e[_0x34f8('0x125')][0x7],_0x1a2a2e['m_filter_transform_matrix'][0xb],_0x1a2a2e['m_filter_transform_matrix'][0xf]),_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x15a')][_0x34f8('0x114')]=_0x22ff34;var _0xaf4a15=new _three[(_0x34f8('0xf2'))]();_0xaf4a15[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x19')][0x0],_0x1a2a2e['m_filter_normal_matrix'][0x4],_0x1a2a2e[_0x34f8('0x19')][0x8],_0x1a2a2e[_0x34f8('0x19')][0xc],_0x1a2a2e['m_filter_normal_matrix'][0x1],_0x1a2a2e[_0x34f8('0x19')][0x5],_0x1a2a2e[_0x34f8('0x19')][0x9],_0x1a2a2e[_0x34f8('0x19')][0xd],_0x1a2a2e[_0x34f8('0x19')][0x2],_0x1a2a2e[_0x34f8('0x19')][0x6],_0x1a2a2e[_0x34f8('0x19')][0xa],_0x1a2a2e[_0x34f8('0x19')][0xe],_0x1a2a2e['m_filter_normal_matrix'][0x3],_0x1a2a2e[_0x34f8('0x19')][0x7],_0x1a2a2e['m_filter_normal_matrix'][0xb],_0x1a2a2e[_0x34f8('0x19')][0xf]),_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x124')]['value']=_0xaf4a15;var _0x287429=new _three[(_0x34f8('0xf2'))]();_0x287429[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x3b')][0x0],_0x1a2a2e[_0x34f8('0x3b')][0x4],_0x1a2a2e[_0x34f8('0x3b')][0x8],_0x1a2a2e[_0x34f8('0x3b')][0xc],_0x1a2a2e[_0x34f8('0x3b')][0x1],_0x1a2a2e[_0x34f8('0x3b')][0x5],_0x1a2a2e[_0x34f8('0x3b')][0x9],_0x1a2a2e[_0x34f8('0x3b')][0xd],_0x1a2a2e[_0x34f8('0x3b')][0x2],_0x1a2a2e[_0x34f8('0x3b')][0x6],_0x1a2a2e[_0x34f8('0x3b')][0xa],_0x1a2a2e[_0x34f8('0x3b')][0xe],_0x1a2a2e[_0x34f8('0x3b')][0x3],_0x1a2a2e[_0x34f8('0x3b')][0x7],_0x1a2a2e[_0x34f8('0x3b')][0xb],_0x1a2a2e[_0x34f8('0x3b')][0xf]),_0x5288d6['material']['uniforms'][_0x34f8('0x108')][_0x34f8('0x114')]=_0x287429;if(_0x5288d6[_0x34f8('0xa9')]==![]&&_0x5288d6['is_gem']==![]){if(_0x1a2a2e[_0x34f8('0x159')][_0xcf63ab][_0x162b38][_0x34f8('0xc4')]('object3d_occluder_',0x0)!=0x0){var _0x539bc4=0x1;_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x216')][_0x34f8('0x114')]=_0x539bc4;}_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x3a')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x2d')],_0x5288d6[_0x34f8('0x20')][_0x34f8('0x238')]['environmentShiftY'][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0xf0')];}}},this[_0x34f8('0x10b')]=function(_0xe29cc1){if(!_0x1a2a2e['m_is_nail_mode']&&!_0x1a2a2e[_0x34f8('0x17c')]&&!_0x1a2a2e[_0x34f8('0x1eb')])_0x1a2a2e[_0x34f8('0xe5')]();for(var _0x39d439=0x0;_0x39d439<_0x1a2a2e[_0x34f8('0x159')][_0xe29cc1][_0x34f8('0x5c')];_0x39d439++){var _0x33139d=_0x1a2a2e[_0x34f8('0xd6')][_0xe29cc1][_0x34f8('0xf')](_0x1a2a2e['mesh_name_array'][_0xe29cc1][_0x39d439]);_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xc5')]['value']=0x1;if(_0x1a2a2e[_0x34f8('0x159')][_0xe29cc1][_0x39d439][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)!=0x0){_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd8')]['value']=0x2;var _0x34ea53=_0xe29cc1,_0x40776b=!!_0x33139d[_0x34f8('0x74')]?_0x33139d[_0x34f8('0x74')]:0x0,_0x16031d=_0x34ea53*_0x1a2a2e[_0x34f8('0x189')]+_0x40776b*0xc,_0x53cf1a=_0x34ea53*_0x1a2a2e[_0x34f8('0x166')]+_0x40776b*0x10;_0x1a2a2e['m_transform_matrix']=_0x1a2a2e[_0x34f8('0x131')][_0x34f8('0x87')](_0x16031d,_0x16031d+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x35')][_0x34f8('0x87')](_0x53cf1a,_0x53cf1a+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x34ea53*0x9,_0x34ea53*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}else{_0x33139d[_0x34f8('0x20')][_0x34f8('0xe8')]=_three['SrcAlphaFactor'],_0x33139d['material'][_0x34f8('0x1cd')]=_three[_0x34f8('0x1c8')],_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=0x0;var _0x1cdff0=_0xe29cc1;_0x1a2a2e[_0x34f8('0xb7')]=_0x1a2a2e['m_occluder_transform_matrices'][_0x34f8('0x87')](_0x1cdff0*0xc,_0x1cdff0*0xc+0xc),_0x1a2a2e[_0x34f8('0x5d')]=_0x1a2a2e[_0x34f8('0x231')][_0x34f8('0x87')](_0x1cdff0*0x10,_0x1cdff0*0x10+0x10),_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e[_0x34f8('0x1c0')][_0x34f8('0x87')](_0x1cdff0*0x9,_0x1cdff0*0x9+0x9),_0x1a2a2e[_0x34f8('0xe5')]();}var _0x3ba731=new _three[(_0x34f8('0xf2'))]();_0x3ba731[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x125')][0x0],_0x1a2a2e['m_filter_transform_matrix'][0x4],_0x1a2a2e[_0x34f8('0x125')][0x8],_0x1a2a2e[_0x34f8('0x125')][0xc],_0x1a2a2e[_0x34f8('0x125')][0x1],_0x1a2a2e['m_filter_transform_matrix'][0x5],_0x1a2a2e[_0x34f8('0x125')][0x9],_0x1a2a2e[_0x34f8('0x125')][0xd],_0x1a2a2e[_0x34f8('0x125')][0x2],_0x1a2a2e[_0x34f8('0x125')][0x6],_0x1a2a2e[_0x34f8('0x125')][0xa],_0x1a2a2e[_0x34f8('0x125')][0xe],_0x1a2a2e[_0x34f8('0x125')][0x3],_0x1a2a2e[_0x34f8('0x125')][0x7],_0x1a2a2e[_0x34f8('0x125')][0xb],_0x1a2a2e[_0x34f8('0x125')][0xf]),_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x15a')][_0x34f8('0x114')]=_0x3ba731;var _0x8ea46d=new _three[(_0x34f8('0xf2'))]();_0x8ea46d[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x19')][0x0],_0x1a2a2e[_0x34f8('0x19')][0x4],_0x1a2a2e[_0x34f8('0x19')][0x8],_0x1a2a2e[_0x34f8('0x19')][0xc],_0x1a2a2e['m_filter_normal_matrix'][0x1],_0x1a2a2e[_0x34f8('0x19')][0x5],_0x1a2a2e[_0x34f8('0x19')][0x9],_0x1a2a2e[_0x34f8('0x19')][0xd],_0x1a2a2e[_0x34f8('0x19')][0x2],_0x1a2a2e[_0x34f8('0x19')][0x6],_0x1a2a2e[_0x34f8('0x19')][0xa],_0x1a2a2e[_0x34f8('0x19')][0xe],_0x1a2a2e[_0x34f8('0x19')][0x3],_0x1a2a2e[_0x34f8('0x19')][0x7],_0x1a2a2e['m_filter_normal_matrix'][0xb],_0x1a2a2e[_0x34f8('0x19')][0xf]),_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x124')]['value']=_0x8ea46d;var _0x3ec38b=new _three[(_0x34f8('0xf2'))]();_0x3ec38b[_0x34f8('0xee')](_0x1a2a2e[_0x34f8('0x3b')][0x0],_0x1a2a2e['m_filter_project_matrix'][0x4],_0x1a2a2e[_0x34f8('0x3b')][0x8],_0x1a2a2e[_0x34f8('0x3b')][0xc],_0x1a2a2e[_0x34f8('0x3b')][0x1],_0x1a2a2e[_0x34f8('0x3b')][0x5],_0x1a2a2e[_0x34f8('0x3b')][0x9],_0x1a2a2e[_0x34f8('0x3b')][0xd],_0x1a2a2e[_0x34f8('0x3b')][0x2],_0x1a2a2e[_0x34f8('0x3b')][0x6],_0x1a2a2e[_0x34f8('0x3b')][0xa],_0x1a2a2e[_0x34f8('0x3b')][0xe],_0x1a2a2e[_0x34f8('0x3b')][0x3],_0x1a2a2e[_0x34f8('0x3b')][0x7],_0x1a2a2e['m_filter_project_matrix'][0xb],_0x1a2a2e['m_filter_project_matrix'][0xf]),_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')]['projectMatrix'][_0x34f8('0x114')]=_0x3ec38b;if(_0x33139d[_0x34f8('0xa9')]==![]&&_0x33139d[_0x34f8('0xcd')]==![]){if(_0x1a2a2e[_0x34f8('0x159')][_0xe29cc1][_0x39d439]['lastIndexOf'](_0x34f8('0x1f3'),0x0)!=0x0){var _0x2de73f=0x1;_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')]['isLightingAngleClipping'][_0x34f8('0x114')]=_0x2de73f;}_0x33139d[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x3a')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x2d')],_0x33139d[_0x34f8('0x20')]['uniforms']['environmentShiftY'][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0xf0')];}}},this[_0x34f8('0x1c6')]=function(_0x135ada){for(var _0x1e76ee=0x0;_0x1e76ee<_0x1a2a2e[_0x34f8('0x159')][_0x135ada][_0x34f8('0x5c')];_0x1e76ee++){var _0xfef4e3=_0x1a2a2e[_0x34f8('0xd6')][_0x135ada]['getObjectByName'](_0x1a2a2e['mesh_name_array'][_0x135ada][_0x1e76ee]);_0xfef4e3[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xc5')][_0x34f8('0x114')]=0x0,_0xfef4e3[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xd8')][_0x34f8('0x114')]=-0x1,_0xfef4e3[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x8f')][_0x34f8('0x114')]=_0xfef4e3[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x37')],_0xfef4e3[_0x34f8('0x143')]=!![],_0x1a2a2e[_0x34f8('0x159')][_0x135ada][_0x1e76ee][_0x34f8('0xc4')](_0x34f8('0x1f3'),0x0)==0x0&&(_0xfef4e3[_0x34f8('0x20')][_0x34f8('0xe8')]=_three[_0x34f8('0x1c8')],_0xfef4e3[_0x34f8('0x20')][_0x34f8('0x1cd')]=_three[_0x34f8('0x14e')]);}},this[_0x34f8('0x1e2')]=function(_0x40245c,_0x2dfce6,_0x3753d1,_0x4fa5dd,_0x336463,_0x194495,_0x1ec6be,_0x231ed3,_0x9df75d){var _0x429a7f=function _0x101282(){};_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=null);_0x40245c[_0x34f8('0x146')]>=0x0&&_0x40245c[_0x34f8('0x146')]<_0x1a2a2e[_0x34f8('0x14b')][_0x34f8('0x5c')]&&_0x1a2a2e[_0x34f8('0x14b')][_0x40245c[_0x34f8('0x146')]]!=null&&(_0x1a2a2e[_0x34f8('0x14b')][_0x40245c[_0x34f8('0x146')]][_0x34f8('0x1a0')](),_0x1a2a2e['m_original_nail_albedo_texture_array'][_0x40245c['nail_type_id']]=null);var _0x1146b5=_0x2dfce6[_0x34f8('0x1a9')]!=''?0x1:0x0;if(_0x1146b5>0x0){var _0x17a6fb=_0x3753d1[_0x2dfce6[_0x34f8('0x1a9')]],_0x46fb12=_0x2dfce6[_0x34f8('0x26')]!='';if(_0x46fb12){var _0x1d139e=_0x3753d1[_0x2dfce6['opa']];if(_0x1d139e['width']!=_0x17a6fb[_0x34f8('0xd')]||_0x1d139e['height']!=_0x17a6fb[_0x34f8('0x3d')])console[_0x34f8('0x52')](_0x34f8('0x1f5'),_0x1d139e[_0x34f8('0xd')],_0x1d139e[_0x34f8('0x3d')],_0x17a6fb[_0x34f8('0xd')],_0x17a6fb[_0x34f8('0x3d')]);else{var _0x1c498e=0x0;for(var _0x244e2c=0x0;_0x244e2c<_0x17a6fb[_0x34f8('0x3d')];_0x244e2c++){for(var _0xcc28f2=0x0;_0xcc28f2<_0x17a6fb[_0x34f8('0xd')];_0xcc28f2++){_0x17a6fb[_0x34f8('0x78')][_0x1c498e+0x3]=_0x1d139e[_0x34f8('0x78')][_0x1c498e],_0x1c498e+=0x4;}}}}var _0x10ca56=void 0x0;_0x2dfce6[_0x34f8('0x1a9')]in _0x1a2a2e[_0x34f8('0x6c')]?_0x10ca56=_0x1a2a2e['m_data_texture_hash_map'][_0x2dfce6[_0x34f8('0x1a9')]]:(_0x10ca56=new _three[(_0x34f8('0x218'))](_0x17a6fb['image'],_0x17a6fb[_0x34f8('0xd')],_0x17a6fb[_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0x10ca56['wrapS']=_three[_0x34f8('0x62')],_0x10ca56[_0x34f8('0x1cf')]=_three[_0x34f8('0x62')],_0x10ca56['generateMipmaps']=!![],_0x10ca56[_0x34f8('0xd7')]=_three[_0x34f8('0xdc')],_0x10ca56[_0x34f8('0x115')]=_three['LinearFilter'],_0x10ca56[_0x34f8('0x1c3')]=!![],_0x10ca56[_0x34f8('0xf5')]=_0x34f8('0x8c'),_0x10ca56['onUpdate']=_0x429a7f,_0x1a2a2e[_0x34f8('0x6c')][_0x2dfce6[_0x34f8('0x1a9')]]=_0x10ca56),_0x4fa5dd[_0x34f8('0x238')]['albedoTexture'][_0x34f8('0x114')]=_0x10ca56,_0x40245c[_0x34f8('0x146')]>=0x0&&_0x40245c[_0x34f8('0x146')]<_0x1a2a2e[_0x34f8('0x14b')][_0x34f8('0x5c')]&&(_0x1a2a2e[_0x34f8('0x14b')][_0x40245c[_0x34f8('0x146')]]=_0x10ca56);}_0x4fa5dd['uniforms'][_0x34f8('0x5f')][_0x34f8('0x114')]!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')]=null);var _0x52f889=_0x2dfce6[_0x34f8('0x1bd')]!=''?0x1:0x0;if(_0x52f889>0x0){var _0x1fa93b=_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]],_0x1bbc2f=_0x2dfce6[_0x34f8('0x9b')]!='';if(!_0x1bbc2f){var _0x122719=0x0;for(var _0x133d48=0x0;_0x133d48<_0x1fa93b[_0x34f8('0x3d')];_0x133d48++){for(var _0x1cc15a=0x0;_0x1cc15a<_0x1fa93b[_0x34f8('0xd')];_0x1cc15a++){_0x1fa93b[_0x34f8('0x78')][_0x122719+0x3]=0x0,_0x122719+=0x4;}}}else{var _0x582ba1=_0x3753d1[_0x2dfce6[_0x34f8('0x9b')]];if(_0x582ba1[_0x34f8('0xd')]!=_0x1fa93b[_0x34f8('0xd')]||_0x582ba1[_0x34f8('0x3d')]!=_0x1fa93b[_0x34f8('0x3d')])console[_0x34f8('0x52')](_0x34f8('0x16a'),_0x582ba1[_0x34f8('0xd')],_0x582ba1[_0x34f8('0x3d')],_0x1fa93b['width'],_0x1fa93b[_0x34f8('0x3d')]);else{var _0xdf9d3e=0x0;for(var _0x30bd32=0x0;_0x30bd32<_0x1fa93b[_0x34f8('0x3d')];_0x30bd32++){for(var _0x3de221=0x0;_0x3de221<_0x1fa93b[_0x34f8('0xd')];_0x3de221++){_0x1fa93b['image'][_0xdf9d3e+0x3]=_0x582ba1[_0x34f8('0x78')][_0xdf9d3e],_0xdf9d3e+=0x4;}}}}_0x9df75d&&_0x1a2a2e[_0x34f8('0x232')]['push']({'image_array':_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]][_0x34f8('0x78')],'width':_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]]['width'],'height':_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]][_0x34f8('0x3d')]});var _0x1423f6=void 0x0;_0x2dfce6[_0x34f8('0x1bd')]in _0x1a2a2e[_0x34f8('0x6c')]?_0x1423f6=_0x1a2a2e['m_data_texture_hash_map'][_0x2dfce6[_0x34f8('0x1bd')]]:(_0x1423f6=new _three[(_0x34f8('0x218'))](_0x3753d1[_0x2dfce6['orm']][_0x34f8('0x78')],_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]][_0x34f8('0xd')],_0x3753d1[_0x2dfce6[_0x34f8('0x1bd')]]['height'],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0x1423f6['wrapS']=_three[_0x34f8('0x62')],_0x1423f6[_0x34f8('0x1cf')]=_three[_0x34f8('0x62')],_0x1423f6[_0x34f8('0x154')]=!![],_0x1423f6[_0x34f8('0xd7')]=_three[_0x34f8('0xdc')],_0x1423f6[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x1423f6['needsUpdate']=!![],_0x1423f6['name']=_0x34f8('0x1bd'),_0x1423f6[_0x34f8('0x127')]=_0x429a7f,_0x1a2a2e[_0x34f8('0x6c')][_0x2dfce6['orm']]=_0x1423f6),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')]=_0x1423f6;}_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x210')]['value']!=null&&(_0x4fa5dd[_0x34f8('0x238')]['environmentTexture']['value']['dispose'](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=null);var _0xb25a97=_0x2dfce6[_0x34f8('0xed')]!=''?0x1:0x0;if(_0xb25a97>0x0){var _0x519840=void 0x0;_0x2dfce6[_0x34f8('0xed')]in _0x1a2a2e['m_data_texture_hash_map']?_0x519840=_0x1a2a2e[_0x34f8('0x6c')][_0x2dfce6['environment']]:(_0x519840=new _three[(_0x34f8('0x218'))](_0x3753d1[_0x2dfce6['environment']][_0x34f8('0x1b3')],_0x3753d1[_0x2dfce6['environment']][_0x34f8('0xd')],_0x3753d1[_0x2dfce6[_0x34f8('0xed')]][_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0x1a2a2e[_0x34f8('0x6c')][_0x2dfce6[_0x34f8('0xed')]]=_0x519840),_0x519840['minFilter']=_three[_0x34f8('0xf4')],_0x519840[_0x34f8('0x115')]=_three['LinearFilter'],_0x519840[_0x34f8('0x1c3')]=!![],_0x519840[_0x34f8('0xf5')]=_0x34f8('0xd1'),_0x519840[_0x34f8('0x127')]=_0x429a7f,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=_0x519840,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x10c')][_0x34f8('0x114')]=_0x519840[_0x34f8('0x78')][_0x34f8('0xd')],_0x4fa5dd['uniforms'][_0x34f8('0x192')][_0x34f8('0x114')]=!![];}_0x4fa5dd['uniforms'][_0x34f8('0x95')][_0x34f8('0x114')]!=null&&(_0x4fa5dd[_0x34f8('0x238')]['brdfLutTexture'][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x95')][_0x34f8('0x114')]=null);var _0xc31263=0x1;if(_0xc31263>0x0&&_0x40245c[_0x34f8('0xcd')]==0x0){var _0xec423c=void 0x0;if(_0x34f8('0x71')in _0x1a2a2e[_0x34f8('0x6c')])_0xec423c=_0x1a2a2e[_0x34f8('0x6c')][_0x34f8('0x71')];else{var _0x49bc7d=new Uint8Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xa7')][_0x34f8('0x23d')],_0x40245c['p_brdf_lut'],_0x40245c[_0x34f8('0x200')]*_0x40245c[_0x34f8('0x101')]*0x4);_0xec423c=new _three[(_0x34f8('0x218'))](_0x49bc7d,_0x40245c[_0x34f8('0x200')],_0x40245c[_0x34f8('0x101')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0xec423c['minFilter']=_three[_0x34f8('0xf4')],_0xec423c[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0xec423c[_0x34f8('0x1c3')]=!![],_0xec423c[_0x34f8('0xf5')]=_0x34f8('0x71'),_0xec423c[_0x34f8('0x127')]=_0x429a7f,_0x1a2a2e[_0x34f8('0x6c')][_0x34f8('0x71')]=_0xec423c;}_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x95')][_0x34f8('0x114')]=_0xec423c;}_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')]!=null&&(_0x4fa5dd[_0x34f8('0x238')]['normalMapTexture'][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd['uniforms'][_0x34f8('0x221')][_0x34f8('0x114')]=null);var _0x1c08cf=_0x2dfce6[_0x34f8('0x149')]!=''?0x1:0x0;if(_0x1c08cf>0x0){var _0x3c9f32=void 0x0;if(_0x2dfce6['normal_map']in _0x1a2a2e[_0x34f8('0x6c')])_0x3c9f32=_0x1a2a2e['m_data_texture_hash_map'][_0x2dfce6[_0x34f8('0x149')]];else{var _0x48de51=_0x40245c[_0x34f8('0x92')]>0x0?_0x3753d1[_0x2dfce6[_0x34f8('0x149')]][_0x34f8('0x1b3')]:_0x3753d1[_0x2dfce6[_0x34f8('0x149')]][_0x34f8('0x78')];_0x3c9f32=new _three[(_0x34f8('0x218'))](_0x48de51,_0x3753d1[_0x2dfce6['normal_map']][_0x34f8('0xd')],_0x3753d1[_0x2dfce6[_0x34f8('0x149')]][_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0x3c9f32[_0x34f8('0xb3')]=_three[_0x34f8('0x62')],_0x3c9f32[_0x34f8('0x1cf')]=_three['MirroredRepeatWrapping'],_0x3c9f32[_0x34f8('0x154')]=!![],_0x3c9f32['minFilter']=_three['LinearMipMapLinearFilter'],_0x3c9f32[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x3c9f32['needsUpdate']=!![],_0x3c9f32[_0x34f8('0xf5')]=_0x34f8('0x1c'),_0x3c9f32[_0x34f8('0x127')]=_0x429a7f,_0x1a2a2e['m_data_texture_hash_map'][_0x2dfce6['normal_map']]=_0x3c9f32;}_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')]=_0x3c9f32;}_0x1a2a2e[_0x34f8('0x15c')]={'image':_0x40245c[_0x34f8('0x9a')],'width':_0x40245c[_0x34f8('0x1ca')],'height':_0x40245c[_0x34f8('0xe4')]},_0x1a2a2e[_0x34f8('0x14c')]={'image':_0x40245c[_0x34f8('0x235')],'width':_0x40245c[_0x34f8('0x89')],'height':_0x40245c[_0x34f8('0xa0')]};_0x40245c[_0x34f8('0xcd')]&&(_0x4fa5dd['uniforms'][_0x34f8('0x10d')][_0x34f8('0x114')]!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')]['albedoTexture']['value']=null),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x5f')]['value']!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')]['ormTexture'][_0x34f8('0x114')]=null),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')]['value']!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')]=null),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x13e')][_0x34f8('0x114')]!=null&&(_0x4fa5dd['uniforms']['opaquePosTexture']['value'][_0x34f8('0x1a0')](),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x13e')]['value']=null),_0x194495!=null&&_0x336463!=null&&(_0x4fa5dd['uniforms'][_0x34f8('0x10d')]['value']=_0x194495[_0x34f8('0x1a3')],_0x4fa5dd[_0x34f8('0x238')]['ormTexture'][_0x34f8('0x114')]=_0x336463[_0x34f8('0x1a3')]),_0x1ec6be!=null&&_0x231ed3!=null&&(_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')]=_0x1ec6be[_0x34f8('0x1a3')],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x13e')]['value']=_0x231ed3[_0x34f8('0x1a3')]));_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x1')][_0x34f8('0x114')]=_0x1146b5,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0xe3')]['value']=_0x52f889,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x50')][_0x34f8('0x114')]=_0xb25a97,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x48')]['value']=_0xc31263,_0x4fa5dd['uniforms'][_0x34f8('0xc8')][_0x34f8('0x114')]=_0x1c08cf,_0x4fa5dd['uniforms'][_0x34f8('0xad')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0xad')],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0xea')][_0x34f8('0x114')]=_0x40245c['fresnel_intensity'],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x4')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0x112')]*3.14159/0xb4,_0x4fa5dd[_0x34f8('0x238')]['vertOrien'][_0x34f8('0x114')]=_0x40245c[_0x34f8('0x12e')]*3.14159/0xb4,_0x4fa5dd[_0x34f8('0x238')]['vertOrienSin'][_0x34f8('0x114')]=Math[_0x34f8('0x103')](_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x158')][_0x34f8('0x114')]),_0x4fa5dd['uniforms'][_0x34f8('0x1f4')][_0x34f8('0x114')]=Math[_0x34f8('0x213')](_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x158')][_0x34f8('0x114')]),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x15')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0x16c')]?0x1:0x0;var _0xba855=_0x40245c[_0x34f8('0xcd')]?0x1:0x0;_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x8f')][_0x34f8('0x114')]=_0xba855||_0x40245c[_0x34f8('0xdf')]>=0x0||_0x40245c[_0x34f8('0xba')]>=0x0?0.5:0x1,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x37')]=_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x8f')][_0x34f8('0x114')],_0x4fa5dd['uniforms'][_0x34f8('0xf1')]['value']=_0xba855,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x3e')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0x16f')]?0x1:0x0,_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x106')]['value']=new _three[(_0x34f8('0x46'))](_0x40245c[_0x34f8('0x104')]['x'],_0x40245c[_0x34f8('0x104')]['y'],_0x40245c[_0x34f8('0x104')]['z']),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0xf8')][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x40245c[_0x34f8('0x73')]['x'],_0x40245c[_0x34f8('0x73')]['y'],_0x40245c[_0x34f8('0x73')]['z']),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x22d')]['value']=new _three[(_0x34f8('0x46'))](_0x40245c[_0x34f8('0x7')]['x'],_0x40245c[_0x34f8('0x7')]['y'],_0x40245c[_0x34f8('0x7')]['z']),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x194')][_0x34f8('0x114')]=_0x40245c['gem_absorption'],_0x4fa5dd[_0x34f8('0x238')]['gemBounces']['value']=_0x40245c['gem_bounces'],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x187')][_0x34f8('0x114')]=new _three['Vector3'](_0x40245c[_0x34f8('0x223')]['x'],_0x40245c['gem_color']['y'],_0x40245c[_0x34f8('0x223')]['z']),_0x4fa5dd['uniforms'][_0x34f8('0x116')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0xbb')],_0x4fa5dd['uniforms'][_0x34f8('0xb5')][_0x34f8('0x114')]=_0x40245c['gem_ior'],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x117')][_0x34f8('0x114')]=_0x40245c[_0x34f8('0x92')],_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x19a')]['value']=_0x40245c['inverse_tone_mapping']>0x0?0x1:0x0;var _0x46ee3f=new _three[(_0x34f8('0x79'))]();_0x46ee3f[_0x34f8('0xee')](_0x40245c['small_gem_rotation_mat'][0x0],_0x40245c[_0x34f8('0x2a')][0x3],_0x40245c[_0x34f8('0x2a')][0x6],_0x40245c[_0x34f8('0x2a')][0x1],_0x40245c[_0x34f8('0x2a')][0x4],_0x40245c[_0x34f8('0x2a')][0x7],_0x40245c[_0x34f8('0x2a')][0x2],_0x40245c[_0x34f8('0x2a')][0x5],_0x40245c[_0x34f8('0x2a')][0x8]),_0x4fa5dd[_0x34f8('0x238')][_0x34f8('0x198')][_0x34f8('0x114')]=_0x46ee3f;},this[_0x34f8('0x8')]=function(_0x4fbd0a,_0x268af5,_0x44146c,_0x311366){_0x311366[_0x34f8('0x238')][_0x34f8('0x54')]['value']=new _three[(_0x34f8('0x46'))](_0x4fbd0a[_0x34f8('0xff')][_0x34f8('0x190')][0x0],_0x4fbd0a[_0x34f8('0xff')][_0x34f8('0x190')][0x1],_0x4fbd0a[_0x34f8('0xff')][_0x34f8('0x190')][0x2]),_0x311366[_0x34f8('0x238')][_0x34f8('0x109')]['value']=new _three[(_0x34f8('0x46'))](_0x4fbd0a[_0x34f8('0x105')][_0x34f8('0x190')][0x0],_0x4fbd0a[_0x34f8('0x105')]['color'][0x1],_0x4fbd0a[_0x34f8('0x105')][_0x34f8('0x190')][0x2]),_0x311366[_0x34f8('0x238')][_0x34f8('0x6a')][_0x34f8('0x114')]=new _three['Vector3'](_0x4fbd0a[_0x34f8('0x1a6')][_0x34f8('0x190')][0x0],_0x4fbd0a[_0x34f8('0x1a6')][_0x34f8('0x190')][0x1],_0x4fbd0a[_0x34f8('0x1a6')][_0x34f8('0x190')][0x2]),_0x311366['uniforms'][_0x34f8('0x123')]['value']=new _three[(_0x34f8('0x46'))](_0x4fbd0a[_0x34f8('0x1fd')][0x0],_0x4fbd0a[_0x34f8('0x1fd')][0x1],_0x4fbd0a[_0x34f8('0x1fd')][0x2]);_0x311366['uniforms'][_0x34f8('0x94')][_0x34f8('0x114')]!=null&&(_0x311366[_0x34f8('0x238')]['ambientTexture'][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x311366[_0x34f8('0x238')][_0x34f8('0x94')][_0x34f8('0x114')]=null);var _0x5be403=_0x268af5[_0x34f8('0x1e1')]!=''?0x1:0x0;if(_0x5be403>0x0){var _0x544439=new _three['DataTexture'](_0x44146c[_0x268af5[_0x34f8('0x1e1')]][_0x34f8('0x78')],_0x44146c[_0x268af5['ambient']][_0x34f8('0xd')],_0x44146c[_0x268af5[_0x34f8('0x1e1')]][_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x544439[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x544439['magFilter']=_three[_0x34f8('0xf4')],_0x544439['needsUpdate']=!![],_0x311366[_0x34f8('0x238')][_0x34f8('0x94')]['value']=_0x544439;}_0x311366[_0x34f8('0x238')][_0x34f8('0x121')]['value']!=null&&(_0x311366[_0x34f8('0x238')][_0x34f8('0x121')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x311366[_0x34f8('0x238')][_0x34f8('0x121')][_0x34f8('0x114')]=null);var _0x2e5a2c=_0x268af5[_0x34f8('0x1a9')]!=''?0x1:0x0;if(_0x2e5a2c>0x0){var _0x656597=new _three[(_0x34f8('0x218'))](_0x44146c[_0x268af5[_0x34f8('0x1a9')]][_0x34f8('0x78')],_0x44146c[_0x268af5[_0x34f8('0x1a9')]][_0x34f8('0xd')],_0x44146c[_0x268af5['diffuse']]['height'],_three['RGBAFormat'],_three[_0x34f8('0xc7')]);_0x656597['minFilter']=_three[_0x34f8('0xf4')],_0x656597[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x656597[_0x34f8('0x1c3')]=!![],_0x1a2a2e[_0x34f8('0xb2')]=_0x656597,_0x311366['uniforms'][_0x34f8('0x121')][_0x34f8('0x114')]=_0x656597;}_0x311366[_0x34f8('0x238')]['specularTexture'][_0x34f8('0x114')]!=null&&(_0x311366[_0x34f8('0x238')][_0x34f8('0x1d7')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x311366['uniforms'][_0x34f8('0x1d7')]['value']=null);var _0x1ebc8a=_0x268af5[_0x34f8('0x68')]!=''?0x1:0x0;if(_0x1ebc8a>0x0){var _0x18330e=new _three[(_0x34f8('0x218'))](_0x44146c[_0x268af5[_0x34f8('0x68')]][_0x34f8('0x78')],_0x44146c[_0x268af5[_0x34f8('0x68')]][_0x34f8('0xd')],_0x44146c[_0x268af5[_0x34f8('0x68')]][_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x18330e['minFilter']=_three[_0x34f8('0xf4')],_0x18330e[_0x34f8('0x115')]=_three['LinearFilter'],_0x18330e[_0x34f8('0x1c3')]=!![],_0x311366['uniforms'][_0x34f8('0x1d7')][_0x34f8('0x114')]=_0x18330e;}_0x311366[_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]!=null&&(_0x311366[_0x34f8('0x238')][_0x34f8('0x210')]['value'][_0x34f8('0x1a0')](),_0x311366[_0x34f8('0x238')]['environmentTexture']['value']=null);var _0x1e117a=_0x268af5[_0x34f8('0xed')]!=''?0x1:0x0;if(_0x1e117a>0x0){var _0x29d1da=new _three['DataTexture'](_0x44146c[_0x268af5[_0x34f8('0xed')]][_0x34f8('0x78')],_0x44146c[_0x268af5[_0x34f8('0xed')]][_0x34f8('0xd')],_0x44146c[_0x268af5[_0x34f8('0xed')]][_0x34f8('0x3d')],_three['RGBAFormat'],_three[_0x34f8('0xc7')]);_0x29d1da[_0x34f8('0x154')]=!![],_0x29d1da[_0x34f8('0xd7')]=_three[_0x34f8('0xdc')],_0x29d1da[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x29d1da[_0x34f8('0x1c3')]=!![],_0x311366['uniforms']['environmentTexture'][_0x34f8('0x114')]=_0x29d1da;}_0x311366[_0x34f8('0x238')][_0x34f8('0x64')][_0x34f8('0x114')]!=null&&(_0x311366[_0x34f8('0x238')][_0x34f8('0x64')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x311366[_0x34f8('0x238')][_0x34f8('0x64')][_0x34f8('0x114')]=null);var _0x30e76b=_0x268af5['environment_weight']!=''?0x1:0x0;if(_0x30e76b>0x0){var _0x1abe53=new _three[(_0x34f8('0x218'))](_0x44146c[_0x268af5[_0x34f8('0x215')]][_0x34f8('0x78')],_0x44146c[_0x268af5[_0x34f8('0x215')]][_0x34f8('0xd')],_0x44146c[_0x268af5['environment_weight']][_0x34f8('0x3d')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x1abe53['minFilter']=_three[_0x34f8('0xf4')],_0x1abe53[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x1abe53[_0x34f8('0x1c3')]=!![],_0x311366[_0x34f8('0x238')][_0x34f8('0x64')]['value']=_0x1abe53;}_0x311366['uniforms'][_0x34f8('0x221')][_0x34f8('0x114')]!=null&&(_0x311366['uniforms']['normalMapTexture'][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x311366[_0x34f8('0x238')][_0x34f8('0x221')][_0x34f8('0x114')]=null);var _0x4b8cbc=_0x268af5[_0x34f8('0x149')]!=''?0x1:0x0;if(_0x4b8cbc>0x0){var _0x45c76a=new _three[(_0x34f8('0x218'))](_0x44146c[_0x268af5['normal_map']][_0x34f8('0x78')],_0x44146c[_0x268af5[_0x34f8('0x149')]][_0x34f8('0xd')],_0x44146c[_0x268af5[_0x34f8('0x149')]][_0x34f8('0x3d')],_three['RGBAFormat'],_three['UnsignedByteType']);_0x45c76a[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x45c76a[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x45c76a['needsUpdate']=!![],_0x311366['uniforms'][_0x34f8('0x221')][_0x34f8('0x114')]=_0x45c76a;}_0x311366['uniforms'][_0x34f8('0x1ea')][_0x34f8('0x114')]=_0x5be403,_0x311366['uniforms'][_0x34f8('0x34')][_0x34f8('0x114')]=_0x2e5a2c,_0x311366['uniforms']['isSpecularTexture']['value']=_0x1ebc8a,_0x311366[_0x34f8('0x238')][_0x34f8('0x50')][_0x34f8('0x114')]=_0x1e117a,_0x311366[_0x34f8('0x238')][_0x34f8('0x8e')][_0x34f8('0x114')]=_0x30e76b,_0x311366[_0x34f8('0x238')][_0x34f8('0xc8')][_0x34f8('0x114')]=_0x4b8cbc,_0x311366[_0x34f8('0x238')][_0x34f8('0x7c')][_0x34f8('0x114')]=_0x4fbd0a[_0x34f8('0x15d')],_0x311366['uniforms'][_0x34f8('0xa6')][_0x34f8('0x114')]=_0x4fbd0a[_0x34f8('0x141')],_0x311366[_0x34f8('0x238')]['environmentTileX'][_0x34f8('0x114')]=_0x4fbd0a[_0x34f8('0xe')],_0x311366[_0x34f8('0x238')][_0x34f8('0x57')][_0x34f8('0x114')]=_0x4fbd0a[_0x34f8('0x58')],_0x311366[_0x34f8('0x238')][_0x34f8('0x1ec')][_0x34f8('0x114')]=_0x4fbd0a[_0x34f8('0x32')];},this['Compute3DTransformMatrix']=function(){_0x1a2a2e[_0x34f8('0x125')]=[],_0x1a2a2e['m_filter_normal_matrix']=[],_0x1a2a2e[_0x34f8('0x3b')]=[],_0x1a2a2e[_0x34f8('0x1b4')]=0x0;var _0x5dece1=_0x1a2a2e[_0x34f8('0x18d')]-_0x1a2a2e[_0x34f8('0x1b4')];if(_0x5dece1<0x0)_0x5dece1+=0x168;{for(var _0x9e20ea=0x0;_0x9e20ea<0x4;_0x9e20ea++){for(var _0x40ed34=0x0;_0x40ed34<0x3;_0x40ed34++){_0x1a2a2e[_0x34f8('0x125')][_0x9e20ea*0x4+_0x40ed34]=_0x1a2a2e[_0x34f8('0xb7')][_0x40ed34*0x4+_0x9e20ea];}}_0x1a2a2e[_0x34f8('0x125')][0x3]=_0x1a2a2e[_0x34f8('0x125')][0x7]=_0x1a2a2e['m_filter_transform_matrix'][0xb]=0x0,_0x1a2a2e[_0x34f8('0x125')][0xf]=0x1;for(var _0x26c001=0x0;_0x26c001<0x4;_0x26c001++){for(var _0x84e631=0x0;_0x84e631<0x4;_0x84e631++){_0x1a2a2e[_0x34f8('0x19')][_0x26c001*0x4+_0x84e631]=_0x1a2a2e['m_normal_matrix'][_0x84e631*0x4+_0x26c001];}}_0x1a2a2e[_0x34f8('0xbd')](_0x1a2a2e[_0x34f8('0x3b')],_0x5dece1,_0x1a2a2e[_0x34f8('0x148')]);}},this['GetFittedProjectMatrix']=function(_0x1729e6,_0x2aabd0,_0x431b5e){var _0x3693f8=[0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1];(_0x2aabd0==0x5a||_0x2aabd0==0x10e)&&(_0x3693f8[0x0]=_0x3693f8[0x4]=0x0,_0x3693f8[0x1]=_0x3693f8[0x3]=0x1);for(var _0x150000=0x0;_0x150000<0x9;_0x150000++){_0x431b5e[_0x150000]=0x0;}for(var _0x385432=0x0;_0x385432<0x3;_0x385432++){for(var _0x2ab73d=0x0;_0x2ab73d<0x3;_0x2ab73d++){for(var _0x1164c6=0x0;_0x1164c6<0x3;_0x1164c6++){_0x431b5e[_0x385432*0x3+_0x2ab73d]+=_0x1729e6[_0x385432+_0x1164c6*0x3]*_0x3693f8[_0x1164c6*0x3+_0x2ab73d];}}}},this[_0x34f8('0x19f')]=function(_0x103b36,_0x2a8bc6,_0x2fb466,_0xed34d8){var _0x42eda5=[0x1,-0x1,-0x1,0x1],_0x12f195=[-0x1,-0x1,0x1,0x1],_0x4b32bd=_0x2fb466?-0x1:0x0,_0x2499b1=(_0x2a8bc6/0x5a+0x3+_0x4b32bd)%0x4;for(var _0x241d23=0x0;_0x241d23<0x9;_0x241d23++){_0xed34d8[_0x241d23]=_0x103b36[_0x241d23];}for(var _0xfa8379=0x0;_0xfa8379<0x2;_0xfa8379++){var _0x18123a=_0xfa8379==0x0?_0x42eda5[_0x2499b1]:_0x12f195[_0x2499b1];for(var _0x256f4f=0x0;_0x256f4f<0x3;_0x256f4f++){_0xed34d8[_0x256f4f*0x3+_0xfa8379]*=_0x18123a;}}},this[_0x34f8('0xbd')]=function(_0x385835,_0x54a749,_0x5f373e){var _0x2d222e=[];_0x1a2a2e[_0x34f8('0x20a')](_0x1a2a2e[_0x34f8('0x4d')],_0x54a749,_0x2d222e);var _0x43cda8=[0x2/_0x1a2a2e[_0x34f8('0xc9')],0x0,0x0,0x0,0x2/_0x1a2a2e[_0x34f8('0x17')],0x0,-0x1,-0x1,0x1],_0x3b9e25=[];for(var _0xc22952=0x0;_0xc22952<0x3;_0xc22952++){for(var _0x2973c8=0x0;_0x2973c8<0x3;_0x2973c8++){_0x3b9e25[_0xc22952*0x3+_0x2973c8]=0x0;for(var _0x5b9699=0x0;_0x5b9699<0x3;_0x5b9699++){_0x3b9e25[_0xc22952*0x3+_0x2973c8]+=_0x2d222e[_0xc22952*0x3+_0x5b9699]*_0x43cda8[_0x5b9699*0x3+_0x2973c8];}}}var _0xf1567a=[];_0x1a2a2e[_0x34f8('0x19f')](_0x3b9e25,_0x54a749,_0x5f373e,_0xf1567a);var _0x1e9674=0.1,_0x1c6064=0x3e8;if(_0x1a2a2e[_0x34f8('0x96')])_0x1e9674=0x1,_0x1c6064=0x3e8;else _0x1a2a2e[_0x34f8('0x1eb')]&&(_0x1e9674=0x1,_0x1c6064=0x3e9);_0x385835[0x0]=_0xf1567a[0x0],_0x385835[0x1]=_0xf1567a[0x1],_0x385835[0x2]=0x0,_0x385835[0x3]=_0xf1567a[0x2],_0x385835[0x4]=_0xf1567a[0x3],_0x385835[0x5]=_0xf1567a[0x4],_0x385835[0x6]=0x0,_0x385835[0x7]=_0xf1567a[0x5],_0x385835[0x8]=_0xf1567a[0x6],_0x385835[0x9]=_0xf1567a[0x7],_0x385835[0xa]=-(_0x1c6064+_0x1e9674)/(_0x1c6064-_0x1e9674),_0x385835[0xb]=_0xf1567a[0x8],_0x385835[0xc]=0x0,_0x385835[0xd]=0x0,_0x385835[0xe]=(0x1+_0x1c6064/(_0x1e9674-_0x1c6064))*_0x1c6064*0x2,_0x385835[0xf]=0x0,_0x1a2a2e[_0x34f8('0x17c')]&&(_0x385835[0xa]=-1.0002,_0x385835[0xe]=-0.4001);},this[_0x34f8('0x1fe')]=function(_0x3d0dde,_0x78a52a){_0x78a52a[_0x34f8('0x114')]!=null&&(_0x78a52a['value']['dispose'](),_0x78a52a[_0x34f8('0x114')]=null);var _0x1be700=new _three[(_0x34f8('0x218'))](_0x3d0dde['data'],_0x3d0dde[_0x34f8('0xd')],_0x3d0dde[_0x34f8('0x3d')],_three[_0x34f8('0x18b')],_three[_0x34f8('0xc7')]);_0x1be700[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x1be700[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x1be700['needsUpdate']=!![],_0x78a52a['value']=_0x1be700;},this[_0x34f8('0x69')]=function(){return _0x1a2a2e[_0x34f8('0xcf')];},this[_0x34f8('0x4a')]=function(_0x412d45){for(var _0x1904e0=0x0;_0x1904e0<Math[_0x34f8('0x81')](_0x412d45[_0x34f8('0x5c')],_0x1a2a2e['m_scene_array'][_0x34f8('0x5c')]);_0x1904e0++){_0x412d45[_0x1904e0]&&(_0x1a2a2e[_0x34f8('0x51')](_0x1a2a2e[_0x34f8('0xd6')][_0x1904e0]),_0x1a2a2e[_0x34f8('0x51')](_0x1a2a2e['m_scene_object_array'][_0x1904e0]),_0x1a2a2e[_0x34f8('0x51')](_0x1a2a2e['m_scene_glass_array'][_0x1904e0]),_0x1a2a2e[_0x34f8('0x159')][_0x1904e0]=[],_0x1a2a2e['non_occluder_mesh_name_array'][_0x1904e0]=[],_0x1a2a2e['glass_name_array'][_0x1904e0]=[]);}_0x1a2a2e[_0x34f8('0x1b5')]&&((0x0,_keys2[_0x34f8('0xa')])(_0x1a2a2e[_0x34f8('0x1b5')])[_0x34f8('0x5b')](function(_0x2bcdfc){return _0x1a2a2e[_0x34f8('0x1b5')][_0x2bcdfc][_0x34f8('0x1a0')]();}),_0x1a2a2e[_0x34f8('0x1b5')]={});},this[_0x34f8('0x8b')]=function(_0x5490d2,_0x26323c,_0x339754){_0x1a2a2e[_0x34f8('0x1e7')]!=null&&_0x1a2a2e[_0x34f8('0x1e7')]['dispose'](),_0x1a2a2e[_0x34f8('0x202')]!=null&&_0x1a2a2e['m_target_nail_art'][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x15b')]!=null&&_0x1a2a2e[_0x34f8('0x15b')][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x1e')]!=null&&_0x1a2a2e[_0x34f8('0x1e')]['dispose'](),_0x1a2a2e[_0x34f8('0x30')]!=null&&_0x1a2a2e[_0x34f8('0x30')][_0x34f8('0x1a0')](),_0x1a2a2e['m_target_wrist_occluder_object']!=null&&_0x1a2a2e[_0x34f8('0x88')][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x151')]!=null&&_0x1a2a2e['m_target_opaque_copy'][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x7d')]=_0x5490d2,_0x1a2a2e[_0x34f8('0xb0')]=_0x26323c,_0x1a2a2e[_0x34f8('0xa2')]=_0x339754,_0x1a2a2e[_0x34f8('0x1e7')]=new _three[(_0x34f8('0x40'))](_0x5490d2,_0x26323c,{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x1a2a2e[_0x34f8('0x202')]=new _three[(_0x34f8('0x40'))](_0x5490d2,_0x26323c,{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x1a2a2e[_0x34f8('0x15b')]=new _three[(_0x34f8('0x40'))](_0x5490d2/_0x1a2a2e[_0x34f8('0xa2')],_0x26323c/_0x1a2a2e[_0x34f8('0xa2')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x1a2a2e['m_target_shadow_smooth']=new _three[(_0x34f8('0x40'))](_0x5490d2/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e[_0x34f8('0x19b')],_0x26323c/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e['m_smooth_shadow_size_factor'],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three[_0x34f8('0x8a')]}),_0x1a2a2e[_0x34f8('0x30')]=new _three[(_0x34f8('0x40'))](_0x5490d2/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e[_0x34f8('0x1c7')],_0x26323c/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e[_0x34f8('0x1c7')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three['RGBAFormat']}),_0x1a2a2e['m_target_wrist_occluder_object']=new _three[(_0x34f8('0x40'))](_0x5490d2/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e[_0x34f8('0x1c7')],_0x26323c/_0x1a2a2e[_0x34f8('0xa2')]*_0x1a2a2e[_0x34f8('0x1c7')],{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three['RGBAFormat']}),_0x1a2a2e[_0x34f8('0x151')]=new _three[(_0x34f8('0x40'))](_0x5490d2,_0x26323c,{'minFilter':_three[_0x34f8('0xf4')],'magFilter':_three[_0x34f8('0xf4')],'format':_three['RGBAFormat']}),_0x1a2a2e[_0x34f8('0x182')][_0x34f8('0x8b')](_0x5490d2*_0x1a2a2e[_0x34f8('0xa2')],_0x26323c*_0x1a2a2e[_0x34f8('0xa2')],_0x1a2a2e['m_upsample_factor']);},this[_0x34f8('0x70')]=function(_0x12bc24){_0x1a2a2e[_0x34f8('0x177')]!=null&&(_0x1a2a2e[_0x34f8('0x177')][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x177')]=null),_0x1a2a2e[_0x34f8('0x177')]=_0x12bc24;},this[_0x34f8('0x1ff')]=function(_0x4d73ce,_0x4311de){if(_0x1a2a2e['m_is_nail_mode']){_0x1a2a2e[_0x34f8('0x13')](_0x1a2a2e[_0x34f8('0xd6')][0x0],_0x1a2a2e[_0x34f8('0x159')][0x0],![],0x0),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e['m_is_nail_pbr']?_0x1a2a2e[_0x34f8('0x234')][0x0]:_0x1a2a2e[_0x34f8('0xd6')][0x0],_0x1a2a2e['m_camera'],_0x1a2a2e[_0x34f8('0x1e7')],!![]);if(!_0x1a2a2e[_0x34f8('0xcf')]){var _0x571d77=![];for(var _0x388647=0x0;_0x388647<0x5;_0x388647++){_0x571d77=_0x571d77||_0x1a2a2e[_0x34f8('0x1c5')][_0x34f8('0x1e0')](_0x1a2a2e[_0x34f8('0x171')]*0x5+_0x388647);}_0x571d77&&(_0x1a2a2e['onDrawArraysPrePass1'](_0x1a2a2e[_0x34f8('0xd6')][0x0],_0x1a2a2e[_0x34f8('0x159')][0x0],!![],0x0),_0x4d73ce['render'](_0x1a2a2e[_0x34f8('0xd6')][0x0],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e['m_target_nail_art'],!![]));}}else{_0x4d73ce['setRenderTarget'](_0x1a2a2e[_0x34f8('0x1e7')]),_0x4d73ce['autoClear']=![],_0x4d73ce[_0x34f8('0x13d')]();for(var _0x3370a8=0x0;_0x3370a8<Math['min'](_0x1a2a2e[_0x34f8('0x195')],_0x1a2a2e[_0x34f8('0xd6')]['length']);_0x3370a8++){_0x1a2a2e[_0x34f8('0x13')](_0x1a2a2e[_0x34f8('0xd6')][_0x3370a8],_0x1a2a2e[_0x34f8('0x159')][_0x3370a8],![],_0x3370a8),_0x4d73ce['render'](_0x1a2a2e[_0x34f8('0x234')][_0x3370a8],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x1e7')],![]);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce[_0x34f8('0x155')]=!![];}_0x1a2a2e['m_mesh']['material'][_0x34f8('0x238')][_0x34f8('0x174')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x1e7')][_0x34f8('0x1a3')],_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e['m_scene'],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x151')],!![]);{_0x4d73ce['setRenderTarget'](_0x1a2a2e[_0x34f8('0x1e7')]),_0x4d73ce[_0x34f8('0x155')]=![];for(var _0x544607=0x0;_0x544607<_0x1a2a2e[_0x34f8('0x23a')]['length'];_0x544607++){_0x1a2a2e[_0x34f8('0x13')](_0x1a2a2e[_0x34f8('0x23a')][_0x544607],_0x1a2a2e[_0x34f8('0x1bc')][_0x544607],![],_0x544607),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e[_0x34f8('0x23a')][_0x544607],_0x1a2a2e['m_camera'],_0x1a2a2e[_0x34f8('0x1e7')],![]);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce['autoClear']=!![];}if(_0x1a2a2e[_0x34f8('0xeb')]&&_0x1a2a2e['m_is_bloom']){_0x4d73ce[_0x34f8('0x155')]=![],_0x4d73ce[_0x34f8('0x21e')](_0x1a2a2e['m_target_wrist_occluder']),_0x4d73ce[_0x34f8('0x13d')]();for(var _0x4c6326=0x0;_0x4c6326<Math[_0x34f8('0x81')](_0x1a2a2e[_0x34f8('0x195')],_0x1a2a2e['m_scene_array'][_0x34f8('0x5c')]);_0x4c6326++){_0x1a2a2e['onDrawArraysPrePassSilhouette'](_0x4c6326),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e['m_scene_array'][_0x4c6326],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x15b')],![]),_0x1a2a2e[_0x34f8('0x217')](_0x4c6326);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce[_0x34f8('0x155')]=!![];}else{if(_0x1a2a2e[_0x34f8('0x17c')]||_0x1a2a2e['m_is_ring_mode']){_0x4d73ce[_0x34f8('0x155')]=![],_0x4d73ce[_0x34f8('0x21e')](_0x1a2a2e['m_target_wrist_occluder']),_0x4d73ce[_0x34f8('0x13d')]();for(var _0x5d7802=0x0;_0x5d7802<Math[_0x34f8('0x81')](_0x1a2a2e['m_ring_object_number'],_0x1a2a2e[_0x34f8('0xd6')][_0x34f8('0x5c')]);_0x5d7802++){_0x1a2a2e[_0x34f8('0x23e')](_0x5d7802),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e[_0x34f8('0xd6')][_0x5d7802],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x15b')],![]),_0x1a2a2e[_0x34f8('0x217')](_0x5d7802);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce[_0x34f8('0x21e')](_0x1a2a2e[_0x34f8('0x30')]),_0x4d73ce[_0x34f8('0x13d')]();for(var _0x4038df=0x0;_0x4038df<Math[_0x34f8('0x81')](_0x1a2a2e[_0x34f8('0x195')],_0x1a2a2e[_0x34f8('0xd6')][_0x34f8('0x5c')]);_0x4038df++){_0x1a2a2e['onDrawArraysPrePassSilhouetteShift'](_0x4038df),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e[_0x34f8('0xd6')][_0x4038df],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x30')],![]),_0x1a2a2e[_0x34f8('0x217')](_0x4038df);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce[_0x34f8('0x21e')](_0x1a2a2e[_0x34f8('0x88')]),_0x4d73ce['clear']();if(_0x1a2a2e[_0x34f8('0x195')]>0x1)for(var _0x3c6f04=0x0;_0x3c6f04<Math[_0x34f8('0x81')](_0x1a2a2e[_0x34f8('0x195')],_0x1a2a2e[_0x34f8('0xd6')]['length']);_0x3c6f04++){_0x1a2a2e['onDrawArraysPrePassSilhouetteObject'](_0x3c6f04),_0x4d73ce[_0x34f8('0x60')](),_0x4d73ce[_0x34f8('0x13b')](_0x1a2a2e['m_scene_array'][_0x3c6f04],_0x1a2a2e[_0x34f8('0x1e9')],_0x1a2a2e[_0x34f8('0x88')],![]),_0x1a2a2e[_0x34f8('0x217')](_0x3c6f04);}_0x4d73ce[_0x34f8('0x21e')](null),_0x4d73ce[_0x34f8('0x155')]=!![],_0x1a2a2e[_0x34f8('0x182')]['SetInputTextureWristOccluder'](_0x1a2a2e[_0x34f8('0x15b')][_0x34f8('0x1a3')]),_0x1a2a2e[_0x34f8('0x182')][_0x34f8('0x1ef')](_0x1a2a2e['m_target_wrist_occluder_shift'][_0x34f8('0x1a3')]),_0x1a2a2e[_0x34f8('0x182')][_0x34f8('0x1b')](_0x1a2a2e[_0x34f8('0x1e')]),_0x1a2a2e[_0x34f8('0x182')][_0x34f8('0x1ff')](_0x4d73ce,!![]);}}},this[_0x34f8('0xe1')]=function(_0x3e2b43,_0x52033b,_0x20e3d0,_0x4f0cd2,_0x25de4e,_0x30a0ca,_0x489335,_0x5215b4,_0x1505c1,_0x4af531,_0x5dd345,_0x212a3c){_0x1a2a2e[_0x34f8('0x4a')](_0x212a3c);var _0x10cb15=_0x1a2a2e['mesh_name_array'][_0x34f8('0x5c')];if(_0x212a3c[_0x34f8('0x5c')]>_0x10cb15)for(var _0x27351a=0x0;_0x27351a<_0x212a3c[_0x34f8('0x5c')]-_0x10cb15;_0x27351a++){_0x1a2a2e[_0x34f8('0x159')][_0x34f8('0x12')]([]),_0x1a2a2e[_0x34f8('0x140')][_0x34f8('0x12')]([]),_0x1a2a2e[_0x34f8('0x1bc')][_0x34f8('0x12')]([]),_0x1a2a2e[_0x34f8('0xd6')][_0x34f8('0x12')](new _three[(_0x34f8('0x100'))]()),_0x1a2a2e[_0x34f8('0x234')][_0x34f8('0x12')](new _three['Scene']()),_0x1a2a2e[_0x34f8('0x23a')]['push'](new _three[(_0x34f8('0x100'))]());}else{if(_0x10cb15>_0x212a3c[_0x34f8('0x5c')])for(var _0x122097=_0x10cb15-0x1;_0x122097>=_0x212a3c['length'];_0x122097--){_0x1a2a2e[_0x34f8('0x51')](_0x1a2a2e[_0x34f8('0xd6')]['pop']()),_0x1a2a2e[_0x34f8('0x51')](_0x1a2a2e[_0x34f8('0x234')][_0x34f8('0x66')]()),_0x1a2a2e['clearScene'](_0x1a2a2e[_0x34f8('0x23a')][_0x34f8('0x66')]()),_0x1a2a2e[_0x34f8('0x159')][_0x34f8('0x66')](),_0x1a2a2e['non_occluder_mesh_name_array'][_0x34f8('0x66')](),_0x1a2a2e[_0x34f8('0x1bc')][_0x34f8('0x66')]();}}_0x1a2a2e[_0x34f8('0x1a8')]=_0x30a0ca,_0x1a2a2e[_0x34f8('0x1b1')]=_0x489335,_0x1a2a2e[_0x34f8('0x24')]=_0x4af531,_0x3e2b43[_0x34f8('0x1fa')](function(_0x3c7cd2,_0x1d0baa){if(_0x212a3c[_0x1d0baa]==![])return;var _0xc55345=_0x52033b[_0x1d0baa],_0x15e434=_0x20e3d0[_0x1d0baa];if(!!_0x3c7cd2){var _0x4f2d9b=_0x4f0cd2[_0x1d0baa][_0x34f8('0xb8')]();if(_0x25de4e)_0x4f2d9b=0x0;for(var _0x2d801b=0x0;_0x2d801b<_0x4f2d9b;_0x2d801b++){var _0x22c064=function _0x1c6e54(){delete this[_0x34f8('0x18f')],this[_0x34f8('0x18f')]=null;},_0x340d1a=_0x4f0cd2[_0x1d0baa][_0x34f8('0x1e0')](_0x2d801b),_0x372ce9=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x340d1a[_0x34f8('0x8d')],_0x340d1a[_0x34f8('0x129')]),_0x5c3770=new Float32Array(_0x1a2a2e['YMKModule'][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x340d1a[_0x34f8('0x178')],_0x340d1a[_0x34f8('0x4c')]),_0x581294=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x340d1a[_0x34f8('0x138')],_0x340d1a[_0x34f8('0x16')]),_0xb75461=new Int32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x340d1a[_0x34f8('0xe7')],_0x340d1a[_0x34f8('0x14a')]),_0x492779=new _three[(_0x34f8('0x1d'))]();_0x492779[_0x34f8('0x6b')]((0x0,_from2[_0x34f8('0xa')])(_0xb75461)),_0x492779[_0x34f8('0xb')]('position',new _three[(_0x34f8('0x53'))](_0x372ce9,0x3)[_0x34f8('0x14f')](_0x22c064)),_0x492779[_0x34f8('0xb')](_0x34f8('0x1c'),new _three[(_0x34f8('0x53'))](_0x5c3770,0x3)['onUpload'](_0x22c064)),_0x492779[_0x34f8('0xb')](_0x34f8('0x157'),new _three[(_0x34f8('0x53'))](_0x581294,0x2)[_0x34f8('0x14f')](_0x22c064));var _0x46686c=new _shader4[(_0x34f8('0xa'))](),_0x4a1782=new _three[(_0x34f8('0x236'))]({'uniforms':_0x46686c[_0x34f8('0x196')],'vertexShader':_0x46686c[_0x34f8('0x6e')],'fragmentShader':_0x46686c[_0x34f8('0x1aa')],'depthTest':!![],'depthWrite':!![],'side':_three['DoubleSide'],'blending':_three[_0x34f8('0x206')],'blendEquation':_three[_0x34f8('0x1e3')],'blendSrc':_three[_0x34f8('0x1c8')],'blendDst':_three[_0x34f8('0x14e')],'transparent':!![]});_0x4a1782[_0x34f8('0x238')][_0x34f8('0x65')][_0x34f8('0x114')]=_0x25de4e?0x1:0x0,_0x4a1782[_0x34f8('0x238')][_0x34f8('0x135')][_0x34f8('0x114')]=0x1;_0x1a2a2e[_0x34f8('0x1ee')]&&(_0x4a1782[_0x34f8('0xe8')]=_three[_0x34f8('0xb9')],_0x4a1782[_0x34f8('0x1cd')]=_three[_0x34f8('0x1c8')]);var _0x2f0b89={'ambient':'','diffuse':'','specular':'','environment':'','environment_weight':'','normal_map':'','orm':'','trans':'','opa':''};_0x1a2a2e['Update3DObject'](_0x340d1a,_0x2f0b89,null,_0x4a1782);var _0x53d991=new _three[(_0x34f8('0x1f7'))](_0x492779,_0x4a1782);_0x53d991[_0x34f8('0xa9')]=![],_0x53d991[_0x34f8('0xcd')]=![],_0x53d991[_0x34f8('0x74')]=0x0,_0x53d991[_0x34f8('0xf5')]=_0x34f8('0x1f3')+_0x2d801b,_0x1a2a2e[_0x34f8('0x159')][_0x1d0baa][_0x34f8('0x12')](_0x53d991[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0xd6')][_0x1d0baa][_0x34f8('0x1ae')](_0x53d991);}var _0x4dbd4f=_0x3c7cd2[_0x34f8('0xb8')](),_0x4d31c5={};for(var _0x345a76=0x0;_0x345a76<_0x4dbd4f;_0x345a76++){var _0x1b2640=_0x3c7cd2[_0x34f8('0x1e0')](_0x345a76);_0x1b2640['is_referenced_small_gem']&&(_0x4d31c5[_0x1b2640[_0x34f8('0x1f0')]]={'norm':_0x30a0ca[_0x1d0baa][_0x345a76],'pos':_0x489335[_0x1d0baa][_0x345a76]}),_0x1a2a2e[_0x34f8('0x185')]=_0x1b2640[_0x34f8('0x11d')]/0.5;}var _0x5a9e22=Math[_0x34f8('0x81')](_0x1a2a2e[_0x34f8('0x185')],0x1);_0x1a2a2e['m_shadow_smooth_filter'][_0x34f8('0x1fc')](_0x5a9e22),_0x1a2a2e[_0x34f8('0x232')]=[],_0x1a2a2e[_0x34f8('0x23b')](_0x1a2a2e[_0x34f8('0x6c')]),_0x1a2a2e[_0x34f8('0x6c')]={};for(var _0x21ce33=0x0;_0x21ce33<_0x4dbd4f;_0x21ce33++){var _0x56010d=function _0x4b1764(){delete this['array'],this['array']=null;},_0x5511d5=_0x3c7cd2[_0x34f8('0x1e0')](_0x21ce33),_0x2fe6b0=_0x15e434[_0x21ce33],_0x168b16=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32']['buffer'],_0x5511d5[_0x34f8('0x8d')],_0x5511d5[_0x34f8('0x129')]),_0x5dcfbc=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x5511d5[_0x34f8('0x178')],_0x5511d5[_0x34f8('0x4c')]),_0x3e58df=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x5511d5[_0x34f8('0x138')],_0x5511d5['texcoord_array_size']),_0x37d81a=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x5511d5[_0x34f8('0x1d3')],_0x5511d5[_0x34f8('0x241')]),_0x2915e2=new Int32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x5511d5['p_index_array'],_0x5511d5[_0x34f8('0x14a')]),_0x1cbdcc=new _three[(_0x34f8('0x1d'))]();_0x5511d5[_0x34f8('0xcd')]==![]&&_0x1cbdcc[_0x34f8('0x6b')]((0x0,_from2[_0x34f8('0xa')])(_0x2915e2));_0x1cbdcc['addAttribute'](_0x34f8('0xf6'),new _three['Float32BufferAttribute'](_0x168b16,0x3)[_0x34f8('0x14f')](_0x56010d)),_0x1cbdcc[_0x34f8('0xb')]('normal',new _three[(_0x34f8('0x53'))](_0x5dcfbc,0x3)[_0x34f8('0x14f')](_0x56010d)),_0x1cbdcc[_0x34f8('0xb')]('inputTextureCoordinate',new _three[(_0x34f8('0x53'))](_0x3e58df,0x2)[_0x34f8('0x14f')](_0x56010d)),_0x1cbdcc[_0x34f8('0xb')](_0x34f8('0x136'),new _three[(_0x34f8('0x53'))](_0x37d81a,0x3)[_0x34f8('0x14f')](_0x56010d));var _0x429ac9=null;if(_0x5511d5[_0x34f8('0xa9')]||_0x5511d5[_0x34f8('0xcd')]){var _0x202720=new _pbr2[(_0x34f8('0xa'))](),_0x1930d8=_0x202720[_0x34f8('0x1aa')];_0x5511d5[_0x34f8('0xcd')]&&(_0x1930d8=_0x34f8('0x239')+_0x1930d8),_0x25de4e&&(_0x1930d8=_0x34f8('0x225')+_0x1930d8),_0x5dd345==![]&&(_0x1930d8='#define\x20IS_COLOR_RATIO\x0a'+_0x1930d8),_0x429ac9=new _three[(_0x34f8('0x236'))]({'uniforms':_0x202720[_0x34f8('0x196')],'vertexShader':_0x202720[_0x34f8('0x6e')],'fragmentShader':_0x1930d8,'depthTest':_0x25de4e?![]:!![],'depthWrite':!![],'side':_three[_0x34f8('0xf7')],'blending':_three[_0x34f8('0x206')],'blendEquation':_three[_0x34f8('0x1e3')],'blendSrc':_three[_0x34f8('0x1f9')],'blendDst':_three[_0x34f8('0x1c8')],'blendSrcAlpha':_three[_0x34f8('0xb9')],'blendDstAlpha':_three[_0x34f8('0x1c8')],'transparent':!![]});}else{var _0x1e7ef5=new _shader4[(_0x34f8('0xa'))]();_0x429ac9=new _three[(_0x34f8('0x236'))]({'uniforms':_0x1e7ef5[_0x34f8('0x196')],'vertexShader':_0x1e7ef5['vertexShader'],'fragmentShader':_0x1e7ef5[_0x34f8('0x1aa')],'depthTest':_0x25de4e?![]:!![],'depthWrite':!![],'side':_three[_0x34f8('0xf7')],'blending':_three[_0x34f8('0x206')],'blendEquation':_three[_0x34f8('0x1e3')],'blendSrc':_0x25de4e?_three['SrcAlphaFactor']:_three[_0x34f8('0xb9')],'blendDst':_three[_0x34f8('0x1c8')],'transparent':!![]}),_0x429ac9[_0x34f8('0x238')]['isNailMode'][_0x34f8('0x114')]=_0x25de4e?0x1:0x0;}var _0x31e62e=_0x30a0ca[_0x1d0baa][_0x21ce33],_0x4ca498=_0x489335[_0x1d0baa][_0x21ce33],_0x55d0cf=_0x5215b4[_0x1d0baa][_0x21ce33],_0x4546ac=_0x1505c1[_0x1d0baa][_0x21ce33];_0x5511d5[_0x34f8('0x16f')]&&_0x5511d5['referencing_small_gem_id']in _0x4d31c5&&(_0x31e62e=_0x4d31c5[_0x5511d5[_0x34f8('0x209')]]['norm'],_0x4ca498=_0x4d31c5[_0x5511d5[_0x34f8('0x209')]]['pos']);if(_0x5511d5[_0x34f8('0xa9')]||_0x5511d5[_0x34f8('0xcd')])_0x1a2a2e['Update3DPBRObject'](_0x5511d5,_0x2fe6b0,_0xc55345,_0x429ac9,_0x31e62e,_0x4ca498,_0x55d0cf,_0x4546ac,_0x5dd345);else _0x1a2a2e[_0x34f8('0x8')](_0x5511d5,_0x2fe6b0,_0xc55345,_0x429ac9);if(!_0x25de4e){var _0x125141=new _three[(_0x34f8('0x1f7'))](_0x1cbdcc,_0x429ac9);_0x125141['frustumCulled']=![],_0x125141[_0x34f8('0x11e')]=_0x5511d5[_0x34f8('0x11e')],_0x125141[_0x34f8('0xa9')]=_0x5511d5[_0x34f8('0xa9')],_0x125141[_0x34f8('0xcd')]=_0x5511d5[_0x34f8('0xcd')],_0x125141[_0x34f8('0x16f')]=_0x5511d5[_0x34f8('0x16f')],_0x125141[_0x34f8('0x1f0')]=_0x5511d5[_0x34f8('0x1f0')],_0x125141[_0x34f8('0x209')]=_0x5511d5[_0x34f8('0x209')],_0x125141[_0x34f8('0x1dc')]={'norm':_0x31e62e,'pos':_0x4ca498},_0x125141[_0x34f8('0x74')]=_0x5511d5[_0x34f8('0x23c')],_0x125141[_0x34f8('0x167')]=_0x5511d5['watch_time_component_parameter'][_0x34f8('0x22e')],_0x125141[_0x34f8('0x19d')]=_0x5511d5[_0x34f8('0x208')][_0x34f8('0xd5')],_0x125141[_0x34f8('0x11b')]=_0x5511d5[_0x34f8('0x1f1')][_0x34f8('0x22e')],_0x125141[_0x34f8('0x152')]=_0x5511d5['watch_digital_time_component_parameter'][_0x34f8('0xd5')],_0x125141[_0x34f8('0x47')]=_0x5511d5[_0x34f8('0x1f1')]['time_system'],_0x125141[_0x34f8('0x13f')]=_0x5511d5[_0x34f8('0x1f1')][_0x34f8('0xb4')],_0x125141[_0x34f8('0x107')]=new Float32Array(_0x1a2a2e['YMKModule'][_0x34f8('0x10a')]['buffer'],_0x5511d5['watch_digital_time_component_parameter'][_0x34f8('0x1bb')],0x1a)[_0x34f8('0x87')](),_0x125141[_0x34f8('0xf5')]=_0x34f8('0x1ce')+_0x21ce33,_0x1a2a2e[_0x34f8('0x159')][_0x1d0baa][_0x34f8('0x12')](_0x125141[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0x140')][_0x1d0baa][_0x34f8('0x12')](_0x125141[_0x34f8('0xf5')]),_0x1a2a2e['m_scene_array'][_0x1d0baa][_0x34f8('0x1ae')](_0x125141);if(_0x5511d5['is_glass'])_0x1a2a2e[_0x34f8('0x1bc')][_0x1d0baa]['push'](_0x125141[_0x34f8('0xf5')]),_0x1a2a2e['m_scene_glass_array'][_0x1d0baa][_0x34f8('0x1ae')](_0x125141[_0x34f8('0xaa')]());else{var _0x1b30dc=new _three['Mesh'](_0x1cbdcc,_0x429ac9);_0x1b30dc[_0x34f8('0x1ed')]=![],_0x1b30dc[_0x34f8('0x11e')]=_0x5511d5[_0x34f8('0x11e')],_0x1b30dc['is_pbr']=_0x5511d5[_0x34f8('0xa9')],_0x1b30dc[_0x34f8('0xcd')]=_0x5511d5[_0x34f8('0xcd')],_0x1b30dc[_0x34f8('0x16f')]=_0x5511d5[_0x34f8('0x16f')],_0x1b30dc[_0x34f8('0x74')]=_0x5511d5[_0x34f8('0x23c')],_0x1b30dc[_0x34f8('0xf5')]='object3d_'+_0x21ce33,_0x1a2a2e[_0x34f8('0x234')][_0x1d0baa]['add'](_0x1b30dc);}}else{if(_0x5511d5['is_pbr'])for(var _0xa52ca9=0x4;_0xa52ca9>=0x0;_0xa52ca9--){var _0x1d62b3=_0x429ac9[_0x34f8('0xaa')]();_0x1a2a2e[_0x34f8('0x1e2')](_0x5511d5,_0x2fe6b0,_0xc55345,_0x1d62b3);var _0x5c8dd8=new _three[(_0x34f8('0x1f7'))](_0x1cbdcc,_0x1d62b3);_0x5c8dd8[_0x34f8('0xa9')]=_0x5511d5[_0x34f8('0xa9')],_0x5c8dd8[_0x34f8('0xcd')]=_0x5511d5['is_gem'],_0x5c8dd8[_0x34f8('0x16f')]=_0x5511d5[_0x34f8('0x16f')],_0x5c8dd8['matrix_index']=_0x5511d5[_0x34f8('0x23c')],_0x5c8dd8['name']=_0x34f8('0x1ce')+_0x21ce33+'_'+_0xa52ca9,_0x5c8dd8[_0x34f8('0xef')]=_0xa52ca9,_0x5c8dd8['is_first_nail_object']=_0x21ce33==0x0,_0x1a2a2e[_0x34f8('0x159')][_0x1d0baa][_0x34f8('0x12')](_0x5c8dd8[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0x140')][_0x1d0baa][_0x34f8('0x12')](_0x5c8dd8[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0xd6')][_0x1d0baa][_0x34f8('0x1ae')](_0x5c8dd8);if(_0x5511d5[_0x34f8('0x11e')]){var _0x534239=new _three[(_0x34f8('0x1f7'))](_0x1cbdcc,_0x1d62b3);_0x534239[_0x34f8('0x11e')]=_0x5511d5['is_glass'],_0x534239[_0x34f8('0xa9')]=_0x5511d5[_0x34f8('0xa9')],_0x534239['name']=_0x34f8('0x1ce')+_0x21ce33+'_'+_0xa52ca9,_0x534239[_0x34f8('0xef')]=_0xa52ca9,_0x534239['is_first_nail_object']=_0x21ce33==0x0,_0x1a2a2e[_0x34f8('0x1bc')][_0x1d0baa][_0x34f8('0x12')](_0x534239[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0x23a')][_0x1d0baa][_0x34f8('0x1ae')](_0x534239);}else{var _0x17067f=new _three['Mesh'](_0x1cbdcc,_0x1d62b3);_0x17067f[_0x34f8('0x11e')]=_0x5511d5[_0x34f8('0x11e')],_0x17067f[_0x34f8('0xa9')]=_0x5511d5[_0x34f8('0xa9')],_0x17067f[_0x34f8('0xf5')]='object3d_'+_0x21ce33+'_'+_0xa52ca9,_0x17067f[_0x34f8('0xef')]=_0xa52ca9,_0x17067f[_0x34f8('0xc6')]=_0x21ce33==0x0,_0x1a2a2e[_0x34f8('0x234')][_0x1d0baa][_0x34f8('0x1ae')](_0x17067f);}}else for(var _0x4bb0df=0x0;_0x4bb0df<0x5;_0x4bb0df++){var _0x3e0dbf=_0x429ac9[_0x34f8('0xaa')]();_0x1a2a2e['Update3DObject'](_0x5511d5,_0x2fe6b0,_0xc55345,_0x3e0dbf);var _0x4a1d4e=new _three[(_0x34f8('0x1f7'))](_0x1cbdcc,_0x3e0dbf);_0x4a1d4e[_0x34f8('0xa9')]=_0x5511d5[_0x34f8('0xa9')],_0x4a1d4e[_0x34f8('0xcd')]=_0x5511d5[_0x34f8('0xcd')],_0x4a1d4e[_0x34f8('0x16f')]=_0x5511d5[_0x34f8('0x16f')],_0x4a1d4e[_0x34f8('0x74')]=_0x5511d5[_0x34f8('0x23c')],_0x4a1d4e[_0x34f8('0xf5')]=_0x34f8('0x1ce')+_0x21ce33+'_'+_0x4bb0df,_0x4a1d4e[_0x34f8('0xef')]=_0x4bb0df,_0x1a2a2e[_0x34f8('0x159')][_0x1d0baa][_0x34f8('0x12')](_0x4a1d4e[_0x34f8('0xf5')]),_0x1a2a2e['non_occluder_mesh_name_array'][_0x1d0baa]['push'](_0x4a1d4e[_0x34f8('0xf5')]),_0x1a2a2e[_0x34f8('0xd6')][_0x1d0baa][_0x34f8('0x1ae')](_0x4a1d4e);}}}}}),_0x5dd345&&(_0x1a2a2e[_0x34f8('0x195')]=_0x1a2a2e[_0x34f8('0xd6')][_0x34f8('0x5c')]);},this[_0x34f8('0x23b')]=function(_0x5af8c2){},this[_0x34f8('0x133')]=function(_0x2a8d71){},this[_0x34f8('0x1c1')]=function(_0x3422fe){if(_0x1a2a2e[_0x34f8('0x1ee')]==_0x3422fe)return;_0x1a2a2e[_0x34f8('0x1ee')]=_0x3422fe;for(var _0xb35cc8=0x0;_0xb35cc8<_0x1a2a2e[_0x34f8('0xd6')][_0x34f8('0x5c')];_0xb35cc8++){for(var _0x33eed8=0x0;_0x33eed8<_0x1a2a2e[_0x34f8('0x159')][_0xb35cc8][_0x34f8('0x5c')];_0x33eed8++){if(_0x1a2a2e['mesh_name_array'][_0xb35cc8][_0x33eed8]['lastIndexOf']('object3d_occluder_',0x0)!=0x0)continue;var _0x1e69fa=_0x1a2a2e[_0x34f8('0xd6')][_0xb35cc8][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x159')][_0xb35cc8][_0x33eed8]);_0x1a2a2e[_0x34f8('0x1ee')]?(_0x1e69fa[_0x34f8('0x20')][_0x34f8('0xe8')]=_three[_0x34f8('0xb9')],_0x1e69fa['material'][_0x34f8('0x1cd')]=_three[_0x34f8('0x1c8')]):(_0x1e69fa[_0x34f8('0x20')]['blendSrc']=_three['OneMinusSrcAlphaFactor'],_0x1e69fa[_0x34f8('0x20')][_0x34f8('0x1cd')]=_three[_0x34f8('0x14e')]);}}},this[_0x34f8('0x98')]=function(_0x1263a0){},this[_0x34f8('0x1b6')]=function(_0x3f4bcb){},this[_0x34f8('0x240')]=function(_0x36cff0){_0x1a2a2e[_0x34f8('0x96')]=![],_0x1a2a2e[_0x34f8('0x17c')]=![],_0x1a2a2e['m_is_ring_mode']=![],_0x1a2a2e[_0x34f8('0xeb')]=!![],_0x1a2a2e[_0x34f8('0xb7')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')]['HEAPF32'][_0x34f8('0x23d')],_0x36cff0[_0x34f8('0x1ab')],0xc),_0x1a2a2e[_0x34f8('0x5d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x36cff0[_0x34f8('0x39')],0x10),_0x1a2a2e[_0x34f8('0x4d')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x36cff0[_0x34f8('0x176')],0x9),_0x1a2a2e[_0x34f8('0x72')]=_0x36cff0[_0x34f8('0x4e')];},this[_0x34f8('0x1d9')]=function(_0x2b7dcc){_0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e['YMKModule'][_0x34f8('0x168')][_0x34f8('0x61')]&&(_0x1a2a2e[_0x34f8('0x96')]=!![],_0x1a2a2e[_0x34f8('0x17c')]=![],_0x1a2a2e[_0x34f8('0x1eb')]=![],_0x1a2a2e[_0x34f8('0xeb')]=![],_0x1a2a2e[_0x34f8('0xcf')]=![],_0x1a2a2e[_0x34f8('0x242')]=![]);if(_0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e[_0x34f8('0x186')]['VN_VTOMode']['NAIL_TIP'])_0x1a2a2e[_0x34f8('0x96')]=!![],_0x1a2a2e['m_is_wrist_mode']=![],_0x1a2a2e[_0x34f8('0x1eb')]=![],_0x1a2a2e[_0x34f8('0xeb')]=![],_0x1a2a2e[_0x34f8('0xcf')]=![],_0x1a2a2e[_0x34f8('0x242')]=!![];else{if(_0x2b7dcc['vto_mode']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x219')])_0x1a2a2e[_0x34f8('0x96')]=![],_0x1a2a2e['m_is_wrist_mode']=!![],_0x1a2a2e[_0x34f8('0x1eb')]=![],_0x1a2a2e['m_is_viewer_mode']=![],_0x1a2a2e[_0x34f8('0xcf')]=![],_0x1a2a2e[_0x34f8('0x242')]=![];else _0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x11c')]&&(_0x1a2a2e['m_is_nail_mode']=![],_0x1a2a2e[_0x34f8('0x17c')]=![],_0x1a2a2e['m_is_ring_mode']=!![],_0x1a2a2e['m_is_viewer_mode']=![],_0x1a2a2e[_0x34f8('0xcf')]=![],_0x1a2a2e[_0x34f8('0x242')]=![]);}_0x1a2a2e['m_pnp_step']=_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x142')]*0xc,_0x1a2a2e[_0x34f8('0x166')]=_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x142')]*0x10,_0x1a2a2e[_0x34f8('0x1db')]=_0x2b7dcc['matrix_count'],_0x1a2a2e[_0x34f8('0x131')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x1ab')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*_0x1a2a2e['m_pnp_step']),_0x1a2a2e['m_hand_normal_matrices']=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc['p_normal_matrices'],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*_0x1a2a2e['m_noraml_pnp_step']),_0x1a2a2e[_0x34f8('0x1c0')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x244')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*0x9),_0x1a2a2e[_0x34f8('0x22f')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x1b7')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*0xc),_0x1a2a2e[_0x34f8('0x231')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0xaf')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*0x10),_0x1a2a2e[_0x34f8('0x72')]=_0x2b7dcc[_0x34f8('0x4e')],_0x1a2a2e[_0x34f8('0x153')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x86')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*0xc),_0x1a2a2e[_0x34f8('0xa1')]=new Float32Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x10a')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x230')],_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x31')]*0x10),_0x1a2a2e[_0x34f8('0x9')]=_0x2b7dcc[_0x34f8('0xd2')],_0x1a2a2e[_0x34f8('0x195')]=_0x2b7dcc[_0x34f8('0xfe')],_0x1a2a2e['m_nail_art_image_width']=_0x2b7dcc['nail_art_image_width'],_0x1a2a2e[_0x34f8('0x170')]=_0x2b7dcc[_0x34f8('0x7a')],_0x1a2a2e[_0x34f8('0xb6')]=[],_0x1a2a2e[_0x34f8('0xae')]=[];if(_0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x61')]||_0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e[_0x34f8('0x186')]['VN_VTOMode'][_0x34f8('0x1e8')]){if(_0x1a2a2e[_0x34f8('0x1c5')]!=null)_0x1a2a2e[_0x34f8('0x1c5')][_0x34f8('0x137')]();if(_0x1a2a2e['m_nail_left_vec']!=null)_0x1a2a2e['m_nail_left_vec'][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0x56')]!=null)_0x1a2a2e[_0x34f8('0x56')]['delete']();if(_0x1a2a2e[_0x34f8('0x59')]!=null)_0x1a2a2e[_0x34f8('0x59')][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0x18a')]!=null)_0x1a2a2e[_0x34f8('0x18a')][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0xc2')]!=null)_0x1a2a2e['m_four_way_thumb_pbr'][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0x179')]!=null)_0x1a2a2e[_0x34f8('0x179')][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0x2e')]!=null)_0x1a2a2e[_0x34f8('0x2e')][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0x1cc')]!=null)_0x1a2a2e['m_four_way_ring_finger_pbr'][_0x34f8('0x137')]();if(_0x1a2a2e[_0x34f8('0xac')]!=null)_0x1a2a2e[_0x34f8('0xac')][_0x34f8('0x137')]();_0x1a2a2e[_0x34f8('0x1c5')]=_0x2b7dcc[_0x34f8('0xa5')],_0x1a2a2e['m_nail_left_vec']=_0x2b7dcc[_0x34f8('0x111')],_0x1a2a2e[_0x34f8('0x56')]=_0x2b7dcc['nail_rect_right_ratio'],_0x1a2a2e['m_nail_top_vec']=_0x2b7dcc['nail_rect_top_ratio'],_0x1a2a2e[_0x34f8('0x18a')]=_0x2b7dcc[_0x34f8('0x134')];var _0xdae13a=_0x2b7dcc[_0x34f8('0x21d')],_0x4c6252=_0x2b7dcc[_0x34f8('0x10e')],_0x2bf93e=_0x2b7dcc[_0x34f8('0x21a')];for(var _0xc13ab3=0x0;_0xc13ab3<0x5;_0xc13ab3++){_0x1a2a2e['m_is_nail_valid'][_0xc13ab3]=_0xdae13a[_0x34f8('0x1e0')](_0xc13ab3);}for(var _0x500ad4=0x0;_0x500ad4<0x4*0x5;_0x500ad4++){_0x1a2a2e[_0x34f8('0xb6')][_0x34f8('0x12')](new Uint8Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xa7')][_0x34f8('0x23d')],_0x4c6252[_0x34f8('0x1e0')](_0x500ad4),_0x2b7dcc[_0x34f8('0x11f')]*_0x2b7dcc[_0x34f8('0x7a')]*0x4)),_0x1a2a2e[_0x34f8('0xae')][_0x34f8('0x12')](new Uint8Array(_0x1a2a2e['YMKModule'][_0x34f8('0xa7')][_0x34f8('0x23d')],_0x2bf93e[_0x34f8('0x1e0')](_0x500ad4),_0x2b7dcc[_0x34f8('0x243')]*_0x2b7dcc[_0x34f8('0x162')]*0x4));}_0x1a2a2e['m_four_way_thumb_pbr']=_0x2b7dcc[_0x34f8('0x22')],_0x1a2a2e['m_four_way_index_finger_pbr']=_0x2b7dcc['index_finger_pbr'],_0x1a2a2e[_0x34f8('0x2e')]=_0x2b7dcc[_0x34f8('0x49')],_0x1a2a2e[_0x34f8('0x1cc')]=_0x2b7dcc[_0x34f8('0x6f')],_0x1a2a2e[_0x34f8('0xac')]=_0x2b7dcc[_0x34f8('0x214')],_0xdae13a[_0x34f8('0x137')](),_0x4c6252[_0x34f8('0x137')](),_0x2bf93e[_0x34f8('0x137')]();}var _0x4fa7eb=Math[_0x34f8('0x5e')](_0x2b7dcc['min_luma_for_hand'],0x0),_0x1bbdac=Math[_0x34f8('0x81')](_0x2b7dcc[_0x34f8('0x222')]-_0x2b7dcc[_0x34f8('0x1b9')],0x1);_0x1a2a2e['m_dynamic_range_offset']=_0x4fa7eb*_0x1a2a2e['m_natural_adjust_intensity'],_0x1a2a2e[_0x34f8('0x6d')]=_0x1bbdac*_0x1a2a2e[_0x34f8('0xfa')]-_0x1a2a2e[_0x34f8('0xfa')]+0x1;var _0x14ae6e=_0x1a2a2e[_0x34f8('0xfa')]*0.75;_0x1a2a2e[_0x34f8('0x4b')]=_0x4fa7eb*_0x14ae6e,_0x1a2a2e[_0x34f8('0x7f')]=_0x1bbdac*_0x14ae6e-_0x14ae6e+0x1,_0x1a2a2e[_0x34f8('0x1b2')]=_0x2b7dcc[_0x34f8('0x222')],_0x1a2a2e['m_enable_adjusting_color']=_0x2b7dcc[_0x34f8('0xfb')]&&_0x2b7dcc[_0x34f8('0x139')]==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x219')];var _0x3fcf21=_0x2b7dcc[_0x34f8('0xa8')];for(var _0x1ae5e2=0x0;_0x1ae5e2<0xc;_0x1ae5e2++){_0x1a2a2e[_0x34f8('0x76')][_0x1ae5e2]=_0x3fcf21[_0x34f8('0x1e0')](_0x1ae5e2);}_0x3fcf21[_0x34f8('0x137')]();var _0xd87595=_0x2b7dcc[_0x34f8('0x228')];for(var _0x5b6753=0x0;_0x5b6753<0x4;_0x5b6753++){_0x1a2a2e[_0x34f8('0x144')][_0x5b6753]=_0xd87595[_0x34f8('0x1e0')](_0x5b6753);}_0xd87595['delete'](),_0x1a2a2e[_0x34f8('0x2f')]=_0x2b7dcc[_0x34f8('0x1d4')],_0x1a2a2e['m_is_nail_tip_changed']=_0x2b7dcc[_0x34f8('0xfd')],_0x1a2a2e[_0x34f8('0x22b')]=_0x2b7dcc['is_nail_env_map_changed'],_0x1a2a2e[_0x34f8('0x1e5')]=_0x2b7dcc['is_four_way'],_0x1a2a2e[_0x34f8('0x20d')]=_0x2b7dcc[_0x34f8('0x207')],_0x1a2a2e[_0x34f8('0x161')]=_0x2b7dcc['nail_pbr_mode'],_0x1a2a2e[_0x34f8('0x182')][_0x34f8('0x1d9')](_0x2b7dcc);if(_0x2b7dcc['vto_mode']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x61')]||_0x2b7dcc['vto_mode']==_0x1a2a2e[_0x34f8('0x186')]['VN_VTOMode'][_0x34f8('0x1e8')]){_0x1a2a2e[_0x34f8('0x19c')]!=null&&_0x1a2a2e[_0x34f8('0x19c')][_0x34f8('0x1a0')]();_0x1a2a2e['m_nail_mask_last3']!=null&&_0x1a2a2e[_0x34f8('0x9d')][_0x34f8('0x1a0')]();var _0xc7f4ba=new Uint8Array(_0x1a2a2e['YMKModule'][_0x34f8('0xa7')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x181')],_0x2b7dcc[_0x34f8('0x27')]*_0x2b7dcc[_0x34f8('0xde')]*0x4),_0x2568bf=new _three[(_0x34f8('0x218'))](_0xc7f4ba,_0x2b7dcc[_0x34f8('0x27')],_0x2b7dcc[_0x34f8('0xde')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x2568bf[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x2568bf[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x2568bf[_0x34f8('0x1c3')]=!![],_0x1a2a2e[_0x34f8('0x19c')]=_0x2568bf;var _0xf358c4=new Uint8Array(_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0xa7')][_0x34f8('0x23d')],_0x2b7dcc[_0x34f8('0x15e')],_0x2b7dcc[_0x34f8('0x27')]*_0x2b7dcc[_0x34f8('0xde')]*0x4),_0x12559b=new _three[(_0x34f8('0x218'))](_0xf358c4,_0x2b7dcc['nail_segment_width'],_0x2b7dcc[_0x34f8('0xde')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x12559b[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x12559b[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x12559b[_0x34f8('0x1c3')]=!![],_0x1a2a2e[_0x34f8('0x9d')]=_0x12559b;if(_0x1a2a2e['m_is_nail_art_changed']||_0x1a2a2e['m_is_nail_tip_changed'])for(var _0x52c919=0x0;_0x52c919<0x4*0x5;_0x52c919++){_0x1a2a2e[_0x34f8('0x199')][_0x52c919]!=null&&_0x1a2a2e[_0x34f8('0x199')][_0x52c919][_0x34f8('0x1a0')](),_0x1a2a2e[_0x34f8('0x199')][_0x52c919]=new _three['DataTexture'](_0x1a2a2e[_0x34f8('0xb6')][_0x52c919],_0x1a2a2e[_0x34f8('0x197')],_0x1a2a2e[_0x34f8('0x170')],_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]),_0x1a2a2e[_0x34f8('0x199')][_0x52c919]['minFilter']=_three[_0x34f8('0xf4')],_0x1a2a2e[_0x34f8('0x199')][_0x52c919][_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x1a2a2e['m_nail_art_texture'][_0x52c919][_0x34f8('0x1c3')]=!![];}}if(_0x2b7dcc['vto_mode']==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x168')][_0x34f8('0x11c')]){var _0x46daba=_0x2b7dcc['ring_mount_occlude_distances'];_0x1a2a2e[_0x34f8('0x172')]=[];for(var _0x1a3e96=0x0;_0x1a3e96<_0x1a2a2e[_0x34f8('0x195')];_0x1a3e96++){_0x1a2a2e['m_ring_mount_occlude_distances'][_0x34f8('0x12')](_0x46daba[_0x34f8('0x1e0')](_0x1a3e96));}_0x46daba[_0x34f8('0x137')]();var _0x521da9=_0x2b7dcc[_0x34f8('0x5a')],_0x566fe3=_0x2b7dcc[_0x34f8('0xe9')];_0x1a2a2e[_0x34f8('0x11')]=[],_0x1a2a2e[_0x34f8('0x173')]=[];for(var _0x591ef8=0x0;_0x591ef8<_0x1a2a2e[_0x34f8('0x195')];_0x591ef8++){_0x1a2a2e[_0x34f8('0x11')][_0x34f8('0x12')](_0x521da9['get'](_0x591ef8)),_0x1a2a2e[_0x34f8('0x173')]['push'](_0x566fe3[_0x34f8('0x1e0')](_0x591ef8));}_0x521da9[_0x34f8('0x137')](),_0x566fe3[_0x34f8('0x137')]();}},this['GetRingFingerOccluderData']=function(_0x338e03){var _0x1d048c=_0x338e03[_0x34f8('0xc9')],_0x3388f3=_0x338e03[_0x34f8('0x17')],_0x466f3b=_0x338e03[_0x34f8('0x67')],_0x22030d=_0x338e03[_0x34f8('0x19e')],_0x2eef3c=_0x338e03[_0x34f8('0xd9')],_0x132b6d=_0x338e03[_0x34f8('0x20e')],_0x13e85a=![];if(_0x466f3b!=_0x1a2a2e['YMKModule'][_0x34f8('0x6')][_0x34f8('0xd4')])_0x13e85a=!![];var _0x2a069d=[[0x0,0x1,0x0,0x1],[0x0,-0x1,0x0,0x1],[-0x1,0x0,0x0,0x1],[0x1,0x0,0x0,0x1]],_0x380ccd=[[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0]],_0x485de5=_0x1a2a2e[_0x34f8('0x131')][_0x34f8('0x87')](0x0*_0x1a2a2e[_0x34f8('0x189')],0x0*_0x1a2a2e[_0x34f8('0x189')]+0xc),_0x5201b4=[];for(var _0x1c12ae=0x0;_0x1c12ae<0x4;_0x1c12ae++){for(var _0x58ff6f=0x0;_0x58ff6f<0x3;_0x58ff6f++){_0x5201b4[_0x58ff6f*0x4+_0x1c12ae]=_0x485de5[_0x58ff6f*0x4+_0x1c12ae];}}_0x5201b4[0xc]=_0x5201b4[0xd]=_0x5201b4[0xe]=0x0,_0x5201b4[0xf]=0x1,_0x1a2a2e[_0x34f8('0x4d')]=_0x1a2a2e['m_hand_camera_matrices'][_0x34f8('0x87')](0x0*0x9,0x0*0x9+0x9);var _0x1f8363=[];_0x1a2a2e[_0x34f8('0xbd')](_0x1f8363,0x0,![]);for(var _0xd877cd=0x0;_0xd877cd<0x4;_0xd877cd++){var _0x1366d1=[0x0,0x0,0x0,0x0];for(var _0x24c5ac=0x0;_0x24c5ac<0x4;_0x24c5ac++){for(var _0x1b9ac3=0x0;_0x1b9ac3<0x4;_0x1b9ac3++){_0x1366d1[_0x24c5ac]+=_0x5201b4[_0x24c5ac*0x4+_0x1b9ac3]*_0x2a069d[_0xd877cd][_0x1b9ac3];}}for(var _0x1c9a43=0x0;_0x1c9a43<0x4;_0x1c9a43++){for(var _0x1d2a41=0x0;_0x1d2a41<0x4;_0x1d2a41++){_0x380ccd[_0xd877cd][_0x1c9a43]+=_0x1f8363[_0x1d2a41*0x4+_0x1c9a43]*_0x1366d1[_0x1d2a41];}}for(var _0x48b937=0x0;_0x48b937<0x4;_0x48b937++){_0x380ccd[_0xd877cd][_0x48b937]/=_0x380ccd[_0xd877cd][0x3];}_0x380ccd[_0xd877cd][0x0]=(_0x380ccd[_0xd877cd][0x0]+0x1)*0.5,_0x380ccd[_0xd877cd][0x1]=(_0x380ccd[_0xd877cd][0x1]+0x1)*0.5;}var _0x149a43=_0x380ccd[0x0][0x1]-_0x380ccd[0x1][0x1],_0x1e64cb=-(_0x380ccd[0x0][0x0]-_0x380ccd[0x1][0x0]),_0x337adf=_0x466f3b==_0x1a2a2e[_0x34f8('0x186')][_0x34f8('0x6')]['OCCLUDE_BASED_ON_LEFT']?0x0:0x1,_0xd5ed68=[_0x22030d[_0x34f8('0x1e0')](_0x337adf*0x2+0x0)/_0x1d048c,_0x22030d[_0x34f8('0x1e0')](_0x337adf*0x2+0x1)/_0x3388f3],_0x4e94d6=[_0x2eef3c[_0x34f8('0x1e0')]((_0x337adf+0x2)*0x2+0x0)/_0x1d048c,_0x2eef3c[_0x34f8('0x1e0')]((_0x337adf+0x2)*0x2+0x1)/_0x3388f3];_0xd5ed68[0x0]=(_0xd5ed68[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0xd5ed68[0x1]=(_0xd5ed68[0x1]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x4e94d6[0x0]=(_0x4e94d6[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x4e94d6[0x1]=(_0x4e94d6[0x1]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5;var _0x436f5e=_0x4e94d6[0x1]-_0xd5ed68[0x1],_0x3bda40=-(_0x4e94d6[0x0]-_0xd5ed68[0x0]),_0x5b1ed6=_0x132b6d['get'](0x0),_0x12252e=_0x132b6d[_0x34f8('0x1e0')](0x1),_0x549092=[_0x2eef3c['get'](0x0)/_0x1d048c,_0x2eef3c[_0x34f8('0x1e0')](0x1)/_0x3388f3],_0x328aea=[_0x2eef3c[_0x34f8('0x1e0')](0x2)/_0x1d048c,_0x2eef3c[_0x34f8('0x1e0')](0x3)/_0x3388f3];_0x549092[0x0]=(_0x549092[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x549092[0x1]=(_0x549092[0x1]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x328aea[0x0]=(_0x328aea[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x328aea[0x1]=(_0x328aea[0x1]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5;var _0x2751e1=[_0x328aea[0x0]-_0x549092[0x0],_0x328aea[0x1]-_0x549092[0x1]],_0x52bfdc=Math['sqrt'](_0x2751e1[0x0]*_0x2751e1[0x0]+_0x2751e1[0x1]*_0x2751e1[0x1]),_0x5b8d16=0x0,_0x5f195d=0x0,_0xef2f4d=0x0;if(_0x338e03[_0x34f8('0x93')]){_0x5b8d16=_0x328aea[0x1]-_0x549092[0x1],_0x5f195d=-(_0x328aea[0x0]-_0x549092[0x0]);var _0x408f3d=Math[_0x34f8('0x77')](_0x5b8d16*_0x5b8d16+_0x5f195d*_0x5f195d);_0x5b8d16=_0x5b8d16/_0x408f3d,_0x5f195d=_0x5f195d/_0x408f3d,_0xef2f4d=-(_0x5b8d16*_0x549092[0x0])-_0x5f195d*_0x549092[0x1];}var _0x47ff96=0x0,_0x2e035e=0x0,_0x90a567=0x0,_0x57cd3a=0x0;if(_0x338e03[_0x34f8('0x93')]){var _0x2d151d=[_0x2eef3c['get']((0x0+0x2)*0x2+0x0)/_0x1d048c,_0x2eef3c[_0x34f8('0x1e0')]((0x0+0x2)*0x2+0x1)/_0x3388f3],_0x4cd225=[_0x2eef3c[_0x34f8('0x1e0')]((0x1+0x2)*0x2+0x0)/_0x1d048c,_0x2eef3c['get']((0x1+0x2)*0x2+0x1)/_0x3388f3];_0x2d151d[0x0]=(_0x2d151d[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x2d151d[0x1]=(_0x2d151d[0x1]-0.5)*_0x1a2a2e['m_zoom_scale_ratio']+0.5,_0x4cd225[0x0]=(_0x4cd225[0x0]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x4cd225[0x1]=(_0x4cd225[0x1]-0.5)*_0x1a2a2e[_0x34f8('0x12a')]+0.5,_0x47ff96=_0x4cd225[0x1]-_0x2d151d[0x1],_0x2e035e=-(_0x4cd225[0x0]-_0x2d151d[0x0]);var _0x5b68a0=Math[_0x34f8('0x77')](_0x47ff96*_0x47ff96+_0x2e035e*_0x2e035e);_0x5b8d16=_0x47ff96/_0x5b68a0,_0x5f195d=_0x2e035e/_0x5b68a0,_0x90a567=-(_0x47ff96*_0x2d151d[0x0])-_0x2e035e*_0x2d151d[0x1],_0x57cd3a=_0x2d151d[0x1];}return _0x22030d[_0x34f8('0x137')](),_0x2eef3c[_0x34f8('0x137')](),_0x132b6d['delete'](),{'ring_cylinder_axis_line':[_0x149a43,_0x1e64cb,_0x2751e1[0x0],_0x2751e1[0x1]],'ring_stack_visible_axis':[_0x436f5e,_0x3bda40],'ring_circle_flat':[_0x5b8d16,_0x5f195d,_0xef2f4d,_0x52bfdc],'ring_interval_info':[_0x549092[0x0],_0x549092[0x1],_0x5b1ed6,_0x12252e],'is_ring_finger_occluder':_0x1a2a2e[_0x34f8('0x9c')],'is_non_blocked_flat_applied':_0x13e85a,'ring_non_blocked_flat':[_0x47ff96,_0x2e035e,_0x90a567,_0x57cd3a]};},this[_0x34f8('0x1f6')]=function(_0x2dd41f,_0x54beeb){var _0x3d7aa1=0x0,_0x42b269=_0x1a2a2e[_0x34f8('0xd6')][_0x3d7aa1][_0x34f8('0xf')](_0x1a2a2e['non_occluder_mesh_name_array'][_0x3d7aa1][_0x2dd41f]);if(_0x42b269[_0x34f8('0xa9')]==![])return;_0x42b269[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xea')][_0x34f8('0x114')]=_0x54beeb;},this['SetGemParameters']=function(_0x103e06,_0x337ccd,_0x35726d,_0x1b3f68){var _0x2b34b3=0x0,_0x31d08d=_0x1a2a2e[_0x34f8('0xd6')][_0x2b34b3][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x2b34b3][_0x103e06]);if(_0x31d08d[_0x34f8('0x16f')]==![])_0x1a2a2e[_0x34f8('0xb1')](_0x103e06,_0x337ccd,_0x35726d,_0x1b3f68);else{var _0x5e1c59=_0x31d08d[_0x34f8('0x1f0')];for(var _0x2d03ed=0x0;_0x2d03ed<_0x1a2a2e[_0x34f8('0x140')][_0x2b34b3]['length'];_0x2d03ed++){var _0x1fdcf6=_0x1a2a2e[_0x34f8('0xd6')][_0x2b34b3][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x2b34b3][_0x2d03ed]);_0x1fdcf6[_0x34f8('0x16f')]&&_0x1fdcf6[_0x34f8('0x209')]==_0x5e1c59&&_0x1a2a2e[_0x34f8('0xb1')](_0x2d03ed,_0x337ccd,_0x35726d,_0x1b3f68);}}},this['SetGemParameters2']=function(_0x362f60,_0x1b94c9,_0x3d1c95,_0x4a201c){var _0x2b7418=_0x1b94c9!=null?parseInt(_0x1b94c9[_0x34f8('0x212')](0x1,0x2),0x10)/0xff:0x0,_0xce617b=_0x1b94c9!=null?parseInt(_0x1b94c9['substr'](0x3,0x2),0x10)/0xff:0x0,_0xb38f2e=_0x1b94c9!=null?parseInt(_0x1b94c9[_0x34f8('0x212')](0x5,0x2),0x10)/0xff:0x0,_0x4adb62=0x0,_0x4e270b=_0x1a2a2e[_0x34f8('0xd6')][_0x4adb62]['getObjectByName'](_0x1a2a2e[_0x34f8('0x140')][_0x4adb62][_0x362f60]);if(!_0x4e270b[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xf1')]||_0x4e270b[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xf1')]['value']==0x0)return;if(_0x1b94c9!=null)_0x4e270b[_0x34f8('0x20')][_0x34f8('0x238')]['gemColor'][_0x34f8('0x114')]=new _three[(_0x34f8('0x46'))](_0x2b7418,_0xce617b,_0xb38f2e);if(_0x4a201c!=null)_0x4e270b[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x116')][_0x34f8('0x114')]=_0x4a201c;if(_0x3d1c95!=null)_0x4e270b[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xb5')][_0x34f8('0x114')]=_0x3d1c95;},this[_0x34f8('0x183')]=function(_0x411693,_0x5d1df1){var _0x4e568d=0x0,_0x481445=_0x1a2a2e[_0x34f8('0xd6')][_0x4e568d]['getObjectByName'](_0x1a2a2e[_0x34f8('0x140')][_0x4e568d][_0x411693]);if(_0x481445[_0x34f8('0x16f')]==![])_0x1a2a2e[_0x34f8('0x10f')](_0x411693,_0x5d1df1);else{var _0x485821=_0x481445[_0x34f8('0x1f0')];for(var _0xd06a25=0x0;_0xd06a25<_0x1a2a2e[_0x34f8('0x140')][_0x4e568d][_0x34f8('0x5c')];_0xd06a25++){var _0x594d88=_0x1a2a2e[_0x34f8('0xd6')][_0x4e568d]['getObjectByName'](_0x1a2a2e[_0x34f8('0x140')][_0x4e568d][_0xd06a25]);_0x594d88[_0x34f8('0x16f')]&&_0x594d88[_0x34f8('0x209')]==_0x485821&&_0x1a2a2e[_0x34f8('0x10f')](_0xd06a25,_0x5d1df1);}}},this[_0x34f8('0x10f')]=function(_0x2765d1,_0x2fb6a4){var _0x2f3ca5=0x0,_0x480467=_0x1a2a2e['m_scene_array'][_0x2f3ca5]['getObjectByName'](_0x1a2a2e[_0x34f8('0x140')][_0x2f3ca5][_0x2765d1]);_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xf1')][_0x34f8('0x114')]=_0x2fb6a4?0x1:0x0,_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x8f')]['value']=_0x2fb6a4?0.5:0x1;if(_0x2fb6a4==![]){}else _0x480467['material'][_0x34f8('0x238')][_0x34f8('0x5f')]['value']!=null&&(_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x480467[_0x34f8('0x20')]['uniforms'][_0x34f8('0x5f')][_0x34f8('0x114')]=null),_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')]=_0x480467['is_small_gem']?_0x480467[_0x34f8('0x1dc')]['norm'][_0x34f8('0x1a3')]:_0x1a2a2e[_0x34f8('0x1a8')][_0x2f3ca5][_0x2765d1][_0x34f8('0x1a3')],_0x480467[_0x34f8('0x20')]['uniforms'][_0x34f8('0x10d')][_0x34f8('0x114')]!=null&&(_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')][_0x34f8('0x1a0')](),_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=null),_0x480467[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=_0x480467[_0x34f8('0x16f')]?_0x480467[_0x34f8('0x1dc')][_0x34f8('0x5')][_0x34f8('0x1a3')]:_0x1a2a2e['m_gem_pos_env_maps'][_0x2f3ca5][_0x2765d1][_0x34f8('0x1a3')];},this[_0x34f8('0x16d')]=function(_0x3878e1,_0x1f7fd3){var _0x5c836c=0x0;if(_0x1f7fd3){var _0x4ad573=_0x1a2a2e[_0x34f8('0x140')][_0x5c836c][_0x3878e1],_0x4b0a52=_0x1a2a2e[_0x34f8('0x23a')][_0x5c836c]['getObjectByName'](_0x4ad573);if(!!_0x4b0a52)return;_0x4b0a52=_0x1a2a2e[_0x34f8('0xd6')][_0x5c836c][_0x34f8('0xf')](_0x4ad573),_0x1a2a2e[_0x34f8('0x23a')][_0x5c836c][_0x34f8('0x1ae')](_0x4b0a52[_0x34f8('0xaa')]()),_0x4b0a52=_0x1a2a2e['m_scene_object_array'][_0x5c836c]['getObjectByName'](_0x4ad573),_0x1a2a2e[_0x34f8('0x234')][_0x5c836c][_0x34f8('0xab')](_0x4b0a52),_0x1a2a2e[_0x34f8('0x1bc')][_0x5c836c][_0x34f8('0x12')](_0x4ad573);}else{var _0x7f00e=_0x1a2a2e[_0x34f8('0x140')][_0x5c836c][_0x3878e1],_0x32aaf3=_0x1a2a2e[_0x34f8('0x23a')][_0x5c836c][_0x34f8('0xf')](_0x7f00e);if(!_0x32aaf3)return;_0x1a2a2e[_0x34f8('0x23a')][_0x5c836c][_0x34f8('0xab')](_0x32aaf3),_0x32aaf3=_0x1a2a2e[_0x34f8('0xd6')][_0x5c836c][_0x34f8('0xf')](_0x7f00e),_0x1a2a2e[_0x34f8('0x234')][_0x5c836c][_0x34f8('0x1ae')](_0x32aaf3[_0x34f8('0xaa')]());var _0x39ff18=_0x1a2a2e[_0x34f8('0x1bc')][_0x5c836c][_0x34f8('0x229')](_0x7f00e);_0x39ff18>-0x1?_0x1a2a2e['glass_name_array'][_0x5c836c][_0x34f8('0x99')](_0x39ff18,0x1):console[_0x34f8('0x52')](_0x34f8('0xca'));}},this[_0x34f8('0x1be')]=function(_0x5c9198,_0x5c8879,_0xaadb56,_0x4d66c6,_0x5d3eb2){var _0x2c2244=arguments[_0x34f8('0x5c')]>0x5&&arguments[0x5]!==undefined?arguments[0x5]:0x0,_0x24cdde=_0x1a2a2e['m_scene_array'][_0x2c2244]['getObjectByName'](_0x1a2a2e[_0x34f8('0x140')][_0x2c2244][_0x5c9198]);if(_0x24cdde[_0x34f8('0xa9')]==![])return;_0x24cdde[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xad')][_0x34f8('0x114')]=_0x5c8879,_0x24cdde[_0x34f8('0x20')]['uniforms'][_0x34f8('0x4')][_0x34f8('0x114')]=_0xaadb56*3.14159/0xb4,_0x24cdde[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x158')][_0x34f8('0x114')]=_0x4d66c6*3.14159/0xb4,_0x24cdde[_0x34f8('0x20')][_0x34f8('0x238')]['vertOrienSin'][_0x34f8('0x114')]=Math[_0x34f8('0x103')](_0x24cdde[_0x34f8('0x20')]['uniforms'][_0x34f8('0x158')][_0x34f8('0x114')]),_0x24cdde[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1f4')][_0x34f8('0x114')]=Math[_0x34f8('0x213')](_0x24cdde[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x158')]['value']),_0x24cdde['material'][_0x34f8('0x238')][_0x34f8('0x15')][_0x34f8('0x114')]=_0x5d3eb2?0x1:0x0;},this[_0x34f8('0x1a4')]=function(_0x99686a,_0x21326c){var _0x2e4f64=arguments[_0x34f8('0x5c')]>0x2&&arguments[0x2]!==undefined?arguments[0x2]:0x0,_0x499e4e=_0x1a2a2e['m_scene_array'][_0x2e4f64][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x2e4f64][_0x99686a]);if(_0x499e4e[_0x34f8('0x16f')]==![])_0x1a2a2e[_0x34f8('0x237')](_0x99686a,_0x21326c,_0x2e4f64);else{var _0x19c2bc=_0x499e4e[_0x34f8('0x1f0')];for(var _0x43f528=0x0;_0x43f528<_0x1a2a2e[_0x34f8('0x140')][_0x2e4f64][_0x34f8('0x5c')];_0x43f528++){var _0x1a9855=_0x1a2a2e['m_scene_array'][_0x2e4f64][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x2e4f64][_0x43f528]);_0x1a9855['is_small_gem']&&_0x1a9855[_0x34f8('0x209')]==_0x19c2bc&&_0x1a2a2e[_0x34f8('0x237')](_0x43f528,_0x21326c,_0x2e4f64);}}},this[_0x34f8('0x237')]=function(_0x11dd40,_0x8ab5e1){var _0x2ad862=arguments[_0x34f8('0x5c')]>0x2&&arguments[0x2]!==undefined?arguments[0x2]:0x0,_0x316728=_0x1a2a2e[_0x34f8('0xd6')][_0x2ad862][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x2ad862][_0x11dd40]);if(_0x316728[_0x34f8('0xa9')]==![])return;_0x316728[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]!=null&&(_0x316728['material'][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]['dispose'](),_0x316728[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=null);var _0x5c1859=_0x1a2a2e[_0x34f8('0x126')](_0x8ab5e1[_0x34f8('0x75')],_0x8ab5e1[_0x34f8('0x1b3')],_0x8ab5e1[_0x34f8('0xd')],_0x8ab5e1['height'],!![]);_0x5c1859[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x5c1859[_0x34f8('0x115')]=_three[_0x34f8('0xf4')],_0x5c1859[_0x34f8('0x1c3')]=!![],_0x316728[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x210')][_0x34f8('0x114')]=_0x5c1859;},this[_0x34f8('0x20b')]=function(_0x356984,_0x412215){if(_0x356984)return _0x356984;if(_0x412215>0x800)return 0x800;return _0x412215;},this[_0x34f8('0x204')]=function(_0x7fe92e,_0x1ccd2d,_0x13877a){return new _promise2[(_0x34f8('0xa'))](function(_0x446794){var _0x16bf7c=new Image();_0x16bf7c[_0x34f8('0xbe')]=_0x34f8('0x180'),_0x16bf7c[_0x34f8('0x1e4')]=function(){var _0x5436db=document[_0x34f8('0x1b8')](_0x34f8('0xf3')),_0x47fb8b=_0x1a2a2e[_0x34f8('0x20b')](_0x1ccd2d,_0x16bf7c[_0x34f8('0xd')]),_0x5ba468=_0x1a2a2e[_0x34f8('0x20b')](_0x13877a,_0x16bf7c[_0x34f8('0x3d')]);_0x5436db[_0x34f8('0xd')]=_0x47fb8b,_0x5436db[_0x34f8('0x3d')]=_0x5ba468;var _0x371b76=_0x5436db[_0x34f8('0x128')]('2d');_0x371b76[_0x34f8('0x20c')](_0x16bf7c,0x0,0x0,_0x16bf7c[_0x34f8('0xd')],_0x16bf7c[_0x34f8('0x3d')],0x0,0x0,_0x47fb8b,_0x5ba468);var _0x322406=new Uint8Array(_0x371b76[_0x34f8('0x110')](0x0,0x0,_0x47fb8b,_0x5ba468)[_0x34f8('0x1a1')]);_mediaUtils2[_0x34f8('0xa')][_0x34f8('0x63')](_0x5436db),_0x446794({'image_array':_0x322406,'width':_0x47fb8b,'height':_0x5ba468});},_0x16bf7c[_0x34f8('0x188')]=_0x446794,_0x16bf7c[_0x34f8('0x75')]=_0x7fe92e;});},this['getImageDataByHexCode']=function(_0x40573e,_0x30a74c,_0x1023f0){var _0xdf20e2=document['createElement'](_0x34f8('0xf3'));_0xdf20e2[_0x34f8('0xd')]=_0x30a74c,_0xdf20e2[_0x34f8('0x3d')]=_0x1023f0;var _0x70d4bd=_0xdf20e2[_0x34f8('0x128')]('2d');_0x70d4bd[_0x34f8('0x21c')]=_0x40573e,_0x70d4bd['fillRect'](0x0,0x0,_0x30a74c,_0x1023f0);var _0x65b071=document[_0x34f8('0x1b8')](_0x34f8('0xf3'));_0x65b071[_0x34f8('0xd')]=_0x30a74c,_0x65b071[_0x34f8('0x3d')]=_0x1023f0;var _0x22c962=_0x65b071[_0x34f8('0x128')]('2d');_0x22c962[_0x34f8('0x20c')](_0xdf20e2,0x0,0x0,_0x30a74c,_0x1023f0);var _0x419d35=new Uint8Array(_0x22c962['getImageData'](0x0,0x0,_0x30a74c,_0x1023f0)[_0x34f8('0x1a1')]);return _mediaUtils2[_0x34f8('0xa')][_0x34f8('0x63')](_0xdf20e2),_mediaUtils2[_0x34f8('0xa')]['releaseCanvas'](_0x65b071),{'image_array':_0x419d35,'width':_0x30a74c,'height':_0x1023f0};},this[_0x34f8('0x110')]=function(){var _0x1a3ccb=(0x0,_asyncToGenerator3[_0x34f8('0xa')])(_regenerator2[_0x34f8('0xa')]['mark'](function _0x133570(_0xce615,_0x5968f7,_0x3640e6){var _0x4ce75c,_0x404d83,_0x1f1bd2;return _regenerator2['default'][_0x34f8('0xd3')](function _0x390cdd(_0xb94b78){while(0x1){switch(_0xb94b78[_0x34f8('0x18')]=_0xb94b78[_0x34f8('0x1a')]){case 0x0:_0x4ce75c=/^http/i[_0x34f8('0x1dd')](_0xce615),_0x404d83=_0x4ce75c?_browserUtils2[_0x34f8('0xa')]['changeHost'](_0xce615):_0xce615;if(!_0x1a2a2e[_0x34f8('0x29')][_0x404d83]){_0xb94b78['next']=0x4;break;}return _0xb94b78[_0x34f8('0x175')](_0x34f8('0x147'),_0x1a2a2e[_0x34f8('0x29')][_0x404d83]);case 0x4:if(!_0x4ce75c){_0xb94b78[_0x34f8('0x1a')]=0xa;break;}_0xb94b78[_0x34f8('0x1a')]=0x7;return _0x1a2a2e['getImageDataByUrl'](_0x404d83,_0x5968f7,_0x3640e6);case 0x7:_0xb94b78['t0']=_0xb94b78[_0x34f8('0x7b')],_0xb94b78[_0x34f8('0x1a')]=0xb;break;case 0xa:_0xb94b78['t0']=_0x1a2a2e[_0x34f8('0xdb')](_0x404d83,0x200,0x200);case 0xb:_0x1f1bd2=_0xb94b78['t0'];_0x1f1bd2&&(_0x1a2a2e[_0x34f8('0x29')][_0x404d83]=_0x1f1bd2);return _0xb94b78['abrupt'](_0x34f8('0x147'),_0x1f1bd2);case 0xe:case'end':return _0xb94b78[_0x34f8('0x91')]();}}},_0x133570,_0x1a2a2e);}));return function(_0x1a68b1,_0x172a5f,_0x4b1f97){return _0x1a3ccb[_0x34f8('0x22c')](this,arguments);};}(),this['getDataTexture']=function(_0x5609fe,_0x553d1f,_0x4a7e1a,_0x12cf18){var _0x361717=arguments['length']>0x4&&arguments[0x4]!==undefined?arguments[0x4]:![],_0x4375d0=/^5/i[_0x34f8('0x1dd')](_0x5609fe);if(!_0x1a2a2e[_0x34f8('0x1b5')][_0x5609fe]){var _0x16c974=new _three[(_0x34f8('0x218'))](_0x553d1f,_0x4a7e1a,_0x12cf18,_three[_0x34f8('0x8a')],_three[_0x34f8('0xc7')]);_0x16c974[_0x34f8('0xd7')]=_three[_0x34f8('0xf4')],_0x16c974[_0x34f8('0x115')]=_three[_0x34f8('0xf4')];!_0x361717&&(_0x16c974[_0x34f8('0xb3')]=_three[_0x34f8('0x62')],_0x16c974[_0x34f8('0x1cf')]=_three[_0x34f8('0x62')]);_0x16c974[_0x34f8('0x1c3')]=!![];if(_0x4375d0)return _0x16c974;_0x1a2a2e[_0x34f8('0x1b5')][_0x5609fe]=_0x16c974;}return _0x1a2a2e[_0x34f8('0x1b5')][_0x5609fe];},this[_0x34f8('0x122')]=function(){var _0x17ee31=(0x0,_asyncToGenerator3[_0x34f8('0xa')])(_regenerator2[_0x34f8('0xa')]['mark'](function _0x3abe9a(_0x3ac806,_0x291c58,_0x378482){var _0x303ba6=arguments[_0x34f8('0x5c')]>0x3&&arguments[0x3]!==undefined?arguments[0x3]:0x0,_0x3a83d4,_0x174c66,_0x450bec,_0x2f9101,_0x352e4f,_0x262201,_0xbfc0ac,_0x8b3334,_0x528e63,_0x554d20,_0x425519,_0x4007b1,_0x556ad9;return _regenerator2['default']['wrap'](function _0x254c88(_0x2f3c5c){while(0x1){switch(_0x2f3c5c[_0x34f8('0x18')]=_0x2f3c5c['next']){case 0x0:_0x3a83d4=_0x378482[_0x34f8('0xd')],_0x174c66=_0x378482[_0x34f8('0x3d')];(_0x291c58==PBRTextureMapEnum['AO']||_0x291c58==PBRTextureMapEnum[_0x34f8('0x1d1')]||_0x291c58==PBRTextureMapEnum[_0x34f8('0x120')]||_0x291c58==PBRTextureMapEnum[_0x34f8('0x1ba')]||_0x291c58==PBRTextureMapEnum[_0x34f8('0x2c')])&&(_0x3a83d4=_0x1a2a2e[_0x34f8('0x232')][_0x3ac806]['width'],_0x174c66=_0x1a2a2e['m_cached_orm_map'][_0x3ac806][_0x34f8('0x3d')]);_0x2f3c5c[_0x34f8('0x1a')]=0x5;return _0x1a2a2e['getImageData'](_0x378482,_0x3a83d4,_0x174c66);case 0x5:_0x450bec=_0x2f3c5c[_0x34f8('0x7b')],_0x2f9101=_0x450bec[_0x34f8('0x17d')],_0x352e4f=_0x450bec[_0x34f8('0xd')],_0x262201=_0x450bec[_0x34f8('0x3d')],_0x3a83d4=_0x352e4f,_0x174c66=_0x262201,_0xbfc0ac=_0x1a2a2e[_0x34f8('0xd6')][_0x303ba6][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x303ba6][_0x3ac806]);if(!(_0xbfc0ac['is_pbr']==![]&&_0xbfc0ac[_0x34f8('0xcd')]==![])){_0x2f3c5c[_0x34f8('0x1a')]=0xe;break;}return _0x2f3c5c[_0x34f8('0x175')](_0x34f8('0x147'));case 0xe:if(_0xbfc0ac['material']['uniforms'][_0x34f8('0xf1')]['value']==0x1){}else{if(_0x291c58==PBRTextureMapEnum[_0x34f8('0x118')])_0x8b3334=_0x1a2a2e[_0x34f8('0x126')](_0x291c58+_0x378482,_0x2f9101,_0x3a83d4,_0x174c66),_0xbfc0ac[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x10d')][_0x34f8('0x114')]=_0x8b3334;else{if(_0x291c58==PBRTextureMapEnum[_0x34f8('0x2c')]){for(_0x528e63=0x0;_0x528e63<_0x174c66;_0x528e63++){for(_0x554d20=0x0;_0x554d20<_0x3a83d4;_0x554d20++){_0x1a2a2e[_0x34f8('0x232')][_0x3ac806][_0x34f8('0x17d')][(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x0]=_0x2f9101[(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x0],_0x1a2a2e['m_cached_orm_map'][_0x3ac806][_0x34f8('0x17d')][(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x1]=_0x2f9101[(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x1],_0x1a2a2e[_0x34f8('0x232')][_0x3ac806]['image_array'][(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x2]=_0x2f9101[(_0x528e63*_0x3a83d4+_0x554d20)*0x4+0x2];}}_0xbfc0ac[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')]=_0x1a2a2e['getDataTexture'](_0x291c58+_0x378482,_0x1a2a2e[_0x34f8('0x232')][_0x3ac806][_0x34f8('0x17d')],_0x3a83d4,_0x174c66);}else{if(_0x291c58==PBRTextureMapEnum['AO']||_0x291c58==PBRTextureMapEnum[_0x34f8('0x1d1')]||_0x291c58==PBRTextureMapEnum[_0x34f8('0x120')]||_0x291c58==PBRTextureMapEnum[_0x34f8('0x1ba')]){_0x425519=void 0x0;if(_0x291c58==PBRTextureMapEnum['AO'])_0x425519=0x0;else{if(_0x291c58==PBRTextureMapEnum[_0x34f8('0x120')])_0x425519=0x1;else{if(_0x291c58==PBRTextureMapEnum[_0x34f8('0x1d1')])_0x425519=0x2;else{if(_0x291c58==PBRTextureMapEnum[_0x34f8('0x1ba')])_0x425519=0x3;else console['error'](_0x34f8('0x1bf'));}}}_0x291c58==PBRTextureMapEnum['TRANSMISSION']&&(_0xbfc0ac[_0x34f8('0x227')]=!![],_0x1a2a2e[_0x34f8('0x16d')](_0x3ac806,_0xbfc0ac[_0x34f8('0x20')]['uniforms']['transmission_intensity'][_0x34f8('0x114')]>0x0));for(_0x4007b1=0x0;_0x4007b1<_0x174c66;_0x4007b1++){for(_0x556ad9=0x0;_0x556ad9<_0x3a83d4;_0x556ad9++){_0x1a2a2e[_0x34f8('0x232')][_0x3ac806][_0x34f8('0x17d')][(_0x4007b1*_0x3a83d4+_0x556ad9)*0x4+_0x425519]=_0x2f9101[(_0x4007b1*_0x3a83d4+_0x556ad9)*0x4+0x0];}}_0xbfc0ac['material'][_0x34f8('0x238')][_0x34f8('0x5f')][_0x34f8('0x114')]=_0x1a2a2e[_0x34f8('0x126')](_0x291c58+_0x378482,_0x1a2a2e[_0x34f8('0x232')][_0x3ac806][_0x34f8('0x17d')],_0x3a83d4,_0x174c66);}else _0x291c58==PBRTextureMapEnum[_0x34f8('0x41')]?_0xbfc0ac[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x221')]['value']=_0x1a2a2e[_0x34f8('0x126')](_0x291c58+_0x378482,_0x2f9101,_0x3a83d4,_0x174c66):console['error'](_0x34f8('0x1d0')+_0x291c58);}}}case 0xf:case _0x34f8('0x163'):return _0x2f3c5c[_0x34f8('0x91')]();}}},_0x3abe9a,_0x1a2a2e);}));return function(_0x3e578c,_0x313b4f,_0x33f891){return _0x17ee31[_0x34f8('0x22c')](this,arguments);};}(),this[_0x34f8('0x1f8')]=function(_0x42118c,_0x837517,_0x2a6d99){var _0x35563d=0x0,_0x5e0b14=_0x1a2a2e[_0x34f8('0xd6')][_0x35563d][_0x34f8('0xf')](_0x1a2a2e['non_occluder_mesh_name_array'][_0x35563d][_0x42118c]);if(_0x5e0b14['is_pbr']==![]||_0x5e0b14[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xf1')]['value']==0x1)return;if(_0x837517==PBRTextureMapEnum['AO'])_0x5e0b14[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xcc')]['value']=_0x2a6d99;else{if(_0x837517==PBRTextureMapEnum[_0x34f8('0x120')])_0x5e0b14[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x2b')][_0x34f8('0x114')]=_0x2a6d99;else{if(_0x837517==PBRTextureMapEnum[_0x34f8('0x1d1')])_0x5e0b14[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x15f')][_0x34f8('0x114')]=_0x2a6d99;else{if(_0x837517==PBRTextureMapEnum[_0x34f8('0x41')])_0x5e0b14['material'][_0x34f8('0x238')]['normal_intensity'][_0x34f8('0x114')]=_0x2a6d99;else{if(_0x837517==PBRTextureMapEnum[_0x34f8('0x118')])_0x5e0b14[_0x34f8('0x20')]['uniforms'][_0x34f8('0x160')][_0x34f8('0x114')]=_0x2a6d99;else{if(_0x837517==PBRTextureMapEnum[_0x34f8('0x1ba')])_0x5e0b14[_0x34f8('0x20')]['uniforms'][_0x34f8('0x1c4')][_0x34f8('0x114')]=_0x2a6d99;}}}}}!!_0x5e0b14[_0x34f8('0x227')]&&_0x5e0b14[_0x34f8('0x227')]==!![]&&_0x1a2a2e[_0x34f8('0x16d')](_0x42118c,_0x5e0b14[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1c4')][_0x34f8('0x114')]>0x0);},this['SetPBRTextureMapTransform']=function(_0x35dd81,_0x5ef9bb,_0x14eab9,_0x5598ae,_0x353691){var _0x5bd397=_0x14eab9*Math['PI']/0xb4,_0x521e4e=0x1/(_0x5598ae['x']*0.01),_0x21dd96=0x1/(_0x5598ae['y']*0.01),_0x1a82a3=-_0x353691['x'],_0x333eb3=_0x353691['y'],_0x338b1a=0x0,_0x568ced=_0x1a2a2e[_0x34f8('0xd6')][_0x338b1a][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x338b1a][_0x35dd81]);if(_0x568ced['is_pbr']==![]||_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0xf1')][_0x34f8('0x114')]==0x1)return;if(_0x5ef9bb==PBRTextureMapEnum[_0x34f8('0x118')])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x184')][_0x34f8('0x114')]=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);else{if(_0x5ef9bb==PBRTextureMapEnum['AO'])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x3c')][_0x34f8('0x114')]=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);else{if(_0x5ef9bb==PBRTextureMapEnum[_0x34f8('0x1d1')])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')]['metallic_transform']['value']=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);else{if(_0x5ef9bb==PBRTextureMapEnum['NORMAL'])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x18c')][_0x34f8('0x114')]=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);else{if(_0x5ef9bb==PBRTextureMapEnum[_0x34f8('0x120')])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')]['roughness_transform']['value']=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);else{if(_0x5ef9bb==PBRTextureMapEnum[_0x34f8('0x1ba')])_0x568ced[_0x34f8('0x20')][_0x34f8('0x238')][_0x34f8('0x1a2')][_0x34f8('0x114')]=new _three[(_0x34f8('0xf2'))]()[_0x34f8('0xee')](_0x5bd397,_0x521e4e,_0x1a82a3,0x0,0x0,_0x21dd96,_0x333eb3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0);}}}}}},this[_0x34f8('0x84')]=function(_0xcc890f){_0x1a2a2e[_0x34f8('0x9c')]=_0xcc890f;},this[_0x34f8('0x85')]=function(_0x352372,_0xbc917d){var _0x5ef2d4=0x0,_0x3fafb1=_0x1a2a2e[_0x34f8('0xd6')][_0x5ef2d4][_0x34f8('0xf')](_0x1a2a2e[_0x34f8('0x140')][_0x5ef2d4][_0x352372]);if(_0x3fafb1[_0x34f8('0xa9')]==![])return;_0x3fafb1['is_watch_time_component']=_0xbc917d[_0x34f8('0x22e')],_0x3fafb1[_0x34f8('0x19d')]=_0xbc917d[_0x34f8('0xd5')];},this['SetZoomRatio']=function(_0x254110){return _0x1a2a2e[_0x34f8('0x12a')]=_0x254110;},this[_0x34f8('0x13a')]=function(_0x5c8a5f){return _0x1a2a2e[_0x34f8('0xbc')]=_0x5c8a5f;},this[_0x34f8('0x22a')]=function(_0x2ea4a1){return _0x1a2a2e[_0x34f8('0x1f')]=_0x2ea4a1;};},_temp);exports[_0x34f8('0xa')]=Object3DFirstFilter,module['exports']=exports[_0x34f8('0xa')];

/***/ }),

/***/ 3345:
/***/ (function(module, exports, __webpack_require__) {

var _0xa6d2=['m_scene','m_height','LinearFilter','m_geometry','ResetWidthHeight','frame_height','frameHeight','SetInputTexture','RGBAFormat','SetInputTextureWristOccluder','depthTest','vertexShader','smoothHalfKernel','default','DisposeTexture','frame_width','SetOutputTexture','Scene','RenderFrame','SetHandARMetadata','m_target','wristOccluderTexture','inputImageTexture','SetInputTextureWristOccluderShift','__esModule','m_upsample_factor','fragmentShader','frameWidth','call','m_camera','WebGLRenderTarget','m_mesh','SetShadowOffsetKernelRatio','ShaderMaterial','defineProperty','material','m_shadow_size_factor','wristOccluderShiftTexture','render','m_shadow_offset_kernel_ratio','dispose','m_width','Camera','ring_shadow_smooth_half_kernel','uniforms','input_uniforms','value','PlaneGeometry'];(function(_0x39daef,_0xa6d20a){var _0x2f760d=function(_0x2b3eaa){while(--_0x2b3eaa){_0x39daef['push'](_0x39daef['shift']());}};_0x2f760d(++_0xa6d20a);}(_0xa6d2,0x157));var _0x2f76=function(_0x39daef,_0xa6d20a){_0x39daef=_0x39daef-0x0;var _0x2f760d=_0xa6d2[_0x39daef];return _0x2f760d;};'use strict';Object[_0x2f76('0x1b')](exports,_0x2f76('0x11'),{'value':!![]}),exports['default']=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3346),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x5b915e){return _0x5b915e&&_0x5b915e[_0x2f76('0x11')]?_0x5b915e:{'default':_0x5b915e};}var ShadowSmoothFilter=(_temp=_class=function(_0x4bacf8){(0x0,_inherits3[_0x2f76('0x6')])(_0xe81a31,_0x4bacf8);function _0xe81a31(_0x5cdb63,_0x6ce5cd,_0x1ba400){(0x0,_classCallCheck3['default'])(this,_0xe81a31);var _0x10683d=(0x0,_possibleConstructorReturn3[_0x2f76('0x6')])(this,(_0xe81a31['__proto__']||(0x0,_getPrototypeOf2[_0x2f76('0x6')])(_0xe81a31))[_0x2f76('0x15')](this,_0x5cdb63,_0x6ce5cd));_initialiseProps[_0x2f76('0x15')](_0x10683d),_0x10683d[_0x2f76('0x8')]=_0x5cdb63,_0x10683d[_0x2f76('0x2e')]=_0x6ce5cd,_0x10683d['m_upsample_factor']=_0x1ba400,_0x10683d[_0x2f76('0x1d')]=0x1,_0x10683d[_0x2f76('0x20')]=0x1,_0x10683d[_0x2f76('0x22')]=_0x5cdb63,_0x10683d[_0x2f76('0x2a')]=_0x6ce5cd,_0x10683d[_0x2f76('0x16')]=new _three[(_0x2f76('0x23'))](),_0x10683d['m_target']=new _three[(_0x2f76('0x17'))](_0x5cdb63/_0x10683d[_0x2f76('0x12')]*_0x10683d[_0x2f76('0x1d')],_0x6ce5cd/_0x10683d[_0x2f76('0x12')]*_0x10683d[_0x2f76('0x1d')],{'minFilter':_three[_0x2f76('0x2b')],'magFilter':_three[_0x2f76('0x2b')],'format':_three[_0x2f76('0x1')]}),_0x10683d[_0x2f76('0x2c')]=new _three[(_0x2f76('0x28'))](0x2,0x2);var _0x43c718=new _shader2['default'](),_0x4c3d4b=new _three[(_0x2f76('0x1a'))]({'uniforms':_0x43c718[_0x2f76('0x26')],'vertexShader':_0x43c718[_0x2f76('0x4')],'fragmentShader':_0x43c718[_0x2f76('0x13')]});return _0x10683d[_0x2f76('0x18')]=new _three['Mesh'](_0x10683d[_0x2f76('0x2c')],_0x4c3d4b),_0x10683d[_0x2f76('0x18')]['material'][_0x2f76('0x3')]=![],_0x10683d['m_mesh'][_0x2f76('0x1c')]['depthWrite']=![],_0x10683d[_0x2f76('0x29')]=new _three[(_0x2f76('0xa'))](),_0x10683d['m_scene']['add'](_0x10683d[_0x2f76('0x18')]),_0x10683d;}return _0xe81a31;}(_basefilter2['default']),_initialiseProps=function _initialiseProps(){var _0x32ad73=this;this[_0x2f76('0x0')]=function(_0x5d88a8){return _0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')][_0x2f76('0x25')][_0x2f76('0xf')]['value']=_0x5d88a8;},this[_0x2f76('0x2')]=function(_0x33d00a){return _0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')][_0x2f76('0x25')][_0x2f76('0xe')][_0x2f76('0x27')]=_0x33d00a;},this[_0x2f76('0x10')]=function(_0x436ac5){return _0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')]['uniforms'][_0x2f76('0x1e')][_0x2f76('0x27')]=_0x436ac5;},this[_0x2f76('0x9')]=function(_0x4ebfb5){return _0x32ad73[_0x2f76('0xd')]=_0x4ebfb5;},this[_0x2f76('0xb')]=function(_0x53f7b6,_0x18a560){_0x18a560?_0x53f7b6[_0x2f76('0x1f')](_0x32ad73[_0x2f76('0x29')],_0x32ad73[_0x2f76('0x16')],_0x32ad73[_0x2f76('0xd')],!![]):_0x53f7b6[_0x2f76('0x1f')](_0x32ad73['m_scene'],_0x32ad73[_0x2f76('0x16')]);},this[_0x2f76('0x19')]=function(_0x5997d2){return _0x32ad73[_0x2f76('0x20')]=_0x5997d2;},this[_0x2f76('0xc')]=function(_0x240c20){_0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')][_0x2f76('0x25')][_0x2f76('0x14')]['value']=_0x240c20[_0x2f76('0x8')],_0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')][_0x2f76('0x25')][_0x2f76('0x2f')][_0x2f76('0x27')]=_0x240c20[_0x2f76('0x2e')]*_0x32ad73['m_shadow_size_factor'],_0x32ad73[_0x2f76('0x18')][_0x2f76('0x1c')][_0x2f76('0x25')][_0x2f76('0x5')][_0x2f76('0x27')]=_0x240c20[_0x2f76('0x24')]*_0x32ad73[_0x2f76('0x1d')]*_0x32ad73[_0x2f76('0x20')];},this[_0x2f76('0x2d')]=function(_0x40f25b,_0x418d07,_0x1820cf){_0x32ad73['m_target']!=null&&_0x32ad73['m_target'][_0x2f76('0x21')](),_0x32ad73[_0x2f76('0x22')]=_0x40f25b,_0x32ad73[_0x2f76('0x2a')]=_0x418d07,_0x32ad73['m_upsample_factor']=_0x1820cf,_0x32ad73[_0x2f76('0xd')]=new _three['WebGLRenderTarget'](_0x40f25b/_0x32ad73[_0x2f76('0x12')]*_0x32ad73[_0x2f76('0x1d')],_0x418d07/_0x32ad73[_0x2f76('0x12')]*_0x32ad73[_0x2f76('0x1d')],{'minFilter':_three[_0x2f76('0x2b')],'magFilter':_three[_0x2f76('0x2b')],'format':_three['RGBAFormat']});},this[_0x2f76('0x7')]=function(){};},_temp);exports[_0x2f76('0x6')]=ShadowSmoothFilter,module['exports']=exports[_0x2f76('0x6')];

/***/ }),

/***/ 3346:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x9dab=['\x20\x20\x20\x20sum_of_shift_sil\x20+=\x20texture2D(wristOccluderShiftTexture,\x20textureCoordinate\x20+\x20sample_step).r;','fragmentShader','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','float\x20avg_of_shift_mount\x20=\x20sum_of_shift_mount\x20/\x20float(smoothHalfKernel\x20*\x202.0\x20+\x201.0);','\x20\x20\x20\x20sum_of_shift_mount\x20+=\x20texture2D(wristOccluderShiftTexture,\x20textureCoordinate\x20+\x20sample_step).g;','input_uniforms','join','const\x20int\x20maxSmoothHalfKernel\x20=\x201000;','uniform\x20sampler2D\x20wristOccluderShiftTexture;','uniform\x20float\x20smoothHalfKernel;','\x20\x20\x20\x20if\x20(float(i)\x20>\x202.0\x20*\x20smoothHalfKernel)\x20{break;}','void\x20main()\x20{','vertexShader','uniform\x20float\x20frameHeight;','default','defineProperty','exports','uniform\x20sampler2D\x20wristOccluderTexture;','varying\x20vec2\x20textureCoordinate;','uniform\x20float\x20frameWidth;','float\x20sum_of_shift_mount\x20=\x200.0;','uniform\x20sampler2D\x20inputImageTexture;','gl_FragColor\x20=\x20vec4(avg_of_shift_sil,\x20avg_of_shift_mount,\x20texture2D(wristOccluderShiftTexture,\x20textureCoordinate).ba);','textureCoordinate\x20=\x20uv;','__esModule'];(function(_0xd9c89e,_0x9dab38){var _0x5c670b=function(_0x4fdad7){while(--_0x4fdad7){_0xd9c89e['push'](_0xd9c89e['shift']());}};_0x5c670b(++_0x9dab38);}(_0x9dab,0x9d));var _0x5c67=function(_0xd9c89e,_0x9dab38){_0xd9c89e=_0xd9c89e-0x0;var _0x5c670b=_0x9dab[_0xd9c89e];return _0x5c670b;};'use strict';Object[_0x5c67('0x8')](exports,_0x5c67('0x11'),{'value':!![]}),exports[_0x5c67('0x7')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x4e7bd8){return _0x4e7bd8&&_0x4e7bd8[_0x5c67('0x11')]?_0x4e7bd8:{'default':_0x4e7bd8};}var ShadowSmoothShader=function ShadowSmoothShader(){(0x0,_classCallCheck3[_0x5c67('0x7')])(this,ShadowSmoothShader),this[_0x5c67('0x17')]={'inputImageTexture':{'type':'t','value':null},'wristOccluderTexture':{'type':'t','value':null},'wristOccluderShiftTexture':{'type':'t','value':null},'frameWidth':{'type':'f','value':null},'frameHeight':{'type':'f','value':null},'smoothHalfKernel':{'type':'f','value':null}},this[_0x5c67('0x5')]=[_0x5c67('0xb'),_0x5c67('0x4'),_0x5c67('0x10'),_0x5c67('0x14'),'}'][_0x5c67('0x18')]('\x0a'),this[_0x5c67('0x13')]=[_0x5c67('0xb'),_0x5c67('0xe'),_0x5c67('0xa'),_0x5c67('0x1'),_0x5c67('0xc'),_0x5c67('0x6'),_0x5c67('0x2'),_0x5c67('0x0'),_0x5c67('0x4'),'float\x20sum_of_shift_sil\x20=\x200.0;',_0x5c67('0xd'),'for\x20(int\x20i\x20=\x200;\x20i\x20<=\x20maxSmoothHalfKernel;\x20i++)','{',_0x5c67('0x3'),'\x20\x20\x20\x20vec2\x20sample_step\x20=\x20vec2(0.0,\x20(float(i)\x20-\x20smoothHalfKernel)\x20/\x20frameHeight);',_0x5c67('0x12'),_0x5c67('0x16'),'}','float\x20avg_of_shift_sil\x20=\x20sum_of_shift_sil\x20/\x20float(smoothHalfKernel\x20*\x202.0\x20+\x201.0);',_0x5c67('0x15'),_0x5c67('0xf'),'}'][_0x5c67('0x18')]('\x0a');};exports[_0x5c67('0x7')]=ShadowSmoothShader,module[_0x5c67('0x9')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3347:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x31e2=['uniform\x20vec3\x20diffuseColor;','envCoordinate.y\x20=\x201.\x20-\x20clamp(0.5\x20+\x20r.y\x20/\x202.,\x200.,\x201.);','lightColorDiffuse.xyz\x20=\x20environment.rgb\x20*\x20environmentIntensity\x20\x20+\x20lightColorDiffuse.rgb;','uniform\x20float\x20isNormalMapTexture;','uniform\x20vec3\x20ambientColor;','\x20\x20\x20\x20float\x20curr_local_x_step\x20=\x20clamp(local_pos_x\x20+\x201.0,\x200.0,\x202.0);','rgb\x20=\x20min(rgb,\x20vec3(1.0));','uniform\x20float\x20environmentTileX;','uniform\x20float\x20ring_mount_occlude_left_distance;','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x201)','uniform\x20vec3\x20transmissionFilter;','vec3\x20r\x20=\x20normalize(reflect(normalize(gl_Position.xyz),\x20fragmentNormal)\x20+\x20vec3(0.,\x200.,\x201.));','uniform\x20float\x20isEnvironmentWeightTexture;','rgb\x20=\x20max(rgb,\x20vec3(0.0));','\x20\x20\x20\x20float\x20top\x20=\x20nail_rect.z;','uniform\x20float\x20isRenderSilhouette;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(localPos.z\x20>\x20curr_ring_mount_occlude_distance)','if\x20(isNailMode\x20==\x201.0)','uniform\x20float\x20environmentShiftX;','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(1.0,\x200.0,\x200.0,\x201.0);','uniform\x20sampler2D\x20alphaHistogramTexture;','\x20\x20\x20\x20nail_finish_texture\x20=\x20dot(RGBToY,\x20lightColorDiffuse.rgb);','uniform\x20vec3\x20dynamic_range_offset;','uniform\x20sampler2D\x20specularTexture;','uniform\x20vec4\x20gradient2Factors;','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x201.0,\x200.0,\x201.0);','vertexShader','if\x20(isDiffuseTexture\x20>\x200.0)','uniform\x20float\x20is_dynamic_range;','outputAlpha\x20=\x20lightColorDiffuse.a;','vec2\x20envTextureCoordinate\x20=\x20vec2(envCoordinate.x\x20+\x20environmentShiftX,\x20envCoordinate.y\x20+\x20environmentShiftY);','uniform\x20mediump\x20float\x20zoom_scale_ratio;','\x20\x20\x20\x20gl_Position.z\x20=\x200.8\x20*\x20(gl_Position.z\x20-\x20orig_Position.z)\x20+\x20orig_Position.z;','uniform\x20vec2\x20maxAlphaFactors;','float\x20GetCurrRingMountPosition(float\x20local_pos_x,\x20float\x20mount_occlude_left_distance,\x20float\x20mount_occlude_right_distance)','uniform\x20sampler2D\x20ambientTexture;','uniform\x20float\x20ring_mount_occlude_right_distance;','vec3\x20YUVToRGB(float\x20y,\x20vec2\x20uv)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(1.0,\x201.0,\x200.0,\x201.0);','vec4\x20camCoord\x20=\x20gl_Position;','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x203)','uniform\x20float\x20isEnableGradient1;','uniform\x20vec4\x20gradient1Factors;','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x202)','vec4\x20lightColorDiffuse\x20=\x20vec4(diffuseColor.rgb,\x201.0);','uniform\x20float\x20isRemapAlpha3;','uniform\x20sampler2D\x20normalMapTexture;','uniform\x20mat4\x20normalTransformMatrix;','uniform\x20sampler2D\x20lumaHistogramTexture;','uniform\x20int\x20silhouetteChannel;','if\x20(isLightingAngleClipping\x20>\x200.0)','lightingAngle\x20=\x201.0;','varying\x20vec3\x20localPos;','uniform\x20float\x20isOccluder;','\x20\x20\x20\x20nail_env_map\x20=\x20dot(RGBToY,\x20environment.rgb);','if\x20(isNailMode\x20<\x201.0)','\x20\x20\x20\x20float\x20left\x20=\x20nail_rect.x;','gl_Position\x20=\x20modelViewProjMatrix\x20*\x20vec4(position,\x201.0);','varying\x20vec3\x20fragmentNormal;','\x20\x20\x20\x20float\x20diffuse\x20=\x20abs(dot(unit_fragment_normal,\x20L));','float\x20nail_finish_texture\x20=\x200.0;','\x20\x20\x20\x20float\x20texture_alpha\x20=\x20texture2D(diffuseTexture,\x20textureCoordinate).a;','\x20\x20\x20\x20vec4\x20nailMaskLast3\x20=\x20texture2D(nailMaskLast3Texture,\x20nailMaskTexcoord);','void\x20main()\x20{','exports','return\x20rgb;','if\x20(environmentTileY\x20>\x201.0)','const\x20float\x20lookup_y1\x20=\x201.0\x20/\x206.0;','attribute\x20vec2\x20inputTextureCoordinate;','float\x20lightingAngle\x20=\x20abs(dot(unit_fragment_normal,\x20L));','vec4\x20diffuse\x20=\x20texture2D(diffuseTexture,\x20coord);','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskLast3.g;','\x20\x20\x20\x20}','varying\x20vec2\x20textureCoordinate;','uniform\x20vec3\x20clearColorRatio;','lightColorDiffuse.a\x20=\x201.0;','uniform\x20float\x20transparent;','else\x20if\x20(environmentMode\x20<\x202.0)','uniform\x20float\x20isDiffuseTexture;','lightColorDiffuse\x20=\x20lightColorDiffuse\x20*\x20diffuse;','\x20\x20\x20\x20float\x20diff_mount_occlude_distance_step\x20=\x20(mount_occlude_right_distance\x20-\x20mount_occlude_left_distance)\x20/\x202.0;','environment.rgb\x20=\x20environment.rgb\x20*\x20environment.a;','uniform\x20vec3\x20dynamic_range_compress;','\x20\x20\x20\x20float\x20right\x20=\x20nail_rect.y;','if\x20(isOccluder\x20==\x201.0)','else\x20if\x20(environmentMode\x20<\x203.0)','default','\x20\x20\x20\x20vec2\x20nailMaskTexcoord\x20=\x20vec2(gl_FragCoord.x\x20/\x20frameWidth,\x20gl_FragCoord.y\x20/\x20frameHeight);','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x200.0,\x201.0,\x201.0);','uniform\x20float\x20frameHeight;','uniform\x20vec2\x20targetColor2UV;','const\x20float\x20lookup_y3\x20=\x205.0\x20/\x206.0;','\x20\x20\x20\x20if\x20(is_nail_debug\x20==\x200)','\x20\x20\x20\x20return\x20curr_ring_mount_occlude_distance;','Vector4','uniform\x20float\x20isChangeColor3;','\x20\x20\x20\x20float\x20curr_ring_mount_occlude_distance\x20=\x20mount_occlude_left_distance\x20+\x20curr_local_x_step\x20*\x20diff_mount_occlude_distance_step;','\x20\x20\x20\x20if\x20(nailMaskTexcoord.x\x20<\x20left\x20||\x20nailMaskTexcoord.x\x20>\x20right\x20||\x20nailMaskTexcoord.y\x20<\x20top\x20||\x20nailMaskTexcoord.y\x20>\x20bottom)','textureCoordinate\x20=\x20inputTextureCoordinate;','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x200.0;','else','Vector3','\x20\x20\x20\x20environment.xyz\x20=\x20dynamic_range_offset_environment.xyz\x20+\x20environment.xyz\x20*\x20dynamic_range_compress_environment.x;','uniform\x20mat4\x20projectMatrix;','float\x20GetCurrRingMountPosition(float\x20local_pos_x,\x20float\x20mount_occlude_left_distance,\x20float\x20mount_occlude_right_distance);','\x20\x20\x20\x20\x20\x20\x20\x20outputAlpha\x20=\x20outputAlpha\x20*\x20((nailMask\x20>\x200.0)?\x201.0\x20:\x200.0);','uniform\x20sampler2D\x20diffuseTexture;','envCoordinate.x\x20=\x20clamp(0.75\x20+\x20r.x\x20/\x204.,\x200.,\x201.);','Vector2','uniform\x20float\x20frameWidth;','if\x20(isNailMode\x20==\x201.0\x20&&\x20isNailArt\x20==\x200.0)','const\x20float\x20lookup_y2\x20=\x203.0\x20/\x206.0;','uniform\x20float\x20isLightingAngleClipping;','join','float\x20nail_env_map\x20=\x200.0;','uniform\x20float\x20isNailMode;','\x20\x20\x20\x20if\x20(nailIndex\x20==\x200)','\x20\x20\x20\x20if\x20(silhouetteChannel\x20==\x200\x20&&\x20texture_alpha\x20>\x200.0)','Idiff\x20=\x20clamp(Idiff\x20+\x20ambientColor\x20*\x200.05\x20*\x20outputAlpha,\x200.0,\x201.0);','uniform\x20float\x20isAmbientTexture;','uniform\x20float\x20environmentTileY;','const\x20vec3\x20RGBToY\x20=\x20vec3(0.299,\x200.587,\x200.114);','\x20\x20\x20\x20vec4\x20orig_Position\x20=\x20modelViewProjMatrix\x20*\x20vec4(0.0,\x200.0,\x200.0,\x201.0);','uniform\x20float\x20isEnableGradient2;','\x20\x20\x20\x20vec4\x20nailMaskFirst3\x20=\x20texture2D(nailMaskFirst3Texture,\x20nailMaskTexcoord);','vec3\x20L\x20=\x20vec3(0.0,\x200.0,\x201.0);','fragmentNormal\x20=\x20normalize(transformedNormal.xyz);','envTextureCoordinate.y\x20=\x201.0\x20-\x20fract((1.0\x20-\x20envCoordinate.y)\x20*\x20environmentTileY);','uniform\x20sampler2D\x20environmentTexture;','float\x20outputAlpha\x20=\x20lightColorDiffuse.a;','vec3\x20unit_fragment_normal\x20=\x20normalize(fragmentNormal);','vec3\x20rgb\x20=\x20vec3(y\x20+\x201.402\x20*\x20duv.y,\x20y\x20-\x20dot(vec2(0.344,\x200.714),\x20duv),\x20y\x20+\x201.772\x20*\x20duv.x);','vec2\x20coord\x20=\x20clamp(textureCoordinate\x20+\x20watchTextureCoordinateOffset,\x200.0,\x201.0);','input_uniforms','lightColorDiffuse.xyz\x20=\x20environment.rgb\x20*\x20lightColorDiffuse.rgb\x20*\x20environmentIntensity;','if\x20(is_dynamic_range\x20>\x200.0)','fragmentNormal.x\x20=\x20fragmentNormal.x\x20+\x20gl_Position.x\x20/\x20gl_Position.w\x20/\x205.;','uniform\x20float\x20isRemapAlpha1;','localPos\x20=\x20gl_Position.xyz;','__esModule','fragmentNormal\x20=\x20normalize(fragmentNormal);','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.g;','\x20\x20\x20\x20diffuse.xyz\x20=\x20dynamic_range_offset.xyz\x20+\x20diffuse.xyz\x20*\x20dynamic_range_compress.x;','lightColorDiffuse.xyz\x20=\x20environment.rgb\x20*\x20environmentIntensity\x20\x20-\x20lightColorDiffuse.rgb;','vec2\x20duv\x20=\x20uv\x20-\x200.5;','\x20\x20\x20\x20return;','uniform\x20vec4\x20nail_rect;','uniform\x20float\x20isChangeColor1;','if\x20(environmentTileX\x20>\x201.0)','if\x20(environmentMode\x20<\x201.0)','const\x20float\x20inv_256\x20=\x201.0\x20/\x20256.0;','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.b;','\x20\x20\x20\x20{','vec4\x20transformedNormal\x20=\x20normalTransformMatrix\x20*\x20vec4(normal,\x201.0);','uniform\x20int\x20is_nail_debug;','uniform\x20vec2\x20targetColor3UV;','\x20\x20\x20\x20else\x20if\x20(silhouetteChannel\x20==\x202)','\x20\x20\x20\x20float\x20bottom\x20=\x20nail_rect.w;','Matrix4','\x20\x20\x20\x20Idiff\x20=\x20vec3(nail_finish_texture,\x20nail_env_map,\x20diffuse);','\x20\x20lightColorDiffuse.rgb\x20=\x20lightColorDiffuse.rgb\x20*\x20lightColorDiffuse.a;','if\x20(isRenderSilhouette\x20>\x200.0\x20&&\x20silhouetteChannel\x20>=\x200\x20&&\x20silhouetteChannel\x20<=\x202)','uniform\x20int\x20nailIndex;','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.r;','uniform\x20vec2\x20targetColor1UV;','\x20\x20\x20\x20vec3\x20compress\x20=\x20clamp(dynamic_range_compress\x20*\x201.0,\x200.0,\x201.0);','uniform\x20float\x20isRemapAlpha2;','lightColorDiffuse\x20=\x20lightColorDiffuse\x20*\x20transparent;','varying\x20vec2\x20envCoordinate;','\x20\x20\x20\x20nailMaskTexcoord\x20=\x20(nailMaskTexcoord\x20-\x20vec2(0.5))\x20/\x20vec2(zoom_scale_ratio)\x20+\x20vec2(0.5);'];(function(_0x16dbfd,_0x31e2fa){var _0x248239=function(_0x494207){while(--_0x494207){_0x16dbfd['push'](_0x16dbfd['shift']());}};_0x248239(++_0x31e2fa);}(_0x31e2,0xc4));var _0x2482=function(_0x16dbfd,_0x31e2fa){_0x16dbfd=_0x16dbfd-0x0;var _0x248239=_0x31e2[_0x16dbfd];return _0x248239;};'use strict';Object['defineProperty'](exports,_0x2482('0x71'),{'value':!![]}),exports[_0x2482('0x3c')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0xa1a0c6){return _0xa1a0c6&&_0xa1a0c6['__esModule']?_0xa1a0c6:{'default':_0xa1a0c6};}var Object3DFirstShader=function Object3DFirstShader(){(0x0,_classCallCheck3[_0x2482('0x3c')])(this,Object3DFirstShader),this[_0x2482('0x6b')]={'modelViewProjMatrix':{'type':'m4','value':new _three[(_0x2482('0x84'))]()},'normalTransformMatrix':{'type':'m4','value':new _three[(_0x2482('0x84'))]()},'projectMatrix':{'type':'m4','value':new _three[(_0x2482('0x84'))]()},'isDiffuseTexture':{'type':'f','value':0x0},'isSpecularTexture':{'type':'f','value':0x0},'isAmbientTexture':{'type':'f','value':0x0},'isEnvironmentTexture':{'type':'f','value':0x0},'isEnvironmentWeightTexture':{'type':'f','value':0x0},'isNormalMapTexture':{'type':'f','value':0x0},'diffuseTexture':{'type':'t','value':null},'specularTexture':{'type':'t','value':null},'ambientTexture':{'type':'t','value':null},'environmentTexture':{'type':'t','value':null},'environmentWeightTexture':{'type':'t','value':null},'normalMapTexture':{'type':'t','value':null},'diffuseColor':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'specularColor':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'ambientColor':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'transparent':{'type':'f','value':0x0},'transmissionFilter':{'type':'v3','value':new _three['Vector3'](0x0,0x0,0x0)},'isLightingAngleClipping':{'type':'f','value':0x0},'environmentMode':{'type':'f','value':0x0},'environmentShiftX':{'type':'f','value':0x0},'environmentShiftY':{'type':'f','value':0x0},'environmentTileX':{'type':'f','value':0x0},'environmentTileY':{'type':'f','value':0x0},'environmentIntensity':{'type':'f','value':0x0},'nail_rect':{'type':'v4','value':new _three[(_0x2482('0x44'))](0x0,0x0,0x0,0x0)},'maxAlphaFactors':{'type':'v2','value':new _three[(_0x2482('0x52'))](0x0,0x0)},'isChangeColor1':{'type':'f','value':0x0},'isChangeColor2':{'type':'f','value':0x0},'isChangeColor3':{'type':'f','value':0x0},'targetColor1UV':{'type':'v2','value':new _three['Vector2'](0x0,0x0)},'targetColor2UV':{'type':'v2','value':new _three[(_0x2482('0x52'))](0x0,0x0)},'targetColor3UV':{'type':'v2','value':new _three[(_0x2482('0x52'))](0x0,0x0)},'clearColorRatio':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'isRemapAlpha1':{'type':'f','value':0x0},'isRemapAlpha2':{'type':'f','value':0x0},'isRemapAlpha3':{'type':'f','value':0x0},'isEnableGradient1':{'type':'f','value':0x0},'gradient1Factors':{'type':'v4','value':new _three[(_0x2482('0x44'))](0x0,0x0,0x0,0x0)},'isEnableGradient2':{'type':'f','value':0x0},'gradient2Factors':{'type':'v4','value':new _three[(_0x2482('0x44'))](0x0,0x0,0x0,0x0)},'lumaHistogramTexture':{'type':'t','value':null},'alphaHistogramTexture':{'type':'t','value':null},'isRenderSilhouette':{'type':'f','value':0x0},'silhouetteChannel':{'type':'i','value':-0x1},'silhouetteValue':{'type':'f','value':0x0},'isNailMode':{'type':'f','value':0x1},'isNailArt':{'type':'f','value':0x0},'nailMaskFirst3Texture':{'type':'t','value':null},'nailMaskLast3Texture':{'type':'t','value':null},'nailIndex':{'type':'i','value':-0x1},'frameWidth':{'type':'f','value':0x0},'frameHeight':{'type':'f','value':0x0},'is_nail_debug':{'type':'i','value':0x0},'isOccluder':{'type':'i','value':0x0},'is_dynamic_range':{'type':'f','value':0x0},'dynamic_range_compress':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'dynamic_range_offset':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'dynamic_range_compress_environment':{'type':'v3','value':new _three['Vector3'](0x0,0x0,0x0)},'dynamic_range_offset_environment':{'type':'v3','value':new _three[(_0x2482('0x4b'))](0x0,0x0,0x0)},'zoom_scale_ratio':{'type':'f','value':0x1},'watchTextureCoordinateOffset':{'type':'v2','value':new _three['Vector2'](0x0,0x0)},'ring_mount_occlude_distance':{'type':'f','value':0x3},'ring_mount_occlude_left_distance':{'type':'f','value':1.5},'ring_mount_occlude_right_distance':{'type':'f','value':1.5}},this[_0x2482('0x0')]=[_0x2482('0x2a'),'attribute\x20vec3\x20tangent;',_0x2482('0x2f'),_0x2482('0x20'),_0x2482('0x8e'),_0x2482('0x1a'),'uniform\x20mat4\x20modelViewProjMatrix;',_0x2482('0x15'),_0x2482('0x4d'),_0x2482('0x5'),_0x2482('0x1b'),_0x2482('0x25'),_0x2482('0x1f'),_0x2482('0x70'),_0x2482('0x7f'),_0x2482('0x64'),_0x2482('0x6e'),_0x2482('0x72'),_0x2482('0x48'),_0x2482('0x9b'),_0x2482('0x51'),_0x2482('0x91'),_0x2482('0x3a'),'{',_0x2482('0x60'),_0x2482('0x6'),'}',_0x2482('0xd'),'gl_Position\x20=\x20projectMatrix\x20*\x20camCoord\x20*\x20vec4(zoom_scale_ratio,\x20zoom_scale_ratio,\x201.0,\x201.0);','}']['join']('\x0a'),this['fragmentShader']=[_0x2482('0x34'),'uniform\x20float\x20isSpecularTexture;',_0x2482('0x5d'),'uniform\x20float\x20isEnvironmentTexture;',_0x2482('0x9c'),_0x2482('0x93'),_0x2482('0x50'),_0x2482('0xa7'),_0x2482('0x9'),_0x2482('0x66'),'uniform\x20sampler2D\x20environmentWeightTexture;',_0x2482('0x14'),_0x2482('0x90'),'uniform\x20vec3\x20specularColor;',_0x2482('0x94'),_0x2482('0x32'),_0x2482('0x9a'),_0x2482('0x56'),'uniform\x20float\x20environmentMode;',_0x2482('0xa2'),'uniform\x20float\x20environmentShiftY;',_0x2482('0x97'),_0x2482('0x5e'),'uniform\x20float\x20environmentIntensity;',_0x2482('0x7'),_0x2482('0x79'),'uniform\x20float\x20isChangeColor2;',_0x2482('0x45'),_0x2482('0x8a'),_0x2482('0x40'),_0x2482('0x81'),_0x2482('0x30'),_0x2482('0x6f'),_0x2482('0x8c'),_0x2482('0x13'),_0x2482('0xf'),_0x2482('0x61'),_0x2482('0x10'),_0x2482('0xa8'),_0x2482('0x16'),_0x2482('0xa4'),_0x2482('0x9f'),_0x2482('0x17'),'uniform\x20float\x20silhouetteValue;',_0x2482('0x59'),'uniform\x20float\x20isNailArt;','uniform\x20sampler2D\x20nailMaskFirst3Texture;','uniform\x20sampler2D\x20nailMaskLast3Texture;',_0x2482('0x88'),_0x2482('0x53'),_0x2482('0x3f'),_0x2482('0x80'),_0x2482('0x78'),_0x2482('0x38'),_0x2482('0xa6'),'uniform\x20vec3\x20dynamic_range_compress_environment;','uniform\x20vec3\x20dynamic_range_offset_environment;',_0x2482('0x2'),'uniform\x20vec2\x20watchTextureCoordinateOffset;','uniform\x20float\x20ring_mount_occlude_distance;',_0x2482('0x98'),_0x2482('0xa'),_0x2482('0x5'),_0x2482('0x2f'),'varying\x20vec3\x20fragmentNormal;',_0x2482('0x8e'),_0x2482('0x1a'),_0x2482('0x5f'),_0x2482('0x7c'),_0x2482('0x29'),_0x2482('0x55'),_0x2482('0x41'),_0x2482('0x4e'),_0x2482('0xb'),'{',_0x2482('0x76'),_0x2482('0x69'),_0x2482('0x9d'),_0x2482('0x96'),_0x2482('0x27'),'}',_0x2482('0x25'),_0x2482('0x87'),'{',_0x2482('0x23'),'\x20\x20\x20\x20float\x20curr_ring_mount_occlude_distance\x20=\x20GetCurrRingMountPosition(localPos.x,\x20ring_mount_occlude_left_distance,\x20ring_mount_occlude_right_distance);',_0x2482('0x5b'),_0x2482('0x7e'),_0x2482('0xa3'),_0x2482('0xa0'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(1.0,\x201.0,\x200.0,\x201.0);',_0x2482('0x2e'),'\x20\x20\x20\x20else\x20if\x20(silhouetteChannel\x20==\x201\x20&&\x20texture_alpha\x20>\x200.0)','\x20\x20\x20\x20{',_0x2482('0xa9'),'\x20\x20\x20\x20\x20\x20\x20\x20if\x20(localPos.z\x20>\x20curr_ring_mount_occlude_distance)',_0x2482('0xc'),'\x20\x20\x20\x20}',_0x2482('0x82'),_0x2482('0x3e'),_0x2482('0x77'),'}',_0x2482('0x22'),_0x2482('0x58'),_0x2482('0x12'),_0x2482('0x8d'),_0x2482('0x67'),'if\x20(transparent\x20<\x201.0)\x20lightColorDiffuse.rgb\x20=\x20lightColorDiffuse.rgb\x20*\x20transmissionFilter;',_0x2482('0x1'),'{',_0x2482('0x6a'),_0x2482('0x2c'),_0x2482('0x6d'),'{',_0x2482('0x74'),'}',_0x2482('0x35'),_0x2482('0x1d'),'{',_0x2482('0x86'),'}',_0x2482('0x3'),_0x2482('0x31'),_0x2482('0xa1'),'{',_0x2482('0xa5'),'}','}','if\x20(isEnvironmentTexture\x20>\x200.0\x20&&\x20isNailArt\x20==\x200.0)','{',_0x2482('0x4'),_0x2482('0x7a'),'{','envTextureCoordinate.x\x20=\x20fract(envCoordinate.x\x20*\x20environmentTileX);','}',_0x2482('0x28'),'{',_0x2482('0x65'),'}','vec4\x20environment\x20=\x20texture2D(environmentTexture,\x20envTextureCoordinate);',_0x2482('0x6d'),'{',_0x2482('0x8b'),_0x2482('0x4c'),'}',_0x2482('0xa1'),'{',_0x2482('0x1c'),'}',_0x2482('0x37'),_0x2482('0x7b'),'{','lightColorDiffuse.xyz\x20=\x20environment.rgb\x20*\x20environmentIntensity\x20+\x20lightColorDiffuse.rgb\x20*\x20(1.0\x20-\x20environmentIntensity);','}',_0x2482('0x33'),'{',_0x2482('0x6c'),'}',_0x2482('0x3b'),'{',_0x2482('0x92'),'}',_0x2482('0x4a'),'{',_0x2482('0x75'),'}','}',_0x2482('0x68'),_0x2482('0x63'),_0x2482('0x2b'),_0x2482('0x18'),'{',_0x2482('0x19'),'}','vec3\x20Idiff\x20=\x20lightColorDiffuse.xyz\x20*\x20lightingAngle;',_0x2482('0x5c'),_0x2482('0x54'),'{',_0x2482('0x21'),'\x20\x20\x20\x20diffuse\x20=\x20pow(diffuse,\x2032.0);',_0x2482('0x85'),'}','if\x20(isNailMode\x20==\x201.0)','{',_0x2482('0x3d'),_0x2482('0x8f'),_0x2482('0x62'),_0x2482('0x24'),'\x20\x20\x20\x20float\x20nailMask;',_0x2482('0x5a'),_0x2482('0x89'),_0x2482('0x99'),_0x2482('0x73'),_0x2482('0x11'),_0x2482('0x7d'),_0x2482('0xe'),'\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskLast3.r;','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x204)',_0x2482('0x2d'),_0x2482('0x1e'),_0x2482('0x39'),_0x2482('0x9e'),_0x2482('0x83'),_0x2482('0x47'),_0x2482('0x49'),_0x2482('0x42'),_0x2482('0x4f'),'}','gl_FragColor\x20=\x20vec4(Idiff,\x20outputAlpha);','}','',_0x2482('0x8'),'{',_0x2482('0x95'),_0x2482('0x36'),_0x2482('0x46'),_0x2482('0x43'),'}'][_0x2482('0x57')]('\x0a');};exports['default']=Object3DFirstShader,module[_0x2482('0x26')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3348:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x1096=['\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lumaRatio);','uniform\x20mat4\x20metallic_transform;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20env_uv\x20=\x20GetEquirectUV(normalize(norm_mat\x20*\x20Transpose(smallGemRotationMatrix)\x20*\x20out_dir_rgb[c].rgb),\x20horiOrien,\x20vertOrienSin,\x20vertOrienCos);','\x20\x20\x20\x20return\x20outMatrix;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba\x20=\x20mix(albedo_rgba,\x20vec4(adjusted_nail_color,\x201.0),','\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nailMaskPackage\x20=\x20vec2(0.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20max(customWeight,\x20inverse_tone_mapping),','set','\x20\x20\x20if\x20(is_src_hdr\x20==\x201.0)','\x20\x20\x20}','\x20\x20\x20\x20vec2\x20result\x20=\x20uv\x20-\x20vec2(0.5);','exports','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20max_bounces,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20exposure_multiplier\x20=\x20(0.8\x20+\x20customLightIntensity\x20*\x200.4);','uniform\x20float\x20customLightIntensity;','\x20\x20\x20\x20vec3\x20b\x20=\x20D\x20*\x20color\x20-\x20B;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20frameHeight)','\x20\x20\x20\x20incident\x20=\x20normalize(incident);','\x20\x20\x20\x20vec3\x20color\x20=\x20mix(diffuse_color,\x20background,\x20transmission)\x20+\x20specular_color;','vec2\x20GetEquirectUV(vec3\x20r,\x20float\x20hori_orien,\x20float\x20vert_orien_sin,\x20float\x20vert_orien_cos)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x203,','uniform\x20float\x20isBrdfLutTexture;','\x20\x20\x20\x20\x20\x20\x20if\x20(abs(dot(-in_dir,\x20norm))\x20>\x20cos_critic_angle)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20correct_iters,','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_diff\x20=\x20GetColorRatio(diff_ratio_weight,\x20color_ratio_0,\x20color_ratio_1,\x20color_ratio_2,\x20color_ratio_3);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ao\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20ao_transform[0].x,\x20ao_transform[1].xy,\x20ao_transform[2].xy)).r;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20albedo_rgba\x20=\x20(isAlbedoTexture\x20==\x200.0)?\x20vec4(1.0,\x201.0,\x201.0,\x201.0)\x20:\x20texture2D(albedoTexture,\x20TransformUV(texcoord,\x20albedo_transform[0].x,\x20albedo_scale,\x20albedo_transform[2].xy));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20background,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vertOrienCos,','\x20\x20\x20\x20}','\x20\x20\x20\x20vec3\x20specular\x20=\x20prefiltered_color\x20*\x20(mix(F0,\x20F,\x20fresnelIntensity)\x20*\x20brdf.x\x20+\x20brdf.y);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(nailGlitter\x20>\x200.0)','\x20\x20\x20\x20const\x20float\x20ni\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[1]\x20=\x20refract(in_dir,\x20norm,\x20ior[1]);','\x20\x20\x20\x20return\x20clamp(uv,\x200.0,\x201.0);','\x20\x20\x20if\x20(opaque_pos_rgba.a\x20==\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20frameWidth,','uniform\x20float\x20isOrmTexture;','\x20\x20\x20float\x20n\x20=\x20(-b\x20+\x20sqrt(b\x20*\x20b\x20-\x20a\x20*\x20c))\x20/\x20a;','\x20\x20\x20\x20vec3\x20kD\x20=\x201.0\x20-\x20kS;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else','\x20\x20\x20float\x20b\x20=\x20dot(p,\x20r);','uniform\x20float\x20ring_mount_occlude_right_distance;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo\x20=\x20pow(nail_color,\x20vec3(GAMMA));','\x20\x20\x20\x20result.x\x20=\x20(0.5\x20+\x20uv.x\x20*\x20(width\x20-\x201.0))\x20/\x20width;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_3,','\x20\x20\x20\x20\x20\x20\x20\x20modelViewProjMatrix_\x20=\x20modelViewMatrix;','vec2\x20CorrectUVToPixelCenter(vec2\x20uv,\x20float\x20width,\x20float\x20height)','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20env_color\x20=\x20vec3(0.0);','\x20\x20\x20float\x20a\x20=\x20r.x\x20*\x20r.x\x20+\x20r.y\x20*\x20r.y\x20+\x20r.z\x20*\x20r.z;','\x20\x20\x20\x20T\x20=\x20normalize(T\x20-\x20dot(T,\x20N)\x20*\x20N);','\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20spec_uv\x20=\x20GetEquirectUV(R);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20metallic\x20=\x20metallic_intensity\x20*\x20metallic;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20p\x20=\x20local_pos;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20front_color_uv\x20=\x20GetEquirectUV(front_refl);','\x20\x20\x20\x20vec3\x20B\x20=\x20cross(N,\x20T);','uniform\x20float\x20is_replace_user_polish;','uniform\x20sampler2D\x20rootSourceTexture;','\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(255.0)\x20*\x20rgbe.rgb\x20*\x20pow(vec3(2.0),\x20vec3(rgbe.a\x20*\x20255.0\x20-\x20128.0\x20-\x208.0));','vec2\x20CorrectUVToPixelCenter(vec2\x20uv,\x20float\x20width,\x20float\x20height);','vec2\x20GetNailMaskPackage(sampler2D\x20nailMaskFirst3Texture,','vec2\x20GetEquirectUV(vec3\x20r)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNormalMapTexture\x20>\x200.0\x20&&\x20nailGlitter\x20==\x200.0)','\x20\x20\x20\x20const\x20float\x20y_blend_range\x20=\x200.05;','const\x20float\x20PI\x20=\x203.14159265359;','uniform\x20float\x20isNailMetallic;','\x20\x20\x20\x20\x20\x20\x20\x20rgb_weights[4]\x20=\x20vec3(0.0,\x200.0,\x200.5);','\x20\x20\x20\x20\x20\x20\x20if\x20(i\x20==\x20max_bounces)\x20{break;}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20luma\x20=\x20dot(RGBToY,\x20color);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rootSource.rgb\x20=\x20mix(rootSource.rgb,\x20albedo_rgba.rgb,\x20is_replace_user_polish);','\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20spec_ratio_weight\x20=\x20GetRatioWeight(spec_uv);','uniform\x20int\x20cameraRotation;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lumaRatio);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20local_norm,','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color\x20=\x20mix(env_color,\x20front_refl_color,\x20fresnel);','\x20\x20\x20\x20//\x20HDR\x20tone\x20mapping\x20and\x20gamma\x20correction','uniform\x20float\x20maxLuma;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20cameraRotation,','defineProperty','\x20\x20\x20\x20vec3\x20F0\x20=\x20vec3(0.04);','uniform\x20vec3\x20colorRatio3;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ior[NUM_DISPER],','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_tip\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20out_dir\x20=\x20DiamondBounceRay(gemLocalPos,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20isCameraFront,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_2,','\x20\x20\x20\x20\x20\x20\x20vec4\x20ldr\x20=\x20texture2D(texture,\x20coord);','default','uniform\x20mat4\x20projectMatrix;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20d_\x20=\x20vec3(0.0);','\x20\x20\x20\x20float\x20x_line\x20=\x200.25;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(apply_pbr\x20==\x200)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20horiOrien,','\x20\x20\x20\x20\x20\x20\x20\x20env_color\x20=\x20env_color\x20*\x20(gemColor\x20+\x20absorb\x20*\x20pow(2.71828,\x20-gemAbsorption\x20*\x20out_dir.a\x20/\x20obj_size));','vec3\x20AdjustTransmittedOutputDirection(vec3\x20out_dir,\x20vec3\x20out_pos,\x20sampler2D\x20opaque_pos_env,\x20vec3\x20pos_scale,\x20vec3\x20pos_shift);','\x20\x20\x20\x20if\x20(isColorRatio\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(silhouetteChannel\x20==\x200\x20&&\x20texture_alpha\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20=\x20mix(albedo_rgba.rgb,\x20rootSource.rgb,','uniform\x20float\x20inverse_tone_mapping;','vec4\x20GetRatioWeight(vec2\x20pos)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20worldCoordinate,','\x20\x20\x20\x20float\x20x0\x20=\x20uv0.x\x20*\x20pow(0.5,\x20l0);','fragmentShader','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20brdf_lut,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x201.0,','\x20\x20\x20\x20float\x20y1\x20=\x201.0\x20-\x20(2.0\x20-\x20uv1.y)\x20*\x20pow(0.5,\x20l1\x20+\x201.0);','\x20\x20\x20\x20vec3\x20luma_color\x20=\x20vec3(0.0,\x200.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20specular_multiplier,','#define\x20GAMMA\x202.2','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20metallic,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ao,','\x20\x20\x20\x20\x20\x20\x20\x20color\x20*=\x20exposure;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(dot(n,\x20ld)\x20==\x200.0)','\x20\x20\x20\x20vec2\x20uv1\x20=\x20CorrectUVToPixelCenter(coord,\x20w1,\x20w1\x20*\x200.5);','float\x20GetCurrRingMountPosition(float\x20local_pos_x,\x20float\x20mount_occlude_left_distance,\x20float\x20mount_occlude_right_distance);','\x20\x20\x20for\x20(int\x20i\x20=\x200;\x20i\x20<\x20MAXBOUNCESITERS;\x20i++)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ao\x20=\x20ao_intensity\x20*\x20mix(_ao,\x20mix(1.0,\x20_ao,\x20customContrast),\x20customWeight);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20background\x20=\x20InvACESToneMapping(background);','vec3\x20InvACESToneMapping(vec3\x20color);','\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20diff\x20=\x201.0\x20/\x20float(NUM_DISPER\x20-\x201);','\x20\x20\x20\x20float\x20NdotL\x20=\x20max(dot(N,\x20L),\x200.0);','vec4\x20HDRTexture2D(sampler2D\x20texture,\x20vec2\x20coord,\x20float\x20is_src_hdr);','uniform\x20float\x20customReflection;','uniform\x20float\x20customShimmerScale;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rootSourceTexcoord,','\x20\x20\x20\x20vec3\x20diffuse\x20=\x20irradiance\x20*\x20albedo;','\x20\x20\x20\x20if\x20(is_inv_tonemap_albedo\x20==\x201.0)','uniform\x20vec3\x20colorRatio1;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio0,','\x20\x20\x20\x20\x20\x20\x20\x20diffuse\x20*=\x20maxLuma;','const\x20vec3\x20RGBToY\x20=\x20vec3(0.299,\x200.587,\x200.114);','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x204)','\x20\x20\x20\x20cameraPos\x20=\x20vec3(0.0);','\x20\x20\x20\x20return\x200.5\x20*\x20(rs\x20+\x20rp);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x201.0,','uniform\x20float\x20customMetallic;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3(i0.y,\x20i1.y,\x20i2.y),','uniform\x20mat4\x20albedo_transform;','\x20\x20\x20\x20float\x20zoom_scale_ratio_\x20=\x20zoom_scale_ratio;','\x20\x20\x20\x20vec3\x20R\x20=\x20reflect(-V,\x20N);','__esModule','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20zoom_scale_ratio,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20out_pos;','\x20\x20\x20\x20float\x20ggx1\x20=\x20GeometrySchlickGGX(NdotL,\x20roughness);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.a\x20=\x20mix(1.0,\x20albedo_rgba.a,\x20is_nail_tip);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','Matrix4','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20transmission,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20float\x20nom\x20=\x20a2;','\x20\x20\x20\x20vec4\x20worldCoord\x20=\x20modelViewProjMatrix_\x20*\x20vec4(position,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20diffuse_multiplier\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20\x20luma_color\x20=\x20(kD\x20*\x20mix(luma_diffuse,\x20background,\x20transmission)\x20*\x20is_ibl_diff\x20+\x20luma_specular\x20*\x20is_ibl_spec)\x20*\x20ao;','\x20\x20\x20\x20\x20\x20\x20vec3\x20norm\x20=\x20texture2D(norm_env,\x20norm_env_uv).rgb\x20*\x202.0\x20-\x201.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20customWeight\x20*\x20customTransparency);','uniform\x20float\x20vertOrienCos;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20backgroundTexcoord\x20=\x20vec2(gl_FragCoord.x\x20/\x20frameWidth,\x20gl_FragCoord.y\x20/\x20frameHeight);','vec3\x20FresnelSchlick(float\x20cosTheta,\x20vec3\x20F0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ao,','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskLast3.r;','\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20c\x20=\x200;\x20c\x20<\x20NUM_DISPER;\x20c++)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20pos_shift,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20frameHeight);','\x20\x20\x20float\x20cos_critic_angle\x20=\x20cos(asin(1.0\x20/\x20ior[2]));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20d_\x20=\x20normalize(p\x20+\x20ld\x20*\x20t);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vertOrienCos,','float\x20GeometrySmith(vec3\x20N,\x20vec3\x20V,\x20vec3\x20L,\x20float\x20roughness)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo,','\x20\x20\x20\x20\x20\x20\x20\x20specular\x20*=\x20maxLuma;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20env_color_ratio\x20=\x20GetColorRatio(ratio_weight,\x20colorRatio0,\x20colorRatio1,\x20colorRatio2,\x20colorRatio3);','\x20\x20\x20\x20localPos\x20=\x20position;','\x20\x20\x20\x20result.y\x20=\x20(0.5\x20+\x20uv.y\x20*\x20(height\x20-\x201.0))\x20/\x20height;','vertexShader','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20hori_orien,','uniform\x20float\x20isNailMode;','\x20\x20\x20\x20\x20\x20\x20\x20else\x20if\x20(silhouetteChannel\x20==\x201\x20&&\x20texture_alpha\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20apply_inverse_tone_mapping\x20=\x200.0;','\x20\x20\x20\x20vec4\x20blend_range\x20=\x20vec4(-x_blend_range,\x20x_blend_range,\x20-y_blend_range,\x20y_blend_range);','vec3\x20FresnelSchlick(float\x20cosTheta,\x20vec3\x20F0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20=\x20mix(albedo_rgba.rgb,\x20adjusted_nail_color,\x20customWeight\x20*\x20(1.0\x20-\x20isNailArt));','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20out_dir_rgb[NUM_DISPER];','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nailIndex,','\x20\x20\x20\x20float\x20nt\x20=\x20ior;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20mix(vec3(0.0,\x200.0,\x201.0),\x20normalM,\x20normal_intensity);','vec3\x20FresnelSchlickRoughness(float\x20cosTheta,\x20vec3\x20F0,\x20float\x20roughness)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20cameraRotation,','uniform\x20float\x20albedo_intensity;','uniform\x20float\x20frameWidth;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color\x20=\x20albedoColor\x20*\x20color;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(silhouetteValue,\x201.0,\x200.0,\x201.0);','\x20\x20\x20\x20vec4\x20c0\x20=\x20texture2D(texture,\x20vec2(x0,\x20y0));','\x20\x20\x20\x20const\x20float\x20C\x20=\x202.43;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rootSourceTexcoord,','\x20\x20\x20float\x20c\x20=\x20(p.x\x20*\x20p.x\x20+\x20p.y\x20*\x20p.y\x20+\x20p.z\x20*\x20p.z)\x20-\x20d\x20*\x20d;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio2,','\x20\x20\x20\x20\x20\x20\x20\x20color\x20=\x20pow(color,\x20vec3(1.0\x20/\x20GAMMA));','\x20\x20\x20\x20worldCoordinate\x20=\x20(is_render_opaque_object_env\x20==\x201.0\x20||\x20is_render_opaque_pos_env\x20==\x201.0)?\x20position.xyz\x20:\x20worldCoord.xyz;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(localPos.z\x20>\x20curr_ring_mount_occlude_distance)','uniform\x20sampler2D\x20opaquePosTexture;','\x20\x20\x20\x20float\x20sv\x20=\x20vert_orien_sin;','\x20\x20\x20\x20float\x20rp\x20=\x20pow((ni\x20*\x20ct\x20-\x20nt\x20*\x20ci)\x20/\x20(ni\x20*\x20ct\x20+\x20nt\x20*\x20ci),\x202.0);','\x20\x20\x20\x20\x20\x20\x20if\x20(correct_iters\x20>\x200)','\x20\x20\x20\x20float\x20l0\x20=\x20floor(lod);','uniform\x20sampler2D\x20nailMaskFirst3Texture;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20clamp(mix(normalM,\x20vec3(0.5,0.5,1.0),\x20(1.0\x20-\x202.0\x20*\x20customNormalWeight)\x20*\x20customWeight),\x200.0,\x201.0);','uniform\x20float\x20isHDREnvMap;','uniform\x20vec3\x20gemCenter;','\x20\x20\x20\x20vec3\x20V\x20=\x20normalize(cam_pos\x20-\x20world_pos);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo,','\x20\x20\x20vec3\x20opaque_pos\x20=\x20opaque_pos_rgba.rgb\x20*\x20pos_scale\x20-\x20pos_shift;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20luma_ratio_spec\x20=\x20dot(spec_ratio_weight,\x20luma_ratio);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20albedo_luma\x20=\x200.299\x20*\x20albedo_rgba.r\x20+\x200.587\x20*\x20albedo_rgba.g\x20+\x200.114\x20*\x20albedo_rgba.b;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20t\x20=\x20(dot(n,\x20q)\x20-\x20dot(n,\x20p))\x20/\x20dot(n,\x20ld);','vec2\x20GetEquirectUV(vec3\x20r,\x20float\x20hori_orien,\x20float\x20vert_orien_sin,\x20float\x20vert_orien_cos);','uniform\x20float\x20customTransparency;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20nail_rect,','\x20\x20\x20\x20\x20\x20\x20\x20}','uniform\x20float\x20gemAbsorption;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20albedo\x20=\x20pow(albedo_rgba.rgb,\x20vec3(GAMMA));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color\x20=\x20MTPBR(frag_normal,','uniform\x20float\x20isEnableMirrorHDR;','\x20\x20\x20\x20\x20\x20\x20out_dir\x20=\x20reflect(in_dir,\x20norm);','uniform\x20sampler2D\x20environmentTexture;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color\x20=\x20MTPBR(frag_normal,','\x20\x20\x20\x20vec3\x20F\x20=\x20FresnelSchlickRoughness(max(dot(N,\x20V),\x200.0),\x20F0,\x20roughness);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20roughness,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transmission\x20*=\x20transmission_intensity;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20nailMaskLast3Texture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMode\x20!=\x201.0\x20||\x20is_nail_design\x20==\x201)','uniform\x20mat3\x20smallGemRotationMatrix;','#endif','\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(0.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20_roughness\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20roughness_transform[0].x,\x20roughness_transform[1].xy,\x20roughness_transform[2].xy)).g;','\x20\x20\x20\x20float\x20denom\x20=\x20NdotV\x20*\x20(1.0\x20-\x20k)\x20+\x20k;','Matrix3','\x20\x20\x20\x20\x20\x20\x20\x20diffuse\x20*=\x20luma_ratio_diff\x20*\x20color_ratio_diff;','\x20\x20\x20\x20\x20\x20\x20\x20luma_color\x20=\x20pow(luma_color,\x20vec3(1.0\x20/\x20GAMMA));','vec4\x20GetRatioWeight(vec2\x20pos);','\x20\x20\x20\x20float\x20diff_mount_occlude_distance_step\x20=\x20(mount_occlude_right_distance\x20-\x20mount_occlude_left_distance)\x20/\x202.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20opaque_env_uv\x20=\x20GetEquirectUV(opaque_dir);','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMode\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio1,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20nailIndex,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20incident,','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20front_refl\x20=\x20reflect(view,\x20norm);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20isCameraFront,','\x20\x20\x20\x20\x20\x20\x20\x20albedo\x20=\x20InvACESToneMapping(albedo);','\x20\x20\x20\x20if\x20(r\x20>\x200.0)','varying\x20vec3\x20gemLocalPos;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else\x20if\x20(is_nail_tip\x20==\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(0.0,\x201.0,\x200.0,\x200.0),','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20background\x20=\x20pow(background,\x20vec3(GAMMA));','uniform\x20float\x20frameHeight;','\x20\x20\x20\x20\x20\x20\x20\x20rootSourceTexcoord\x20=\x20(rootSourceTexcoord\x20-\x20vec2(0.5))\x20/\x20vec2(zoom_scale_ratio)\x20+\x20vec2(0.5);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ao\x20=\x20mix(1.0,\x20_ao,\x20customContrast);','varying\x20vec3\x20localNorm;','\x20\x20\x20\x20\x20\x20\x20\x20normalTransformMatrix_[2][1]\x20/=\x20z_scale;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_0,','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.r;','\x20\x20\x20\x20vec3\x20prefiltered_color\x20=\x20RGBEToFloat(TextureLOD(ibl_map,\x20ibl_spec_uv,\x20roughness\x20*\x204.0));','\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20rootSource\x20=\x20texture2D(rootSourceTexture,\x20rootSourceTexcoord);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20metallic\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20metallic_transform[0].x,\x20metallic_transform[1].xy,\x20metallic_transform[2].xy)).b;','uniform\x20mat4\x20roughness_transform;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20texture2D(normalMapTexture,\x20TransformUV(texcoord,\x200.0,\x20vec2(1.0\x20/\x200.15),\x20vec2(0.0))).rgb;','float\x20GeometrySmith(vec3\x20N,\x20vec3\x20V,\x20vec3\x20L,\x20float\x20roughness);','\x20\x20\x20\x20\x20\x20\x20\x20normalTransformMatrix_[2][0]\x20/=\x20z_scale;','\x20\x20\x20\x20uv.y\x20=\x201.0\x20-\x20uv.y;','input_uniforms','uniform\x20float\x20vertOrien;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20color_Y\x20=\x20dot(RGBToY,\x20color);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20specular_multiplier\x20=\x20customReflection;','uniform\x20mat4\x20modelViewProjMatrix;','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x203)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20customWeight\x20*\x20customTransparency);','\x20\x20\x20\x20const\x20float\x20x_blend_range\x20=\x200.025;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else','float\x20GetCurrRingMountPosition(float\x20local_pos_x,\x20float\x20mount_occlude_left_distance,\x20float\x20mount_occlude_right_distance)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transmission,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ior[i]\x20=\x20max(1.0,\x20gemIOR\x20+\x202.0\x20*\x20gemDispersion\x20*\x20(-0.5\x20+\x20float(i)\x20*\x20diff));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20frag_normal\x20=\x20normalize(frag_normal);','const\x20int\x20MAXCORRECTITERS\x20=\x203;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20adjusted_nail_color\x20=\x20mix(adjusted_nail_color,\x20\x20rootSource.rgb,\x20customTransparency);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(0.0,\x200.0,\x201.0,\x200.0),','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[j]\x20=\x20out_dir;','\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20diff_ratio_weight\x20=\x20GetRatioWeight(diff_uv);','uniform\x20float\x20isGem;','\x20\x20\x20\x20\x20\x20\x20local_pos\x20=\x20hit;','vec4\x20TextureLOD(sampler2D\x20texture,\x20vec2\x20coord,\x20float\x20lod);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20opaque_rgba\x20=\x20vec4(0.0);','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x200.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20q\x20=\x20texture2D(pos_env,\x20env_uv).rgb\x20*\x20pos_scale\x20-\x20pos_shift;','uniform\x20float\x20transmission_intensity;','\x20\x20\x20vec3\x20in_dir\x20=\x20refract(incident,\x20local_norm,\x201.0\x20/\x20ior[2]);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roughness\x20=\x20roughness_intensity\x20*\x20mix(_roughness,\x20customRoughness,\x20customWeight);','\x20\x20\x20\x20float\x20w0\x20=\x20environmentWidth\x20*\x20pow(0.5,\x20l0);','\x20\x20\x20else','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20background,','uniform\x20mediump\x20float\x20zoom_scale_ratio;','uniform\x20vec3\x20gemPosShift;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(albedoTexture,\x20TransformUV(texcoord,\x20albedo_transform[0].x,\x20albedo_transform[1].xy,\x20albedo_transform[2].xy));','\x20\x20\x20\x20\x20\x20\x20\x20projectMatrix_\x20=\x20projectionMatrix;','\x20\x20\x20\x20return\x20mix(c0,\x20c1,\x20lod\x20-\x20l0);','vec3\x20ACESToneMapping(vec3\x20color)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color.rgb\x20=\x20mix(color.rgb,\x20vec3(outputAlpha),\x20outputAlpha);','\x20\x20\x20\x20normal\x20=\x20normalize(normal);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20=\x20mix(rootSource.rgb,\x20albedo_rgba.rgb,\x20albedo_rgba.a);','\x20\x20\x20\x20if\x20(isNailMode\x20==\x201.0\x20&&\x20isNailMetallic\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20albedo,','\x20\x20\x20\x20\x20\x20\x20\x20luma_color\x20=\x20ACESToneMapping(luma_color);','Vector4','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x20silhouetteValue,\x200.0,\x201.0);','uniform\x20vec3\x20cube_camera_position;','\x20\x20\x20\x20color\x20=\x20pow(color,\x20vec3(1.0\x20/\x20GAMMA));','\x20\x20\x20\x20if\x20(nailIndex\x20==\x200)','uniform\x20vec3\x20opaque_pos_scale;','\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20j\x20=\x200;\x20j\x20<\x20NUM_DISPER;\x20j++)','\x20\x20\x20\x20float\x20ao_x_exposure\x20=\x20ao\x20*\x20exposure;','varying\x20vec3\x20cameraPos;','uniform\x20float\x20nailGlitter;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo.rgb\x20*=\x20albedo_intensity;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nail_rect,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMode\x20==\x201.0\x20&&\x20nail_rect.y\x20-\x20nail_rect.x\x20>\x200.999\x20&&\x20nail_rect.w\x20-\x20nail_rect.z\x20>\x200.999)','vec3\x20MTPBR(vec3\x20norm,','uniform\x20mat4\x20normal_transform;','uniform\x20float\x20customWeight;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opaque_rgba\x20=\x20HDRTexture2D(normalMapTexture,\x20opaque_env_uv,\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20opaque_dir\x20=\x20AdjustTransmittedOutputDirection(out_dir_rgb[c].rgb,\x20out_pos,\x20opaquePosTexture,\x20gemPosScale\x20*\x20OPAQUE_SCALE,\x20gemPosShift\x20*\x20OPAQUE_SCALE);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20pos_scale,','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20front_refl_color\x20=\x20HDRTexture2D(environmentTexture,\x20front_refl_uv,\x20isHDREnvMap).rgb\x20*\x20front_color_ratio;','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x201.0);','\x20\x20\x20\x20mat4\x20projectMatrix_\x20=\x20projectMatrix;','\x20\x20\x20\x20vec4\x20nailMaskLast3\x20=\x20texture2D(nailMaskLast3Texture,\x20rootSourceTexcoord);','uniform\x20float\x20is_nail_tip;','\x20\x20\x20\x20const\x20float\x20E\x20=\x200.14;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_pos);','\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[4]\x20=\x20(abs(dot(-in_dir,\x20norm))\x20>\x20cos(asin(1.0\x20/\x20ior[4])))?\x20refract(in_dir,\x20norm,\x20ior[4])\x20:\x20out_dir_rgb[2];','\x20\x20\x20\x20float\x20top\x20=\x20nail_rect.z;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x200.0,\x20silhouetteValue,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20env_color_ratio\x20=\x20vec3(1.0,\x201.0,\x201.0);','uniform\x20float\x20is_render_opaque_pos_env;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20customWeight\x20*\x20(1.0\x20-\x20isNailArt));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nailMaskLast3Texture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio0,','uniform\x20mat4\x20transmission_transform;','uniform\x20int\x20gemBounces;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20normalM\x20*\x202.0\x20-\x201.0;','\x20\x20\x20\x20vec3\x20diffuse_color\x20=\x20kD\x20*\x20diffuse\x20*\x20is_ibl_diff\x20*\x20ao_x_exposure;','\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20diff_uv\x20=\x20GetEquirectUV(N);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20absorb\x20=\x201.0\x20-\x20gemColor;','\x20\x20\x20\x20const\x20float\x20D\x20=\x200.59;','\x20\x20\x20\x20uv\x20*=\x20vec2(0.5,\x201.0)\x20*\x20PI_INV;','\x20\x20\x20\x20result\x20+=\x20vec2(0.5);','\x20\x20\x20\x20//\x20ambient\x20lighting\x20(we\x20now\x20use\x20IBL\x20as\x20the\x20ambient\x20term)','const\x20float\x20PI_INV\x20=\x201.0\x20/\x20PI;','\x20\x20\x20\x20float\x20left\x20=\x20nail_rect.x;','uniform\x20vec3\x20albedoColor;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out\x20vec3\x20out_dir_rgb[NUM_DISPER],','\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20z_scale\x20=\x202.0;','\x20\x20\x20\x20localNorm\x20=\x20normal;','uniform\x20float\x20customRoughness;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20diffuse_multiplier,','\x20\x20\x20\x20\x20\x20\x20\x20uv.x\x20=\x20abs(abs(abs(uv.x\x20-\x200.25)\x20-\x200.25)\x20-\x200.25)\x20+\x200.75;','vec2\x20TransformUV(vec2\x20uv,\x20float\x20r,\x20vec2\x20s,\x20vec2\x20t);','\x20\x20\x20\x20else\x20if\x20(isGem\x20==\x201.0)','\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gemBounces,','\x20\x20\x20vec3\x20out_dir\x20=\x20in_dir;','\x20\x20\x20\x20const\x20float\x20B\x20=\x200.03;','\x20\x20\x20\x20\x20\x20\x20\x20result\x20=\x20vec2(cos(r)\x20*\x20result.x\x20-\x20sin(r)\x20*\x20result.y,\x20sin(r)\x20*\x20result.x\x20+\x20cos(r)\x20*\x20result.y);','\x20\x20\x20\x20return\x20curr_ring_mount_occlude_distance;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.a\x20*=\x20(mix(1.0,\x20luma,\x20nailGlitter)\x20*\x20customGlitterOpacity);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20inverse_tone_mapping,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20luma_ratio);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20outputAlpha\x20=\x20albedo_rgba.a;','float\x20GeometrySchlickGGX(float\x20NdotV,\x20float\x20roughness);','uniform\x20mat4\x20ao_transform;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sky_rgb\x20=\x20HDRTexture2D(environmentTexture,\x20env_uv,\x20isHDREnvMap).rgb;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20fresnel\x20=\x20Reflectance(view,\x20norm,\x20gemIOR)\x20*\x20fresnelIntensity;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vertOrienSin,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio3,','\x20\x20\x20\x20uv.xz\x20=\x20clamp((xy.yw\x20-\x20pos.xy)\x20/\x20(xy.yw\x20-\x20xy.xz),\x200.0,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(-cube_camera_position,\x201.0));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20background\x20=\x20texture2D(rootSourceTexture,\x20backgroundTexcoord).rgb;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[2]\x20=\x20refract(in_dir,\x20norm,\x20ior[2]);','Vector3','\x20\x20\x20\x20vec2\x20uv\x20=\x20vec2(atan(r_.z,\x20r_.x),\x20asin(r_.y));','varying\x20vec3\x20fragmentNormal;','\x20\x20\x20\x20return\x20vec2(nailMask,\x20nailMask\x20/\x20max_mask\x20>\x200.99\x20?\x201.0:\x200.0);','uniform\x20float\x20customNormalWeight;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20environmentTexture,','\x20\x20\x20\x20vec2\x20uv\x20=\x20vec2(atan(r.z,\x20r.x),\x20asin(r.y));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20albedo_rgba\x20=\x20(isAlbedoTexture\x20==\x200.0)?','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20albedo;','\x20\x20\x20\x20float\x20w1\x20=\x20environmentWidth\x20*\x20pow(0.5,\x20l1);','\x20\x20\x20\x20return\x20weight.x\x20*\x20color_ratio_0\x20+\x20weight.y\x20*\x20color_ratio_1\x20+\x20weight.z\x20*\x20color_ratio_2\x20+\x20weight.w\x20*\x20color_ratio_3;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20mix(ao,\x201.0,\x20(1.0\x20-\x20customContrast)\x20*\x20customWeight),','\x20\x20\x20\x20uv\x20+=\x200.5;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20outputAlpha\x20=\x20albedo_rgba.a\x20*\x20nailMaskPackage.y;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20albedo_scale\x20=\x20albedo_transform[1].xy;','\x20\x20\x20\x20\x20\x20\x20out_pos\x20=\x20hit;','\x20\x20\x20\x20\x20\x20\x20\x20zoom_scale_ratio_\x20=\x201.0;','\x20\x20\x20\x20gemLocalPos\x20=\x20smallGemRotationMatrix\x20*\x20(position.xyz\x20-\x20gemCenter);','\x20\x20\x20\x20result\x20*=\x20s;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isColorRatio\x20>\x200.0)','uniform\x20vec3\x20nail_color;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x202)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sd\x20=\x20d_;','join','uniform\x20vec3\x20colorRatio0;','float\x20DistributionGGX(vec3\x20N,\x20vec3\x20H,\x20float\x20roughness)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gemLocalNorm,','\x20\x20\x20\x20vec4\x20c1\x20=\x20texture2D(texture,\x20vec2(x1,\x20y1));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20frag_normal\x20=\x20normalize(fragmentNormal);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20ratio_weight\x20=\x20GetRatioWeight(env_color_uv);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20view\x20=\x20normalize(worldCoordinate);','\x20\x20\x20\x20\x20\x20\x20ldr.rgb\x20=\x20pow(ldr.rgb,\x20vec3(GAMMA));','\x20\x20\x20\x20\x20\x20\x20\x20float\x20obj_size\x20=\x20max(gemPosScale.x,\x20max(gemPosScale.y,\x20gemPosScale.z));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isSmallGem\x20==\x200.0)','\x20\x20\x20\x20if\x20(pos.x\x20>\x200.5)','uniform\x20vec3\x20opaque_pos_shift;','\x20\x20\x20\x20if\x20(isRenderSilhouette\x20>\x200.0\x20&&\x20silhouetteChannel\x20>=\x200\x20&&\x20silhouetteChannel\x20<=\x202)','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20luma_specular\x20=\x20specular\x20*\x20luma_ratio_spec;','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.g;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20env_color\x20+=\x20mix(sky_rgb\x20*\x20env_color_ratio,\x20opaque_rgba.rgb,\x20opaque_rgba.a)\x20*\x20rgb_weights[c];','uniform\x20float\x20exposure;','\x20\x20\x20vec3\x20p\x20=\x20out_pos;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','varying\x20vec3\x20localPos;','vec3\x20GetColorRatio(vec4\x20weight,\x20vec3\x20color_ratio_0,\x20vec3\x20color_ratio_1,\x20vec3\x20color_ratio_2,\x20vec3\x20color_ratio_3);','uniform\x20int\x20is_nail_design;','#define\x20MAX_INV_TONEMAP_VALUE\x207.243','\x20\x20\x20\x20return\x20nom\x20/\x20denom;','vec2\x20GetEquirectUV(vec3\x20r);','\x20\x20\x20\x20float\x20a2\x20=\x20a\x20*\x20a;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20adjusted_nail_color\x20=\x20mix(nail_color,\x20rootSource.rgb,\x20customTransparency);','\x20\x20\x20\x20ibl_diff_uv\x20=\x20CorrectUVToPixelCenter(ibl_diff_uv,\x20environmentWidth\x20*\x200.25,\x20environmentWidth\x20*\x200.125);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transmission,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3(0.0,\x200.0,\x200.0),','vec4\x20HDRTexture2D(sampler2D\x20texture,\x20vec2\x20coord,\x20float\x20is_src_hdr)','\x20\x20\x20\x20textureCoordinate\x20=\x20inputTextureCoordinate;','\x20\x20\x20\x20\x20\x20\x20\x20pos.x\x20=\x201.0\x20-\x20pos.x;','\x20\x20\x20\x20return\x20color;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3(0.0),','\x20\x20\x20\x20float\x20a\x20=\x20roughness\x20*\x20roughness;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio0,','\x20\x20\x20\x20vec3\x20i0\x20=\x20inMatrix[0];','\x20\x20\x20\x20return\x20ggx1\x20*\x20ggx2;','\x20\x20\x20\x20vec4\x20weight\x20=\x20uv.xyxy\x20*\x20uv.zzww;','#define\x20OPAQUE_SCALE\x205.0','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20pos_env,','\x20\x20\x20\x20ibl_diff_uv\x20=\x20vec2(0.75\x20+\x20ibl_diff_uv.x\x20*\x200.25,\x200.875\x20+\x20ibl_diff_uv.y\x20*\x200.125);','\x20\x20\x20\x20\x20\x20\x20\x20modelViewProjMatrix_[2][2]\x20*=\x20z_scale;','uniform\x20mat4\x20normalTransformMatrix;','uniform\x20float\x20is_render_opaque_object_env;','\x20\x20\x20\x20if\x20(rgbe.a\x20==\x200.0)','uniform\x20float\x20horiOrien;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedoTexture,','\x20\x20\x20\x20float\x20nailMask;','\x20\x20\x20\x20const\x20float\x20A\x20=\x202.51;','\x20\x20\x20\x20return\x20F0\x20+\x20(1.0\x20-\x20F0)\x20*\x20pow(clamp(1.0\x20-\x20cosTheta,\x200.0,\x201.0),\x205.0);','\x20\x20\x20\x20\x20\x20\x20\x20float\x20curr_ring_mount_occlude_distance\x20=\x20GetCurrRingMountPosition(localPos.x,\x20ring_mount_occlude_left_distance,\x20ring_mount_occlude_right_distance);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20brdfLutTexture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nailMaskPackage\x20=\x20GetNailMaskPackage(nailMaskFirst3Texture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio1,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio2,','uniform\x20vec2\x20watchTextureCoordinateOffset;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMode\x20==\x201.0\x20&&\x20is_nail_tip\x20==\x200.0\x20&&\x20nail_rect.y\x20-\x20nail_rect.x\x20>\x200.999\x20&&\x20nail_rect.w\x20-\x20nail_rect.z\x20>\x200.999)','\x20\x20\x20\x20vec3\x20r_\x20=\x20mat_v\x20*\x20r;','\x20\x20\x20\x20vec2\x20uv0\x20=\x20CorrectUVToPixelCenter(coord,\x20w0,\x20w0\x20*\x200.5);','#ifdef\x20IS_COLOR_RATIO','\x20\x20\x20\x20if\x20(is_render_opaque_object_env\x20==\x201.0\x20||\x20is_render_opaque_pos_env\x20==\x201.0)','uniform\x20int\x20nailIndex;','uniform\x20float\x20ring_mount_occlude_left_distance;','uniform\x20float\x20silhouetteValue;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20brdfLutTexture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_debug\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20metallic,','\x20\x20\x20\x20\x20\x20\x20ray_distance\x20+=\x20distance(local_pos,\x20hit);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio3,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20world_pos,','\x20\x20\x20\x20\x20\x20\x20\x20rgb_weights[3]\x20=\x20vec3(0.0,\x200.0,\x200.5);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20vec3\x20i2\x20=\x20inMatrix[2];','\x20\x20\x20\x20float\x20NdotH\x20=\x20max(dot(N,\x20H),\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_scale\x20=\x20mix(albedo_transform[1].xy,\x20vec2(1.0)\x20/\x20customShimmerScale,\x20customWeight);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio3,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20albedo_rgb_multiplier\x20=\x201.0\x20-\x20min(max(albedo_luma\x20-\x200.8,\x200.0),\x200.2)\x20*\x200.25;','\x20\x20\x20\x20gl_Position\x20=\x20projectMatrix_\x20*\x20worldCoord\x20*\x20vec4(zoom_scale_ratio_,\x20zoom_scale_ratio_,\x201.0,\x201.0);','\x20\x20\x20\x20return\x20F0\x20+\x20(max(vec3(1.0\x20-\x20roughness),\x20F0)\x20-\x20F0)\x20*\x20pow(clamp(1.0\x20-\x20cosTheta,\x200.0,\x201.0),\x205.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20exposure,','\x20\x20\x20\x20\x20\x20\x20\x20else','vec3\x20AdjustTransmittedOutputDirection(vec3\x20out_dir,\x20vec3\x20out_pos,\x20sampler2D\x20opaque_pos_env,\x20vec3\x20pos_scale,\x20vec3\x20pos_shift)','\x20\x20\x20\x20return\x20(-b\x20-\x20sqrt(b\x20*\x20b\x20-\x204.0\x20*\x20a\x20*\x20c))\x20/\x20(2.0\x20*\x20a);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20vert_orien_cos,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_debug\x20==\x200)','\x20\x20\x20\x20vec3\x20N\x20=\x20norm;','vec3\x20ACESToneMapping(vec3\x20color);','\x20\x20\x20\x20vec3\x20c\x20=\x20E\x20*\x20color;','uniform\x20float\x20roughness_intensity;','uniform\x20int\x20isCameraFront;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.a\x20=\x201.0;','uniform\x20float\x20ring_mount_occlude_distance;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20metallic,','\x20\x20\x20\x20float\x20ggx2\x20=\x20GeometrySchlickGGX(NdotV,\x20roughness);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20worldCoordinate,','\x20\x20\x20\x20float\x20curr_local_x_step\x20=\x20clamp(local_pos_x\x20+\x201.0,\x200.0,\x202.0);','uniform\x20vec3\x20gemColor;','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_spec\x20=\x20GetColorRatio(spec_ratio_weight,\x20color_ratio_0,\x20color_ratio_1,\x20color_ratio_2,\x20color_ratio_3);','\x20\x20\x20\x20float\x20NdotV\x20=\x20max(dot(N,\x20V),\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else','\x20\x20\x20\x20color\x20=\x20ACESToneMapping(color);','\x20\x20\x20vec3\x20r\x20=\x20normalize(out_dir);','float\x20GeometrySchlickGGX(float\x20NdotV,\x20float\x20roughness)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20outputAlpha);','void\x20main()','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20is_ibl_spec,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20cam_pos,','\x20\x20\x20\x20vec3\x20a\x20=\x20C\x20*\x20color\x20-\x20A;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20apply_inverse_tone_mapping\x20=\x201.0;','\x20\x20\x20float\x20d\x20=\x20length(opaque_pos);','float\x20Reflectance(vec3\x20incident,\x20vec3\x20normal,\x20float\x20ior)','const\x20int\x20MAXBOUNCESITERS\x20=\x2010;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20frameHeight);','mat3\x20Transpose(mat3\x20inMatrix)','\x20\x20\x20\x20TBN\x20=\x20mat3(T,\x20B,\x20N);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ior[5],','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20luma_ratio)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20zoom_scale_ratio,','\x20\x20\x20\x20gemLocalNorm\x20=\x20smallGemRotationMatrix\x20*\x20normal.xyz;','\x20\x20\x20\x20\x20\x20\x20\x20else\x20if\x20(silhouetteChannel\x20==\x202\x20&&\x20texture_alpha\x20>\x200.0)','\x20\x20\x20\x20vec4\x20xy\x20=\x20line\x20+\x20blend_range;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(k\x20==\x20correct_iters)\x20{break;}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20metallic\x20=\x20metallic_intensity\x20*\x20mix(_metallic,\x20customMetallic,\x20customWeight);','\x20\x20\x20\x20else','#ifdef\x20IS_GEM','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20vert_orien_sin,','uniform\x20float\x20isEnvironmentTexture;','\x20\x20\x20\x20\x20\x20\x20\x20int\x20apply_pbr\x20=\x201;','\x20\x20\x20\x20vec3\x20T\x20=\x20normalize(vec3(normalTransformMatrix_\x20*\x20vec4(tangent.xyz,\x200.0)));','uniform\x20sampler2D\x20albedoTexture;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20mix(vec3(0.0,\x200.0,\x201.0),\x20normalM,\x200.8\x20*\x20customRoughness);','#define\x20NUM_DISPER\x205','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo\x20=\x20pow(albedo_rgba.rgb,\x20vec3(GAMMA));','float\x20DistributionGGX(vec3\x20N,\x20vec3\x20H,\x20float\x20roughness);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[3]\x20=\x20(abs(dot(-in_dir,\x20norm))\x20>\x20cos(asin(1.0\x20/\x20ior[3])))?\x20refract(in_dir,\x20norm,\x20ior[3])\x20:\x20out_dir_rgb[2];','varying\x20vec3\x20worldCoordinate;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20cameraPos,','\x20\x20\x20\x20vec4\x20transformedNormal\x20=\x20normalTransformMatrix_\x20*\x20vec4(normal,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20ibl_map,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMetallic\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sample_dir\x20=\x20d_;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20n\x20=\x20texture2D(norm_env,\x20env_uv).rgb\x20*\x202.0\x20-\x201.0;','varying\x20vec2\x20envCoordinate;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20exposure\x20*\x20maxLuma,','uniform\x20vec3\x20gemPosScale;','\x20\x20\x20\x20float\x20max_mask\x20=\x20max(max(max(max(max(nailMaskFirst3.r,\x20nailMaskFirst3.g),\x20nailMaskFirst3.b),\x20nailMaskLast3.r),\x20nailMaskLast3.g),\x200.0001);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20horiOrien,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roughness,','varying\x20vec3\x20gemLocalNorm;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20mix(roughness,\x200.0,\x20(1.0\x20-\x20customRoughness)\x20*\x20customWeight),','\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskLast3.g;','\x20\x20\x20\x20\x20\x20\x20vec3\x20hit\x20=\x20texture2D(pos_env,\x20norm_env_uv).rgb\x20*\x20pos_scale\x20-\x20pos_shift;','\x20\x20\x20{','\x20\x20\x20\x20float\x20curr_ring_mount_occlude_distance\x20=\x20mount_occlude_left_distance\x20+\x20curr_local_x_step\x20*\x20diff_mount_occlude_distance_step;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x200.0,','varying\x20mat3\x20TBN;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20is_inv_tonemap_albedo,','\x20\x20\x20\x20\x20\x20\x20vec2\x20norm_env_uv\x20=\x20GetEquirectUV(sample_dir);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20apply_inverse_tone_mapping,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20k\x20=\x200;\x20k\x20<\x20MAXCORRECTITERS;\x20k++)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20ratio_weight\x20=\x20GetRatioWeight(front_color_uv);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20=\x20mix(albedo_rgba.rgb,\x20rootSource.rgb,','uniform\x20float\x20isColorRatio;','uniform\x20float\x20vertOrienSin;','vec4\x20TextureLOD(sampler2D\x20texture,\x20vec2\x20coord,\x20float\x20lod)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20apply_pbr\x20=\x200;','uniform\x20vec4\x20nail_rect;','\x20\x20\x20\x20result\x20+=\x20t;','vec3\x20FresnelSchlickRoughness(float\x20cosTheta,\x20vec3\x20F0,\x20float\x20roughness);','\x20\x20\x20\x20mat3\x20outMatrix\x20=\x20mat3(vec3(i0.x,\x20i1.x,\x20i2.x),','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20roughness\x20=\x20roughness_intensity\x20*\x20roughness;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20env_color_uv\x20=\x20GetEquirectUV(normalize(norm_mat\x20*\x20Transpose(smallGemRotationMatrix)\x20*\x20out_dir_rgb[c].rgb));','\x20\x20\x20vec4\x20opaque_pos_rgba\x20=\x20texture2D(opaque_pos_env,\x20GetEquirectUV(normalize(p)));','uniform\x20float\x20normal_intensity;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20*=\x20albedo_intensity;','\x20\x20\x20\x20return\x20result;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailArt\x20>\x200.5)','uniform\x20float\x20gemIOR;','\x20\x20\x20float\x20ray_distance\x20=\x200.0;','\x20\x20\x20\x20vec3\x20brdf\x20=\x20RGBEToFloat(texture2D(brdf_lut,\x20vec2(tmp,\x201.0\x20-\x20roughness)));','\x20\x20\x20\x20vec2\x20ibl_spec_uv\x20=\x20GetEquirectUV(R,\x20hori_orien,\x20vertOrienSin,\x20vertOrienCos);','\x20\x20\x20\x20vec3\x20N\x20=\x20normalize(vec3(normalTransformMatrix_\x20*\x20vec4(normal,\x201.0)));','\x20\x20\x20\x20else\x20if\x20(is_render_opaque_pos_env\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20float\x20luma_ratio_diff\x20=\x20dot(diff_ratio_weight,\x20luma_ratio);','varying\x20vec2\x20textureCoordinate;','\x20\x20\x20\x20float\x20tmp\x20=\x20mix(1.0,\x20max(dot(N,\x20V),\x200.0),\x20fresnelIntensity);','vec3\x20RGBEToFloat(vec4\x20rgbe)','\x20\x20\x20\x20vec3\x20irradiance\x20=\x20RGBEToFloat(texture2D(ibl_map,\x20ibl_diff_uv));','\x20\x20\x20\x20vec3\x20i1\x20=\x20inMatrix[1];','#ifdef\x20IS_NAIL','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ormTexture,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20env_uv\x20=\x20GetEquirectUV(sd);','\x20\x20\x20\x20uv.yw\x20=\x201.0\x20-\x20uv.xz;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20exposure\x20*\x20exposure_multiplier\x20*\x20maxLuma,','vec4\x20DiamondBounceRay(vec3\x20local_pos,','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(silhouetteChannel\x20==\x201)','uniform\x20int\x20silhouetteChannel;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20exposure_multiplier\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out\x20vec3\x20out_pos)','\x20\x20\x20\x20\x20\x20\x20\x20kS\x20/=\x20MAX_INV_TONEMAP_VALUE;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20norm_env,','\x20\x20\x20\x20\x20\x20\x20\x20modelViewProjMatrix_[2][0]\x20*=\x20z_scale;','uniform\x20float\x20ao_intensity;','float\x20Reflectance(vec3\x20incident,\x20vec3\x20normal,\x20float\x20ior);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20_ao\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20ao_transform[0].x,\x20ao_transform[1].xy,\x20ao_transform[2].xy)).r;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(1.0,\x20silhouetteValue,\x200.0,\x201.0);','\x20\x20\x20\x20vec2\x20ibl_diff_uv\x20=\x20GetEquirectUV(N,\x20hori_orien,\x20vertOrienSin,\x20vertOrienCos);','uniform\x20float\x20customContrast;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb[0]\x20=\x20refract(in_dir,\x20norm,\x20ior[0]);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20frameWidth,','\x20\x20\x20\x20\x20\x20\x20vec3\x20sample_dir\x20=\x20in_dir;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}'];(function(_0x2bec45,_0x109603){var _0xdc04d7=function(_0x439057){while(--_0x439057){_0x2bec45['push'](_0x2bec45['shift']());}};_0xdc04d7(++_0x109603);}(_0x1096,0x11c));var _0xdc04=function(_0x2bec45,_0x109603){_0x2bec45=_0x2bec45-0x0;var _0xdc04d7=_0x1096[_0x2bec45];return _0xdc04d7;};'use strict';Object[_0xdc04('0x1aa')](exports,_0xdc04('0x1e8'),{'value':!![]}),exports[_0xdc04('0x1b3')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x17eabe){return _0x17eabe&&_0x17eabe[_0xdc04('0x1e8')]?_0x17eabe:{'default':_0x17eabe};}var Object3DSecondPBRShader=function Object3DSecondPBRShader(){(0x0,_classCallCheck3[_0xdc04('0x1b3')])(this,Object3DSecondPBRShader),this[_0xdc04('0x26b')]={'modelViewProjMatrix':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()},'normalTransformMatrix':{'type':'m4','value':new _three['Matrix4']()},'projectMatrix':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()},'isAlbedoTexture':{'type':'f','value':0x0},'isOrmTexture':{'type':'f','value':0x0},'isEnvironmentTexture':{'type':'f','value':0x0},'isBrdfLutTexture':{'type':'f','value':0x0},'isNormalMapTexture':{'type':'f','value':0x0},'albedoTexture':{'type':'t','value':null},'ormTexture':{'type':'t','value':null},'environmentTexture':{'type':'t','value':null},'brdfLutTexture':{'type':'t','value':null},'normalMapTexture':{'type':'t','value':null},'rootSourceTexture':{'type':'t','value':null},'opaquePosTexture':{'type':'t','value':null},'exposure':{'type':'f','value':0x1},'isRenderSilhouette':{'type':'f','value':0x0},'silhouetteChannel':{'type':'i','value':-0x1},'silhouetteValue':{'type':'f','value':0x0},'horiOrien':{'type':'f','value':0x0},'vertOrien':{'type':'f','value':0x0},'vertOrienSin':{'type':'f','value':0x0},'vertOrienCos':{'type':'f','value':0x0},'isEnableMirrorHDR':{'type':'f','value':0x0},'maxLuma':{'type':'f','value':0x1},'lumaRatio':{'type':'v4','value':new _three[(_0xdc04('0x1e'))](0x1,0x1,0x1,0x1)},'isColorRatio':{'type':'f','value':0x0},'colorRatio0':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x1,0x1,0x1)},'colorRatio1':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x1,0x1,0x1)},'colorRatio2':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x1,0x1,0x1)},'colorRatio3':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x1,0x1,0x1)},'isGem':{'type':'f','value':0x0},'isSmallGem':{'type':'f','value':0x0},'gemIOR':{'type':'f','value':-0x1},'gemDispersion':{'type':'f','value':-0x1},'gemAbsorption':{'type':'f','value':-0x1},'gemCenter':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'gemPosScale':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'gemPosShift':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'gemColor':{'type':'v3','value':new _three['Vector3'](0x0,0x0,0x0)},'albedoColor':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x1,0x1,0x1)},'gemBounces':{'type':'i','value':-0x1},'fresnelIntensity':{'type':'f','value':0x1},'isHDREnvMap':{'type':'f','value':0x1},'customRoughness':{'type':'f','value':0x0},'customMetallic':{'type':'f','value':0x0},'customContrast':{'type':'f','value':0x0},'customLightIntensity':{'type':'f','value':0x0},'customReflection':{'type':'f','value':0x0},'customTransparency':{'type':'f','value':0x0},'customNormalScale':{'type':'f','value':0x1},'customNormalWeight':{'type':'f','value':0.5},'customGlitterOpacity':{'type':'f','value':0x1},'customShimmerScale':{'type':'f','value':0x1},'customWeight':{'type':'f','value':0x0},'isNailMode':{'type':'f','value':0x0},'isNailArt':{'type':'f','value':0x0},'isNailMetallic':{'type':'f','value':0x0},'nailMaskFirst3Texture':{'type':'t','value':null},'nailMaskLast3Texture':{'type':'t','value':null},'nailIndex':{'type':'i','value':0x0},'frameWidth':{'type':'f','value':0x0},'frameHeight':{'type':'f','value':0x0},'cameraRotation':{'type':'i','value':0x0},'isCameraFront':{'type':'i','value':0x0},'is_nail_debug':{'type':'i','value':0x0},'is_nail_design':{'type':'i','value':0x0},'nail_color':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'is_replace_user_polish':{'type':'f','value':0x0},'is_nail_tip':{'type':'f','value':0x0},'zoom_scale_ratio':{'type':'f','value':0x1},'ao_intensity':{'type':'f','value':0x1},'ao_transform':{'type':'m4','value':new _three['Matrix4']()[_0xdc04('0x163')](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'roughness_intensity':{'type':'f','value':0x1},'roughness_transform':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()[_0xdc04('0x163')](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'metallic_intensity':{'type':'f','value':0x1},'metallic_transform':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()[_0xdc04('0x163')](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'normal_intensity':{'type':'f','value':0x1},'normal_transform':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()[_0xdc04('0x163')](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'albedo_intensity':{'type':'f','value':0x1},'albedo_transform':{'type':'m4','value':new _three[(_0xdc04('0x1ef'))]()[_0xdc04('0x163')](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'transmission_intensity':{'type':'f','value':0x1},'transmission_transform':{'type':'m4','value':new _three['Matrix4']()['set'](0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0)},'watchTextureCoordinateOffset':{'type':'v2','value':new _three['Vector2'](0x0,0x0)},'ring_mount_occlude_distance':{'type':'f','value':0x3},'ring_mount_occlude_left_distance':{'type':'f','value':1.5},'ring_mount_occlude_right_distance':{'type':'f','value':1.5},'smallGemRotationMatrix':{'type':'m3','value':new _three[(_0xdc04('0x249'))]()},'nailGlitter':{'type':'f','value':0x0},'inverse_tone_mapping':{'type':'f','value':0x0},'environmentWidth':{'type':'f','value':0x0},'nail_rect':{'type':'v4','value':new _three[(_0xdc04('0x1e'))](0x0,0x0,0x0,0x0)},'is_render_opaque_object_env':{'type':'f','value':0x0},'is_render_opaque_pos_env':{'type':'f','value':0x0},'cube_camera_position':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'opaque_pos_scale':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)},'opaque_pos_shift':{'type':'v3','value':new _three[(_0xdc04('0x6a'))](0x0,0x0,0x0)}},this[_0xdc04('0x20a')]=['attribute\x20vec2\x20inputTextureCoordinate;','attribute\x20vec3\x20tangent;','',_0xdc04('0x26f'),_0xdc04('0xaf'),_0xdc04('0x1b4'),'uniform\x20mediump\x20float\x20zoom_scale_ratio;','uniform\x20float\x20isNailMetallic;',_0xdc04('0x20c'),_0xdc04('0x244'),_0xdc04('0x22d'),_0xdc04('0xb0'),_0xdc04('0x3d'),_0xdc04('0x20'),'',_0xdc04('0x13f'),_0xdc04('0x6c'),_0xdc04('0x10c'),_0xdc04('0x122'),'varying\x20vec3\x20gemLocalNorm;',_0xdc04('0x257'),_0xdc04('0x25f'),_0xdc04('0x96'),_0xdc04('0x26'),'',_0xdc04('0xed'),'{','\x20\x20\x20\x20mat4\x20modelViewProjMatrix_\x20=\x20modelViewProjMatrix;','\x20\x20\x20\x20mat4\x20normalTransformMatrix_\x20=\x20normalTransformMatrix;',_0xdc04('0x33'),_0xdc04('0x1e6'),_0xdc04('0x1e0'),_0xdc04('0xc1'),_0xdc04('0x56'),_0xdc04('0x18a'),'\x20\x20\x20\x20\x20\x20\x20\x20modelViewProjMatrix_\x20*=\x20mat4(vec4(1.0,\x200.0,\x200.0,\x200.0),',_0xdc04('0x25a'),_0xdc04('0x3'),_0xdc04('0x67'),'\x20\x20\x20\x20\x20\x20\x20\x20normalTransformMatrix_\x20=\x20mat4(1.0);',_0xdc04('0x15'),_0xdc04('0x7a'),'\x20\x20\x20\x20\x20\x20\x20\x20cameraPos\x20=\x20cube_camera_position;',_0xdc04('0x179'),_0xdc04('0x1b'),'\x20\x20\x20\x20{',_0xdc04('0x4f'),_0xdc04('0x150'),'\x20\x20\x20\x20\x20\x20\x20\x20modelViewProjMatrix_[2][1]\x20*=\x20z_scale;',_0xdc04('0xae'),_0xdc04('0x269'),_0xdc04('0x260'),'\x20\x20\x20\x20\x20\x20\x20\x20normalTransformMatrix_[2][2]\x20/=\x20z_scale;',_0xdc04('0x179'),_0xdc04('0xfb'),_0xdc04('0x7b'),_0xdc04('0x50'),_0xdc04('0x208'),_0xdc04('0x1f3'),_0xdc04('0x222'),_0xdc04('0xd2'),'',_0xdc04('0x10e'),'\x20\x20\x20\x20fragmentNormal\x20=\x20normalize(transformedNormal.xyz);',_0xdc04('0xa2'),'',_0xdc04('0x105'),_0xdc04('0x13c'),_0xdc04('0x18e'),_0xdc04('0x193'),_0xdc04('0xf7'),'}']['join']('\x0a'),this[_0xdc04('0x1c2')]=['uniform\x20float\x20isAlbedoTexture;',_0xdc04('0x181'),_0xdc04('0x103'),_0xdc04('0x171'),'uniform\x20float\x20isNormalMapTexture;',_0xdc04('0x106'),'uniform\x20sampler2D\x20ormTexture;',_0xdc04('0x23d'),'uniform\x20sampler2D\x20brdfLutTexture;','uniform\x20sampler2D\x20normalMapTexture;',_0xdc04('0x195'),_0xdc04('0x225'),_0xdc04('0x93'),'uniform\x20float\x20isRenderSilhouette;',_0xdc04('0x14b'),_0xdc04('0xc4'),_0xdc04('0xb2'),_0xdc04('0x26c'),_0xdc04('0x12a'),_0xdc04('0x1f8'),_0xdc04('0x23b'),_0xdc04('0x1a8'),'uniform\x20vec4\x20lumaRatio;',_0xdc04('0x129'),_0xdc04('0x83'),_0xdc04('0x1db'),'uniform\x20vec3\x20colorRatio2;',_0xdc04('0x1ac'),_0xdc04('0x6'),'uniform\x20float\x20isSmallGem;',_0xdc04('0xaf'),_0xdc04('0x138'),'uniform\x20float\x20gemDispersion;',_0xdc04('0x238'),_0xdc04('0x22d'),_0xdc04('0x115'),_0xdc04('0x13'),_0xdc04('0xe5'),_0xdc04('0x4d'),_0xdc04('0x42'),'uniform\x20float\x20fresnelIntensity;',_0xdc04('0x22c'),_0xdc04('0x51'),_0xdc04('0x1e3'),_0xdc04('0x156'),_0xdc04('0x16a'),_0xdc04('0x1d6'),_0xdc04('0x235'),'uniform\x20float\x20customNormalScale;',_0xdc04('0x6e'),'uniform\x20float\x20customGlitterOpacity;',_0xdc04('0x1d7'),_0xdc04('0x2d'),_0xdc04('0x20c'),'uniform\x20float\x20isNailArt;',_0xdc04('0x19d'),_0xdc04('0x22a'),'uniform\x20sampler2D\x20nailMaskLast3Texture;',_0xdc04('0xc2'),_0xdc04('0x219'),_0xdc04('0x25c'),_0xdc04('0x1a3'),_0xdc04('0xde'),'uniform\x20int\x20is_nail_debug;',_0xdc04('0x98'),_0xdc04('0x7e'),_0xdc04('0x194'),_0xdc04('0x35'),_0xdc04('0x151'),_0xdc04('0x61'),_0xdc04('0xdd'),_0xdc04('0x266'),'uniform\x20float\x20metallic_intensity;',_0xdc04('0x15c'),_0xdc04('0x134'),_0xdc04('0x2c'),_0xdc04('0x218'),_0xdc04('0x1e5'),_0xdc04('0xc'),_0xdc04('0x41'),_0xdc04('0xbc'),_0xdc04('0xe0'),_0xdc04('0xc3'),_0xdc04('0x186'),_0xdc04('0x27'),_0xdc04('0x1be'),'uniform\x20mat3\x20smallGemRotationMatrix;',_0xdc04('0x12'),'uniform\x20float\x20environmentWidth;',_0xdc04('0x12d'),_0xdc04('0x3d'),_0xdc04('0x20'),_0xdc04('0x23'),_0xdc04('0x8e'),'',_0xdc04('0x13f'),_0xdc04('0x6c'),_0xdc04('0x113'),_0xdc04('0x10c'),_0xdc04('0x122'),_0xdc04('0x25f'),_0xdc04('0x96'),_0xdc04('0x11a'),'varying\x20vec3\x20gemLocalPos;',_0xdc04('0x26'),'',_0xdc04('0x19c'),_0xdc04('0x4b'),_0xdc04('0x108'),_0xdc04('0x1c8'),_0xdc04('0x99'),_0xdc04('0xab'),'',_0xdc04('0xdb'),_0xdc04('0x1ba'),_0xdc04('0x197'),'vec4\x20DiamondBounceRay(vec3\x20local_pos,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20local_norm,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20incident,',_0xdc04('0x1ad'),_0xdc04('0x30'),_0xdc04('0x1ff'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sampler2D\x20norm_env,',_0xdc04('0xac'),_0xdc04('0x173'),_0xdc04('0x168'),_0xdc04('0x4e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out\x20vec3\x20out_pos);',_0xdc04('0x10a'),_0xdc04('0x210'),_0xdc04('0x12f'),_0xdc04('0x60'),_0xdc04('0x268'),_0xdc04('0x234'),_0xdc04('0x9b'),_0xdc04('0x1d5'),_0xdc04('0x1d2'),_0xdc04('0x2b'),_0xdc04('0xef'),_0xdc04('0xca'),_0xdc04('0x1c3'),_0xdc04('0x10f'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20albedo,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20metallic,',_0xdc04('0x119'),_0xdc04('0x1fb'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20is_ibl_diff,',_0xdc04('0xee'),_0xdc04('0xd4'),_0xdc04('0x20b'),_0xdc04('0x102'),_0xdc04('0xd8'),_0xdc04('0x1f0'),_0xdc04('0x11'),_0xdc04('0x123'),_0xdc04('0xa7'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio1,',_0xdc04('0xbb'),_0xdc04('0xd0'),_0xdc04('0x5e'),_0xdc04('0x152'),'vec3\x20RGBEToFloat(vec4\x20rgbe);',_0xdc04('0x8'),_0xdc04('0x54'),_0xdc04('0x198'),_0xdc04('0x242'),_0xdc04('0x1d8'),_0xdc04('0x236'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20nailIndex,',_0xdc04('0xfa'),_0xdc04('0x217'),_0xdc04('0x254'),_0xdc04('0x158'),_0xdc04('0xf5'),_0xdc04('0x24c'),_0xdc04('0x97'),_0xdc04('0x1ce'),_0xdc04('0xf6'),'{',_0xdc04('0xa8'),_0xdc04('0x143'),_0xdc04('0xcd'),_0xdc04('0x130'),_0xdc04('0x1e4'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3(i0.z,\x20i1.z,\x20i2.z));',_0xdc04('0x15e'),'}','',_0xdc04('0x1de'),_0xdc04('0xf4'),_0xdc04('0x1'),'',_0xdc04('0xed'),'{',_0xdc04('0x8f'),_0xdc04('0x56'),'\x20\x20\x20\x20\x20\x20\x20\x20float\x20texture_alpha\x20=\x20texture2D(albedoTexture,\x20textureCoordinate).a;',_0xdc04('0x14a'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture_alpha\x20=\x20step(128.0\x20/\x20255.0,\x20texture_alpha);',_0xdc04('0xb7'),_0xdc04('0x1bc'),_0xdc04('0x38'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(silhouetteValue,\x200.0,\x200.0,\x201.0);',_0xdc04('0x224'),_0xdc04('0x21b'),'\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x20d'),_0xdc04('0x38'),_0xdc04('0x1f'),_0xdc04('0x224'),_0xdc04('0x154'),_0xdc04('0x237'),_0xdc04('0xfc'),_0xdc04('0x3b'),_0xdc04('0x179'),_0xdc04('0x13d'),'\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4((worldCoordinate\x20-\x20cube_camera_position\x20+\x20opaque_pos_shift\x20*\x20OPAQUE_SCALE)\x20/\x20(opaque_pos_scale\x20*\x20OPAQUE_SCALE),\x201.0);',_0xdc04('0x179'),_0xdc04('0x55'),_0xdc04('0x56'),_0xdc04('0x101'),'\x20\x20\x20\x20\x20\x20\x20\x20mat3\x20norm_mat\x20=\x20mat3(normalTransformMatrix);','\x20\x20\x20\x20\x20\x20\x20\x20mat3\x20inv_norm_mat\x20=\x20Transpose(norm_mat);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20incident\x20=\x20normalize(smallGemRotationMatrix\x20*\x20inv_norm_mat\x20*\x20normalize(worldCoordinate));','','\x20\x20\x20\x20\x20\x20\x20\x20float\x20ior[NUM_DISPER];',_0xdc04('0x1d3'),'\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20i\x20=\x200;\x20i\x20<\x20NUM_DISPER;\x20i++)',_0xdc04('0x276'),_0xdc04('0x8b'),_0xdc04('0x18c'),_0xdc04('0x46'),'',_0xdc04('0x212'),_0xdc04('0x1eb'),_0xdc04('0x1af'),_0xdc04('0x85'),_0xdc04('0x252'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ior,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gemPosScale,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gemPosShift,',_0xdc04('0x145'),_0xdc04('0xb3'),_0xdc04('0x170'),_0xdc04('0x57'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20out_dir_rgb,',_0xdc04('0x37'),'\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rgb_weights[NUM_DISPER];','\x20\x20\x20\x20\x20\x20\x20\x20rgb_weights[0]\x20=\x20vec3(0.5,\x200.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20rgb_weights[1]\x20=\x20vec3(0.5,\x200.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20rgb_weights[2]\x20=\x20vec3(0.0,\x201.0,\x200.0);',_0xdc04('0xcb'),_0xdc04('0x19e'),_0xdc04('0x1fd'),_0xdc04('0x38'),_0xdc04('0x9'),_0xdc04('0x8c'),_0xdc04('0x1fe'),_0xdc04('0x2f'),_0xdc04('0x24e'),_0xdc04('0x2e'),_0xdc04('0x1ee'),'',_0xdc04('0x15d'),_0xdc04('0x3c'),_0xdc04('0x7d'),_0xdc04('0x1fe'),_0xdc04('0x132'),_0xdc04('0x88'),_0xdc04('0x207'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x62'),_0xdc04('0x92'),_0xdc04('0x237'),_0xdc04('0x1b9'),'',_0xdc04('0x89'),'\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20norm\x20=\x20normalize(fragmentNormal);',_0xdc04('0x253'),'\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20front_refl_uv\x20=\x20GetEquirectUV(front_refl,\x20horiOrien,\x20vertOrienSin,\x20vertOrienCos);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20front_color_ratio\x20=\x20vec3(1.0,\x201.0,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isColorRatio\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x192'),_0xdc04('0x127'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20front_color_ratio\x20=\x20GetColorRatio(ratio_weight,\x20colorRatio0,\x20colorRatio1,\x20colorRatio2,\x20colorRatio3);',_0xdc04('0x237'),_0xdc04('0x31'),_0xdc04('0x63'),'',_0xdc04('0x1a6'),_0xdc04('0x1cb'),'\x20\x20\x20\x20\x20\x20\x20\x20color\x20=\x20ACESToneMapping(color);',_0xdc04('0x221'),'',_0xdc04('0x32'),_0xdc04('0x245'),_0xdc04('0x179'),_0xdc04('0x100'),_0xdc04('0x56'),'\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rootSourceTexcoord\x20=\x20vec2(gl_FragCoord.x\x20/\x20frameWidth,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragCoord.y\x20/\x20frameHeight);',_0xdc04('0x25d'),_0xdc04('0x264'),_0xdc04('0x104'),_0xdc04('0x161'),_0xdc04('0x144'),_0xdc04('0x24f'),_0xdc04('0x38'),_0xdc04('0xb9'),_0xdc04('0x3f'),_0xdc04('0x21e'),_0xdc04('0x29'),_0xdc04('0x213'),_0xdc04('0x1e9'),_0xdc04('0x1a9'),_0xdc04('0x1b0'),_0xdc04('0x180'),_0xdc04('0x200'),_0xdc04('0xd9'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(nailMaskPackage.x\x20<\x200.001\x20&&\x20is_nail_tip\x20==\x200.0)',_0xdc04('0x12c'),_0xdc04('0x237'),_0xdc04('0x245'),_0xdc04('0x1b7'),_0xdc04('0x38'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(rootSource.rgb,\x200.0);',_0xdc04('0x237'),_0xdc04('0xd5'),_0xdc04('0x38'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20texcoord\x20=\x20clamp(textureCoordinate\x20+\x20watchTextureCoordinateOffset,\x200.0,\x201.0);',_0xdc04('0x87'),_0xdc04('0x19a'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20normalM;',_0xdc04('0x110'),_0xdc04('0x1f1'),_0xdc04('0x267'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x184'),_0xdc04('0x1f1'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20texture_granularity\x20=\x20mix(normal_transform[1].xy,\x20vec2(1.0\x20/\x20customNormalScale),\x20customWeight);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalM\x20=\x20texture2D(normalMapTexture,\x20TransformUV(texcoord,\x20normal_transform[0].x,\x20texture_granularity,\x20normal_transform[2].xy)).rgb;',_0xdc04('0x22b'),_0xdc04('0x15a'),_0xdc04('0x43'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMetallic\x20==\x201.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x107'),_0xdc04('0x15a'),_0xdc04('0x184'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x215'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20frag_normal\x20=\x20normalize(TBN\x20*\x20normalM);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x0'),'',_0xdc04('0x243'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x175'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ao\x20=\x20mix(1.0,\x20ao,\x20ao_intensity);',_0xdc04('0x265'),_0xdc04('0x190'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roughness\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20roughness_transform[0].x,\x20roughness_transform[1].xy,\x20roughness_transform[2].xy)).g;',_0xdc04('0x131'),_0xdc04('0x78'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(nailGlitter\x20>\x200.0)',_0xdc04('0xcf'),_0xdc04('0x176'),_0xdc04('0x9d'),_0xdc04('0x128'),_0xdc04('0x271'),_0xdc04('0x211'),_0xdc04('0x239'),_0xdc04('0x28'),'','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20transmission\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20transmission_transform[0].x,\x20transmission_transform[1].xy,\x20transmission_transform[2].xy)).a;',_0xdc04('0x241'),_0xdc04('0x1f9'),_0xdc04('0x68'),_0xdc04('0x25b'),_0xdc04('0x1d1'),'',_0xdc04('0x23e'),_0xdc04('0x10d'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20worldCoordinate,',_0xdc04('0xb8'),_0xdc04('0x6f'),_0xdc04('0x205'),_0xdc04('0xc7'),_0xdc04('0x11c'),_0xdc04('0x75'),_0xdc04('0x1e2'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20mix(1.0,\x200.0,\x20(1.0\x20-\x20customReflection)\x20*\x20customWeight),',_0xdc04('0x114'),_0xdc04('0x1b8'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vertOrienSin,',_0xdc04('0x203'),_0xdc04('0x9f'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20background,',_0xdc04('0x162'),_0xdc04('0x40'),_0xdc04('0xba'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio2,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio3,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lumaRatio);',_0xdc04('0x144'),_0xdc04('0x17b'),_0xdc04('0x1f1'),_0xdc04('0x23a'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3(0.0,\x200.0,\x200.0),',_0xdc04('0x1c0'),_0xdc04('0xc5'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20normalMapTexture,',_0xdc04('0x22f'),_0xdc04('0xe1'),_0xdc04('0x240'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ao,',_0xdc04('0x1c4'),_0xdc04('0x1c4'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20exposure\x20*\x20maxLuma,',_0xdc04('0x118'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vertOrienSin,',_0xdc04('0x178'),_0xdc04('0x275'),_0xdc04('0x177'),_0xdc04('0x5d'),_0xdc04('0x1dc'),_0xdc04('0x250'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20colorRatio2,',_0xdc04('0x65'),_0xdc04('0x1a4'),_0xdc04('0x1a0'),_0xdc04('0x5c'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x245'),_0xdc04('0x21a'),_0xdc04('0x5f'),_0xdc04('0xbd'),_0xdc04('0x1f1'),_0xdc04('0x77'),_0xdc04('0x15a'),_0xdc04('0xec'),_0xdc04('0x1ee'),_0xdc04('0x144'),_0xdc04('0xe8'),_0xdc04('0x1fe'),_0xdc04('0x153'),_0xdc04('0x1d0'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20_metallic\x20=\x20texture2D(ormTexture,\x20TransformUV(texcoord,\x20metallic_transform[0].x,\x20metallic_transform[1].xy,\x20metallic_transform[2].xy)).b;',_0xdc04('0xff'),_0xdc04('0x247'),_0xdc04('0xe'),_0xdc04('0x26e'),_0xdc04('0x1f4'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_tip\x20!=\x200.0)',_0xdc04('0x1f1'),_0xdc04('0x25e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20metallic\x20=\x20customMetallic;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20roughness\x20=\x20customRoughness;',_0xdc04('0x15a'),_0xdc04('0x71'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(1.0,\x201.0,\x201.0,\x201.0):',_0xdc04('0x14'),_0xdc04('0x135'),_0xdc04('0x137'),_0xdc04('0x1f1'),_0xdc04('0x1a'),_0xdc04('0xdf'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','',_0xdc04('0x72'),_0xdc04('0x14c'),_0xdc04('0x20e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(isNailMetallic\x20==\x201.0\x20&&\x20isNailArt\x20<\x200.5\x20&&\x20is_nail_tip\x20==\x200.0)',_0xdc04('0x1f1'),_0xdc04('0x187'),_0xdc04('0x1ed'),_0xdc04('0x169'),_0xdc04('0xf1'),_0xdc04('0x15a'),_0xdc04('0x184'),_0xdc04('0x1f1'),_0xdc04('0x1a1'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20adjusted_nail_color\x20=\x20clamp(nail_color,\x200.0,\x201.0);',_0xdc04('0x2'),_0xdc04('0x1bd'),_0xdc04('0x1f7'),_0xdc04('0x15f'),_0xdc04('0x3e'),_0xdc04('0x232'),_0xdc04('0xd1'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo_rgba.rgb\x20=\x20albedo_rgba.rgb\x20*\x20albedo_rgb_multiplier;',_0xdc04('0x169'),_0xdc04('0x109'),_0xdc04('0xf1'),_0xdc04('0x15a'),'','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color\x20=\x20MTPBR(frag_normal,',_0xdc04('0xa0'),_0xdc04('0xe3'),_0xdc04('0xb8'),_0xdc04('0x6f'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20albedo,',_0xdc04('0xc7'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20roughness,',_0xdc04('0x1ca'),_0xdc04('0x52'),_0xdc04('0x1c7'),_0xdc04('0x148'),_0xdc04('0x1b8'),_0xdc04('0x64'),_0xdc04('0x203'),_0xdc04('0x121'),_0xdc04('0xa5'),_0xdc04('0x125'),_0xdc04('0x40'),_0xdc04('0xba'),_0xdc04('0x220'),_0xdc04('0xc9'),_0xdc04('0x15b'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20outputAlpha\x20=\x20albedo_rgba.a;',_0xdc04('0x2a'),_0xdc04('0x1f1'),_0xdc04('0xc6'),_0xdc04('0x11b'),_0xdc04('0x1ae'),_0xdc04('0x18'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color.rgb\x20=\x20mix(color.rgb,\x20vec3(0.0,\x201.0,\x200.0),\x200.5\x20*\x20nailMaskPackage.x);',_0xdc04('0x1ea'),_0xdc04('0x259'),_0xdc04('0x11b'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20outputAlpha\x20=\x20albedo_rgba.a\x20*\x20nailMaskPackage.y;',_0xdc04('0x1ea'),_0xdc04('0x15a'),_0xdc04('0xec'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x245'),_0xdc04('0x237'),_0xdc04('0x179'),'}','',_0xdc04('0x17'),'{','\x20\x20\x20\x20const\x20float\x20A\x20=\x202.51;',_0xdc04('0x59'),'\x20\x20\x20\x20const\x20float\x20C\x20=\x202.43;',_0xdc04('0x47'),_0xdc04('0x36'),'\x20\x20\x20\x20return\x20(color\x20*\x20(A\x20*\x20color\x20+\x20B))\x20/\x20(color\x20*\x20(C\x20*\x20color\x20+\x20D)\x20+\x20E);','}','',_0xdc04('0xd6'),'{',_0xdc04('0x94'),_0xdc04('0xea'),_0xdc04('0x133'),_0xdc04('0x17f'),_0xdc04('0x11f'),'\x20\x20\x20\x20\x20\x20\x20return\x20out_dir;',_0xdc04('0x165'),'',_0xdc04('0x230'),_0xdc04('0xf2'),'',_0xdc04('0x18d'),_0xdc04('0x185'),_0xdc04('0x21f'),_0xdc04('0x182'),'','\x20\x20\x20return\x20normalize(p\x20+\x20n\x20*\x20r);','}','',_0xdc04('0x18b'),'{','\x20\x20\x20\x20vec2\x20result;',_0xdc04('0x188'),_0xdc04('0x209'),_0xdc04('0x136'),'}','',_0xdc04('0x149'),_0xdc04('0x1a5'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20incident,',_0xdc04('0xf8'),_0xdc04('0x30'),_0xdc04('0x1ff'),_0xdc04('0x14f'),_0xdc04('0xac'),_0xdc04('0x173'),_0xdc04('0x168'),_0xdc04('0x4e'),_0xdc04('0x14d'),'{',_0xdc04('0xd'),_0xdc04('0x58'),_0xdc04('0x201'),_0xdc04('0x139'),_0xdc04('0x1cf'),_0xdc04('0x11f'),_0xdc04('0x19f'),'\x20\x20\x20\x20\x20\x20\x20in_dir\x20=\x20normalize(in_dir);',_0xdc04('0x159'),_0xdc04('0x228'),'\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x191'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sd\x20=\x20in_dir;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20ld\x20=\x20in_dir;',_0xdc04('0x1b5'),_0xdc04('0x126'),_0xdc04('0x7f'),_0xdc04('0xfe'),_0xdc04('0x146'),_0xdc04('0x112'),_0xdc04('0xb'),_0xdc04('0x1cc'),_0xdc04('0xcc'),_0xdc04('0x117'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0xdc04('0x273'),_0xdc04('0xcc'),_0xdc04('0x233'),_0xdc04('0x202'),_0xdc04('0x223'),_0xdc04('0x81'),_0xdc04('0x95'),_0xdc04('0x111'),_0xdc04('0x160'),_0xdc04('0x124'),_0xdc04('0x1f6'),_0xdc04('0x11e'),_0xdc04('0xc8'),_0xdc04('0x79'),_0xdc04('0x172'),'\x20\x20\x20\x20\x20\x20\x20{',_0xdc04('0x157'),_0xdc04('0x17d'),_0xdc04('0x69'),_0xdc04('0x10b'),_0xdc04('0x39'),_0xdc04('0x258'),_0xdc04('0x160'),_0xdc04('0x23c'),_0xdc04('0x24'),_0xdc04('0x4'),'\x20\x20\x20\x20\x20\x20\x20in_dir\x20=\x20out_dir;',_0xdc04('0x7'),_0xdc04('0x165'),'\x20\x20\x20return\x20vec4(out_dir,\x20ray_distance);','}','',_0xdc04('0x84'),'{',_0xdc04('0xa6'),_0xdc04('0x9c'),_0xdc04('0xce'),'\x20\x20\x20\x20float\x20NdotH2\x20=\x20NdotH\x20*\x20NdotH;','',_0xdc04('0x1f2'),'\x20\x20\x20\x20float\x20denom\x20=\x20(NdotH2\x20*\x20(a2\x20-\x201.0)\x20+\x201.0);','\x20\x20\x20\x20denom\x20=\x20PI\x20*\x20denom\x20*\x20denom;','',_0xdc04('0x9a'),'}','',_0xdc04('0x1fa'),'{',_0xdc04('0xb6'),'}','',_0xdc04('0x216'),'{',_0xdc04('0xd3'),'}','',_0xdc04('0xeb'),'{','\x20\x20\x20\x20float\x20r\x20=\x20(roughness\x20+\x201.0);','\x20\x20\x20\x20float\x20k\x20=\x20(r\x20*\x20r)\x20/\x208.0;','\x20\x20\x20\x20float\x20nom\x20=\x20NdotV;',_0xdc04('0x248'),_0xdc04('0x9a'),'}','',_0xdc04('0x204'),'{',_0xdc04('0xe7'),_0xdc04('0x1d4'),_0xdc04('0xe2'),_0xdc04('0x1ec'),_0xdc04('0xa9'),'}','',_0xdc04('0x16f'),'{','\x20\x20\x20\x20float\x20cv\x20=\x20vert_orien_cos;',_0xdc04('0x226'),'\x20\x20\x20\x20mat3\x20mat_v\x20=\x20mat3(vec3(1.0,\x200.0,\x200.0),\x20vec3(0.0,\x20cv,\x20sv),\x20vec3(0.0,\x20-sv,\x20cv));',_0xdc04('0xbe'),'',_0xdc04('0x6b'),_0xdc04('0x48'),_0xdc04('0x76'),_0xdc04('0x26a'),'\x20\x20\x20\x20if\x20(isEnableMirrorHDR\x20==\x201.0)','\x20\x20\x20\x20{',_0xdc04('0x53'),_0xdc04('0x179'),'\x20\x20\x20\x20float\x20hori_shift\x20=\x20(hori_orien\x20*\x200.5\x20*\x20PI_INV);','\x20\x20\x20\x20uv.x\x20-=\x20hori_shift;','\x20\x20\x20\x20uv.x\x20=\x20uv.x\x20-\x20floor(uv.x);',_0xdc04('0x17e'),'}',_0xdc04('0x199'),'{',_0xdc04('0x70'),_0xdc04('0x48'),_0xdc04('0x76'),_0xdc04('0x26a'),'\x20\x20\x20\x20uv.x\x20=\x20uv.x\x20-\x20floor(uv.x);',_0xdc04('0x17e'),'}','',_0xdc04('0xa1'),'{',_0xdc04('0x164'),_0xdc04('0x11f'),'\x20\x20\x20\x20\x20\x20\x20return\x20vec4(RGBEToFloat(texture2D(texture,\x20coord)),\x201.0);',_0xdc04('0x165'),_0xdc04('0x10'),_0xdc04('0x11f'),_0xdc04('0x1b2'),_0xdc04('0x8a'),'\x20\x20\x20\x20\x20\x20\x20return\x20vec4(InvACESToneMapping(ldr.rgb),\x20ldr.a);',_0xdc04('0x165'),'}','','vec3\x20InvACESToneMapping(vec3\x20color)','{',_0xdc04('0xb5'),_0xdc04('0x59'),_0xdc04('0x21d'),_0xdc04('0x47'),_0xdc04('0x36'),_0xdc04('0xf0'),_0xdc04('0x16b'),_0xdc04('0xdc'),_0xdc04('0xd7'),'}','',_0xdc04('0x2b'),_0xdc04('0xef'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20world_pos,',_0xdc04('0x1c3'),_0xdc04('0x10f'),_0xdc04('0x1c'),_0xdc04('0x1c9'),_0xdc04('0x119'),_0xdc04('0x1fb'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20is_ibl_diff,',_0xdc04('0xee'),_0xdc04('0xd4'),_0xdc04('0x20b'),_0xdc04('0x102'),_0xdc04('0xd8'),_0xdc04('0x1f0'),_0xdc04('0x11'),_0xdc04('0x123'),_0xdc04('0x261'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_ratio_1,',_0xdc04('0x1b1'),_0xdc04('0x189'),_0xdc04('0xf9'),'{',_0xdc04('0xda'),_0xdc04('0x22e'),_0xdc04('0x1e7'),'',_0xdc04('0x1ab'),_0xdc04('0x1da'),_0xdc04('0x255'),'\x20\x20\x20\x20F0\x20=\x20mix(F0,\x20albedo,\x20metallic);','',_0xdc04('0x4a'),_0xdc04('0x23f'),'','\x20\x20\x20\x20vec3\x20kS\x20=\x20F;',_0xdc04('0x1da'),_0xdc04('0x14e'),_0xdc04('0x183'),'\x20\x20\x20\x20kD\x20*=\x201.0\x20-\x20metallic;','',_0xdc04('0x155'),_0xdc04('0x9e'),_0xdc04('0xad'),_0xdc04('0x142'),_0xdc04('0x1d9'),'',_0xdc04('0x140'),_0xdc04('0x13a'),_0xdc04('0x13b'),_0xdc04('0x263'),_0xdc04('0x17a'),_0xdc04('0x1c6'),_0xdc04('0xc0'),'\x20\x20\x20\x20if\x20(isColorRatio\x20>\x200.0)','\x20\x20\x20\x20{',_0xdc04('0x45'),_0xdc04('0x18f'),_0xdc04('0x5'),_0xdc04('0x1a2'),_0xdc04('0x13e'),_0xdc04('0x231'),'\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20luma_diffuse\x20=\x20diffuse\x20*\x20luma_ratio_diff;',_0xdc04('0x90'),_0xdc04('0x1f5'),_0xdc04('0x174'),_0xdc04('0xe6'),_0xdc04('0x24a'),'\x20\x20\x20\x20\x20\x20\x20\x20specular\x20*=\x20luma_ratio_spec\x20*\x20color_ratio_spec;',_0xdc04('0x179'),_0xdc04('0x100'),'#endif',_0xdc04('0x56'),_0xdc04('0x1dd'),_0xdc04('0x206'),_0xdc04('0x179'),_0xdc04('0x25')+_0xdc04('0x44'),'\x20\x20\x20\x20vec3\x20specular_color\x20=\x20specular\x20*\x20is_ibl_spec\x20*\x20ao_x_exposure;',_0xdc04('0x16e'),'',_0xdc04('0x1a7'),_0xdc04('0xe9'),_0xdc04('0x21'),_0xdc04('0xc0'),_0xdc04('0x1bb'),_0xdc04('0x56'),'\x20\x20\x20\x20\x20\x20\x20\x20luma_color\x20*=\x20exposure;',_0xdc04('0x1d'),_0xdc04('0x24b'),'\x20\x20\x20\x20\x20\x20\x20\x20float\x20luma_color_Y\x20=\x20dot(RGBToY,\x20luma_color);',_0xdc04('0x26d'),'\x20\x20\x20\x20\x20\x20\x20\x20color\x20+=\x20mix(luma_color_Y\x20-\x20color_Y,\x200.0,\x20transmission);',_0xdc04('0x179'),_0xdc04('0x245'),'',_0xdc04('0xa4'),'}','',_0xdc04('0xf3'),'{',_0xdc04('0x16d'),_0xdc04('0x19'),'\x20\x20\x20\x20vec3\x20refr\x20=\x20normalize(refract(incident,\x20normal,\x201.0\x20/\x20ior));','',_0xdc04('0x17c'),_0xdc04('0x214'),'\x20\x20\x20\x20float\x20ci\x20=\x20dot(-incident,\x20normal);','\x20\x20\x20\x20float\x20ct\x20=\x20dot(refr,\x20-normal);','\x20\x20\x20\x20float\x20rs\x20=\x20pow((ni\x20*\x20ci\x20-\x20nt\x20*\x20ct)\x20/\x20(ni\x20*\x20ci\x20+\x20nt\x20*\x20ct),\x202.0);',_0xdc04('0x227'),_0xdc04('0x1e1'),'}','',_0xdc04('0x141'),'{',_0xdc04('0xb1'),_0xdc04('0x246'),_0xdc04('0x100'),_0xdc04('0x196'),'}','',_0xdc04('0x12b'),'{',_0xdc04('0x229'),'\x20\x20\x20\x20float\x20l1\x20=\x20l0\x20+\x201.0;','',_0xdc04('0xf'),_0xdc04('0xbf'),_0xdc04('0x73'),_0xdc04('0x1cd'),'',_0xdc04('0x1c1'),'\x20\x20\x20\x20float\x20y0\x20=\x201.0\x20-\x20(2.0\x20-\x20uv0.y)\x20*\x20pow(0.5,\x20l0\x20+\x201.0);','\x20\x20\x20\x20float\x20x1\x20=\x20uv1.x\x20*\x20pow(0.5,\x20l1);',_0xdc04('0x1c5'),'',_0xdc04('0x21c'),_0xdc04('0x86'),'',_0xdc04('0x16'),'}','','vec2\x20TransformUV(vec2\x20uv,\x20float\x20r,\x20vec2\x20s,\x20vec2\x20t)','{',_0xdc04('0x166'),_0xdc04('0x12e'),_0xdc04('0x256'),_0xdc04('0x5a'),_0xdc04('0x7c'),_0xdc04('0x49'),_0xdc04('0x136'),'}',_0xdc04('0x198'),_0xdc04('0x242'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rootSourceTexcoord,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20nail_rect,',_0xdc04('0x251'),_0xdc04('0xfa'),_0xdc04('0x217'),_0xdc04('0x254'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20frameWidth,',_0xdc04('0x16c'),'{','\x20\x20\x20\x20vec4\x20nailMaskFirst3\x20=\x20texture2D(nailMaskFirst3Texture,\x20rootSourceTexcoord);',_0xdc04('0x34'),_0xdc04('0x116'),_0xdc04('0xb4'),_0xdc04('0x22'),_0xdc04('0x262'),'\x20\x20\x20\x20else\x20if\x20(nailIndex\x20==\x201)',_0xdc04('0x91'),_0xdc04('0x80'),'\x20\x20\x20\x20\x20\x20\x20\x20nailMask\x20=\x20nailMaskFirst3.b;',_0xdc04('0x270'),_0xdc04('0x1fc'),_0xdc04('0x1df'),_0xdc04('0x11d'),_0xdc04('0x4c'),'\x20\x20\x20\x20float\x20right\x20=\x20nail_rect.y;',_0xdc04('0x3a'),'\x20\x20\x20\x20float\x20bottom\x20=\x20nail_rect.w;','\x20\x20\x20\x20if\x20(rootSourceTexcoord.x\x20<\x20left\x20||\x20rootSourceTexcoord.x\x20>\x20right\x20||\x20rootSourceTexcoord.y\x20<\x20top\x20||\x20rootSourceTexcoord.y\x20>\x20bottom)',_0xdc04('0xa'),_0xdc04('0x6d'),'}',_0xdc04('0x1bf'),'{','\x20\x20\x20\x20float\x20y_line\x20=\x200.5;',_0xdc04('0x1b6'),_0xdc04('0x8d'),_0xdc04('0xa3'),_0xdc04('0x272'),_0xdc04('0x19b'),_0xdc04('0x20f'),'\x20\x20\x20\x20vec4\x20line\x20=\x20vec4(x_line,\x20x_line,\x20y_line,\x20y_line);',_0xdc04('0xfd'),'\x20\x20\x20\x20vec4\x20uv;',_0xdc04('0x66'),_0xdc04('0x147'),_0xdc04('0xaa'),'\x20\x20\x20\x20return\x20weight;','}','vec3\x20GetColorRatio(vec4\x20weight,\x20vec3\x20color_ratio_0,\x20vec3\x20color_ratio_1,\x20vec3\x20color_ratio_2,\x20vec3\x20color_ratio_3)','{',_0xdc04('0x74'),'}','',_0xdc04('0x274'),'{',_0xdc04('0xe4'),_0xdc04('0x24d'),_0xdc04('0x120'),_0xdc04('0x5b'),'}'][_0xdc04('0x82')]('\x0a');};exports[_0xdc04('0x1b3')]=Object3DSecondPBRShader,module[_0xdc04('0x167')]=exports[_0xdc04('0x1b3')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3349:
/***/ (function(module, exports, __webpack_require__) {

var _0x5067=['Mesh','Vector3','m_four_way_middle_finger_pbr','needsUpdate','m_four_way_index','is_ring_finger_occluder','index_finger','nail_base_skin_colors','nail_mask_last3','transparency','m_is_zoom_src_enabled','hand_mask_height','value','nail_mask_first3','shear_handle_mode','m_shadow_offset_kernel_ratio','m_four_way_thumb','hand_roi_height','magFilter','ring_interval_info','nail_light_mask','SetWristOccluderTexture','p_nail_light_mask','RING_VTO','nail_rect','SetObjectIntensity','m_vto_mode','wrist_trapezoid_matrix','dispose','shadow_offset','Vector4','m_target','zoom_scale_ratio','default','nail_valid','m_mesh','inputImageTexture2','bloom_texture','NAIL_TIP','SetObject3DViewerMetadata','p_wrist_trapezoid_matrix','m_four_way_little_finger','ring_non_blocked_flat','YMKModule','uniforms','m_scene','wristObjectMaskTexture','shadowSmoothTexture','defineProperty','is_enabled','material','is_nail_enabled','is_zoom_src','depthTest','m_four_way_index_finger','is_non_blocked_flat_applied','UpdateShaderParametersPass2','m_is_nail_pbr','m_is_nail_art_array','minFilter','hand_roi_width','nail_diffuse','m_zoom_scale_ratio','max','SetBloomTexture','roi_width','UnsignedByteType','get','NAIL_POLISH','input_uniforms','SetAlgorithmIndex','is_nail_debug','diffuse','zoom_scale_factor','ring_object_number','light_intensity','frame_height','is_show_hand_mask','SetObject3DRenderData','__esModule','vertexShader','shadow_intensity','SetZoomRatio','SetNailArtTexture','fragmentShader','hand_roi_y','delete','m_algorithm_index','nail_segment_height','HEAPU8','gem_mesh_env_map','ring_stack_visible_axis','ring_boundary_smooth_total_range','m_four_way_thumb_pbr','m_camera','RenderFrame','RGBAFormat','__proto__','nail_rect_left_ratio','ring_shadow_smooth_half_kernel','SetShadowSmoothTexture','ring_cylinder_axis_line','frame_width','m_four_way_ring_finger_pbr','m_geometry','m_four_way_index_finger_pbr','SetHandARMetadata','hand_mask','vto_mode','thumb','m_is_shared_texture_for_nail_art','is_nail_art','wristOccluderTexture','onDrawArraysPrePass2','color','ring_finger','nail_rect_right_ratio','intensity','WRIST_VTO','roi_start_x','render','SetRingFingerOccluderData','SetIsZoomSrcEnabled','max_luma','depthWrite','shear_heandle_mode','roi_height','p_nail_mask_first3','m_show_hand_mask','is_replace_user_polish','SetIsNailDebug','nail_env_map_strength','Scene','index_finger_pbr','nail_rect_top_ratio','p_hand_mask','LinearFilter','m_intensity','nail_transparency','frameWidth','m_four_way_ring_finger','is_render_nail_tip','AlphaFormat','m_four_way_little_finger_pbr','is_ring_finger_palm_side','p_nail_mask_last3','is_hand_mask_texture','VN_VTOMode','hand_roi_x','middle_finger','ring_circle_flat','is_nail_pbr','is_render_nail_mask','nail_segment_width','little_finger','DataTexture','SetShowHandMask','ring_boundary_smooth_expand_range','buffer','nail_base_skin_color','middle_finger_pbr','m_four_way_middle_finger','step_3D_x'];(function(_0x5b5541,_0x506790){var _0x29efa0=function(_0x51a6f6){while(--_0x51a6f6){_0x5b5541['push'](_0x5b5541['shift']());}};_0x29efa0(++_0x506790);}(_0x5067,0x1e4));var _0x29ef=function(_0x5b5541,_0x506790){_0x5b5541=_0x5b5541-0x0;var _0x29efa0=_0x5067[_0x5b5541];return _0x29efa0;};'use strict';Object[_0x29ef('0x35')](exports,_0x29ef('0x54'),{'value':!![]}),exports['default']=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3350),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x4cfb90){return _0x4cfb90&&_0x4cfb90[_0x29ef('0x54')]?_0x4cfb90:{'default':_0x4cfb90};}var Object3DSecondFilter=function(_0x49e082){(0x0,_inherits3[_0x29ef('0x26')])(_0x38c6c2,_0x49e082);function _0x38c6c2(_0x5a9c35,_0x1b5deb,_0x494ba2){(0x0,_classCallCheck3['default'])(this,_0x38c6c2);var _0x4301bc=(0x0,_possibleConstructorReturn3['default'])(this,(_0x38c6c2[_0x29ef('0x66')]||(0x0,_getPrototypeOf2[_0x29ef('0x26')])(_0x38c6c2))['call'](this,_0x5a9c35,_0x1b5deb));_0x4301bc[_0x29ef('0x76')]=function(){return _0x4301bc[_0x29ef('0x3d')]();},_0x4301bc[_0x29ef('0x3d')]=function(){if(!_0x4301bc[_0x29ef('0x1f')])_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x29')][_0x29ef('0x11')]=null;_0x4301bc['m_mesh']['material'][_0x29ef('0x31')][_0x29ef('0x25')]['value']=_0x4301bc['m_zoom_scale_ratio'],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x39')][_0x29ef('0x11')]=_0x4301bc[_0x29ef('0xf')]?0x1:0x0,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x7a')][_0x29ef('0x11')]=_0x4301bc[_0x29ef('0x8e')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x4')][_0x29ef('0x11')]=0.25/_0x4301bc[_0x29ef('0x6b')],_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['step_3D_y'][_0x29ef('0x11')]=0.25/_0x4301bc[_0x29ef('0x51')];if(_0x4301bc[_0x29ef('0x1f')]==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')][_0x29ef('0x49')]){_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x74')][_0x29ef('0x11')]=[_0x4301bc[_0x29ef('0x3f')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]*0x5+0x0),_0x4301bc[_0x29ef('0x3f')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]*0x5+0x1),_0x4301bc[_0x29ef('0x3f')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]*0x5+0x2),_0x4301bc[_0x29ef('0x3f')]['get'](_0x4301bc['m_four_way_index']*0x5+0x3),_0x4301bc[_0x29ef('0x3f')]['get'](_0x4301bc[_0x29ef('0x9')]*0x5+0x4)];var _0x44a341=_0x4301bc[_0x29ef('0x15')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x370d07=_0x4301bc[_0x29ef('0x3b')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x27a0fd=_0x4301bc[_0x29ef('0x3')]['get'](_0x4301bc['m_four_way_index']),_0x55f9f3=_0x4301bc[_0x29ef('0x91')][_0x29ef('0x48')](_0x4301bc['m_four_way_index']),_0x3aef46=_0x4301bc[_0x29ef('0x2e')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x277088=_0x4301bc[_0x29ef('0x62')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x5af066=_0x4301bc['m_four_way_index_finger_pbr'][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x10d9c9=_0x4301bc[_0x29ef('0x7')]['get'](_0x4301bc[_0x29ef('0x9')]),_0x49143=_0x4301bc[_0x29ef('0x6c')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]),_0x5c375f=_0x4301bc[_0x29ef('0x94')][_0x29ef('0x48')](_0x4301bc[_0x29ef('0x9')]);_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['nail_colors'][_0x29ef('0x11')]=[new _three['Vector3'](_0x44a341[_0x29ef('0x77')]['r']/0xff,_0x44a341[_0x29ef('0x77')]['g']/0xff,_0x44a341[_0x29ef('0x77')]['b']/0xff),new _three[(_0x29ef('0x6'))](_0x370d07[_0x29ef('0x77')]['r']/0xff,_0x370d07[_0x29ef('0x77')]['g']/0xff,_0x370d07[_0x29ef('0x77')]['b']/0xff),new _three[(_0x29ef('0x6'))](_0x27a0fd[_0x29ef('0x77')]['r']/0xff,_0x27a0fd[_0x29ef('0x77')]['g']/0xff,_0x27a0fd[_0x29ef('0x77')]['b']/0xff),new _three['Vector3'](_0x55f9f3['color']['r']/0xff,_0x55f9f3[_0x29ef('0x77')]['g']/0xff,_0x55f9f3[_0x29ef('0x77')]['b']/0xff),new _three[(_0x29ef('0x6'))](_0x3aef46[_0x29ef('0x77')]['r']/0xff,_0x3aef46[_0x29ef('0x77')]['g']/0xff,_0x3aef46['color']['b']/0xff)],_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x8f')][_0x29ef('0x11')]=[_0x44a341[_0x29ef('0xe')]*0.01,_0x370d07[_0x29ef('0xe')]*0.01,_0x27a0fd[_0x29ef('0xe')]*0.01,_0x55f9f3[_0x29ef('0xe')]*0.01,_0x3aef46[_0x29ef('0xe')]*0.01],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x88')]['value']=[_0x44a341[_0x29ef('0x50')]*0.01,_0x370d07['light_intensity']*0.01,_0x27a0fd['light_intensity']*0.01,_0x55f9f3['light_intensity']*0.01,_0x3aef46[_0x29ef('0x50')]*0.01],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x42')][_0x29ef('0x11')]=[_0x44a341[_0x29ef('0x4d')]*0.01,_0x370d07['diffuse']*0.01,_0x27a0fd[_0x29ef('0x4d')]*0.01,_0x55f9f3['diffuse']*0.01,_0x3aef46[_0x29ef('0x4d')]*0.01],_0x4301bc[_0x29ef('0x3e')]?_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')][_0x29ef('0x38')][_0x29ef('0x11')]=[_0x277088['is_enabled'],_0x5af066[_0x29ef('0x36')],_0x10d9c9[_0x29ef('0x36')],_0x49143['is_enabled'],_0x5c375f[_0x29ef('0x36')]]:_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['is_nail_enabled'][_0x29ef('0x11')]=[_0x44a341[_0x29ef('0x36')],_0x370d07['is_enabled'],_0x27a0fd['is_enabled'],_0x55f9f3[_0x29ef('0x36')],_0x3aef46[_0x29ef('0x36')]],_0x4301bc['m_mesh'][_0x29ef('0x37')]['uniforms'][_0x29ef('0x9c')]['value']=_0x4301bc[_0x29ef('0x3e')]?0x1:0x0;}},_0x4301bc['DisposeTexture']=function(){_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x12')][_0x29ef('0x11')]!=null&&(_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x12')][_0x29ef('0x11')][_0x29ef('0x21')](),_0x4301bc['m_mesh']['material'][_0x29ef('0x31')][_0x29ef('0x12')]['value']=null),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0xd')][_0x29ef('0x11')]!=null&&(_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0xd')][_0x29ef('0x11')][_0x29ef('0x21')](),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0xd')][_0x29ef('0x11')]=null),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['nail_light_mask'][_0x29ef('0x11')]!=null&&(_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x19')][_0x29ef('0x11')][_0x29ef('0x21')](),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x19')][_0x29ef('0x11')]=null),_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')][_0x29ef('0x70')][_0x29ef('0x11')]!=null&&(_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['hand_mask'][_0x29ef('0x11')][_0x29ef('0x21')](),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x70')]['value']=null);},_0x4301bc[_0x29ef('0x64')]=function(_0x41338d,_0x346769){_0x4301bc[_0x29ef('0x76')](),_0x346769?_0x41338d['render'](_0x4301bc['m_scene'],_0x4301bc[_0x29ef('0x63')],_0x4301bc[_0x29ef('0x24')],!![]):_0x41338d[_0x29ef('0x7d')](_0x4301bc[_0x29ef('0x32')],_0x4301bc['m_camera']);},_0x4301bc[_0x29ef('0x53')]=function(_0x21e21a,_0x241790,_0x1de527,_0x3bbbf6,_0x9d0b3c){var _0x385443=0.5,_0x34ffcb=0.3,_0x43e0da=_0x21e21a['size']();for(var _0x4d991b=0x0;_0x4d991b<_0x43e0da;_0x4d991b++){var _0x11526d=_0x21e21a[_0x29ef('0x48')](_0x4d991b);_0x385443=_0x11526d['shadow_intensity']*_0x34ffcb,_0x4301bc[_0x29ef('0x14')]=Math['min'](_0x11526d[_0x29ef('0x22')]/0.5,0x1);}_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x56')][_0x29ef('0x11')]=_0x385443;},_0x4301bc[_0x29ef('0x2c')]=function(){_0x4301bc[_0x29ef('0x1f')]=null,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['is_viewer'][_0x29ef('0x11')]=0x1;},_0x4301bc[_0x29ef('0x6f')]=function(_0x4edc70){_0x4301bc[_0x29ef('0x1f')]=_0x4edc70[_0x29ef('0x71')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x80')]['value']=0x1,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['min_luma']['value']=0x0,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x4e')][_0x29ef('0x11')]=0x1;if(_0x4edc70[_0x29ef('0x71')]==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')]['NAIL_POLISH']||_0x4edc70[_0x29ef('0x71')]==_0x4301bc['YMKModule'][_0x29ef('0x98')][_0x29ef('0x2b')]){_0x4301bc[_0x29ef('0x73')]=!![],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x9d')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x71')]==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')]['NAIL_POLISH']?0x1:0x0,_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x92')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x71')]==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')][_0x29ef('0x2b')]?0x1:0x0,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x97')][_0x29ef('0x11')]=0x0;var _0x5a885d=_0x4edc70[_0x29ef('0x27')];_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['is_nail_valid'][_0x29ef('0x11')]=[_0x5a885d['get'](0x0),_0x5a885d[_0x29ef('0x48')](0x1),_0x5a885d[_0x29ef('0x48')](0x2),_0x5a885d[_0x29ef('0x48')](0x3),_0x5a885d['get'](0x4)];var _0x513c98=_0x4edc70[_0x29ef('0x67')],_0x29df04=_0x4edc70[_0x29ef('0x79')],_0x51f01c=_0x4edc70[_0x29ef('0x8b')],_0x4ba8d0=_0x4edc70['nail_rect_bottom_ratio'];_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x1d')][_0x29ef('0x11')]=[new _three[(_0x29ef('0x23'))](_0x513c98[_0x29ef('0x48')](0x0),_0x29df04[_0x29ef('0x48')](0x0),_0x51f01c[_0x29ef('0x48')](0x0),_0x4ba8d0[_0x29ef('0x48')](0x0)),new _three[(_0x29ef('0x23'))](_0x513c98['get'](0x1),_0x29df04[_0x29ef('0x48')](0x1),_0x51f01c[_0x29ef('0x48')](0x1),_0x4ba8d0[_0x29ef('0x48')](0x1)),new _three[(_0x29ef('0x23'))](_0x513c98[_0x29ef('0x48')](0x2),_0x29df04[_0x29ef('0x48')](0x2),_0x51f01c[_0x29ef('0x48')](0x2),_0x4ba8d0[_0x29ef('0x48')](0x2)),new _three['Vector4'](_0x513c98['get'](0x3),_0x29df04[_0x29ef('0x48')](0x3),_0x51f01c['get'](0x3),_0x4ba8d0[_0x29ef('0x48')](0x3)),new _three[(_0x29ef('0x23'))](_0x513c98[_0x29ef('0x48')](0x4),_0x29df04[_0x29ef('0x48')](0x4),_0x51f01c['get'](0x4),_0x4ba8d0[_0x29ef('0x48')](0x4))],_0x5a885d[_0x29ef('0x5b')](),_0x513c98['delete'](),_0x29df04[_0x29ef('0x5b')](),_0x51f01c[_0x29ef('0x5b')](),_0x4ba8d0[_0x29ef('0x5b')]();var _0x2f94fc=_0x4edc70[_0x29ef('0x1')],_0xf767d6=_0x2f94fc[_0x29ef('0x48')](0x0),_0x43c4c9=_0x2f94fc['get'](0x1),_0x53536c=_0x2f94fc[_0x29ef('0x48')](0x2),_0x3c4c52=_0x2f94fc[_0x29ef('0x48')](0x3),_0x150fdf=_0x2f94fc['get'](0x4);_0x2f94fc[_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0xc')][_0x29ef('0x11')]=[new _three[(_0x29ef('0x6'))](_0xf767d6['r']/0xff,_0xf767d6['g']/0xff,_0xf767d6['b']/0xff),new _three['Vector3'](_0x43c4c9['r']/0xff,_0x43c4c9['g']/0xff,_0x43c4c9['b']/0xff),new _three[(_0x29ef('0x6'))](_0x53536c['r']/0xff,_0x53536c['g']/0xff,_0x53536c['b']/0xff),new _three['Vector3'](_0x3c4c52['r']/0xff,_0x3c4c52['g']/0xff,_0x3c4c52['b']/0xff),new _three[(_0x29ef('0x6'))](_0x150fdf['r']/0xff,_0x150fdf['g']/0xff,_0x150fdf['b']/0xff)],_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x86')]['value']=_0x4edc70[_0x29ef('0x86')]?0x1:0x0;var _0xd65797=new Uint8Array(_0x4301bc[_0x29ef('0x30')][_0x29ef('0x5e')][_0x29ef('0x0')],_0x4edc70[_0x29ef('0x84')],_0x4edc70[_0x29ef('0x9e')]*_0x4edc70['nail_segment_height']*0x4),_0x3040c6=new _three['DataTexture'](_0xd65797,_0x4edc70[_0x29ef('0x9e')],_0x4edc70[_0x29ef('0x5d')],_three[_0x29ef('0x65')],_three['UnsignedByteType']);_0x3040c6[_0x29ef('0x40')]=_three[_0x29ef('0x8d')],_0x3040c6[_0x29ef('0x17')]=_three[_0x29ef('0x8d')],_0x3040c6[_0x29ef('0x8')]=!![],_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['nail_mask_first3']['value']=_0x3040c6;var _0x1fead1=new Uint8Array(_0x4301bc[_0x29ef('0x30')]['HEAPU8'][_0x29ef('0x0')],_0x4edc70[_0x29ef('0x96')],_0x4edc70[_0x29ef('0x9e')]*_0x4edc70[_0x29ef('0x5d')]*0x4),_0x13976c=new _three[(_0x29ef('0xa0'))](_0x1fead1,_0x4edc70['nail_segment_width'],_0x4edc70[_0x29ef('0x5d')],_three[_0x29ef('0x65')],_three[_0x29ef('0x47')]);_0x13976c[_0x29ef('0x40')]=_three['LinearFilter'],_0x13976c[_0x29ef('0x17')]=_three['LinearFilter'],_0x13976c[_0x29ef('0x8')]=!![],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0xd')]['value']=_0x13976c;var _0x39e9e6=new Uint8Array(_0x4301bc[_0x29ef('0x30')][_0x29ef('0x5e')][_0x29ef('0x0')],_0x4edc70[_0x29ef('0x1b')],_0x4edc70[_0x29ef('0x9e')]*_0x4edc70[_0x29ef('0x5d')]),_0xb75ea0=new _three[(_0x29ef('0xa0'))](_0x39e9e6,_0x4edc70[_0x29ef('0x9e')],_0x4edc70['nail_segment_height'],_three[_0x29ef('0x93')],_three['UnsignedByteType']);_0xb75ea0[_0x29ef('0x40')]=_three['LinearFilter'],_0xb75ea0[_0x29ef('0x17')]=_three[_0x29ef('0x8d')],_0xb75ea0[_0x29ef('0x8')]=!![],_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')]['nail_light_mask'][_0x29ef('0x11')]=_0xb75ea0,_0x4301bc[_0x29ef('0x3f')]!=null&&(_0x4301bc[_0x29ef('0x3f')]['delete'](),_0x4301bc[_0x29ef('0x3f')]=null),_0x4301bc[_0x29ef('0x15')]!=null&&(_0x4301bc[_0x29ef('0x15')][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x15')]=null),_0x4301bc[_0x29ef('0x3b')]!=null&&(_0x4301bc['m_four_way_index_finger']['delete'](),_0x4301bc[_0x29ef('0x3b')]=null),_0x4301bc[_0x29ef('0x3')]!=null&&(_0x4301bc[_0x29ef('0x3')][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x3')]=null),_0x4301bc[_0x29ef('0x91')]!=null&&(_0x4301bc['m_four_way_ring_finger'][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x91')]=null),_0x4301bc[_0x29ef('0x2e')]!=null&&(_0x4301bc[_0x29ef('0x2e')]['delete'](),_0x4301bc['m_four_way_little_finger']=null),_0x4301bc[_0x29ef('0x62')]!=null&&(_0x4301bc['m_four_way_thumb_pbr'][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x62')]=null),_0x4301bc[_0x29ef('0x6e')]!=null&&(_0x4301bc[_0x29ef('0x6e')][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x6e')]=null),_0x4301bc[_0x29ef('0x7')]!=null&&(_0x4301bc[_0x29ef('0x7')]['delete'](),_0x4301bc[_0x29ef('0x7')]=null),_0x4301bc[_0x29ef('0x6c')]!=null&&(_0x4301bc[_0x29ef('0x6c')][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x6c')]=null),_0x4301bc[_0x29ef('0x94')]!=null&&(_0x4301bc[_0x29ef('0x94')][_0x29ef('0x5b')](),_0x4301bc[_0x29ef('0x94')]=null),_0x4301bc[_0x29ef('0x3f')]=_0x4edc70[_0x29ef('0x74')],_0x4301bc['m_four_way_thumb']=_0x4edc70[_0x29ef('0x72')],_0x4301bc[_0x29ef('0x3b')]=_0x4edc70[_0x29ef('0xb')],_0x4301bc[_0x29ef('0x3')]=_0x4edc70[_0x29ef('0x9a')],_0x4301bc[_0x29ef('0x91')]=_0x4edc70[_0x29ef('0x78')],_0x4301bc[_0x29ef('0x2e')]=_0x4edc70[_0x29ef('0x9f')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x13')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x82')],_0x4301bc[_0x29ef('0x62')]=_0x4edc70['thumb_pbr'],_0x4301bc['m_four_way_index_finger_pbr']=_0x4edc70[_0x29ef('0x8a')],_0x4301bc[_0x29ef('0x7')]=_0x4edc70[_0x29ef('0x2')],_0x4301bc[_0x29ef('0x6c')]=_0x4edc70['ring_finger_pbr'],_0x4301bc[_0x29ef('0x94')]=_0x4edc70['little_finger_pbr'];}else{if(_0x4edc70[_0x29ef('0x71')]==_0x4301bc[_0x29ef('0x30')]['VN_VTOMode'][_0x29ef('0x7b')]||_0x4edc70['vto_mode']==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')][_0x29ef('0x1c')]){_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x9d')][_0x29ef('0x11')]=0x0,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['is_show_multi_obj'][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x4f')]>0x1?0x1:0x0,_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')][_0x29ef('0x97')][_0x29ef('0x11')]=0x1;var _0xfc20c9=new Uint8Array(_0x4301bc[_0x29ef('0x30')]['HEAPU8'][_0x29ef('0x0')],_0x4edc70[_0x29ef('0x8c')],_0x4edc70['hand_mask_width']*_0x4edc70[_0x29ef('0x10')]),_0x541800=new _three[(_0x29ef('0xa0'))](_0xfc20c9,_0x4edc70['hand_mask_width'],_0x4edc70['hand_mask_height'],_three[_0x29ef('0x93')],_three[_0x29ef('0x47')]);_0x541800[_0x29ef('0x40')]=_three[_0x29ef('0x8d')],_0x541800[_0x29ef('0x17')]=_three[_0x29ef('0x8d')],_0x541800[_0x29ef('0x8')]=!![],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x70')][_0x29ef('0x11')]=_0x541800,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x52')][_0x29ef('0x11')]=_0x4301bc[_0x29ef('0x85')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['is_ring_finger_palm_side'][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x95')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x90')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x6b')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['frameHeight']['value']=_0x4edc70[_0x29ef('0x51')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x68')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x68')]*_0x4301bc['m_shadow_offset_kernel_ratio'],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x7c')]['value']=_0x4edc70[_0x29ef('0x99')],_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')]['roi_start_y'][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x5a')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x46')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x41')],_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')][_0x29ef('0x83')][_0x29ef('0x11')]=_0x4edc70[_0x29ef('0x16')];var _0x4a1c4e=new Float32Array([0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1]);if(_0x4edc70['vto_mode']==_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')][_0x29ef('0x7b')]){_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x31')][_0x29ef('0x4e')][_0x29ef('0x11')]=0.95;if(_0x4edc70['ring_object_number']==0x1){var _0x5dd6b0=new Float32Array(_0x4301bc[_0x29ef('0x30')][_0x29ef('0x5e')][_0x29ef('0x0')],_0x4edc70[_0x29ef('0x2d')],0x5*0x9);_0x4a1c4e=_0x5dd6b0['slice'](0x0,0x9);}}_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x20')]['value']=_0x4a1c4e;}}},_0x4301bc[_0x29ef('0x87')]=function(_0x5572d5){return _0x4301bc['m_mesh'][_0x29ef('0x37')]['uniforms'][_0x29ef('0x4c')][_0x29ef('0x11')]=_0x5572d5;},_0x4301bc[_0x29ef('0x58')]=function(_0x16becb){if(_0x4301bc[_0x29ef('0x73')])_0x4301bc['m_mesh'][_0x29ef('0x37')]['uniforms'][_0x29ef('0x75')][_0x29ef('0x11')]=_0x16becb;},_0x4301bc[_0x29ef('0x1a')]=function(_0x525bc3){if(!_0x4301bc[_0x29ef('0x73')])_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms']['wristOccluderTexture'][_0x29ef('0x11')]=_0x525bc3;},_0x4301bc['SetwristObjectMaskTexture']=function(_0x3ef836){if(!_0x4301bc[_0x29ef('0x73')])_0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x33')][_0x29ef('0x11')]=_0x3ef836;},_0x4301bc[_0x29ef('0x69')]=function(_0x10df7f){return _0x4301bc['m_mesh'][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x34')]['value']=_0x10df7f;},_0x4301bc[_0x29ef('0x45')]=function(_0x44d7f2){return _0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x2a')][_0x29ef('0x11')]=_0x44d7f2;},_0x4301bc['SetDebugGemMeshEnvMap']=function(_0x22abf4){return _0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x5f')][_0x29ef('0x11')]=_0x22abf4;},_0x4301bc[_0x29ef('0x7e')]=function(_0x509b49){_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x6a')][_0x29ef('0x11')]=_0x509b49[_0x29ef('0x6a')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')]['uniforms'][_0x29ef('0x9b')][_0x29ef('0x11')]=_0x509b49[_0x29ef('0x9b')],_0x4301bc['m_mesh'][_0x29ef('0x37')]['uniforms']['ring_interval_info'][_0x29ef('0x11')]=_0x509b49[_0x29ef('0x18')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0xa')][_0x29ef('0x11')]=_0x509b49[_0x29ef('0xa')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['is_non_blocked_flat_applied'][_0x29ef('0x11')]=_0x509b49[_0x29ef('0x3c')]?0x1:0x0,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['ring_non_blocked_flat'][_0x29ef('0x11')]=_0x509b49[_0x29ef('0x2f')],_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x60')]['value']=_0x509b49['ring_stack_visible_axis'];var _0x114414=_0x509b49[_0x29ef('0x18')][0x2],_0x5418dd=_0x509b49[_0x29ef('0x18')][0x3],_0x32ec79=_0x5418dd-_0x114414,_0x5208cc=0.6,_0x32bb35=Math[_0x29ef('0x44')](_0x32ec79-_0x5208cc,0x0)/(0x1-_0x5208cc)*0.1,_0x2f72ed=0.1+_0x32bb35;_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0xa2')]['value']=_0x32bb35,_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')][_0x29ef('0x61')][_0x29ef('0x11')]=_0x2f72ed;},_0x4301bc[_0x29ef('0x57')]=function(_0x14d597){return _0x4301bc[_0x29ef('0x43')]=_0x14d597;},_0x4301bc[_0x29ef('0x1e')]=function(_0x35819a){return _0x4301bc[_0x29ef('0x8e')]=_0x35819a;},_0x4301bc[_0x29ef('0xa1')]=function(_0x29c436){return _0x4301bc['m_show_hand_mask']=_0x29c436?0x1:0x0;},_0x4301bc['SetIsNailPbr']=function(_0x6d3456){return _0x4301bc[_0x29ef('0x3e')]=_0x6d3456;},_0x4301bc[_0x29ef('0x4b')]=function(_0x761ea8){return _0x4301bc[_0x29ef('0x5c')]=_0x761ea8;},_0x4301bc[_0x29ef('0x7f')]=function(_0x171c48){return _0x4301bc['m_is_zoom_src_enabled']=_0x171c48;},_0x4301bc['SetObject3DViewerBackgroundColor']=function(_0x1bfdff,_0x3c5540,_0x42442a,_0x19728e){return _0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x31')]['viewer_background'][_0x29ef('0x11')]=new _three[(_0x29ef('0x23'))](_0x1bfdff/0xff,_0x3c5540/0xff,_0x42442a/0xff,_0x19728e/0xff);},_0x4301bc[_0x29ef('0x30')]=_0x494ba2,_0x4301bc[_0x29ef('0x6b')]=_0x5a9c35,_0x4301bc[_0x29ef('0x51')]=_0x1b5deb;var _0x5747e1=new _shader2['default'](),_0x7bab7e=new _three['ShaderMaterial']({'uniforms':_0x5747e1[_0x29ef('0x4a')],'vertexShader':_0x5747e1[_0x29ef('0x55')],'fragmentShader':_0x5747e1[_0x29ef('0x59')]});return _0x4301bc[_0x29ef('0x28')]=new _three[(_0x29ef('0x5'))](_0x4301bc[_0x29ef('0x6d')],_0x7bab7e),_0x4301bc[_0x29ef('0x28')][_0x29ef('0x37')][_0x29ef('0x3a')]=![],_0x4301bc[_0x29ef('0x28')]['material'][_0x29ef('0x81')]=![],_0x4301bc[_0x29ef('0x32')]=new _three[(_0x29ef('0x89'))](),_0x4301bc[_0x29ef('0x32')]['add'](_0x4301bc['m_mesh']),_0x4301bc['m_vto_mode']=_0x4301bc[_0x29ef('0x30')][_0x29ef('0x98')][_0x29ef('0x49')],_0x4301bc[_0x29ef('0x43')]=0x1,_0x4301bc[_0x29ef('0xf')]=!![],_0x4301bc[_0x29ef('0x8e')]=0x1,_0x4301bc['m_show_hand_mask']=0x0,_0x4301bc[_0x29ef('0x3e')]=![],_0x4301bc[_0x29ef('0x14')]=0x1,_0x4301bc[_0x29ef('0x5c')]=0x0,_0x4301bc[_0x29ef('0x3f')]=null,_0x4301bc[_0x29ef('0x15')]=null,_0x4301bc[_0x29ef('0x3b')]=null,_0x4301bc['m_four_way_middle_finger']=null,_0x4301bc[_0x29ef('0x91')]=null,_0x4301bc[_0x29ef('0x2e')]=null,_0x4301bc['m_four_way_thumb_pbr']=null,_0x4301bc[_0x29ef('0x6e')]=null,_0x4301bc[_0x29ef('0x7')]=null,_0x4301bc['m_four_way_ring_finger_pbr']=null,_0x4301bc[_0x29ef('0x94')]=null,_0x4301bc;}return _0x38c6c2;}(_basefilter2[_0x29ef('0x26')]);exports[_0x29ef('0x26')]=Object3DSecondFilter,module['exports']=exports['default'];

/***/ }),

/***/ 3350:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x5ab7=['uniform\x20int\x20is_nail_art[5];','\x20\x20\x20\x20ring_mount_shadow_mask\x20=\x20sum_of_shift_mount\x20/\x20float(half_kernel_size\x20*\x202\x20+\x201);','uniform\x20vec4\x20ring_circle_flat;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_ring_finger_palm_side\x20==\x200)','uniform\x20float\x20roi_start_y;','\x20\x20\x20\x20\x20\x20\x20\x20textureCoordinateZoom.y\x20<\x20process_start_y\x20||\x20textureCoordinateZoom.y\x20>\x20process_end_y)','uniform\x20int\x20is_ring_finger_palm_side;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20shading\x20=\x201.0\x20-\x20nail_diffuse[i]\x20*\x200.1;','uniform\x20sampler2D\x20nail_light_mask;','\x20\x20\x20\x20float\x20b\x20=\x20flat_line.y;','uniform\x20float\x20shadow_intensity;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20nail_mask_values[5];','uniform\x20vec3\x20nail_base_skin_colors[5];','\x20\x20\x20\x20\x20\x20\x20\x20else','uniform\x20float\x20min_luma;','exports','\x20\x20\x20\x20return\x20ring_alpha_mask;','uniform\x20vec4\x20ring_interval_info;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roughness\x20=\x20nail_diffuse[i]\x20*\x201.6;','if\x20(is_render_nail_mask\x20==\x201\x20||\x20is_render_nail_tip\x20==\x201)','vec3\x20average_rgb\x20=\x20mix(root_source.rgb,\x20vec3(0.0),\x20weight)\x20+\x20center.rgb\x20*\x20intensity;','\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[3]\x20=\x20texture2D(nail_mask_last3,\x20textureCoordinateZoom).r;','gl_FragColor\x20=\x20bloom;','\x20\x20\x20\x20{','float\x20weight\x20=\x20center.a\x20*\x20intensity;','\x20\x20\x20\x20\x20\x20\x20\x20//\x20Find\x20line\x20pass\x20the\x20point\x20and\x20parallel\x20with\x20ring\x20cylinder\x20axis','uniform\x20float\x20roi_width;','input_uniforms','\x20\x20\x20\x20vec4\x20K\x20=\x20vec4(0.0,\x20-1.0\x20/\x203.0,\x202.0\x20/\x203.0,\x20-1.0);','float\x20ring_mount_mask\x20=\x20wrist_occlude_texture_center.r;','\x20\x20\x20\x20if\x20(interval_info.z\x20!=\x20-1.0\x20&&\x20interval_info.w\x20!=\x20-1.0)','default','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20textureCoordinate\x20+\x20vec2(step_3D_x,\x20step_3D_y)))\x20/\x204.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20clamp(average_rgb,\x20vec3(0.0),\x20vec3(1.0));','uniform\x20sampler2D\x20nail_mask_first3;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(point_on_flat_position\x20>=\x200.9)','\x20\x20\x20\x20average_rgb\x20=\x20mix(add,\x20screen,\x200.5);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20result_rgb\x20=\x20root_source.rgb;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_valid[i]\x20==\x200\x20||\x20textureCoordinateZoom.x\x20<\x20roi_left\x20||\x20textureCoordinateZoom.x\x20>\x20roi_right||\x20textureCoordinateZoom.y\x20<\x20roi_top\x20||\x20textureCoordinateZoom.y\x20>\x20roi_bottom)','vec4\x20bloom\x20=\x20texture2D(gem_mesh_env_map,\x20textureCoordinate);','#define\x20IS_DEBUG_MESH_ENV\x200','fragmentShader','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(root_source.rgb,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20distance_point_above_non_blocked_flat\x20=\x20getDistancePointAboveFlat(ring_non_blocked_flat,\x20textureCoordinate.xy);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roi_right\x20=\x20nail_rect[i].y;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20edge\x20=\x20size\x20/\x202.0;','uniform\x20float\x20process_end_y;','\x20\x20\x20\x20float\x20d\x20=\x20q.x\x20-\x20min(q.w,\x20q.y);','\x20\x20\x20\x20return\x20line_y\x20-\x20point.y;','uniform\x20float\x20nail_texture_shift;','\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20mask_coord\x20=\x20textureCoordinate;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20textureCoordinate\x20+\x20vec2(-step_3D_x,\x20step_3D_y))\x20+','uniform\x20float\x20process_end_x;','\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20intersection_point\x20=\x20findIntersectionOfTwoLine(point_line,\x20vec3(flat_line.x,\x20flat_line.y,\x20flat_line.z));','uniform\x20sampler2D\x20hand_mask;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(float(i)\x20>\x202.0\x20*\x20float(half_kernel_size))\x20{break;}','vec4\x20root_source\x20=\x20(is_viewer\x20==\x201)?\x20viewer_background\x20:\x20texture2D(inputImageTexture2,\x20(is_zoom_src\x20==\x201.0)?\x20textureCoordinateZoom\x20:\x20textureCoordinate);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(point_on_flat_position\x20<=\x200.1)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20result_rgb\x20=\x20mix(result_rgb,\x20average_rgb,\x20nail_mask_values[i]);','\x20\x20\x20\x20float\x20x\x20=\x20(line_2.z\x20*\x20line_1.y\x20-\x20line_1.z\x20*\x20line_2.y)\x20/\x20(line_1.x\x20*\x20line_2.y\x20-line_2.x\x20*\x20line_1.y);','uniform\x20float\x20zoom_scale_factor;','uniform\x20int\x20is_nail_valid[5];','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','if\x20(is_hand_mask_texture\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20float\x20light_mask\x20=\x20texture2D(nail_light_mask,\x20textureCoordinateZoom).a;','\x20\x20\x20\x20if\x20(is_nail_debug\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20float\x20alpha_from_left_interval\x20=\x20clamp((point_on_flat_position\x20-\x20(interval_info.z\x20-\x20ring_boundary_smooth_expand_range\x20-\x200.02))\x20/\x20ring_boundary_smooth_total_range,\x200.0,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20+=\x20finish_texture\x20*\x20roughness;','uniform\x20float\x20nail_transparency[5];','uniform\x20vec3\x20nail_colors[5];','\x20\x20\x20\x20float\x20y\x20=\x20(line_2.z\x20*\x20line_1.x\x20-\x20line_1.z\x20*\x20line_2.x)\x20/\x20(line_1.y\x20*\x20line_2.x\x20-line_2.y\x20*\x20line_1.x);','vec4\x20center\x20=\x20(texture2D(inputImageTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20-step_3D_y))\x20+\x20','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(shear_handle_mode\x20==\x201)','\x20\x20\x20\x20warped_textureCoord\x20=\x20warped_cylider_textureCoord;','return;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20result_rgb\x20=\x20mix(result_rgb.rgb,\x20average_rgb,\x20nail_mask_values[i]\x20*\x20float(is_nail_enabled[i]));','\x20\x20\x20\x20\x20\x20\x20\x20float\x20point_on_flat_position\x20=\x20getPositionOnCircleFlat(intersection_point);','\x20\x20\x20\x20vec3\x20add\x20=\x20average_rgb\x20+\x20bloom.rgb;','\x20\x20\x20\x20vec4\x20nail_art\x20=\x20(texture2D(wristOccluderTexture,\x20textureCoordinate\x20+\x20vec2(-step_3D_x,\x20-step_3D_y))\x20+','vec4\x20wrist_occlude_texture_center\x20=\x20vec4(0.0);','\x20\x20\x20\x20if\x20(b\x20!=\x200.0)','\x20\x20\x20\x20int\x20half_kernel_size\x20=\x20ring_shadow_smooth_half_kernel;','uniform\x20int\x20is_render_nail_mask;','if\x20(textureCoordinateZoom.x\x20<\x20process_start_x\x20||\x20textureCoordinateZoom.x\x20>\x20process_end_x\x20||','\x20\x20\x20\x20vec3\x20p\x20=\x20abs(fract(c.xxx\x20+\x20K.xyz)\x20*\x206.0\x20-\x20K.www);','\x20\x20\x20\x20vec4\x20K\x20=\x20vec4(1.0,\x202.0\x20/\x203.0,\x201.0\x20/\x203.0,\x203.0);','\x20\x20\x20\x20warped_cylider_textureCoord.y\x20=\x20warped_cylider_textureCoord.y;','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20finish_texture\x20=\x20center.rrr;','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(result_rgb,\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20center.rgb\x20=\x20vec3(min_luma)\x20+\x20(max_luma\x20-\x20min_luma)\x20*\x20center.rgb;','\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20i\x20=\x200;\x20i\x20<\x205;\x20i++)','uniform\x20int\x20is_hand_mask_texture;','\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[0]\x20=\x20texture2D(nail_mask_first3,\x20textureCoordinateZoom).r;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(ring_interval_info.w\x20==\x201.0)','uniform\x20float\x20is_zoom_src;','uniform\x20float\x20step_3D_y;','\x20\x20\x20\x20wrist_occlude_texture_center\x20=\x20(texture2D(wristOccluderTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20-step_3D_y))\x20+\x20','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20nail_color\x20=\x20(is_nail_art[i]\x20==\x201\x20&&\x20is_replace_user_polish\x20==\x200)?\x20mix(root_source.rgb,\x20nail_art.rgb,\x20nail_art.a)\x20:\x20nail_colors[i];','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20base_color\x20=\x20mix(root_source.rgb,\x20adaptive_nail_art,\x20nail_mask_values[i]);','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(ring_interval_info.z\x20==\x200.0)','\x20\x20\x20\x20if\x20(is_show_hand_mask\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[1]\x20=\x20texture2D(nail_mask_first3,\x20textureCoordinateZoom).g;','uniform\x20int\x20is_show_multi_obj;','else','uniform\x20vec4\x20viewer_background;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nail_color\x20=\x20vec3(min_luma)\x20+\x20(max_luma\x20-\x20min_luma)\x20*\x20nail_color;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20mix(root_source.rgb,\x20nail_art.rgb,\x20nail_art.a);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ring_alpha_mask\x20=\x201.0;','uniform\x20int\x20is_show_hand_mask;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','vec3\x20origin_root_source_rgb\x20=\x20root_source.rgb;','uniform\x20int\x20is_replace_user_polish;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20env_map_rgb\x20=\x20mix(vec3(0.0,\x200.0,\x200.0),\x20center.ggg,\x20center.a\x20*\x20nail_env_map_strength[i]);','\x20\x20\x20\x20vec4\x20q\x20=\x20mix(vec4(p.xyw,\x20c.r),\x20vec4(c.r,\x20p.yzx),\x20step(p.x,\x20c.r));','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20edge_tone\x20=\x20vec3(0.2,\x200.2,\x200.2);','uniform\x20sampler2D\x20shadowSmoothTexture;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roi_top\x20=\x20nail_rect[i].z;','\x20\x20\x20\x20for\x20(int\x20i\x20=\x200;\x20i\x20<=\x20maxSmoothHalfKernel;\x20i++)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20base_color\x20=\x20mix(root_source.rgb,\x20nail_art.rgb,\x20nail_mask_values[i]);','\x20\x20\x20\x20float\x20a\x20=\x20flat_line.x;','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(average_rgb,\x201.0);','vec2\x20findIntersectionOfTwoLine(vec3\x20line_1,\x20vec3\x20line_2)','Vector3','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20average_rgb\x20=\x20vec3(1.0)\x20-\x20(vec3(1.0)\x20-\x20env_map_rgb)\x20*\x20(vec3(1.0)\x20-\x20nail_color);','\x20\x20\x20\x20float\x20dy\x20=\x20point.y\x20-\x20ring_interval_info.y;','\x20\x20\x20\x20warped_cylider_textureCoord\x20=\x20vec2(temp_warped_textureCoord.x\x20/\x20temp_warped_textureCoord.z,\x20\x20temp_warped_textureCoord.y\x20/\x20temp_warped_textureCoord.z);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(hand_mask_intensity\x20>\x200.5)','\x20\x20\x20\x20float\x20sum_of_shift_mount\x20=\x200.0;','uniform\x20float\x20max_luma;','uniform\x20sampler2D\x20wristOccluderTexture;','uniform\x20int\x20shear_handle_mode;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_replace_user_polish\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20-step_3D_y))\x20+\x20','uniform\x20float\x20nail_diffuse[5];','uniform\x20float\x20step_3D_x;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20mix(root_source.rgb,\x20center.rgb,\x20center.a);','\x20\x20\x20\x20hand_mask_intensity\x20=\x20texture2D(hand_mask,\x20textureCoordinateZoom).a;','\x20\x20\x20\x20vec3\x20temp_warped_textureCoord\x20=\x20wrist_trapezoid_matrix\x20*\x20vec3(remapped_textureCoord.x,\x20remapped_textureCoord.y,\x201.0);','uniform\x20vec4\x20ring_non_blocked_flat;','\x20\x20\x20\x20\x20\x20\x20\x20ring_alpha_mask\x20=\x20min(alpha_from_left_interval,\x20alpha_from_right_interval);','\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20mask_color\x20=\x20vec3(face_tone\x20-\x20sign(mask_coord.x\x20+\x20mask_coord.y\x20+\x200.0)\x20*\x20(face_tone\x20-\x20edge_tone));','varying\x20vec2\x20textureCoordinate;','uniform\x20sampler2D\x20nail_mask_last3;','\x20\x20\x20\x20ring_alpha_mask\x20=\x20max(ring_alpha_mask,\x20stack_ring_alpha_mask);','\x20\x20\x20\x20else\x20if\x20(is_render_nail_tip\x20==\x201)','uniform\x20float\x20process_start_y;','uniform\x20float\x20process_start_x;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color_y\x20=\x20pow(color_y,\x202.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20step_3D_y))\x20+\x20','\x20\x20\x20\x20\x20\x20\x20\x20{','uniform\x20float\x20ring_boundary_smooth_expand_range;','\x20\x20\x20\x20is_render_nail\x20=\x201;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','defineProperty','uniform\x20vec4\x20nail_rect[5];','uniform\x20sampler2D\x20wristObjectMaskTexture;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roi_left\x20=\x20nail_rect[i].x;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20adjust_multiplier\x20=\x20mix(mask_multiplier,\x201.0,\x20color_y\x20*\x200.5);','uniform\x20sampler2D\x20inputImageTexture2;','\x20\x20\x20\x20float\x20wrist_occluder_mask\x20=\x20wrist_occlude_texture_center.b;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20mask_multiplier\x20=\x20mix(light_mask_,\x201.0,\x20nail_transparency[i]);','if\x20(is_render_nail\x20==\x200)','uniform\x20int\x20ring_shadow_smooth_half_kernel;','uniform\x20float\x20intensity;','if\x20(is_ring_finger_occluder\x20==\x201\x20&&\x20is_show_hand_mask\x20==\x200)','#if\x20IS_DEBUG_MESH_ENV\x20==\x201','\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roi_bottom\x20=\x20nail_rect[i].w;','\x20\x20\x20\x20else','\x20\x20\x20\x20average_rgb\x20=\x20mix(origin_root_source_rgb,\x20average_rgb,\x20ring_alpha_mask);','\x20\x20\x20\x20float\x20avg_of_shift_sil\x20=\x20sum_of_shift_sil\x20/\x20float(half_kernel_size\x20*\x202\x20+\x201);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(inputImageTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20step_3D_y))\x20+\x20','\x20\x20\x20\x20float\x20non_blocked_smooth_range\x20=\x20ring_circle_flat.w\x20*\x200.1;','\x20\x20\x20\x20vec4\x20bloom\x20=\x20texture2D(bloom_texture,\x20warped_textureCoord);','\x20\x20\x20\x20\x20\x20\x20\x20finish_texture\x20-=\x20vec3(nail_texture_shift);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ring_alpha_mask\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_art[0]\x20==\x201\x20||\x20is_nail_art[1]\x20==\x201\x20||\x20is_nail_art[2]\x20==\x201\x20||\x20is_nail_art[3]\x20==\x201\x20||\x20is_nail_art[4]\x20==\x201)','\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20mix(average_rgb\x20*\x20mask_color,\x20average_rgb,\x20hand_mask_intensity);','float\x20getRingAlphaMaskFromFingerOccluder(vec2\x20axis,\x20vec2\x20point,\x20vec4\x20flat_line,\x20vec4\x20interval_info)','Vector4','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20add\x20=\x20center.rgb\x20+\x20bloom.rgb;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20textureCoordinate\x20+\x20vec2(step_3D_x,\x20-step_3D_y))\x20+','uniform\x20vec2\x20ring_stack_visible_axis;','\x20\x20\x20\x20float\x20sum_of_shift_sil\x20=\x200.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ring_alpha_mask\x20=\x200.0;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(inputImageTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20step_3D_y)))\x20/\x204.0;\x20','\x20\x20\x20\x20\x20\x20\x20\x20float\x20size\x20=\x201.0\x20/\x2036.0;','vec3\x20HSV2RGB(vec3\x20c)','float\x20ring_mount_shadow_mask\x20=\x200.0;','Matrix3','\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20root_source.rgb;;','const\x20vec3\x20RGBToY\x20=\x20vec3(0.299,\x200.587,\x200.114);','\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[2]\x20=\x20texture2D(nail_mask_first3,\x20textureCoordinateZoom).b;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20HSV2RGB(average_hsl);','uniform\x20int\x20is_nail_enabled[5];','\x20\x20\x20\x20wrist_obj_mask_texture_center\x20=\x20(texture2D(wristObjectMaskTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20-step_3D_y))\x20+\x20','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_hsl.b\x20=\x20average_hsl.b\x20*\x20adjust_multiplier;','#endif','uniform\x20mat3\x20wrist_trapezoid_matrix;','join','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nail_color\x20=\x20HSV2RGB(color_hsl);','\x20\x20\x20\x20if\x20(ring_mount_mask\x20>\x200.0\x20||\x20ring_mount_shadow_mask\x20>\x200.0)','vertexShader','vec2\x20warped_textureCoord\x20=\x20textureCoordinate.xy;','\x20\x20\x20\x20float\x20ring_mask\x20=\x20wrist_obj_mask_texture_center.b;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20bloom\x20=\x20texture2D(bloom_texture,\x20textureCoordinate);','\x20\x20\x20\x20float\x20line_y\x20=\x20flat_line.w;','\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[4]\x20=\x20texture2D(nail_mask_last3,\x20textureCoordinateZoom).g;','\x20\x20\x20\x20\x20\x20\x20\x20}','__esModule','\x20\x20\x20\x20return\x20vec3(abs(q.z\x20+\x20(q.w\x20-\x20q.y)\x20/\x20(6.0\x20*\x20d\x20+\x20e)),\x20d\x20/\x20(q.x\x20+\x20e),\x20q.x);','\x20\x20\x20\x20vec3\x20screen\x20=\x20vec3(1.0)\x20-\x20(vec3(1.0)\x20-\x20average_rgb)\x20*\x20(vec3(1.0)\x20-\x20bloom.rgb);','\x20\x20\x20\x20warped_textureCoord\x20=\x20(warped_textureCoord\x20-\x20vec2(0.5))\x20*\x20zoom_scale_factor\x20+\x20vec2(0.5);','uniform\x20int\x20is_nail_pbr;','uniform\x20vec4\x20ring_cylinder_axis_line;','void\x20main()\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20base_color\x20=\x20root_source.rgb;','\x20\x20\x20\x20\x20\x20\x20\x20float\x20alpha_from_right_interval\x20=\x20clamp(((interval_info.w\x20+\x20ring_boundary_smooth_expand_range\x20+\x200.02)\x20-\x20point_on_flat_position)\x20/\x20ring_boundary_smooth_total_range,\x200.0,\x201.0);','\x20\x20\x20\x20return\x20(dx\x20/\x20ring_cylinder_axis_line.z);','uniform\x20sampler2D\x20inputImageTexture;','uniform\x20int\x20is_render_nail_tip;','\x20\x20\x20\x20\x20\x20\x20\x20stack_ring_alpha_mask\x20=\x20getRingAlphaMaskFromFingerOccluder(ring_stack_visible_axis.xy,\x20textureCoordinate.xy,\x20ring_circle_flat,\x20ring_interval_info);','\x20\x20\x20\x20average_rgb\x20=\x20mix(average_rgb,\x20root_source.rgb,\x20occluder_mask);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristObjectMaskTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20step_3D_y)))\x20/\x204.0;\x20','const\x20int\x20maxSmoothHalfKernel\x20=\x201000;','vec2\x20warped_cylider_textureCoord\x20=\x20textureCoordinate.xy;','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','float\x20getDistancePointAboveFlat(vec4\x20flat_line,\x20vec2\x20point)','\x20\x20\x20\x20\x20\x20\x20\x20line_y\x20=\x20(-a\x20*\x20point.x\x20-\x20c)\x20/\x20b;','uniform\x20int\x20is_nail_debug;','\x20\x20\x20\x20float\x20ring_alpha_mask\x20=\x200.0;','uniform\x20int\x20is_viewer;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color_hsl.b\x20*=\x200.94;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20light_mask_\x20=\x20center.b\x20*\x20(1.0\x20-\x200.88\x20*\x20shading)\x20+\x200.88\x20*\x20shading;','textureCoordinateZoom\x20=\x20(uv\x20-\x20vec2(0.5))\x20/\x20vec2(zoom_scale_ratio)\x20+\x20vec2(0.5);','\x20\x20\x20\x20else\x20if\x20(is_nail_pbr\x20!=\x200)','uniform\x20sampler2D\x20gem_mesh_env_map;','textureCoordinate\x20=\x20uv;','\x20\x20\x20\x20float\x20occluder_mask\x20=\x20hand_mask_intensity\x20*\x20wrist_occluder_mask\x20*\x20(1.0\x20-\x20ring_mask);','\x20\x20\x20\x20float\x20c\x20=\x20flat_line.z;','uniform\x20int\x20is_ring_finger_occluder;','\x20\x20\x20\x20\x20\x20\x20\x20mask_coord\x20=\x20sign(vec2(edge)\x20-\x20mod(mask_coord,\x20size));','uniform\x20float\x20frameHeight;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20nail_color\x20=\x20mix(nail_color,\x20base_color,\x20nail_transparency[i]);','uniform\x20float\x20zoom_scale_ratio;','uniform\x20float\x20roi_start_x;','uniform\x20float\x20nail_env_map_strength[5];','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20color_hsl\x20=\x20RGB2HSV(nail_color);','vec3\x20RGB2HSV(vec3\x20c)','\x20\x20\x20\x20float\x20dx\x20=\x20point.x\x20-\x20ring_interval_info.x;','varying\x20vec2\x20textureCoordinateZoom;'];(function(_0x2ac080,_0x5ab76c){var _0x5ef360=function(_0x4fcdc1){while(--_0x4fcdc1){_0x2ac080['push'](_0x2ac080['shift']());}};_0x5ef360(++_0x5ab76c);}(_0x5ab7,0x117));var _0x5ef3=function(_0x2ac080,_0x5ab76c){_0x2ac080=_0x2ac080-0x0;var _0x5ef360=_0x5ab7[_0x2ac080];return _0x5ef360;};'use strict';Object[_0x5ef3('0x83')](exports,_0x5ef3('0xbb'),{'value':!![]}),exports[_0x5ef3('0x6')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x6d7f56){return _0x6d7f56&&_0x6d7f56['__esModule']?_0x6d7f56:{'default':_0x6d7f56};}var Object3DSecondShader=function Object3DSecondShader(){(0x0,_classCallCheck3[_0x5ef3('0x6')])(this,Object3DSecondShader),this[_0x5ef3('0x2')]={'process_start_x':{'type':'f','value':0x0},'process_end_x':{'type':'f','value':0x1},'process_start_y':{'type':'f','value':0x0},'process_end_y':{'type':'f','value':0x1},'inputImageTexture':{'type':'t','value':null},'inputImageTexture2':{'type':'t','value':null},'intensity':{'type':'f','value':0x0},'step_3D_x':{'type':'f','value':0x0},'step_3D_y':{'type':'f','value':0x0},'is_render_nail_mask':{'type':'i','value':0x0},'is_render_nail_tip':{'type':'i','value':0x0},'is_nail_debug':{'type':'i','value':0x0},'nail_mask_first3':{'type':'t','value':null},'nail_mask_last3':{'type':'t','value':null},'nail_light_mask':{'type':'t','value':null},'nail_colors':{'type':'v3','value':[new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0)]},'nail_rect':{'type':'v4','value':[new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x0),new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x0),new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x0),new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x0),new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x0)]},'nail_base_skin_colors':{'type':'v3','value':[new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0),new _three[(_0x5ef3('0x64'))](0x0,0x0,0x0)]},'nail_diffuse':{'type':'f','value':[0x0,0x0,0x0,0x0,0x0]},'is_show_hand_mask':{'type':'i','value':0x0},'is_ring_finger_palm_side':{'type':'i','value':0x0},'is_show_multi_obj':{'type':'i','value':0x0},'is_hand_mask_texture':{'type':'i','value':0x0},'is_viewer':{'type':'i','value':0x0},'viewer_background':{'type':'v4','value':new _three[(_0x5ef3('0x9d'))](0x0,0x0,0x0,0x1)},'hand_mask':{'type':'t','value':null},'wristOccluderTexture':{'type':'t','value':null},'wristObjectMaskTexture':{'type':'t','value':null},'nail_transparency':{'type':'f','value':[0x0,0x0,0x0,0x0,0x0]},'nail_env_map_strength':{'type':'f','value':[0x1,0x1,0x1,0x1,0x1]},'nail_texture_shift':{'type':'f','value':0.191036},'is_nail_enabled':{'type':'iv','value':[0x1,0x1,0x1,0x1,0x1]},'shadowSmoothTexture':{'type':'t','value':null},'ring_shadow_smooth_half_kernel':{'type':'i','value':0x0},'shadow_intensity':{'type':'f','value':0x0},'frameWidth':{'type':'i','value':0x0},'frameHeight':{'type':'i','value':0x0},'is_nail_art':{'type':'i','value':[0x0,0x0,0x0,0x0,0x0]},'is_nail_valid':{'type':'i','value':[0x0,0x0,0x0,0x0,0x0]},'shear_handle_mode':{'type':'i','value':0x1},'is_nail_pbr':{'type':'i','value':0x0},'is_replace_user_polish':{'type':'i','value':0x0},'wrist_trapezoid_matrix':{'type':'m3','value':new _three[(_0x5ef3('0xa7'))]()},'roi_start_x':{'type':'f','value':0x0},'roi_start_y':{'type':'f','value':0x0},'roi_width':{'type':'f','value':0x0},'roi_height':{'type':'f','value':0x0},'ring_circle_flat':{'type':'f','value':[0x0,0x0,0x0,0x0]},'ring_cylinder_axis_line':{'type':'f','value':[0x0,0x0,0x0,0x0]},'ring_interval_info':{'type':'f','value':[0x0,0x0,0x0,0x0]},'is_ring_finger_occluder':{'type':'i','value':0x0},'ring_boundary_smooth_expand_range':{'type':'f','value':0x0},'ring_boundary_smooth_total_range':{'type':'f','value':0.1},'is_non_blocked_flat_applied':{'type':'i','value':0x0},'ring_non_blocked_flat':{'type':'f','value':[0x0,0x0,0x0,0x0]},'ring_stack_visible_axis':{'type':'f','value':[0x0,0x0]},'zoom_scale_ratio':{'type':'f','value':0x1},'zoom_scale_factor':{'type':'f','value':0x1},'max_luma':{'type':'f','value':0x1},'min_luma':{'type':'f','value':0x0},'bloom_texture':{'type':'t','value':null},'gem_mesh_env_map':{'type':'t','value':null},'is_zoom_src':{'type':'f','value':0x1}},this[_0x5ef3('0xb4')]=[_0x5ef3('0x77'),'varying\x20vec2\x20textureCoordinateZoom;',_0x5ef3('0xde'),'void\x20main()\x20{',_0x5ef3('0xcc'),_0x5ef3('0xd7'),_0x5ef3('0xd4'),'}'][_0x5ef3('0xb1')]('\x0a'),this[_0x5ef3('0x10')]=[_0x5ef3('0xf'),_0x5ef3('0x7c'),_0x5ef3('0x1b'),_0x5ef3('0x7b'),_0x5ef3('0x15'),_0x5ef3('0x77'),_0x5ef3('0xe4'),_0x5ef3('0xc5'),_0x5ef3('0x88'),_0x5ef3('0x3a'),_0x5ef3('0xc6'),_0x5ef3('0xcf'),_0x5ef3('0x9'),_0x5ef3('0x78'),_0x5ef3('0xed'),_0x5ef3('0x2d'),_0x5ef3('0x84'),_0x5ef3('0x6f'),_0x5ef3('0x56'),_0x5ef3('0xeb'),_0x5ef3('0x4f'),_0x5ef3('0x43'),_0x5ef3('0xd1'),_0x5ef3('0x51'),_0x5ef3('0x1d'),_0x5ef3('0x6b'),_0x5ef3('0x85'),_0x5ef3('0x5d'),_0x5ef3('0x2c'),_0x5ef3('0xe0'),_0x5ef3('0x18'),_0x5ef3('0xac'),_0x5ef3('0x8c'),_0x5ef3('0xef'),_0x5ef3('0xdf'),_0x5ef3('0xe9'),_0x5ef3('0x1'),'uniform\x20float\x20roi_height;','uniform\x20float\x20frameWidth;',_0x5ef3('0xdc'),_0x5ef3('0xe5'),_0x5ef3('0x24'),_0x5ef3('0x6c'),_0x5ef3('0xbf'),_0x5ef3('0x59'),_0x5ef3('0xf1'),_0x5ef3('0xe7'),_0x5ef3('0xc0'),_0x5ef3('0xf6'),_0x5ef3('0xda'),_0x5ef3('0x80'),'uniform\x20float\x20ring_boundary_smooth_total_range;','uniform\x20int\x20is_non_blocked_flat_applied;',_0x5ef3('0x74'),_0x5ef3('0xa0'),_0x5ef3('0x6a'),_0x5ef3('0xf3'),_0x5ef3('0x8d'),_0x5ef3('0x70'),_0x5ef3('0x47'),_0x5ef3('0xb0'),'uniform\x20sampler2D\x20bloom_texture;',_0x5ef3('0xd6'),_0x5ef3('0x23'),_0x5ef3('0x46'),_0x5ef3('0xa9'),_0x5ef3('0xca'),_0x5ef3('0xe2'),'{',_0x5ef3('0x3'),'\x20\x20\x20\x20vec4\x20p\x20=\x20mix(vec4(c.bg,\x20K.wz),\x20vec4(c.gb,\x20K.xy),\x20step(c.b,\x20c.g));',_0x5ef3('0x5b'),_0x5ef3('0x16'),'\x20\x20\x20\x20float\x20e\x20=\x201.0e-10;',_0x5ef3('0xbc'),'}',_0x5ef3('0xa5'),'{',_0x5ef3('0x3d'),_0x5ef3('0x3c'),'\x20\x20\x20\x20return\x20c.z\x20*\x20mix(K.xxx,\x20clamp(p\x20-\x20K.xxx,\x200.0,\x201.0),\x20c.y);','}',_0x5ef3('0x63'),'{',_0x5ef3('0x22'),_0x5ef3('0x2e'),'\x20\x20\x20\x20return\x20vec2(x,\x20y);','}','float\x20getPositionOnCircleFlat(vec2\x20point)','{',_0x5ef3('0xe3'),_0x5ef3('0x66'),_0x5ef3('0xc4'),'}',_0x5ef3('0xcd'),'{',_0x5ef3('0x61'),_0x5ef3('0xee'),_0x5ef3('0xd9'),_0x5ef3('0xb8'),'\x20\x20\x20\x20int\x20check_result\x20=\x200;',_0x5ef3('0x38'),'\x20\x20\x20\x20{',_0x5ef3('0xce'),_0x5ef3('0x90'),_0x5ef3('0x17'),'}',_0x5ef3('0x9c'),'{',_0x5ef3('0xd0'),_0x5ef3('0x5'),_0x5ef3('0xfc'),_0x5ef3('0x0'),'\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20point_line\x20=\x20vec3(axis.x,\x20axis.y,\x20-(axis.x\x20*\x20point.x)\x20-\x20(axis.y\x20*\x20point.y));',_0x5ef3('0x1c'),_0x5ef3('0x34'),_0x5ef3('0x2a'),_0x5ef3('0xc3'),_0x5ef3('0x75'),_0x5ef3('0x4c'),_0x5ef3('0x7f'),_0x5ef3('0x20'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{',_0x5ef3('0x99'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0xba'),_0x5ef3('0x45'),_0x5ef3('0x7f'),_0x5ef3('0xa'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{',_0x5ef3('0x99'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0x90'),_0x5ef3('0xf5'),'}',_0x5ef3('0xc1'),_0x5ef3('0x8f'),_0x5ef3('0xe'),_0x5ef3('0xfb'),_0x5ef3('0x32'),_0x5ef3('0xaf'),'int\x20is_render_nail\x20=\x200;',_0x5ef3('0xf8'),_0x5ef3('0x81'),_0x5ef3('0x1f'),_0x5ef3('0x3b'),_0x5ef3('0xea'),'{',_0x5ef3('0x11'),'\x20\x20\x20\x20return;','}',_0x5ef3('0xcb'),_0x5ef3('0xb5'),_0x5ef3('0x26'),'{','\x20\x20\x20\x20vec2\x20remapped_textureCoord\x20=\x20vec2(textureCoordinate.x,','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20textureCoordinate.y);',_0x5ef3('0x73'),_0x5ef3('0x67'),'\x20\x20\x20\x20warped_cylider_textureCoord.x\x20=\x20warped_cylider_textureCoord.x;',_0x5ef3('0x3e'),_0x5ef3('0x31'),_0x5ef3('0xbe'),'}',_0x5ef3('0x2f'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(inputImageTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20-step_3D_y))\x20+\x20',_0x5ef3('0x95'),_0x5ef3('0xa3'),_0x5ef3('0x37'),'vec4\x20wrist_obj_mask_texture_center\x20=\x20vec4(0.0);',_0x5ef3('0x26'),'{',_0x5ef3('0x48'),_0x5ef3('0x6e'),_0x5ef3('0x7e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristOccluderTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20step_3D_y)))\x20/\x204.0;\x20',_0x5ef3('0xad'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristObjectMaskTexture,\x20warped_textureCoord\x20+\x20vec2(step_3D_x,\x20-step_3D_y))\x20+\x20','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20texture2D(wristObjectMaskTexture,\x20warped_textureCoord\x20+\x20vec2(-step_3D_x,\x20step_3D_y))\x20+\x20',_0x5ef3('0xc9'),'}',_0x5ef3('0xfd'),_0x5ef3('0xf9'),_0x5ef3('0x58'),_0x5ef3('0xa6'),_0x5ef3('0x26'),'{',_0x5ef3('0x39'),_0x5ef3('0xa1'),_0x5ef3('0x69'),_0x5ef3('0x5f'),_0x5ef3('0xfc'),_0x5ef3('0x1e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20sample_step\x20=\x20vec2(float(i\x20-\x20half_kernel_size)\x20/\x20frameWidth,\x200.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sum_of_shift_sil\x20+=\x20texture2D(shadowSmoothTexture,\x20warped_textureCoord\x20+\x20sample_step).r;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20sum_of_shift_mount\x20+=\x20texture2D(shadowSmoothTexture,\x20warped_textureCoord\x20+\x20sample_step).g;',_0x5ef3('0x90'),_0x5ef3('0x94'),_0x5ef3('0xe6'),'\x20\x20\x20\x20root_source.rgb\x20*=\x20(1.0\x20-\x20avg_of_shift_sil\x20*\x20shadow_intensity);','}','float\x20hand_mask_intensity\x20=\x201.0;',_0x5ef3('0x26'),'{',_0x5ef3('0x72'),_0x5ef3('0x89'),_0x5ef3('0xb6'),_0x5ef3('0xd8'),_0x5ef3('0xc8'),_0x5ef3('0x4d'),_0x5ef3('0xfc'),_0x5ef3('0x19'),_0x5ef3('0xa4'),_0x5ef3('0x14'),'\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20face_tone\x20=\x20vec3(0.3,\x200.3,\x200.3);',_0x5ef3('0x5c'),_0x5ef3('0xdb'),_0x5ef3('0x76'),'\x20\x20\x20\x20\x20\x20\x20\x20',_0x5ef3('0x9b'),'\x20\x20\x20\x20}','}',_0x5ef3('0x8b'),'{',_0x5ef3('0x97'),_0x5ef3('0x35'),_0x5ef3('0xbd'),_0x5ef3('0xb'),'}',_0x5ef3('0x4'),_0x5ef3('0x8e'),'{','\x20\x20\x20\x20float\x20distance_point_above_non_blocked_flat\x20=\x20-1.0;','\x20\x20\x20\x20float\x20stack_ring_alpha_mask\x20=\x200.0;','\x20\x20\x20\x20if\x20(is_non_blocked_flat_applied\x20==\x201)',_0x5ef3('0xfc'),_0x5ef3('0x12'),_0x5ef3('0xc7'),_0x5ef3('0x90'),'\x20\x20\x20\x20float\x20ring_alpha_mask\x20=\x200.0;','\x20\x20\x20\x20ring_alpha_mask\x20=\x20getRingAlphaMaskFromFingerOccluder(ring_cylinder_axis_line.xy,\x20textureCoordinate.xy,\x20ring_circle_flat,\x20ring_interval_info);',_0x5ef3('0x79'),_0x5ef3('0xb3'),'\x20\x20\x20\x20{',_0x5ef3('0xe8'),_0x5ef3('0x55'),_0x5ef3('0xf2'),'\x20\x20\x20\x20\x20\x20\x20\x20{',_0x5ef3('0x68'),_0x5ef3('0xa2'),'\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0x90'),_0x5ef3('0x96'),'\x20\x20\x20\x20if\x20(is_non_blocked_flat_applied\x20==\x201\x20&&\x20distance_point_above_non_blocked_flat\x20>=\x20-non_blocked_smooth_range)','\x20\x20\x20\x20\x20\x20\x20\x20ring_alpha_mask\x20=\x20max(clamp((distance_point_above_non_blocked_flat\x20+\x20non_blocked_smooth_range)\x20/\x20non_blocked_smooth_range,\x200.0,\x201.0),\x20ring_alpha_mask);',_0x5ef3('0x93'),'}','if\x20(is_render_nail_mask\x20==\x200)','{',_0x5ef3('0x62'),'}',_0x5ef3('0x50'),'{',_0x5ef3('0x36'),_0x5ef3('0x9f'),_0x5ef3('0x1a'),_0x5ef3('0x7'),_0x5ef3('0x28'),_0x5ef3('0xfc'),_0x5ef3('0x9a'),_0x5ef3('0x7f'),_0x5ef3('0x54'),'\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0xf2'),_0x5ef3('0x7f'),_0x5ef3('0x71'),_0x5ef3('0xba'),'\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(average_rgb,\x201.0);',_0x5ef3('0x90'),_0x5ef3('0x7a'),_0x5ef3('0xfc'),'\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(average_rgb,\x201.0);',_0x5ef3('0x90'),_0x5ef3('0xd5'),_0x5ef3('0xfc'),_0x5ef3('0xf0'),_0x5ef3('0x44'),_0x5ef3('0x4e'),'\x20\x20\x20\x20\x20\x20\x20\x20nail_mask_values[2]\x20=\x20texture2D(nail_mask_first3,\x20textureCoordinateZoom).b;',_0x5ef3('0xfa'),_0x5ef3('0xb9'),_0x5ef3('0xa8'),_0x5ef3('0x7f'),_0x5ef3('0xb7'),_0x5ef3('0x9e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20screen\x20=\x20vec3(1.0)\x20-\x20(vec3(1.0)\x20-\x20center.rgb)\x20*\x20(vec3(1.0)\x20-\x20bloom.rgb);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20center.rgb\x20=\x20mix(add,\x20screen,\x200.5);','\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0x42'),_0x5ef3('0x7f'),_0x5ef3('0x86'),_0x5ef3('0x13'),_0x5ef3('0x5e'),_0x5ef3('0x91'),_0x5ef3('0xd'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20average_rgb\x20=\x20mix(average_rgb.rgb,\x20center.rgb,\x20nail_mask_values[i]\x20*\x20center.a);',_0x5ef3('0xba'),'\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(average_rgb,\x201.0);',_0x5ef3('0x90'),_0x5ef3('0x92'),_0x5ef3('0xfc'),_0x5ef3('0x27'),_0x5ef3('0xf0'),_0x5ef3('0x44'),_0x5ef3('0x4e'),_0x5ef3('0xaa'),_0x5ef3('0xfa'),_0x5ef3('0xb9'),_0x5ef3('0x41'),_0x5ef3('0x3f'),_0x5ef3('0x98'),_0x5ef3('0xc'),'\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20i\x20=\x200;\x20i\x20<\x205;\x20i++)',_0x5ef3('0x7f'),_0x5ef3('0x86'),_0x5ef3('0x13'),_0x5ef3('0x5e'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20roi_bottom\x20=\x20nail_rect[i].w;',_0x5ef3('0xd'),_0x5ef3('0x82'),_0x5ef3('0xec'),_0x5ef3('0xd3'),_0x5ef3('0x8a'),_0x5ef3('0x4a'),_0x5ef3('0x52'),_0x5ef3('0x25'),_0x5ef3('0xe1'),_0x5ef3('0xd2'),_0x5ef3('0xb2'),_0x5ef3('0x29'),_0x5ef3('0xc2'),_0x5ef3('0x6d'),_0x5ef3('0x25'),_0x5ef3('0x30'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20adaptive_nail_art\x20=\x20mix(nail_art.rgb,\x20nail_base_skin_colors[i],\x200.33);',_0x5ef3('0x4b'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20else',_0x5ef3('0x53'),_0x5ef3('0x60'),_0x5ef3('0x57'),_0x5ef3('0x29'),_0x5ef3('0xdd'),_0x5ef3('0x5a'),_0x5ef3('0x65'),_0x5ef3('0x8'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20average_hsl\x20=\x20RGB2HSV(average_rgb);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20color_y\x20=\x20dot(RGBToY,\x20nail_color);',_0x5ef3('0x7d'),_0x5ef3('0x87'),_0x5ef3('0xae'),_0x5ef3('0xab'),_0x5ef3('0x8'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(is_nail_art[i]\x20==\x201\x20&&\x20is_replace_user_polish\x20==\x200)',_0x5ef3('0x25'),_0x5ef3('0x21'),_0x5ef3('0x29'),_0x5ef3('0x49'),_0x5ef3('0x25'),_0x5ef3('0xf7'),_0x5ef3('0x2b'),_0x5ef3('0x33'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20}',_0x5ef3('0x40'),'\x20\x20\x20\x20}','}','}'][_0x5ef3('0xb1')]('\x0a');};exports['default']=Object3DSecondShader,module[_0x5ef3('0xf4')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3351:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x2be8=['material','add','m_mesh','dispose','LinearFilter','vertexShader','is_use_silhouette','SetSilhouetteTexture','Scene','ShaderMaterial','call','WebGLRenderTarget','value','Mesh','depthTest','exports','m_scene','depthWrite','uniforms','m_target','SetIsUseSilhouette','default','__esModule','input_uniforms','silhouette_texture','__proto__','ResetWidthHeight','RGBAFormat'];(function(_0x4d0e02,_0x2be8f9){var _0xca97db=function(_0x2176ad){while(--_0x2176ad){_0x4d0e02['push'](_0x4d0e02['shift']());}};_0xca97db(++_0x2be8f9);}(_0x2be8,0x1a7));var _0xca97=function(_0x4d0e02,_0x2be8f9){_0x4d0e02=_0x4d0e02-0x0;var _0xca97db=_0x2be8[_0x4d0e02];return _0xca97db;};'use strict';Object['defineProperty'](exports,_0xca97('0x13'),{'value':!![]}),exports[_0xca97('0x12')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_shader=__webpack_require__(3352),_shader2=_interopRequireDefault(_shader),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter);function _interopRequireDefault(_0x3f614e){return _0x3f614e&&_0x3f614e[_0xca97('0x13')]?_0x3f614e:{'default':_0x3f614e};}var Object3DDownscaleFilter=(_temp=_class=function(_0x2fd8a5){(0x0,_inherits3[_0xca97('0x12')])(_0x11476a,_0x2fd8a5);function _0x11476a(_0x1cf816,_0x22761d){(0x0,_classCallCheck3[_0xca97('0x12')])(this,_0x11476a);var _0x2fc368=(0x0,_possibleConstructorReturn3['default'])(this,(_0x11476a[_0xca97('0x16')]||(0x0,_getPrototypeOf2[_0xca97('0x12')])(_0x11476a))[_0xca97('0x7')](this,_0x1cf816,_0x22761d));_initialiseProps[_0xca97('0x7')](_0x2fc368);var _0x3c359f=new _shader2[(_0xca97('0x12'))](),_0x5e5f9b=new _three[(_0xca97('0x6'))]({'uniforms':_0x3c359f[_0xca97('0x14')],'vertexShader':_0x3c359f[_0xca97('0x2')],'fragmentShader':_0x3c359f['fragmentShader']});return _0x2fc368['m_mesh']=new _three[(_0xca97('0xa'))](_0x2fc368['m_geometry'],_0x5e5f9b),_0x2fc368[_0xca97('0x1b')][_0xca97('0x19')][_0xca97('0xb')]=![],_0x2fc368[_0xca97('0x1b')][_0xca97('0x19')][_0xca97('0xe')]=![],_0x2fc368[_0xca97('0xd')]=new _three[(_0xca97('0x5'))](),_0x2fc368['m_scene'][_0xca97('0x1a')](_0x2fc368[_0xca97('0x1b')]),_0x2fc368;}return _0x11476a;}(_basefilter2[_0xca97('0x12')]),_initialiseProps=function _initialiseProps(){var _0xa6d123=this;this[_0xca97('0x17')]=function(_0x96f5e,_0x2c918b){_0xa6d123[_0xca97('0x10')]!=null&&_0xa6d123[_0xca97('0x10')][_0xca97('0x0')]();var _0x26b88d=0x3;_0x96f5e/=_0x26b88d,_0x2c918b/=_0x26b88d,_0xa6d123['m_width']=_0x96f5e,_0xa6d123['m_height']=_0x2c918b,_0xa6d123[_0xca97('0x10')]=new _three[(_0xca97('0x8'))](_0x96f5e,_0x2c918b,{'minFilter':_three[_0xca97('0x1')],'magFilter':_three[_0xca97('0x1')],'format':_three[_0xca97('0x18')]});},this[_0xca97('0x11')]=function(_0x3d27f5){return _0xa6d123[_0xca97('0x1b')][_0xca97('0x19')][_0xca97('0xf')][_0xca97('0x3')]['value']=_0x3d27f5?0x1:0x0;},this[_0xca97('0x4')]=function(_0x3be5b6){return _0xa6d123[_0xca97('0x1b')][_0xca97('0x19')][_0xca97('0xf')][_0xca97('0x15')][_0xca97('0x9')]=_0x3be5b6;};},_temp);exports[_0xca97('0x12')]=Object3DDownscaleFilter,module[_0xca97('0xc')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3352:
/***/ (function(module, exports, __webpack_require__) {

var _0x4ea7=['\x20\x20\x20\x20float\x20silhouette\x20=\x20texture2D(silhouette_texture,\x20texcoord).g;','\x20\x20\x20\x20texcoord\x20=\x20uv;','\x20\x20\x20\x20{','uniform\x20float\x20is_use_silhouette;','\x20\x20\x20\x20else','__esModule','join','defineProperty','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20color;','uniform\x20sampler2D\x20silhouette_texture;','\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','default','\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20color\x20=\x20texture2D(inputImageTexture,\x20texcoord);','vertexShader','uniform\x20sampler2D\x20inputImageTexture;','void\x20main()','varying\x20vec2\x20texcoord;','\x20\x20\x20\x20}','input_uniforms'];(function(_0x515319,_0x4ea79a){var _0x448fb7=function(_0x407d0f){while(--_0x407d0f){_0x515319['push'](_0x515319['shift']());}};_0x448fb7(++_0x4ea79a);}(_0x4ea7,0x1b9));var _0x448f=function(_0x515319,_0x4ea79a){_0x515319=_0x515319-0x0;var _0x448fb7=_0x4ea7[_0x515319];return _0x448fb7;};'use strict';Object[_0x448f('0x3')](exports,_0x448f('0x1'),{'value':!![]}),exports[_0x448f('0x7')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x396291){return _0x396291&&_0x396291[_0x448f('0x1')]?_0x396291:{'default':_0x396291};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x448f('0x7')])(this,Shader),this[_0x448f('0xe')]={'inputImageTexture':{'type':'t','value':null},'silhouette_texture':{'type':'t','value':null},'is_use_silhouette':{'type':'f','value':0x1}},this[_0x448f('0x9')]=[_0x448f('0xc'),_0x448f('0xb'),'{',_0x448f('0x6'),_0x448f('0x10'),'}'][_0x448f('0x2')]('\x0a'),this['fragmentShader']=[_0x448f('0xa'),_0x448f('0x5'),_0x448f('0x12'),_0x448f('0xc'),_0x448f('0xb'),'{',_0x448f('0xf'),'\x20\x20\x20\x20if\x20(is_use_silhouette\x20==\x200.0\x20||\x20(silhouette\x20>\x200.45\x20&&\x20silhouette\x20<\x200.55))',_0x448f('0x11'),_0x448f('0x8'),_0x448f('0x4'),_0x448f('0xd'),_0x448f('0x0'),_0x448f('0x11'),'\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x200.0,\x200.0,\x201.0);',_0x448f('0xd'),'}'][_0x448f('0x2')]('\x0a');};exports[_0x448f('0x7')]=Shader,module['exports']=exports['default'];

/***/ }),

/***/ 3353:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0xd341=['fragmentShader','m_bloom_intensity','roi_texture','m_height','ResetWidthHeight','depthTest','cos','m_width','m_external_bloom_sharpness','defineProperty','m_full_frame_height','LinearFilter','kernel_texture','dispose','Scene','__proto__','setGetBloomIntensityRatioFunc','minFilter','material','RenderFrame','half_kernel','value','BloomGaussian','m_target','RGBAFormat','SetBloomThreshold','min','WebGLRenderTarget','default','ShaderMaterial','SetBloomIntensity','m_full_frame_width','m_camera','m_scene','is_use_roi','m_geometry','m_bloom_scale','m_external_bloom_threshold','m_bbox_size','input_uniforms','Mesh','call','add','SetROITexture','getBloomIntensityRatioFunc','uniforms','pow','threshold','SetIsUseROI','max','DataTexture','m_mesh','bloom_intensity','__esModule','m_is_bloom_kernel_changed','m_projected_scale','frame_height','sin','round','vertexShader','exports','UnsignedByteType','magFilter'];(function(_0x572808,_0xd341af){var _0x421796=function(_0x37eee4){while(--_0x37eee4){_0x572808['push'](_0x572808['shift']());}};_0x421796(++_0xd341af);}(_0xd341,0x1d2));var _0x4217=function(_0x572808,_0xd341af){_0x572808=_0x572808-0x0;var _0x421796=_0xd341[_0x572808];return _0x421796;};'use strict';Object[_0x4217('0x2f')](exports,_0x4217('0x1c'),{'value':!![]}),exports[_0x4217('0x3')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3354),_shader2=_interopRequireDefault(_shader),_isFunction2=__webpack_require__(15),_isFunction3=_interopRequireDefault(_isFunction2);function _interopRequireDefault(_0x26af5a){return _0x26af5a&&_0x26af5a[_0x4217('0x1c')]?_0x26af5a:{'default':_0x26af5a};}var Object3DBloomFilter=(_temp=_class=function(_0x1e0ead){(0x0,_inherits3[_0x4217('0x3')])(_0x1b1c36,_0x1e0ead);function _0x1b1c36(_0x1b2426,_0x5d9a27){(0x0,_classCallCheck3[_0x4217('0x3')])(this,_0x1b1c36);var _0x768e79=(0x0,_possibleConstructorReturn3[_0x4217('0x3')])(this,(_0x1b1c36[_0x4217('0x35')]||(0x0,_getPrototypeOf2['default'])(_0x1b1c36))['call'](this,_0x1b2426,_0x5d9a27));_initialiseProps[_0x4217('0x10')](_0x768e79);var _0x216c60=new _shader2['default'](),_0x497cf9=new _three[(_0x4217('0x4'))]({'uniforms':_0x216c60[_0x4217('0xe')],'vertexShader':_0x216c60[_0x4217('0x22')],'fragmentShader':_0x216c60[_0x4217('0x26')]});return _0x768e79[_0x4217('0x1a')]=new _three[(_0x4217('0xf'))](_0x768e79[_0x4217('0xa')],_0x497cf9),_0x768e79[_0x4217('0x1a')][_0x4217('0x38')][_0x4217('0x2b')]=![],_0x768e79[_0x4217('0x1a')][_0x4217('0x38')]['depthWrite']=![],_0x768e79[_0x4217('0x8')]=new _three[(_0x4217('0x34'))](),_0x768e79[_0x4217('0x8')][_0x4217('0x11')](_0x768e79['m_mesh']),_0x768e79[_0x4217('0x6')]=_0x1b2426,_0x768e79[_0x4217('0x30')]=_0x5d9a27,_0x768e79[_0x4217('0x27')]=0x0,_0x768e79[_0x4217('0x2e')]=0x1,_0x768e79[_0x4217('0xc')]=0x6,_0x768e79[_0x4217('0x1d')]=!![],_0x768e79[_0x4217('0xd')]=0x0,_0x768e79[_0x4217('0x1e')]=0x1,_0x768e79;}return _0x1b1c36;}(_basefilter2[_0x4217('0x3')]),_initialiseProps=function _initialiseProps(){var _0x25dda0=this;this[_0x4217('0x3c')]=function(_0x20cc26,_0x420985,_0x2be985,_0x3f23d0,_0x5aa446){var _0x56c5b0=2.71828,_0x1da286=_0x20cc26*3.14159/0xb4,_0x38496e=(_0x420985-0.5)*Math[_0x4217('0x2c')](_0x1da286)-(_0x2be985-0.5)*Math[_0x4217('0x20')](_0x1da286)+0.5,_0x2ac6f5=(_0x420985-0.5)*Math['sin'](_0x1da286)+(_0x2be985-0.5)*Math[_0x4217('0x2c')](_0x1da286)+0.5;return _0x38496e=Math[_0x4217('0x15')](_0x56c5b0,-_0x3f23d0*Math[_0x4217('0x15')](_0x38496e-0.5,0x2)),_0x2ac6f5=Math[_0x4217('0x15')](_0x56c5b0,-_0x5aa446*Math[_0x4217('0x15')](_0x2ac6f5-0.5,0x2)),_0x38496e*_0x2ac6f5;},this[_0x4217('0x39')]=function(_0x2b3a32,_0x281b34){_0x25dda0[_0x4217('0x1a')][_0x4217('0x38')]['uniforms']['frame_width'][_0x4217('0x3b')]=_0x25dda0[_0x4217('0x2d')],_0x25dda0[_0x4217('0x1a')]['material'][_0x4217('0x14')][_0x4217('0x1f')][_0x4217('0x3b')]=_0x25dda0[_0x4217('0x29')],_0x25dda0[_0x4217('0x1a')][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x16')][_0x4217('0x3b')]=_0x25dda0[_0x4217('0xc')],_0x25dda0['m_mesh'][_0x4217('0x38')][_0x4217('0x14')]['bloom_intensity'][_0x4217('0x3b')]=_0x25dda0[_0x4217('0x27')];if((0x0,_isFunction3['default'])(_0x25dda0[_0x4217('0x13')])){var _0x2a4bd5=_0x25dda0[_0x4217('0x13')]();_0x25dda0['m_mesh'][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x1b')][_0x4217('0x3b')]=_0x25dda0['m_bloom_intensity']*_0x2a4bd5;}var _0x175b52=0.4+0.6*Math['min'](0x1,_0x25dda0['m_projected_scale']*_0x25dda0[_0x4217('0xd')]),_0x49b490=Math[_0x4217('0x1')](_0x25dda0[_0x4217('0x2d')],_0x25dda0[_0x4217('0x29')]),_0xb30e5f=Math[_0x4217('0x18')](0x1,Math[_0x4217('0x21')](0.046*_0x25dda0[_0x4217('0xb')]*_0x49b490*_0x175b52));_0x25dda0[_0x4217('0x1a')][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x3a')][_0x4217('0x3b')]=_0xb30e5f;if(_0x25dda0[_0x4217('0x1d')]){var _0x4b74db=0x1f,_0x48de62=new Uint8Array(_0x4b74db*_0x4b74db*0x4);for(var _0xdaf73e=0x0;_0xdaf73e<_0x4b74db;_0xdaf73e++){for(var _0x34b2ea=0x0;_0x34b2ea<_0x4b74db;_0x34b2ea++){var _0x40ffae=_0x34b2ea/(_0x4b74db-0x1),_0x5eed57=_0xdaf73e/(_0x4b74db-0x1),_0x53bfc5=0x11,_0x3e2717=0x19,_0x18d8b3=0xe,_0x59c3c0=0x258,_0x5525d3=Math[_0x4217('0x18')](0x0,Math[_0x4217('0x1')](0x1,_0x25dda0['m_external_bloom_sharpness'])),_0x564706=_0x53bfc5*(0x1-_0x5525d3)+_0x18d8b3*_0x5525d3,_0x19743e=_0x3e2717*(0x1-_0x5525d3)+_0x59c3c0*_0x5525d3,_0x1e98bb=_0x25dda0[_0x4217('0x3c')](0x69,_0x40ffae,_0x5eed57,_0x564706,_0x19743e),_0x1aa986=_0x25dda0['BloomGaussian'](0x8f,_0x40ffae,_0x5eed57,_0x564706,_0x19743e),_0x35da4e=_0x25dda0[_0x4217('0x3c')](0xc8,_0x40ffae,_0x5eed57,_0x564706,_0x19743e),_0x455651=Math[_0x4217('0x21')](0xff*Math[_0x4217('0x18')](_0x1e98bb,Math[_0x4217('0x18')](_0x1aa986,_0x35da4e)));_0x48de62[(_0xdaf73e*_0x4b74db+_0x34b2ea)*0x4+0x0]=_0x455651,_0x48de62[(_0xdaf73e*_0x4b74db+_0x34b2ea)*0x4+0x1]=_0x455651,_0x48de62[(_0xdaf73e*_0x4b74db+_0x34b2ea)*0x4+0x2]=_0x455651,_0x48de62[(_0xdaf73e*_0x4b74db+_0x34b2ea)*0x4+0x3]=0xff;}}_0x25dda0[_0x4217('0x1a')]['material']['uniforms'][_0x4217('0x32')][_0x4217('0x3b')]!=null&&(_0x25dda0[_0x4217('0x1a')]['material'][_0x4217('0x14')][_0x4217('0x32')][_0x4217('0x3b')][_0x4217('0x33')](),_0x25dda0[_0x4217('0x1a')][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x32')][_0x4217('0x3b')]=null);var _0xcec6b3=new _three[(_0x4217('0x19'))](_0x48de62,_0x4b74db,_0x4b74db,_three[_0x4217('0x3e')],_three[_0x4217('0x24')]);_0xcec6b3[_0x4217('0x37')]=_three[_0x4217('0x31')],_0xcec6b3[_0x4217('0x25')]=_three[_0x4217('0x31')],_0xcec6b3['needsUpdate']=!![],_0x25dda0['m_mesh'][_0x4217('0x38')]['uniforms'][_0x4217('0x32')][_0x4217('0x3b')]=_0xcec6b3,_0x25dda0[_0x4217('0x1d')]=![];}_0x281b34?_0x2b3a32['render'](_0x25dda0['m_scene'],_0x25dda0[_0x4217('0x7')],_0x25dda0['m_target'],!![]):_0x2b3a32['render'](_0x25dda0[_0x4217('0x8')],_0x25dda0[_0x4217('0x7')]);},this[_0x4217('0x2a')]=function(_0x933e57,_0x17d09c,_0x3f85fc){_0x25dda0[_0x4217('0x3d')]!=null&&_0x25dda0['m_target'][_0x4217('0x33')]();_0x25dda0[_0x4217('0xb')]=_0x3f85fc;var _0x4af2d2=0x3;_0x933e57/=_0x4af2d2,_0x17d09c/=_0x4af2d2,_0x25dda0[_0x4217('0x2d')]=_0x933e57,_0x25dda0[_0x4217('0x29')]=_0x17d09c,_0x25dda0[_0x4217('0x3d')]=new _three[(_0x4217('0x2'))](_0x933e57,_0x17d09c,{'minFilter':_three[_0x4217('0x31')],'magFilter':_three['LinearFilter'],'format':_three[_0x4217('0x3e')]});},this[_0x4217('0x5')]=function(_0x16692c){return _0x25dda0['m_bloom_intensity']=_0x16692c;},this['SetBloomSharpness']=function(_0x1fb944){_0x25dda0[_0x4217('0x2e')]!=_0x1fb944&&(_0x25dda0[_0x4217('0x2e')]=_0x1fb944,_0x25dda0['m_is_bloom_kernel_changed']=!![]);},this[_0x4217('0x0')]=function(_0x2de08a){return _0x25dda0[_0x4217('0xc')]=_0x2de08a;},this[_0x4217('0x17')]=function(_0x3502b0){return _0x25dda0['m_mesh'][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x9')][_0x4217('0x3b')]=_0x3502b0?0x1:0x0;},this[_0x4217('0x12')]=function(_0x472213){return _0x25dda0[_0x4217('0x1a')][_0x4217('0x38')][_0x4217('0x14')][_0x4217('0x28')][_0x4217('0x3b')]=_0x472213;},this[_0x4217('0x36')]=function(_0x1a26e2){return _0x25dda0[_0x4217('0x13')]=_0x1a26e2;};},_temp);exports[_0x4217('0x3')]=Object3DBloomFilter,module[_0x4217('0x23')]=exports[_0x4217('0x3')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3354:
/***/ (function(module, exports, __webpack_require__) {

var _0x5d13=['void\x20main()','\x20\x20\x20\x20const\x20float\x20A\x20=\x202.51;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20tmp[c]\x20=\x20max(0.0,\x20tmp[c]\x20-\x20threshold);','\x20\x20\x20\x20float\x20inv_kernel\x20=\x201.0\x20/\x20float(kernel);','\x20\x20\x20\x20color\x20=\x20pow(color,\x20vec3(GAMMA));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20min_rgb\x20=\x20min(tmp.r,\x20min(tmp.g,\x20tmp.b));','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.0),\x201.0);','vec3\x20InvGammaAndInvToneMap(vec3\x20color)','__esModule','\x20\x20\x20\x20vec3\x20a\x20=\x20C\x20*\x20color\x20-\x20A;','\x20\x20\x20\x20const\x20float\x20D\x20=\x200.59;','\x20\x20\x20\x20if\x20(is_use_roi\x20==\x201.0\x20&&\x20roi_mask\x20<\x200.05)','vec3\x20InvGammaAndInvToneMap(vec3\x20color);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv\x20=\x20texcoord\x20+\x20vec2(step_x\x20*\x20float(x),\x20step_y\x20*\x20float(y));','\x20\x20\x20\x20const\x20float\x20C\x20=\x202.43;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(x\x20<\x20-half_kernel\x20||\x20x\x20>\x20half_kernel)','uniform\x20float\x20frame_height;','uniform\x20sampler2D\x20kernel_texture;','vec3\x20ToneMapAndGamma(vec3\x20color)','\x20\x20\x20\x20}','\x20\x20\x20\x20int\x20kernel\x20=\x20half_kernel\x20*\x202\x20+\x201;','\x20\x20\x20\x20return\x20pow(color,\x20vec3(1.0\x20/\x20GAMMA));','\x20\x20\x20\x20float\x20step_y\x20=\x201.0\x20/\x20frame_height;','\x20\x20\x20\x20\x20\x20\x20\x20{','vec3\x20ToneMapAndGamma(vec3\x20color);','\x20\x20\x20\x20float\x20step_x\x20=\x201.0\x20/\x20frame_width;','\x20\x20\x20\x20\x20\x20\x20\x20return;','vec3\x20ACESToneMapping(vec3\x20color);','uniform\x20float\x20is_use_roi;','\x20\x20\x20\x20const\x20float\x20B\x20=\x200.03;','\x20\x20\x20\x20float\x20roi_mask\x20=\x20texture2D(roi_texture,\x20texcoord).r;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ws\x20+=\x20w;','\x20\x20\x20\x20color\x20=\x20ToneMapAndGamma(color);','\x20\x20\x20\x20color\x20=\x20ACESToneMapping(color);','vec3\x20InvACESToneMapping(vec3\x20color);','\x20\x20\x20\x20vec3\x20color\x20=\x20vec3(0.0);','varying\x20vec2\x20texcoord;','\x20\x20\x20\x20float\x20ws\x20=\x200.0;','\x20\x20\x20\x20{','\x20\x20\x20\x20return\x20InvACESToneMapping(color);','default','uniform\x20float\x20bloom_intensity;','fragmentShader','\x20\x20\x20\x20\x20\x20\x20\x20}','join','\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','uniform\x20float\x20frame_width;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','\x20\x20\x20\x20vec3\x20c\x20=\x20E\x20*\x20color;','\x20\x20\x20\x20vec3\x20b\x20=\x20D\x20*\x20color\x20-\x20B;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20color\x20+=\x20tmp\x20*\x20w;','\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20x\x20=\x20-MAX_HALF_KERNEL;\x20x\x20<=\x20MAX_HALF_KERNEL;\x20x++)','\x20\x20\x20\x20for\x20(int\x20y\x20=\x20-MAX_HALF_KERNEL;\x20y\x20<=\x20MAX_HALF_KERNEL;\x20y++)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(w\x20<\x200.01)','uniform\x20int\x20half_kernel;','\x20\x20\x20\x20const\x20float\x20E\x20=\x200.14;','vertexShader','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x201.0);','vec3\x20ACESToneMapping(vec3\x20color)','uniform\x20sampler2D\x20roi_texture;','\x20\x20\x20\x20\x20\x20\x20\x20if\x20(y\x20<\x20-half_kernel\x20||\x20y\x20>\x20half_kernel)','defineProperty','#define\x20GAMMA\x202.2'];(function(_0x28a7e9,_0x5d1359){var _0x4ec790=function(_0x509c8e){while(--_0x509c8e){_0x28a7e9['push'](_0x28a7e9['shift']());}};_0x4ec790(++_0x5d1359);}(_0x5d13,0x10e));var _0x4ec7=function(_0x28a7e9,_0x5d1359){_0x28a7e9=_0x28a7e9-0x0;var _0x4ec790=_0x5d13[_0x28a7e9];return _0x4ec790;};'use strict';Object[_0x4ec7('0x2b')](exports,'__esModule',{'value':!![]}),exports[_0x4ec7('0x16')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x2765ff){return _0x2765ff&&_0x2765ff[_0x4ec7('0x35')]?_0x2765ff:{'default':_0x2765ff};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x4ec7('0x16')])(this,Shader),this['input_uniforms']={'bloom_intensity':{'type':'f','value':0x0},'frame_height':{'type':'f','value':0x0},'frame_width':{'type':'f','value':0x0},'half_kernel':{'type':'i','value':0x0},'inputImageTexture':{'type':'t','value':null},'kernel_texture':{'type':'t','value':null},'roi_texture':{'type':'t','value':null},'threshold':{'type':'f','value':0x0},'is_use_roi':{'type':'f','value':0x1}},this[_0x4ec7('0x26')]=[_0x4ec7('0x12'),_0x4ec7('0x2d'),'{',_0x4ec7('0x1b'),'\x20\x20\x20\x20texcoord\x20=\x20uv;','}'][_0x4ec7('0x1a')]('\x0a'),this[_0x4ec7('0x18')]=[_0x4ec7('0x2c'),'#define\x20MAX_HALF_KERNEL\x2010',_0x4ec7('0x17'),_0x4ec7('0x3d'),_0x4ec7('0x1c'),_0x4ec7('0x24'),'uniform\x20sampler2D\x20inputImageTexture;',_0x4ec7('0x3e'),_0x4ec7('0x29'),'uniform\x20float\x20threshold;',_0x4ec7('0xa'),_0x4ec7('0x12'),_0x4ec7('0x9'),_0x4ec7('0x10'),_0x4ec7('0x39'),_0x4ec7('0x6'),_0x4ec7('0x2d'),'{',_0x4ec7('0xc'),_0x4ec7('0x38'),_0x4ec7('0x14'),_0x4ec7('0x33'),_0x4ec7('0x8'),'\x20\x20\x20\x20}','',_0x4ec7('0x7'),_0x4ec7('0x4'),_0x4ec7('0x2'),_0x4ec7('0x30'),_0x4ec7('0x11'),_0x4ec7('0x13'),_0x4ec7('0x22'),_0x4ec7('0x14'),_0x4ec7('0x2a'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','',_0x4ec7('0x21'),_0x4ec7('0x5'),_0x4ec7('0x3c'),_0x4ec7('0x1d'),'','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20kernel_uv\x20=\x20vec2(float(x\x20+\x20half_kernel)\x20*\x20inv_kernel,\x20float(y\x20+\x20half_kernel)\x20*\x20inv_kernel);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20w\x20=\x20texture2D(kernel_texture,\x20kernel_uv).r;',_0x4ec7('0x23'),_0x4ec7('0x1d'),'',_0x4ec7('0x3a'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20tmp\x20=\x20InvGammaAndInvToneMap(texture2D(inputImageTexture,\x20uv).rgb);',_0x4ec7('0x32'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20tmp\x20+=\x200.5\x20*\x20(tmp\x20-\x20vec3(min_rgb));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20c\x20=\x200;\x20c\x20<\x203;\x20c++)',_0x4ec7('0x2f'),'',_0x4ec7('0xd'),_0x4ec7('0x20'),_0x4ec7('0x19'),_0x4ec7('0x1'),'\x20\x20\x20\x20color\x20/=\x20ws;',_0x4ec7('0xe'),'\x20\x20\x20\x20color\x20*=\x20bloom_intensity;',_0x4ec7('0x27'),'}',_0x4ec7('0x28'),'{',_0x4ec7('0x2e'),'\x20\x20\x20\x20const\x20float\x20B\x20=\x200.03;',_0x4ec7('0x3b'),_0x4ec7('0x37'),_0x4ec7('0x25'),'\x20\x20\x20\x20return\x20(color\x20*\x20(A\x20*\x20color\x20+\x20B))\x20/\x20(color\x20*\x20(C\x20*\x20color\x20+\x20D)\x20+\x20E);','}','vec3\x20InvACESToneMapping(vec3\x20color)','{',_0x4ec7('0x2e'),_0x4ec7('0xb'),_0x4ec7('0x3b'),_0x4ec7('0x37'),_0x4ec7('0x25'),_0x4ec7('0x36'),_0x4ec7('0x1f'),_0x4ec7('0x1e'),'\x20\x20\x20\x20return\x20(-b\x20-\x20sqrt(b\x20*\x20b\x20-\x204.0\x20*\x20a\x20*\x20c))\x20/\x20(2.0\x20*\x20a);','}',_0x4ec7('0x34'),'{',_0x4ec7('0x31'),_0x4ec7('0x15'),'}',_0x4ec7('0x0'),'{',_0x4ec7('0xf'),_0x4ec7('0x3'),'}'][_0x4ec7('0x1a')]('\x0a');};exports['default']=Shader,module['exports']=exports['default'];

/***/ }),

/***/ 3355:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x5639=['p_vertex_array','uniforms','onUpload','vertexShader','addAttribute','__esModule','min','__proto__','buffer','pos_scale','pos_shift','get','m_scene_pos_arrays','array','SetObject3DRenderData','is_referenced_small_gem','input_uniforms','position','exports','default','defineProperty','clone','DoubleSide','gem_pos_scale','fragmentShader','YMKModule','p_normal_array','HEAPF32','length','clearScene','Float32BufferAttribute','m_material','Scene','is_small_gem','m_scene_norm_arrays','Vector3','value','gem_pos_shift','call','gem_center','vertex_array_size','add','ShaderMaterial','is_gem','frustumCulled','pop','Mesh','normal_array_size','is_norm','material','push','BufferGeometry'];(function(_0x5cb236,_0x5639fc){var _0xad8d83=function(_0x2cad6b){while(--_0x2cad6b){_0x5cb236['push'](_0x5cb236['shift']());}};_0xad8d83(++_0x5639fc);}(_0x5639,0x1e9));var _0xad8d=function(_0x5cb236,_0x5639fc){_0x5cb236=_0x5cb236-0x0;var _0xad8d83=_0x5639[_0x5cb236];return _0xad8d83;};'use strict';Object[_0xad8d('0x33')](exports,_0xad8d('0x24'),{'value':!![]}),exports[_0xad8d('0x32')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3356),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0xa43b38){return _0xa43b38&&_0xa43b38[_0xad8d('0x24')]?_0xa43b38:{'default':_0xa43b38};}var Object3dGemMeshEnvFilter=function(_0x23f35f){(0x0,_inherits3[_0xad8d('0x32')])(_0x21de2c,_0x23f35f);function _0x21de2c(_0x592f06,_0x2ce992,_0x325309){(0x0,_classCallCheck3[_0xad8d('0x32')])(this,_0x21de2c);var _0x440343=(0x0,_possibleConstructorReturn3['default'])(this,(_0x21de2c[_0xad8d('0x26')]||(0x0,_getPrototypeOf2[_0xad8d('0x32')])(_0x21de2c))[_0xad8d('0x11')](this,_0x592f06,_0x2ce992));_0x440343[_0xad8d('0x2d')]=function(_0x15abfa,_0x40e02f,_0x46986b){for(var _0x1915b4=0x0;_0x1915b4<Math[_0xad8d('0x25')](_0x46986b[_0xad8d('0x7')],_0x440343[_0xad8d('0xd')]['length']);_0x1915b4++){if(_0x46986b[_0x1915b4]==![])continue;for(var _0x3dfdf2=0x0;_0x3dfdf2<_0x440343[_0xad8d('0xd')][_0x1915b4][_0xad8d('0x7')];_0x3dfdf2++){_0x440343['m_scene_norm_arrays'][_0x1915b4][_0x3dfdf2]!=null&&(_0x440343[_0xad8d('0x8')](_0x440343[_0xad8d('0xd')][_0x1915b4][_0x3dfdf2]),_0x440343[_0xad8d('0x8')](_0x440343[_0xad8d('0x2b')][_0x1915b4][_0x3dfdf2]));}}var _0x2c9a94=_0x440343[_0xad8d('0xd')][_0xad8d('0x7')];if(_0x46986b[_0xad8d('0x7')]>_0x2c9a94)for(var _0x1a9a44=0x0;_0x1a9a44<_0x46986b[_0xad8d('0x7')]-_0x2c9a94;_0x1a9a44++){_0x440343[_0xad8d('0xd')][_0xad8d('0x1d')]([]),_0x440343['m_scene_pos_arrays'][_0xad8d('0x1d')]([]);}else{if(_0x2c9a94>_0x46986b['length'])for(var _0x552058=_0x2c9a94-0x1;_0x552058>=_0x46986b['length'];_0x552058--){_0x440343[_0xad8d('0xd')][_0xad8d('0x18')](),_0x440343[_0xad8d('0x2b')][_0xad8d('0x18')]();}}for(var _0x53c8fb=0x0;_0x53c8fb<_0x15abfa[_0xad8d('0x7')];_0x53c8fb++){if(_0x46986b[_0x53c8fb]==![])continue;var _0x34f0f3=_0x15abfa[_0x53c8fb],_0x1fc0af=_0x34f0f3['size'](),_0x5ae6ea=[],_0x3ce835=[];for(var _0x2fb08d=0x0;_0x2fb08d<_0x1fc0af;_0x2fb08d++){var _0x3701ce=function _0x4cb666(){delete this[_0xad8d('0x2c')],this['array']=null;},_0x244048=_0x34f0f3[_0xad8d('0x2a')](_0x2fb08d);if(_0x40e02f==![]&&(_0x244048[_0xad8d('0x16')]==![]||_0x244048[_0xad8d('0xc')]==!![]&&_0x244048[_0xad8d('0x2e')]==![])){_0x5ae6ea[_0xad8d('0x1d')](null),_0x3ce835[_0xad8d('0x1d')](null);continue;}var _0x1f058f=new Float32Array(_0x440343[_0xad8d('0x4')]['HEAPF32']['buffer'],_0x244048[_0xad8d('0x1f')],_0x244048[_0xad8d('0x13')]),_0x173b78=new Float32Array(_0x440343[_0xad8d('0x4')][_0xad8d('0x6')][_0xad8d('0x27')],_0x244048[_0xad8d('0x5')],_0x244048[_0xad8d('0x1a')]),_0x4e0a3b=new _three[(_0xad8d('0x1e'))]();_0x4e0a3b[_0xad8d('0x23')](_0xad8d('0x30'),new _three['Float32BufferAttribute'](_0x1f058f,0x3)[_0xad8d('0x21')](_0x3701ce)),_0x4e0a3b[_0xad8d('0x23')]('normal',new _three[(_0xad8d('0x9'))](_0x173b78,0x3)[_0xad8d('0x21')](_0x3701ce));var _0x1b1ff9=new _three[(_0xad8d('0x19'))](_0x4e0a3b,_0x440343[_0xad8d('0xa')][_0xad8d('0x0')]());_0x1b1ff9['frustumCulled']=![],_0x1b1ff9['material']['uniforms'][_0xad8d('0x12')][_0xad8d('0xf')]=new _three[(_0xad8d('0xe'))](_0x244048[_0xad8d('0x12')]['x'],_0x244048[_0xad8d('0x12')]['y'],_0x244048[_0xad8d('0x12')]['z']);var _0x1132ef=new _three['Scene']()[_0xad8d('0x14')](_0x1b1ff9),_0x2fb72c=new _three['Mesh'](_0x4e0a3b,_0x440343['m_material'][_0xad8d('0x0')]());_0x2fb72c[_0xad8d('0x17')]=![],_0x2fb72c[_0xad8d('0x1c')]['uniforms'][_0xad8d('0x1b')][_0xad8d('0xf')]=0x0,_0x2fb72c['material'][_0xad8d('0x20')]['gem_center'][_0xad8d('0xf')]=new _three['Vector3'](_0x244048[_0xad8d('0x12')]['x'],_0x244048[_0xad8d('0x12')]['y'],_0x244048[_0xad8d('0x12')]['z']),_0x2fb72c[_0xad8d('0x1c')]['uniforms'][_0xad8d('0x28')][_0xad8d('0xf')]=new _three[(_0xad8d('0xe'))](_0x244048[_0xad8d('0x2')]['x'],_0x244048[_0xad8d('0x2')]['y'],_0x244048['gem_pos_scale']['z']),_0x2fb72c[_0xad8d('0x1c')][_0xad8d('0x20')][_0xad8d('0x29')][_0xad8d('0xf')]=new _three[(_0xad8d('0xe'))](_0x244048[_0xad8d('0x10')]['x'],_0x244048[_0xad8d('0x10')]['y'],_0x244048[_0xad8d('0x10')]['z']);var _0xad78db=new _three[(_0xad8d('0xb'))]()[_0xad8d('0x14')](_0x2fb72c);_0x5ae6ea['push'](_0x1132ef),_0x3ce835[_0xad8d('0x1d')](_0xad78db);}_0x440343[_0xad8d('0xd')][_0x53c8fb]=_0x5ae6ea,_0x440343[_0xad8d('0x2b')][_0x53c8fb]=_0x3ce835;}},_0x440343[_0xad8d('0x4')]=_0x325309;var _0xd0d88a=new _shader2[(_0xad8d('0x32'))]();return _0x440343[_0xad8d('0xa')]=new _three[(_0xad8d('0x15'))]({'uniforms':_0xd0d88a[_0xad8d('0x2f')],'vertexShader':_0xd0d88a[_0xad8d('0x22')],'fragmentShader':_0xd0d88a[_0xad8d('0x3')],'depthTest':!![],'depthWrite':!![],'side':_three[_0xad8d('0x1')],'transparent':![]}),_0x440343[_0xad8d('0xd')]=[],_0x440343[_0xad8d('0x2b')]=[],_0x440343;}return _0x21de2c;}(_basefilter2['default']);exports[_0xad8d('0x32')]=Object3dGemMeshEnvFilter,module[_0xad8d('0x31')]=exports[_0xad8d('0x32')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3356:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x3a05=['\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(tmp\x20*\x200.5\x20+\x200.5,\x201.0);','uniform\x20vec3\x20pos_scale;','\x20\x20\x20\x20}','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4((pos_\x20-\x20gem_center\x20+\x20pos_shift)\x20/\x20pos_scale,\x201.0);','\x20\x20\x20\x20{','exports','fragmentShader','Vector3','\x20\x20\x20\x20else','default','\x20\x20\x20\x20pos_\x20=\x20position.xyz;','__esModule','join','defineProperty','varying\x20vec3\x20normal_;','\x20\x20\x20\x20if\x20(is_norm\x20==\x201)','varying\x20vec3\x20pos_;','uniform\x20vec3\x20gem_center;','vertexShader'];(function(_0xb5f7d9,_0x3a05b2){var _0x5c367b=function(_0x3daca4){while(--_0x3daca4){_0xb5f7d9['push'](_0xb5f7d9['shift']());}};_0x5c367b(++_0x3a05b2);}(_0x3a05,0x93));var _0x5c36=function(_0xb5f7d9,_0x3a05b2){_0xb5f7d9=_0xb5f7d9-0x0;var _0x5c367b=_0x3a05[_0xb5f7d9];return _0x5c367b;};'use strict';Object[_0x5c36('0x12')](exports,_0x5c36('0x10'),{'value':!![]}),exports[_0x5c36('0xe')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x569860){return _0x569860&&_0x569860[_0x5c36('0x10')]?_0x569860:{'default':_0x569860};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x5c36('0xe')])(this,Shader),this['input_uniforms']={'is_norm':{'type':'i','value':0x1},'gem_center':{'type':'v3','value':new _three[(_0x5c36('0xc'))]()},'pos_scale':{'type':'v3','value':new _three[(_0x5c36('0xc'))]()},'pos_shift':{'type':'v3','value':new _three[(_0x5c36('0xc'))]()}},this[_0x5c36('0x4')]=['uniform\x20vec3\x20gem_center;',_0x5c36('0x0'),_0x5c36('0x2'),'void\x20main()','{','\x20\x20\x20\x20normal_\x20=\x20normal.xyz;',_0x5c36('0xf'),'\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position\x20-\x20gem_center,\x201.0);','}'][_0x5c36('0x11')]('\x0a'),this[_0x5c36('0xb')]=['precision\x20highp\x20float;','uniform\x20int\x20is_norm;',_0x5c36('0x3'),_0x5c36('0x6'),'uniform\x20vec3\x20pos_shift;',_0x5c36('0x0'),_0x5c36('0x2'),'void\x20main()','{','\x20\x20\x20\x20vec3\x20tmp\x20=\x20normalize(-normal_);',_0x5c36('0x1'),_0x5c36('0x9'),_0x5c36('0x5'),_0x5c36('0x7'),_0x5c36('0xd'),_0x5c36('0x9'),_0x5c36('0x8'),_0x5c36('0x7'),'}'][_0x5c36('0x11')]('\x0a');};exports['default']=Shader,module[_0x5c36('0xa')]=exports[_0x5c36('0xe')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3357:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x25a8=['size','exports','SetObject3DRenderDataAndCubemap','push','is_referenced_small_gem','RGBAFormat','call','defineProperty','WebGLRenderTarget','minFilter','uniforms','ResetWidthHeight','m_mesh','texture','m_target_pos_arrays','is_small_gem','value','m_target_opaque_object_arrays','get','__proto__','fragmentShader','default','dispose','pop','__esModule','input_uniforms','material','ShaderMaterial','NearestFilter','LinearFilter','cubemap','m_target_opaque_pos_arrays','m_target_norm_arrays','length'];(function(_0x39d9f0,_0x25a811){var _0x212051=function(_0x594b94){while(--_0x594b94){_0x39d9f0['push'](_0x39d9f0['shift']());}};_0x212051(++_0x25a811);}(_0x25a8,0x73));var _0x2120=function(_0x39d9f0,_0x25a811){_0x39d9f0=_0x39d9f0-0x0;var _0x212051=_0x25a8[_0x39d9f0];return _0x212051;};'use strict';Object[_0x2120('0x1c')](exports,_0x2120('0xb'),{'value':!![]}),exports[_0x2120('0x8')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3358),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x539064){return _0x539064&&_0x539064[_0x2120('0xb')]?_0x539064:{'default':_0x539064};}var Object3DCubeToEquirectFilter=(_temp=_class=function(_0x57c3dc){(0x0,_inherits3[_0x2120('0x8')])(_0xefdd53,_0x57c3dc);function _0xefdd53(_0x559882,_0x4f2eec){(0x0,_classCallCheck3[_0x2120('0x8')])(this,_0xefdd53);var _0x44c7a6=(0x0,_possibleConstructorReturn3[_0x2120('0x8')])(this,(_0xefdd53[_0x2120('0x6')]||(0x0,_getPrototypeOf2[_0x2120('0x8')])(_0xefdd53))[_0x2120('0x1b')](this,_0x559882,_0x4f2eec));_initialiseProps[_0x2120('0x1b')](_0x44c7a6);var _0x32057d=new _shader2[(_0x2120('0x8'))](),_0xff3d01=new _three[(_0x2120('0xe'))]({'uniforms':_0x32057d[_0x2120('0xc')],'vertexShader':_0x32057d['vertexShader'],'fragmentShader':_0x32057d[_0x2120('0x7')],'depthTest':![],'depthWrite':![],'transparent':!![]});return _0x44c7a6[_0x2120('0x21')][_0x2120('0xd')]=_0xff3d01,_0x44c7a6[_0x2120('0x13')]=[],_0x44c7a6[_0x2120('0x1')]=[],_0x44c7a6[_0x2120('0x4')]=[],_0x44c7a6['m_target_opaque_pos_arrays']=[],_0x44c7a6;}return _0xefdd53;}(_basefilter2[_0x2120('0x8')]),_initialiseProps=function _initialiseProps(){var _0xd67977=this;this[_0x2120('0x20')]=function(){},this[_0x2120('0x17')]=function(_0x31650b,_0x25b85f,_0x161f9c,_0x3014bb){_0xd67977[_0x2120('0x21')]['material'][_0x2120('0x1f')][_0x2120('0x11')][_0x2120('0x3')]=_0x25b85f;for(var _0x27ea91=0x0;_0x27ea91<_0xd67977['m_target_norm_arrays'][_0x2120('0x14')];_0x27ea91++){if(_0x3014bb[_0x27ea91]==![])continue;for(var _0x3ca2ce=0x0;_0x3ca2ce<_0xd67977[_0x2120('0x13')][_0x27ea91][_0x2120('0x14')];_0x3ca2ce++){_0xd67977[_0x2120('0x13')][_0x27ea91][_0x3ca2ce]!=null&&(_0xd67977[_0x2120('0x13')][_0x27ea91][_0x3ca2ce]['dispose'](),_0xd67977[_0x2120('0x1')][_0x27ea91][_0x3ca2ce][_0x2120('0x9')](),_0xd67977['m_target_opaque_object_arrays'][_0x27ea91][_0x3ca2ce]['dispose'](),_0xd67977[_0x2120('0x12')][_0x27ea91][_0x3ca2ce][_0x2120('0x9')]());}}var _0x4ef542=_0xd67977[_0x2120('0x13')]['length'];if(_0x3014bb[_0x2120('0x14')]>_0x4ef542)for(var _0x49897c=0x0;_0x49897c<_0x3014bb[_0x2120('0x14')]-_0x4ef542;_0x49897c++){_0xd67977['m_target_norm_arrays'][_0x2120('0x18')]([]),_0xd67977[_0x2120('0x1')][_0x2120('0x18')]([]),_0xd67977[_0x2120('0x4')][_0x2120('0x18')]([]),_0xd67977[_0x2120('0x12')][_0x2120('0x18')]([]);}else{if(_0x4ef542>_0x3014bb[_0x2120('0x14')])for(var _0x399a1f=_0x4ef542-0x1;_0x399a1f>=_0x3014bb[_0x2120('0x14')];_0x399a1f--){_0xd67977[_0x2120('0x13')][_0x2120('0xa')](),_0xd67977[_0x2120('0x1')][_0x2120('0xa')](),_0xd67977[_0x2120('0x4')][_0x2120('0xa')](),_0xd67977['m_target_opaque_pos_arrays'][_0x2120('0xa')]();}}for(var _0x2cb0a9=0x0;_0x2cb0a9<_0x31650b[_0x2120('0x14')];_0x2cb0a9++){if(_0x3014bb[_0x2cb0a9]==![])continue;var _0x549e7a=_0x31650b[_0x2cb0a9],_0x25b02c=_0x549e7a[_0x2120('0x15')](),_0x3c0ad9=[],_0x578b66=[],_0x2990b0=[],_0x335523=[];for(var _0x51ca5e=0x0;_0x51ca5e<_0x25b02c;_0x51ca5e++){var _0x1d3a06=_0x549e7a[_0x2120('0x5')](_0x51ca5e);if(_0x161f9c==![]&&(_0x1d3a06['is_gem']==![]||_0x1d3a06[_0x2120('0x2')]==!![]&&_0x1d3a06[_0x2120('0x19')]==![])){_0x3c0ad9['push'](null),_0x578b66['push'](null),_0x2990b0[_0x2120('0x18')](null),_0x335523[_0x2120('0x18')](null);continue;}var _0x4e730f=_0x1d3a06[_0x2120('0x2')]?0x100:_0x161f9c?0x400:0x200,_0xc26b59=_0x4e730f*0x2,_0x2e0ac5=new _three[(_0x2120('0x1d'))](_0xc26b59,_0x4e730f,{'minFilter':_three[_0x2120('0x10')],'magFilter':_three[_0x2120('0x10')],'format':_three['RGBAFormat']});_0x2e0ac5[_0x2120('0x0')][_0x2120('0x1e')]=_three['NearestFilter'],_0x2e0ac5[_0x2120('0x0')]['magFilter']=_three[_0x2120('0xf')],_0x3c0ad9[_0x2120('0x18')](_0x2e0ac5),_0x578b66[_0x2120('0x18')](new _three[(_0x2120('0x1d'))](_0xc26b59,_0x4e730f,{'minFilter':_three[_0x2120('0x10')],'magFilter':_three[_0x2120('0x10')],'format':_three['RGBAFormat']})),_0x2990b0['push'](new _three[(_0x2120('0x1d'))](_0xc26b59,_0x4e730f,{'minFilter':_three['LinearFilter'],'magFilter':_three['LinearFilter'],'format':_three[_0x2120('0x1a')]})),_0x335523[_0x2120('0x18')](new _three['WebGLRenderTarget'](_0xc26b59,_0x4e730f,{'minFilter':_three[_0x2120('0x10')],'magFilter':_three[_0x2120('0x10')],'format':_three[_0x2120('0x1a')]}));}_0xd67977[_0x2120('0x13')][_0x2cb0a9]=_0x3c0ad9,_0xd67977['m_target_pos_arrays'][_0x2cb0a9]=_0x578b66,_0xd67977[_0x2120('0x4')][_0x2cb0a9]=_0x2990b0,_0xd67977[_0x2120('0x12')][_0x2cb0a9]=_0x335523;}};},_temp);exports[_0x2120('0x8')]=Object3DCubeToEquirectFilter,module[_0x2120('0x16')]=exports[_0x2120('0x8')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3358:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x2ff1=['join','vertexShader','const\x20float\x20PI\x20=\x203.14159265359;','exports','defineProperty','default','\x20\x20\x20\x20float\x20phi\x20=\x20(texcoord_.y\x20-\x200.5)\x20*\x20PI;','\x20\x20\x20\x20float\x20theta\x20=\x20texcoord_.x\x20*\x202.0\x20*\x20PI\x20+\x20PI;','precision\x20highp\x20float;','varying\x20vec2\x20texcoord_;','input_uniforms','\x20\x20\x20\x20texcoord_\x20=\x20vec2(uv.x,\x201.0\x20-\x20uv.y);','__esModule','void\x20main()','\x20\x20\x20\x20gl_FragColor\x20=\x20textureCube(cubemap,\x20ref);','\x20\x20\x20\x20ref.z\x20=\x20cos(phi)\x20*\x20sin(theta);','\x20\x20\x20\x20vec3\x20ref;','\x20\x20\x20\x20ref.y\x20=\x20sin(phi);'];(function(_0x2a3f3a,_0x2ff15a){var _0x3fe211=function(_0x385d57){while(--_0x385d57){_0x2a3f3a['push'](_0x2a3f3a['shift']());}};_0x3fe211(++_0x2ff15a);}(_0x2ff1,0x115));var _0x3fe2=function(_0x2a3f3a,_0x2ff15a){_0x2a3f3a=_0x2a3f3a-0x0;var _0x3fe211=_0x2ff1[_0x2a3f3a];return _0x3fe211;};'use strict';Object[_0x3fe2('0xf')](exports,_0x3fe2('0x5'),{'value':!![]}),exports['default']=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x48686e){return _0x48686e&&_0x48686e['__esModule']?_0x48686e:{'default':_0x48686e};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x3fe2('0x10')])(this,Shader),this[_0x3fe2('0x3')]={'cubemap':{'type':'t','value':null}},this[_0x3fe2('0xc')]=[_0x3fe2('0x2'),_0x3fe2('0x6'),'{',_0x3fe2('0x4'),'\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','}']['join']('\x0a'),this['fragmentShader']=[_0x3fe2('0x1'),'uniform\x20samplerCube\x20cubemap;',_0x3fe2('0xd'),_0x3fe2('0x2'),_0x3fe2('0x6'),'{',_0x3fe2('0x0'),_0x3fe2('0x11'),_0x3fe2('0x9'),'\x20\x20\x20\x20ref.x\x20=\x20cos(phi)\x20*\x20cos(theta);',_0x3fe2('0xa'),_0x3fe2('0x8'),_0x3fe2('0x7'),'}'][_0x3fe2('0xb')]('\x0a');};exports[_0x3fe2('0x10')]=Shader,module[_0x3fe2('0xe')]=exports[_0x3fe2('0x10')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3359:
/***/ (function(module, exports, __webpack_require__) {

var _0x1d48=['dispose','m_width','depthWrite','WebGLRenderTarget','__proto__','m_geometry','defineProperty','Scene','uniforms','fragmentShader','ShaderMaterial','add','RGBAFormat','frame_size','LinearFilter','input_uniforms','ceil','min','__esModule','m_mesh','value','call','m_target','ResetWidthHeight','max','Vector2','default','m_scene','depthTest','material','half_kernel'];(function(_0x1622a5,_0x1d482f){var _0x3007a2=function(_0x598b4e){while(--_0x598b4e){_0x1622a5['push'](_0x1622a5['shift']());}};_0x3007a2(++_0x1d482f);}(_0x1d48,0xc1));var _0x3007=function(_0x1622a5,_0x1d482f){_0x1622a5=_0x1622a5-0x0;var _0x3007a2=_0x1d48[_0x1622a5];return _0x3007a2;};'use strict';Object[_0x3007('0x1e')](exports,_0x3007('0xb'),{'value':!![]}),exports[_0x3007('0x13')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3360),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x4b1ca1){return _0x4b1ca1&&_0x4b1ca1[_0x3007('0xb')]?_0x4b1ca1:{'default':_0x4b1ca1};}var Object3DBloomROIDilateFilter=(_temp=_class=function(_0x4e6e7d){(0x0,_inherits3[_0x3007('0x13')])(_0x51256b,_0x4e6e7d);function _0x51256b(_0x55ec6e,_0x4d633d,_0x2f9432){(0x0,_classCallCheck3['default'])(this,_0x51256b);var _0x59e3c8=(0x0,_possibleConstructorReturn3['default'])(this,(_0x51256b[_0x3007('0x1c')]||(0x0,_getPrototypeOf2[_0x3007('0x13')])(_0x51256b))[_0x3007('0xe')](this,_0x55ec6e,_0x4d633d));_initialiseProps[_0x3007('0xe')](_0x59e3c8);var _0x23b2a1=new _shader2[(_0x3007('0x13'))](),_0x2a675d=new _three[(_0x3007('0x3'))]({'uniforms':_0x23b2a1[_0x3007('0x8')],'vertexShader':_0x23b2a1['vertexShader'],'fragmentShader':_0x23b2a1[_0x3007('0x2')]});return _0x59e3c8['m_mesh']=new _three['Mesh'](_0x59e3c8[_0x3007('0x1d')],_0x2a675d),_0x59e3c8[_0x3007('0xc')][_0x3007('0x16')][_0x3007('0x15')]=![],_0x59e3c8[_0x3007('0xc')]['material'][_0x3007('0x1a')]=![],_0x59e3c8['m_scene']=new _three[(_0x3007('0x0'))](),_0x59e3c8[_0x3007('0x14')][_0x3007('0x4')](_0x59e3c8[_0x3007('0xc')]),_0x59e3c8[_0x3007('0x10')](_0x55ec6e,_0x4d633d,_0x2f9432),_0x59e3c8;}return _0x51256b;}(_basefilter2['default']),_initialiseProps=function _initialiseProps(){var _0x2e4cfa=this;this[_0x3007('0x10')]=function(_0x2c58f7,_0x4684ed,_0x10f400){_0x2e4cfa[_0x3007('0xf')]!=null&&_0x2e4cfa[_0x3007('0xf')][_0x3007('0x18')]();var _0x353c41=Math[_0x3007('0x11')](0.4,Math[_0x3007('0xa')](1.6,_0x10f400));_0x2e4cfa[_0x3007('0xc')][_0x3007('0x16')]['uniforms'][_0x3007('0x17')][_0x3007('0xd')]=Math[_0x3007('0x9')](0x64*0.039*_0x353c41);var _0x4c012c=0x64/Math['sqrt'](_0x2c58f7*_0x4684ed);_0x2c58f7*=_0x4c012c,_0x4684ed*=_0x4c012c,_0x2e4cfa['m_mesh'][_0x3007('0x16')][_0x3007('0x1')][_0x3007('0x6')][_0x3007('0xd')]=new _three[(_0x3007('0x12'))](_0x2c58f7,_0x4684ed),_0x2e4cfa[_0x3007('0x19')]=_0x2c58f7,_0x2e4cfa['m_height']=_0x4684ed,_0x2e4cfa[_0x3007('0xf')]=new _three[(_0x3007('0x1b'))](_0x2c58f7,_0x4684ed,{'minFilter':_three[_0x3007('0x7')],'magFilter':_three[_0x3007('0x7')],'format':_three[_0x3007('0x5')]});};},_temp);exports['default']=Object3DBloomROIDilateFilter,module['exports']=exports[_0x3007('0x13')];

/***/ }),

/***/ 3360:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x38f7=['\x20\x20\x20\x20\x20\x20\x20\x20}','\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','\x20\x20\x20\x20for\x20(int\x20y\x20=\x20-MAX_HALF_KERNEL;\x20y\x20<=\x20MAX_HALF_KERNEL;\x20y++)','\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20x\x20=\x20-MAX_HALF_KERNEL;\x20x\x20<=\x20MAX_HALF_KERNEL;\x20x++)','__esModule','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(x\x20<\x20-half_kernel\x20||\x20x\x20>\x20half_kernel)','\x20\x20\x20\x20{','\x20\x20\x20\x20float\x20step_y\x20=\x201.0\x20/\x20frame_size.y;','vertexShader','join','Vector2','varying\x20vec2\x20texcoord;','void\x20main()','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20max_mask\x20=\x20max(max_mask,\x20color.r);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','exports','#define\x20MAX_HALF_KERNEL\x2010','uniform\x20sampler2D\x20inputImageTexture;','\x20\x20\x20\x20texcoord\x20=\x20uv;','default','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(max_mask),\x201.0);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;','\x20\x20\x20\x20\x20\x20\x20\x20{'];(function(_0x507fe3,_0x38f7a7){var _0x426f71=function(_0x5393bc){while(--_0x5393bc){_0x507fe3['push'](_0x507fe3['shift']());}};_0x426f71(++_0x38f7a7);}(_0x38f7,0x1b6));var _0x426f=function(_0x507fe3,_0x38f7a7){_0x507fe3=_0x507fe3-0x0;var _0x426f71=_0x38f7[_0x507fe3];return _0x426f71;};'use strict';Object['defineProperty'](exports,'__esModule',{'value':!![]}),exports[_0x426f('0x12')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x34604c){return _0x34604c&&_0x34604c[_0x426f('0x3')]?_0x34604c:{'default':_0x34604c};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x426f('0x12')])(this,Shader),this['input_uniforms']={'frame_size':{'type':'v2','value':new _three[(_0x426f('0x9'))](0x0,0x0)},'half_kernel':{'type':'i','value':0x0},'inputImageTexture':{'type':'t','value':null}},this[_0x426f('0x7')]=[_0x426f('0xa'),_0x426f('0xb'),'{',_0x426f('0x0'),_0x426f('0x11'),'}'][_0x426f('0x8')]('\x0a'),this['fragmentShader']=[_0x426f('0xf'),'uniform\x20vec2\x20frame_size;','uniform\x20int\x20half_kernel;',_0x426f('0x10'),_0x426f('0xa'),_0x426f('0xb'),'{','\x20\x20\x20\x20float\x20step_x\x20=\x201.0\x20/\x20frame_size.x;',_0x426f('0x6'),'\x20\x20\x20\x20float\x20max_mask\x20=\x200.0;',_0x426f('0x1'),_0x426f('0x5'),'\x20\x20\x20\x20\x20\x20\x20\x20if\x20(y\x20<\x20-half_kernel\x20||\x20y\x20>\x20half_kernel)',_0x426f('0x14'),'',_0x426f('0x2'),_0x426f('0x15'),_0x426f('0x4'),_0x426f('0xd'),'','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20color\x20=\x20texture2D(inputImageTexture,\x20texcoord\x20+\x20vec2(float(x)\x20*\x20step_x,\x20float(y)\x20*\x20step_y));',_0x426f('0xc'),_0x426f('0x16'),'\x20\x20\x20\x20}',_0x426f('0x13'),'}'][_0x426f('0x8')]('\x0a');};exports[_0x426f('0x12')]=Shader,module[_0x426f('0xe')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3361:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x30a1=['m_mesh','defineProperty','ResetWidthHeight','vertexShader','WebGLRenderTarget','SetSilhouetteTexture','default','uniforms','call','depthTest','RGBAFormat','LinearFilter','m_height','ShaderMaterial','exports','add','m_geometry','value','__esModule','fragmentShader','depthWrite','sqrt','dispose','Scene','material','m_scene','m_target'];(function(_0x378cdd,_0x30a12e){var _0xf3b13b=function(_0x1f1675){while(--_0x1f1675){_0x378cdd['push'](_0x378cdd['shift']());}};_0xf3b13b(++_0x30a12e);}(_0x30a1,0x14d));var _0xf3b1=function(_0x378cdd,_0x30a12e){_0x378cdd=_0x378cdd-0x0;var _0xf3b13b=_0x30a1[_0x378cdd];return _0xf3b13b;};'use strict';Object[_0xf3b1('0x13')](exports,_0xf3b1('0x9'),{'value':!![]}),exports[_0xf3b1('0x18')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3362),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x5244e2){return _0x5244e2&&_0x5244e2[_0xf3b1('0x9')]?_0x5244e2:{'default':_0x5244e2};}var Object3DBloomROIDownscaleFilter=(_temp=_class=function(_0xac4df9){(0x0,_inherits3[_0xf3b1('0x18')])(_0x381155,_0xac4df9);function _0x381155(_0x3719d9,_0x2ef00b){(0x0,_classCallCheck3[_0xf3b1('0x18')])(this,_0x381155);var _0x6388f5=(0x0,_possibleConstructorReturn3[_0xf3b1('0x18')])(this,(_0x381155['__proto__']||(0x0,_getPrototypeOf2[_0xf3b1('0x18')])(_0x381155))[_0xf3b1('0x1a')](this,_0x3719d9,_0x2ef00b));_initialiseProps[_0xf3b1('0x1a')](_0x6388f5);var _0x4228ec=new _shader2[(_0xf3b1('0x18'))](),_0x1ec54=new _three[(_0xf3b1('0x4'))]({'uniforms':_0x4228ec['input_uniforms'],'vertexShader':_0x4228ec[_0xf3b1('0x15')],'fragmentShader':_0x4228ec[_0xf3b1('0xa')]});return _0x6388f5[_0xf3b1('0x12')]=new _three['Mesh'](_0x6388f5[_0xf3b1('0x7')],_0x1ec54),_0x6388f5[_0xf3b1('0x12')][_0xf3b1('0xf')][_0xf3b1('0x0')]=![],_0x6388f5[_0xf3b1('0x12')][_0xf3b1('0xf')][_0xf3b1('0xb')]=![],_0x6388f5[_0xf3b1('0x10')]=new _three[(_0xf3b1('0xe'))](),_0x6388f5['m_scene'][_0xf3b1('0x6')](_0x6388f5['m_mesh']),_0x6388f5[_0xf3b1('0x14')](_0x3719d9,_0x2ef00b),_0x6388f5;}return _0x381155;}(_basefilter2[_0xf3b1('0x18')]),_initialiseProps=function _initialiseProps(){var _0x37b7a8=this;this[_0xf3b1('0x14')]=function(_0xd8ad67,_0x49ffcb){_0x37b7a8[_0xf3b1('0x11')]!=null&&_0x37b7a8[_0xf3b1('0x11')][_0xf3b1('0xd')]();var _0x646707=0x64/Math[_0xf3b1('0xc')](_0xd8ad67*_0x49ffcb);_0xd8ad67*=_0x646707,_0x49ffcb*=_0x646707,_0x37b7a8['m_width']=_0xd8ad67,_0x37b7a8[_0xf3b1('0x3')]=_0x49ffcb,_0x37b7a8[_0xf3b1('0x11')]=new _three[(_0xf3b1('0x16'))](_0xd8ad67,_0x49ffcb,{'minFilter':_three[_0xf3b1('0x2')],'magFilter':_three['LinearFilter'],'format':_three[_0xf3b1('0x1')]});},this[_0xf3b1('0x17')]=function(_0x1eb8ac){return _0x37b7a8[_0xf3b1('0x12')]['material'][_0xf3b1('0x19')]['silhouette_texture'][_0xf3b1('0x8')]=_0x1eb8ac;};},_temp);exports['default']=Object3DBloomROIDownscaleFilter,module[_0xf3b1('0x5')]=exports[_0xf3b1('0x18')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3362:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x465f=['input_uniforms','\x20\x20\x20\x20{','join','\x20\x20\x20\x20if\x20(silhouette\x20>\x200.45\x20&&\x20silhouette\x20<\x200.55)','exports','void\x20main()','defineProperty','default','\x20\x20\x20\x20float\x20silhouette\x20=\x20texture2D(silhouette_texture,\x20texcoord).g;','\x20\x20\x20\x20else','\x20\x20\x20\x20}','uniform\x20sampler2D\x20silhouette_texture;','\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(1.0);','vertexShader','varying\x20vec2\x20texcoord;','__esModule'];(function(_0x23204d,_0x465fad){var _0x2fb8da=function(_0x4b4af6){while(--_0x4b4af6){_0x23204d['push'](_0x23204d['shift']());}};_0x2fb8da(++_0x465fad);}(_0x465f,0xf7));var _0x2fb8=function(_0x23204d,_0x465fad){_0x23204d=_0x23204d-0x0;var _0x2fb8da=_0x465f[_0x23204d];return _0x2fb8da;};'use strict';Object[_0x2fb8('0xf')](exports,_0x2fb8('0x8'),{'value':!![]}),exports[_0x2fb8('0x0')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x33a6f3){return _0x33a6f3&&_0x33a6f3[_0x2fb8('0x8')]?_0x33a6f3:{'default':_0x33a6f3};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x2fb8('0x0')])(this,Shader),this[_0x2fb8('0x9')]={'silhouette_texture':{'type':'t','value':null}},this[_0x2fb8('0x6')]=[_0x2fb8('0x7'),_0x2fb8('0xe'),'{','\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);','\x20\x20\x20\x20texcoord\x20=\x20uv;','}']['join']('\x0a'),this['fragmentShader']=[_0x2fb8('0x4'),_0x2fb8('0x7'),_0x2fb8('0xe'),'{',_0x2fb8('0x1'),_0x2fb8('0xc'),_0x2fb8('0xa'),_0x2fb8('0x5'),_0x2fb8('0x3'),_0x2fb8('0x2'),_0x2fb8('0xa'),'\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(0.0,\x200.0,\x200.0,\x201.0);',_0x2fb8('0x3'),'}'][_0x2fb8('0xb')]('\x0a');};exports[_0x2fb8('0x0')]=Shader,module[_0x2fb8('0xd')]=exports[_0x2fb8('0x0')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3363:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x1f78=['m_skin_smooth_color_intensity','SetSkinSmoothStrength','call','__esModule','color_strength','m_mesh','m_target','UpdateSkinSmoothUniforms','LinearFilter','m_second_smooth_filter','DataTexture','analyzing_frame_height','Destroy','rootImageTexture','dispose','uniforms','hair_width','mask_height','roi_y','unpackAlignment','ResetWidthHeight','m_skin_smooth_strength','SetSkinSmoothColorIntensity','AlphaFormat','UnsignedByteType','RenderFrame','roi_x','background_image_height','center_x','smooth_strength','center_y','hairTexture','needsUpdate','analyzing_frame_width','material','exports','value','mask_width','default','roi_width','background_image_width','m_first_smooth_filter','m_hair_mask_texture','DisposeTexture','defineProperty','hair_height','magFilter','roi_height','SetInputTexture','setHairDyeMetadata'];(function(_0x31c73e,_0x1f7867){var _0x4a3fb7=function(_0x3b60c3){while(--_0x3b60c3){_0x31c73e['push'](_0x31c73e['shift']());}};_0x4a3fb7(++_0x1f7867);}(_0x1f78,0x135));var _0x4a3f=function(_0x31c73e,_0x1f7867){_0x31c73e=_0x31c73e-0x0;var _0x4a3fb7=_0x1f78[_0x31c73e];return _0x4a3fb7;};'use strict';Object[_0x4a3f('0x23')](exports,_0x4a3f('0x2c'),{'value':!![]}),exports['default']=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_firstsmoothfilter=__webpack_require__(3364),_firstsmoothfilter2=_interopRequireDefault(_firstsmoothfilter),_secondsmoothfilter=__webpack_require__(3366),_secondsmoothfilter2=_interopRequireDefault(_secondsmoothfilter);function _interopRequireDefault(_0x4c90c8){return _0x4c90c8&&_0x4c90c8[_0x4a3f('0x2c')]?_0x4c90c8:{'default':_0x4c90c8};}var SkinSmoothFilter=(_temp=_class=function(_0x541597){(0x0,_inherits3[_0x4a3f('0x1d')])(_0x1ea616,_0x541597);function _0x1ea616(_0x2f599f,_0x2d8d81){(0x0,_classCallCheck3['default'])(this,_0x1ea616);var _0x336d46=(0x0,_possibleConstructorReturn3[_0x4a3f('0x1d')])(this,(_0x1ea616['__proto__']||(0x0,_getPrototypeOf2[_0x4a3f('0x1d')])(_0x1ea616))[_0x4a3f('0x2b')](this,_0x2f599f,_0x2d8d81));return _initialiseProps[_0x4a3f('0x2b')](_0x336d46),_0x336d46[_0x4a3f('0x20')]=new _firstsmoothfilter2['default'](_0x2f599f,_0x2d8d81),_0x336d46[_0x4a3f('0x0')]=new _secondsmoothfilter2[(_0x4a3f('0x1d'))](_0x2f599f,_0x2d8d81),_0x336d46[_0x4a3f('0x2f')]=_0x336d46[_0x4a3f('0x0')][_0x4a3f('0x2f')],_0x336d46[_0x4a3f('0xc')]=0x32,_0x336d46[_0x4a3f('0x29')]=0x32,_0x336d46;}return _0x1ea616;}(_basefilter2['default']),_initialiseProps=function _initialiseProps(){var _0x147996=this;this[_0x4a3f('0x27')]=function(_0x57abea){_0x147996[_0x4a3f('0x20')][_0x4a3f('0x27')](_0x57abea),_0x147996[_0x4a3f('0x0')]['m_mesh'][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x4')][_0x4a3f('0x1b')]=_0x57abea,_0x147996['m_second_smooth_filter'][_0x4a3f('0x27')](_0x147996[_0x4a3f('0x20')]['m_target']['texture']);},this[_0x4a3f('0x10')]=function(_0x2f40cb,_0x3b7744){_0x147996[_0x4a3f('0x20')]['RenderFrame'](_0x2f40cb,!![]),_0x147996[_0x4a3f('0x0')][_0x4a3f('0x10')](_0x2f40cb,_0x3b7744);},this[_0x4a3f('0xb')]=function(_0xf5960d,_0x458da9){_0x147996['m_first_smooth_filter']=new _firstsmoothfilter2['default'](_0xf5960d,_0x458da9),_0x147996[_0x4a3f('0x0')]=new _secondsmoothfilter2['default'](_0xf5960d,_0x458da9),_0x147996[_0x4a3f('0x2f')]=_0x147996['m_second_smooth_filter']['m_target'];},this[_0x4a3f('0x22')]=function(){_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')]['material'][_0x4a3f('0x6')][_0x4a3f('0x16')][_0x4a3f('0x1b')]!=null&&(_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')]['hairTexture'][_0x4a3f('0x1b')][_0x4a3f('0x5')](),_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x16')][_0x4a3f('0x1b')]=null);},this[_0x4a3f('0x28')]=function(_0x5a4184,_0x116161){var _0x3f250b=_0x5a4184[_0x4a3f('0x18')],_0x4cf851=_0x5a4184[_0x4a3f('0x2')],_0xc405c3=(_0x5a4184[_0x4a3f('0x11')]+_0x5a4184[_0x4a3f('0x1e')]*0.5)/_0x3f250b,_0x2e2457=(_0x5a4184[_0x4a3f('0x9')]+_0x5a4184[_0x4a3f('0x26')]*0.5)/_0x4cf851;_0x147996[_0x4a3f('0x0')]['m_mesh'][_0x4a3f('0x19')]['uniforms'][_0x4a3f('0x13')][_0x4a3f('0x1b')]=_0xc405c3,_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')][_0x4a3f('0x19')]['uniforms'][_0x4a3f('0x15')][_0x4a3f('0x1b')]=_0x2e2457,_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x1f')][_0x4a3f('0x1b')]=_0x3f250b,_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')]['material'][_0x4a3f('0x6')][_0x4a3f('0x12')][_0x4a3f('0x1b')]=_0x4cf851,_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x7')]['value']=_0x5a4184[_0x4a3f('0x1e')],_0x147996['m_second_smooth_filter']['m_mesh'][_0x4a3f('0x19')]['uniforms'][_0x4a3f('0x24')]['value']=_0x5a4184[_0x4a3f('0x26')],_0x5a4184[_0x4a3f('0x1c')]*_0x5a4184[_0x4a3f('0x8')]>0x0?(_0x147996[_0x4a3f('0x21')]=new _three[(_0x4a3f('0x1'))](_0x116161,_0x5a4184['mask_width'],_0x5a4184[_0x4a3f('0x8')],_three[_0x4a3f('0xe')],_three[_0x4a3f('0xf')]),_0x147996[_0x4a3f('0x21')]['minFilter']=_three[_0x4a3f('0x31')],_0x147996[_0x4a3f('0x21')][_0x4a3f('0x25')]=_three['LinearFilter'],_0x147996[_0x4a3f('0x21')][_0x4a3f('0xa')]=0x1,_0x147996[_0x4a3f('0x21')][_0x4a3f('0x17')]=!![],_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')]['material'][_0x4a3f('0x6')][_0x4a3f('0x16')][_0x4a3f('0x1b')]=_0x147996[_0x4a3f('0x21')]):_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')]['material'][_0x4a3f('0x6')]['hairTexture']['value']!=null&&(_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x16')]['value']['dispose'](),_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x16')][_0x4a3f('0x1b')]=null);},this[_0x4a3f('0x30')]=function(){var _0x2e6694=0x0;_0x147996[_0x4a3f('0x29')]<=0x32?_0x2e6694=0.014*_0x147996['m_skin_smooth_color_intensity']:_0x2e6694=0.7+(_0x147996[_0x4a3f('0x29')]-0x32)*0.006,_0x147996[_0x4a3f('0x0')][_0x4a3f('0x2e')]['material'][_0x4a3f('0x6')][_0x4a3f('0x14')][_0x4a3f('0x1b')]=0.00084*_0x147996[_0x4a3f('0xc')],_0x147996['m_second_smooth_filter'][_0x4a3f('0x2e')][_0x4a3f('0x19')][_0x4a3f('0x6')][_0x4a3f('0x2d')]['value']=_0x2e6694;},this[_0x4a3f('0x2a')]=function(_0x539b60){return _0x147996[_0x4a3f('0xc')]=_0x539b60;},this[_0x4a3f('0xd')]=function(_0x4485e9){return _0x147996[_0x4a3f('0x29')]=_0x4485e9;},this[_0x4a3f('0x3')]=function(){_0x147996[_0x4a3f('0x20')][_0x4a3f('0x3')](),_0x147996[_0x4a3f('0x0')][_0x4a3f('0x3')]();};},_temp);exports[_0x4a3f('0x1d')]=SkinSmoothFilter,module[_0x4a3f('0x1a')]=exports[_0x4a3f('0x1d')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3364:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x50cf=['max','call','m_mesh','m_geometry','floor','default','min','value','sampling_step','vertexShader','ShaderMaterial','fragmentShader','__esModule','m_scene','depthTest','exports','depthWrite','material','defineProperty','uniforms','add','__proto__','Vector2','Mesh','Scene','sampling_offset_start'];(function(_0x42b23a,_0x50cfce){var _0x2607cb=function(_0x346f12){while(--_0x346f12){_0x42b23a['push'](_0x42b23a['shift']());}};_0x2607cb(++_0x50cfce);}(_0x50cf,0x17c));var _0x2607=function(_0x42b23a,_0x50cfce){_0x42b23a=_0x42b23a-0x0;var _0x2607cb=_0x50cf[_0x42b23a];return _0x2607cb;};'use strict';Object[_0x2607('0x2')](exports,_0x2607('0x16'),{'value':!![]}),exports[_0x2607('0xf')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3365),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x4aad26){return _0x4aad26&&_0x4aad26['__esModule']?_0x4aad26:{'default':_0x4aad26};}var FirstSmoothFilter=function(_0x159529){(0x0,_inherits3[_0x2607('0xf')])(_0x416c01,_0x159529);function _0x416c01(_0x5dc171,_0x336e23){(0x0,_classCallCheck3[_0x2607('0xf')])(this,_0x416c01);var _0x5a6d99=(0x0,_possibleConstructorReturn3[_0x2607('0xf')])(this,(_0x416c01[_0x2607('0x5')]||(0x0,_getPrototypeOf2['default'])(_0x416c01))[_0x2607('0xb')](this,_0x5dc171,_0x336e23)),_0x5ae72e=new _shader2[(_0x2607('0xf'))](),_0x19396e=new _three[(_0x2607('0x14'))]({'uniforms':_0x5ae72e['input_uniforms'],'vertexShader':_0x5ae72e[_0x2607('0x13')],'fragmentShader':_0x5ae72e[_0x2607('0x15')]});_0x5a6d99[_0x2607('0xc')]=new _three[(_0x2607('0x7'))](_0x5a6d99[_0x2607('0xd')],_0x19396e),_0x5a6d99[_0x2607('0xc')][_0x2607('0x1')][_0x2607('0x18')]=![],_0x5a6d99[_0x2607('0xc')][_0x2607('0x1')][_0x2607('0x0')]=![],_0x5a6d99['m_scene']=new _three[(_0x2607('0x8'))](),_0x5a6d99[_0x2607('0x17')][_0x2607('0x4')](_0x5a6d99[_0x2607('0xc')]);var _0x59bddf=0x6,_0x45a2dc=0x2d0,_0x52654f=Math[_0x2607('0x10')](_0x5dc171,_0x336e23)/_0x45a2dc,_0x37b5cf=Math[_0x2607('0xa')](0x1,Math[_0x2607('0xe')](_0x52654f*_0x59bddf)),_0x1f8532=_0x37b5cf-0.5;return _0x5a6d99[_0x2607('0xc')][_0x2607('0x1')][_0x2607('0x3')][_0x2607('0x9')][_0x2607('0x11')]=new _three[(_0x2607('0x6'))](_0x1f8532/_0x5dc171,0x0),_0x5a6d99[_0x2607('0xc')]['material'][_0x2607('0x3')][_0x2607('0x12')][_0x2607('0x11')]=new _three[(_0x2607('0x6'))](_0x37b5cf/_0x5dc171,0x0),_0x5a6d99;}return _0x416c01;}(_basefilter2[_0x2607('0xf')]);exports[_0x2607('0xf')]=FirstSmoothFilter,module[_0x2607('0x19')]=exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3365:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x15ba=['uniform\x20vec2\x20sampling_offset_start;','defineProperty','\x20\x20\x20\x20vec3\x20surround_0\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_0).rgb;','varying\x20vec2\x20texture_coordinate_surround_3;','\x20\x20\x20\x20vec4\x20average_info;','\x20\x20\x20\x20average_info.rgb\x20=\x20center\x20+\x20surround_0\x20+\x20surround_1\x20+\x20surround_2\x20+\x20surround_3;','\x20\x20\x20\x20vec3\x20surround_1\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_1).rgb;','precision\x20mediump\x20float;','uniform\x20vec2\x20sampling_step;','__esModule','\x20\x20\x20\x20texture_coordinate_surround_3\x20=\x20textureCoordinate\x20-\x20sampling_offset\x20-\x20sampling_step;','\x20\x20\x20\x20vec2\x20sampling_offset\x20=\x20sampling_offset_start;','\x20\x20\x20\x20average_info\x20*=\x200.2;','uniform\x20sampler2D\x20inputImageTexture;','varying\x20vec2\x20texture_coordinate_surround_0;','default','fragmentShader','vertexShader','\x20\x20\x20\x20gl_FragColor\x20=\x20average_info;','varying\x20vec2\x20texture_coordinate_surround_2;','varying\x20vec2\x20textureCoordinate;','void\x20main()\x20{','exports','Vector2','varying\x20vec2\x20texture_coordinate_surround_1;','\x20\x20\x20\x20texture_coordinate_surround_2\x20=\x20textureCoordinate\x20+\x20sampling_offset\x20+\x20sampling_step;','\x20\x20\x20\x20vec3\x20center\x20=\x20texture2D(inputImageTexture,\x20textureCoordinate).rgb;','join','\x20\x20\x20\x20average_info.a\x20=\x20center.g\x20*\x20center.g\x20+\x20surround_0.g\x20*\x20surround_0.g\x20+\x20surround_1.g\x20*\x20surround_1.g\x20+\x20surround_2.g\x20*\x20surround_2.g\x20+\x20surround_3.g\x20*\x20surround_3.g;','input_uniforms','\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','\x20\x20\x20\x20textureCoordinate\x20=\x20uv;'];(function(_0x59f5a6,_0x15ba95){var _0x3dc12e=function(_0x1d5696){while(--_0x1d5696){_0x59f5a6['push'](_0x59f5a6['shift']());}};_0x3dc12e(++_0x15ba95);}(_0x15ba,0x1de));var _0x3dc1=function(_0x59f5a6,_0x15ba95){_0x59f5a6=_0x59f5a6-0x0;var _0x3dc12e=_0x15ba[_0x59f5a6];return _0x3dc12e;};'use strict';Object[_0x3dc1('0x3')](exports,_0x3dc1('0xb'),{'value':!![]}),exports['default']=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x5eeed9){return _0x5eeed9&&_0x5eeed9['__esModule']?_0x5eeed9:{'default':_0x5eeed9};}var FirstSmoothShader=function FirstSmoothShader(){(0x0,_classCallCheck3[_0x3dc1('0x11')])(this,FirstSmoothShader),this[_0x3dc1('0x1f')]={'inputImageTexture':{'type':'t','value':null},'sampling_offset_start':{'type':'v2','value':new _three[(_0x3dc1('0x19'))](0x0,0x0)},'sampling_step':{'type':'v2','value':new _three[(_0x3dc1('0x19'))](0x0,0x0)}},this[_0x3dc1('0x13')]=[_0x3dc1('0x16'),_0x3dc1('0x10'),_0x3dc1('0x1a'),_0x3dc1('0x15'),_0x3dc1('0x5'),_0x3dc1('0x2'),_0x3dc1('0xa'),_0x3dc1('0x17'),_0x3dc1('0x1'),_0x3dc1('0x0'),_0x3dc1('0xd'),'\x20\x20\x20\x20texture_coordinate_surround_0\x20=\x20textureCoordinate\x20+\x20sampling_offset;','\x20\x20\x20\x20texture_coordinate_surround_1\x20=\x20textureCoordinate\x20-\x20sampling_offset;',_0x3dc1('0x1b'),_0x3dc1('0xc'),'}']['join']('\x0a'),this[_0x3dc1('0x12')]=[_0x3dc1('0x9'),_0x3dc1('0xf'),_0x3dc1('0x16'),_0x3dc1('0x10'),_0x3dc1('0x1a'),_0x3dc1('0x15'),_0x3dc1('0x5'),_0x3dc1('0x17'),_0x3dc1('0x1c'),_0x3dc1('0x4'),_0x3dc1('0x8'),'\x20\x20\x20\x20vec3\x20surround_2\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_2).rgb;','\x20\x20\x20\x20vec3\x20surround_3\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_3).rgb;',_0x3dc1('0x6'),_0x3dc1('0x7'),_0x3dc1('0x1e'),_0x3dc1('0xe'),_0x3dc1('0x14'),'}'][_0x3dc1('0x1d')]('\x0a');};exports['default']=FirstSmoothShader,module[_0x3dc1('0x18')]=exports[_0x3dc1('0x11')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3366:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x329b=['Mesh','UnsignedByteType','input_uniforms','max','Scene','add','default','material','m_scene','vertexShader','Vector2','__esModule','DataTexture','fragmentShader','m_mesh','m_table_texture','defineProperty','uniforms','m_table_texture_buffer','needsUpdate','depthTest','value','floor','sampling_step','ShaderMaterial','depthWrite','RGBFormat','exports'];(function(_0x4cd93f,_0x329bb5){var _0x496445=function(_0x5d9abd){while(--_0x5d9abd){_0x4cd93f['push'](_0x4cd93f['shift']());}};_0x496445(++_0x329bb5);}(_0x329b,0x1a7));var _0x4964=function(_0x4cd93f,_0x329bb5){_0x4cd93f=_0x4cd93f-0x0;var _0x496445=_0x329b[_0x4cd93f];return _0x496445;};'use strict';Object[_0x4964('0xd')](exports,_0x4964('0x8'),{'value':!![]}),exports[_0x4964('0x3')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3367),_shader2=_interopRequireDefault(_shader),_portrait_natural_table=__webpack_require__(3368),_portrait_natural_table2=_interopRequireDefault(_portrait_natural_table);function _interopRequireDefault(_0x51e68c){return _0x51e68c&&_0x51e68c[_0x4964('0x8')]?_0x51e68c:{'default':_0x51e68c};}var SecondSmoothFilter=function(_0x3c6045){(0x0,_inherits3[_0x4964('0x3')])(_0x3e17ac,_0x3c6045);function _0x3e17ac(_0x4f45a2,_0x4cc6a5){(0x0,_classCallCheck3[_0x4964('0x3')])(this,_0x3e17ac);var _0x5d4137=(0x0,_possibleConstructorReturn3[_0x4964('0x3')])(this,(_0x3e17ac['__proto__']||(0x0,_getPrototypeOf2[_0x4964('0x3')])(_0x3e17ac))['call'](this,_0x4f45a2,_0x4cc6a5)),_0x23ba20=new _shader2['default'](),_0x47746f=new _three[(_0x4964('0x15'))]({'uniforms':_0x23ba20[_0x4964('0x1b')],'vertexShader':_0x23ba20[_0x4964('0x6')],'fragmentShader':_0x23ba20[_0x4964('0xa')]});_0x5d4137[_0x4964('0xb')]=new _three[(_0x4964('0x19'))](_0x5d4137['m_geometry'],_0x47746f),_0x5d4137['m_mesh'][_0x4964('0x4')][_0x4964('0x11')]=![],_0x5d4137[_0x4964('0xb')][_0x4964('0x4')][_0x4964('0x16')]=![],_0x5d4137[_0x4964('0x5')]=new _three[(_0x4964('0x1'))](),_0x5d4137['m_scene'][_0x4964('0x2')](_0x5d4137[_0x4964('0xb')]);var _0x15cf83=0x6,_0x1c9c5f=0x2d0,_0x37244c=Math['min'](_0x4f45a2,_0x4cc6a5)/_0x1c9c5f,_0x3c1ca2=Math[_0x4964('0x0')](0x1,Math[_0x4964('0x13')](_0x37244c*_0x15cf83)),_0x1dab1a=_0x3c1ca2-0.5;_0x5d4137[_0x4964('0xb')][_0x4964('0x4')][_0x4964('0xe')]['sampling_offset_start']['value']=new _three[(_0x4964('0x7'))](0x0,_0x1dab1a/_0x4cc6a5),_0x5d4137[_0x4964('0xb')][_0x4964('0x4')]['uniforms'][_0x4964('0x14')][_0x4964('0x12')]=new _three[(_0x4964('0x7'))](0x0,_0x3c1ca2/_0x4cc6a5);var _0x456f88=0x100*0x3;_0x5d4137[_0x4964('0xf')]=new Uint8Array(_0x456f88);for(var _0x4a82c2=0x0;_0x4a82c2<_0x456f88;_0x4a82c2++){_0x5d4137[_0x4964('0xf')][_0x4a82c2]=_portrait_natural_table2[_0x4964('0x3')][_0x4a82c2];}return _0x5d4137[_0x4964('0xc')]=new _three[(_0x4964('0x9'))](_0x5d4137[_0x4964('0xf')],0x100,0x1,_three[_0x4964('0x17')],_three[_0x4964('0x1a')]),_0x5d4137['m_table_texture'][_0x4964('0x10')]=!![],_0x5d4137[_0x4964('0xb')][_0x4964('0x4')][_0x4964('0xe')]['mapping_table_texture'][_0x4964('0x12')]=_0x5d4137['m_table_texture'],_0x5d4137;}return _0x3e17ac;}(_basefilter2[_0x4964('0x3')]);exports[_0x4964('0x3')]=SecondSmoothFilter,module[_0x4964('0x18')]=exports[_0x4964('0x3')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3367:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x4f9b=['\x20\x20\x20\x20average_info\x20+=\x20surround_0\x20+\x20surround_1\x20+\x20surround_2\x20+\x20surround_3;','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','uniform\x20sampler2D\x20rootImageTexture;','Vector2','\x20\x20\x20\x20average_info\x20=\x20mix(average_info,\x20root_source,\x20src_weight);','uniform\x20float\x20hair_height;','uniform\x20float\x20hair_width;','uniform\x20float\x20dark_restoration_paramter;','\x20\x20\x20\x20const\x20float\x20RANGE_ADJUST_SQUARE\x20=\x20RANGE_ADJUST\x20*\x20RANGE_ADJUST;','\x20\x20\x20\x20float\x20sqaure_mean\x20=\x20RANGE_ADJUST_SQUARE\x20*\x20average_info.a;\x20','\x20\x20\x20\x20float\x20epsilon\x20=\x20RANGE_ADJUST\x20*\x20smooth_strength;','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color_effect,\x201.0);','\x20\x20\x20\x20vec4\x20average_info\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate);','varying\x20vec2\x20texture_coordinate_surround_2;','\x20\x20\x20\x20vec4\x20color_r\x20=\x20texture2D(mapping_table_texture,\x20vec2(index.r,\x200.5));','\x20\x20\x20\x20color_effect\x20=\x20mix(color_effect,\x20root_source.rgb,\x20hair_mask_value);','uniform\x20sampler2D\x20mapping_table_texture;','varying\x20vec2\x20texture_coordinate_surround_0;','uniform\x20vec2\x20sampling_offset_start;','\x20\x20\x20\x20texture_coordinate_surround_1\x20=\x20texture_coordinate\x20-\x20sampling_offset;','vertexShader','texture_coordinate\x20=\x20uv;','uniform\x20float\x20background_image_height;','uniform\x20float\x20background_image_width;','\x20\x20\x20vec4\x20root_source\x20=\x20texture2D(rootImageTexture,\x20texture_coordinate);','void\x20main()\x20{','varying\x20vec2\x20texture_coordinate_surround_3;','\x20\x20\x20\x20effect_source\x20=\x20clamp(effect_source\x20*\x201.032\x20-\x200.016,\x200.0,\x201.0);','uniform\x20float\x20color_strength;','__esModule','\x20\x20\x20\x20const\x20float\x20base_src_weight\x20=\x200.2;','uniform\x20sampler2D\x20hairTexture;','exports','\x20\x20\x20\x20texture_coordinate_surround_0\x20=\x20texture_coordinate\x20+\x20sampling_offset;','join','input_uniforms','\x20\x20\x20\x20vec3\x20effect_source\x20=\x20average_info.rgb;','\x20\x20\x20\x20hair_texture_coordinate.x\x20=\x20(texture_coordinate.x\x20-\x20center_x)\x20*\x20background_image_width\x20/\x20hair_width\x20+\x200.5;','\x20\x20\x20\x20vec3\x20index\x20=\x20effect_source\x20*\x20vec3(1.0\x20-\x201.0\x20/\x20256.0)\x20+\x20vec3(0.5\x20/\x20256.0);','\x20\x20\x20\x20src_weight\x20=\x20src_weight\x20+\x20base_src_weight\x20-\x20src_weight\x20*\x20base_src_weight;','uniform\x20float\x20smooth_strength;','uniform\x20float\x20center_x;','\x20\x20\x20\x20float\x20src_weight\x20=\x20variance\x20/\x20(variance\x20+\x20(epsilon\x20*\x20epsilon));','\x20\x20\x20\x20float\x20mean\x20=\x20RANGE_ADJUST\x20*\x20average_info.g;','\x20\x20\x20\x20vec4\x20surround_3\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_3);','uniform\x20float\x20center_y;','uniform\x20sampler2D\x20inputImageTexture;','\x20\x20\x20\x20vec3\x20color_effect\x20=\x20vec3(color_r.r,\x20color_g.g,\x20color_b.b);','varying\x20vec2\x20hair_texture_coordinate;','\x20\x20\x20\x20vec4\x20surround_2\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_2);','\x20\x20\x20\x20effect_source\x20=\x20clamp(effect_source\x20*\x20(1.0\x20+\x20dark_restoration_paramter)\x20-\x20dark_restoration_paramter,\x200.0,\x201.0);','\x20\x20\x20\x20float\x20hair_mask_value\x20=\x20texture2D(hairTexture,\x20hair_texture_coordinate).a;','\x20\x20\x20\x20vec4\x20surround_0\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_0);','default','\x20\x20\x20\x20vec2\x20sampling_offset\x20=\x20sampling_offset_start;','uniform\x20float\x20environment_luma_darkest;','varying\x20vec2\x20texture_coordinate;','uniform\x20vec2\x20sampling_step;','varying\x20vec2\x20texture_coordinate_surround_1;'];(function(_0x50720c,_0x4f9b57){var _0x33b00f=function(_0x55c351){while(--_0x55c351){_0x50720c['push'](_0x50720c['shift']());}};_0x33b00f(++_0x4f9b57);}(_0x4f9b,0x1b6));var _0x33b0=function(_0x50720c,_0x4f9b57){_0x50720c=_0x50720c-0x0;var _0x33b00f=_0x4f9b[_0x50720c];return _0x33b00f;};'use strict';Object['defineProperty'](exports,_0x33b0('0x4'),{'value':!![]}),exports[_0x33b0('0x1c')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x51ea47){return _0x51ea47&&_0x51ea47[_0x33b0('0x4')]?_0x51ea47:{'default':_0x51ea47};}var SecondSmoothShader=function SecondSmoothShader(){(0x0,_classCallCheck3['default'])(this,SecondSmoothShader),this[_0x33b0('0xa')]={'inputImageTexture':{'type':'t','value':null},'rootImageTexture':{'type':'t','value':null},'mapping_table_texture':{'type':'t','value':null},'sampling_offset_start':{'type':'v2','value':new _three[(_0x33b0('0x25'))](0x0,0x0)},'sampling_step':{'type':'v2','value':new _three[(_0x33b0('0x25'))](0x0,0x0)},'smooth_strength':{'type':'f','value':0.042},'color_strength':{'type':'f','value':0.7},'environment_luma_darkest':{'type':'f','value':0x0},'dark_restoration_paramter':{'type':'f','value':0x0},'hairTexture':{'type':'t','value':null},'center_x':{'type':'f','value':0.5},'center_y':{'type':'f','value':0.5},'background_image_width':{'type':'f','value':0x280},'background_image_height':{'type':'f','value':0x1e0},'hair_width':{'type':'f','value':0x0},'hair_height':{'type':'f','value':0x0}},this[_0x33b0('0x36')]=[_0x33b0('0x1f'),_0x33b0('0x33'),_0x33b0('0x21'),_0x33b0('0x2f'),_0x33b0('0x1'),'varying\x20vec2\x20hair_texture_coordinate;',_0x33b0('0x34'),_0x33b0('0x20'),_0x33b0('0x10'),_0x33b0('0x14'),_0x33b0('0x39'),_0x33b0('0x38'),_0x33b0('0x28'),_0x33b0('0x27'),_0x33b0('0x0'),_0x33b0('0x37'),_0x33b0('0x23'),_0x33b0('0x1d'),_0x33b0('0x8'),_0x33b0('0x35'),'\x20\x20\x20\x20texture_coordinate_surround_2\x20=\x20texture_coordinate\x20+\x20sampling_offset\x20+\x20sampling_step;','\x20\x20\x20\x20texture_coordinate_surround_3\x20=\x20texture_coordinate\x20-\x20sampling_offset\x20-\x20sampling_step;',_0x33b0('0xc'),'\x20\x20\x20\x20hair_texture_coordinate.y\x20=\x20(texture_coordinate.y\x20-\x20center_y)\x20*\x20background_image_height\x20/\x20hair_height\x20+\x200.5;','}'][_0x33b0('0x9')]('\x0a'),this['fragmentShader']=['precision\x20mediump\x20float;',_0x33b0('0x15'),_0x33b0('0x1f'),_0x33b0('0x17'),_0x33b0('0x24'),_0x33b0('0x6'),'varying\x20vec2\x20texture_coordinate_surround_0;',_0x33b0('0x21'),_0x33b0('0x2f'),_0x33b0('0x1'),_0x33b0('0xf'),_0x33b0('0x3'),_0x33b0('0x1e'),_0x33b0('0x29'),_0x33b0('0x32'),_0x33b0('0x0'),_0x33b0('0x2e'),_0x33b0('0x1b'),'\x20\x20\x20\x20vec4\x20surround_1\x20=\x20texture2D(inputImageTexture,\x20texture_coordinate_surround_1);',_0x33b0('0x18'),_0x33b0('0x13'),_0x33b0('0x22'),'\x20\x20\x20\x20average_info\x20*=\x200.2;','\x20\x20\x20\x20const\x20float\x20RANGE_ADJUST\x20=\x20100.0;',_0x33b0('0x2a'),_0x33b0('0x12'),_0x33b0('0x2b'),'\x20\x20\x20\x20float\x20variance\x20=\x20max(0.0001,\x20sqaure_mean\x20-\x20mean\x20*\x20mean);',_0x33b0('0x2c'),_0x33b0('0x11'),_0x33b0('0x5'),_0x33b0('0xe'),'\x20\x20\x20\x20src_weight\x20=\x201.0\x20-\x20((1.0\x20-\x20src_weight)\x20*\x20min(1.0,\x20average_info.g\x20*\x202.5));',_0x33b0('0x3a'),_0x33b0('0x26'),'\x20\x20\x20\x20vec3\x20blend_source\x20=\x20average_info.rgb;',_0x33b0('0xb'),_0x33b0('0x2'),_0x33b0('0x19'),_0x33b0('0xd'),_0x33b0('0x30'),'\x20\x20\x20\x20vec4\x20color_g\x20=\x20texture2D(mapping_table_texture,\x20vec2(index.g,\x200.5));','\x20\x20\x20\x20vec4\x20color_b\x20=\x20texture2D(mapping_table_texture,\x20vec2(index.b,\x200.5));',_0x33b0('0x16'),'\x20\x20\x20\x20color_effect\x20=\x20mix(blend_source,\x20color_effect,\x20min(1.0,\x20color_strength\x20*\x201.43));',_0x33b0('0x1a'),_0x33b0('0x31'),_0x33b0('0x2d'),'}'][_0x33b0('0x9')]('\x0a');};exports[_0x33b0('0x1c')]=SecondSmoothShader,module[_0x33b0('0x7')]=exports[_0x33b0('0x1c')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3368:
/***/ (function(module, exports) {

module.exports = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13,13,15,14,14,16,16,16,17,17,17,18,18,18,20,19,19,21,21,21,22,22,22,23,23,23,25,24,24,26,26,26,27,27,27,29,28,28,30,30,30,31,31,31,33,32,32,34,33,33,35,35,35,37,36,36,38,37,37,39,39,39,41,40,40,42,41,41,43,42,42,44,43,43,46,45,45,47,46,46,48,47,47,49,48,48,50,49,49,51,50,50,53,52,52,54,53,53,55,54,54,56,55,55,57,56,56,59,57,57,60,59,59,61,60,60,62,61,61,63,62,62,64,63,63,66,64,64,67,65,65,68,67,67,69,68,68,70,69,69,71,70,70,73,71,71,74,72,72,75,73,73,76,74,74,77,76,76,78,77,77,79,78,78,81,79,79,82,80,80,83,81,81,84,82,82,85,84,84,86,85,85,87,86,86,88,87,87,90,88,88,91,89,89,92,90,90,93,91,91,94,92,92,95,93,93,96,95,95,97,96,96,99,97,97,100,98,98,101,99,99,102,100,100,103,101,101,104,102,102,105,103,103,106,104,104,107,106,106,108,107,107,109,108,108,111,109,109,112,110,110,113,111,111,114,112,112,115,113,113,116,114,114,117,115,115,118,116,116,119,117,117,120,118,118,121,119,119,122,121,121,123,122,122,125,123,123,126,124,124,127,125,125,128,126,126,129,127,127,130,128,128,131,129,129,132,130,130,133,131,131,134,132,132,135,133,133,136,134,134,137,135,135,138,136,136,139,137,137,140,138,138,141,139,139,142,140,140,143,141,141,144,142,142,145,144,144,146,145,145,147,146,146,149,147,147,150,148,148,151,149,149,152,150,150,153,151,151,154,152,152,155,153,153,156,154,154,157,155,155,158,156,156,159,157,157,160,158,158,161,159,159,162,160,160,163,161,161,164,162,162,165,163,163,166,164,164,167,165,165,168,166,166,169,167,167,170,168,168,170,169,169,171,170,170,172,171,171,173,172,172,174,173,173,175,174,174,176,175,175,177,176,176,178,176,176,179,177,177,180,178,178,181,179,179,182,180,180,183,181,181,184,182,182,185,183,183,186,184,184,187,185,185,188,186,186,189,187,187,190,188,188,191,189,189,192,190,190,193,191,191,193,192,192,194,193,193,195,194,194,196,195,195,197,196,196,198,197,197,199,198,198,200,198,198,201,199,199,202,200,200,203,201,201,204,202,202,204,203,203,205,204,204,206,205,205,207,206,206,208,207,207,209,208,208,210,209,209,211,210,210,212,210,210,213,211,211,214,212,212,214,213,213,215,214,214,216,215,215,217,216,216,218,217,217,219,218,218,220,219,219,221,220,220,221,220,220,222,221,221,223,222,222,224,223,223,225,224,224,226,225,225,227,226,226,228,227,227,228,228,228,229,228,228,230,229,229,231,230,230,232,231,231,233,232,232,234,233,233,234,234,234,235,235,235,236,235,235,237,236,236,238,237,237,239,238,238,239,239,239,240,240,240,241,241,241,242,241,241,243,242,242,244,243,243,244,244,244,245,245,245,246,246,246,247,247,247,248,247,247,249,248,248,249,249,249,250,250,250,251,251,251,252,252,252,253,252,252,253,253,253,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255]

/***/ }),

/***/ 3369:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x51f5=['material','add','m_scene','default','Mesh','m_mesh','defineProperty','depthTest','ShaderMaterial','__proto__','depthWrite','__esModule','exports','fragmentShader','input_uniforms'];(function(_0x2a32ee,_0x51f534){var _0x1284d0=function(_0x2aac5d){while(--_0x2aac5d){_0x2a32ee['push'](_0x2a32ee['shift']());}};_0x1284d0(++_0x51f534);}(_0x51f5,0x115));var _0x1284=function(_0x2a32ee,_0x51f534){_0x2a32ee=_0x2a32ee-0x0;var _0x1284d0=_0x51f5[_0x2a32ee];return _0x1284d0;};'use strict';Object[_0x1284('0xe')](exports,_0x1284('0x4'),{'value':!![]}),exports[_0x1284('0xb')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3370),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x41418b){return _0x41418b&&_0x41418b['__esModule']?_0x41418b:{'default':_0x41418b};}var CropFilter=function(_0xa57325){(0x0,_inherits3[_0x1284('0xb')])(_0x3160c0,_0xa57325);function _0x3160c0(_0x3d52ee,_0x20db78){(0x0,_classCallCheck3[_0x1284('0xb')])(this,_0x3160c0);var _0x49cf01=(0x0,_possibleConstructorReturn3[_0x1284('0xb')])(this,(_0x3160c0[_0x1284('0x2')]||(0x0,_getPrototypeOf2[_0x1284('0xb')])(_0x3160c0))['call'](this,_0x3d52ee,_0x20db78)),_0x91fb32=new _shader2[(_0x1284('0xb'))](),_0x1062c9=new _three[(_0x1284('0x1'))]({'uniforms':_0x91fb32[_0x1284('0x7')],'vertexShader':_0x91fb32['vertexShader'],'fragmentShader':_0x91fb32[_0x1284('0x6')]});return _0x49cf01[_0x1284('0xd')]=new _three[(_0x1284('0xc'))](_0x49cf01['m_geometry'],_0x1062c9),_0x49cf01[_0x1284('0xd')][_0x1284('0x8')][_0x1284('0x0')]=![],_0x49cf01['m_mesh'][_0x1284('0x8')][_0x1284('0x3')]=![],_0x49cf01[_0x1284('0xa')]=new _three['Scene'](),_0x49cf01[_0x1284('0xa')][_0x1284('0x9')](_0x49cf01[_0x1284('0xd')]),_0x49cf01;}return _0x3160c0;}(_basefilter2[_0x1284('0xb')]);exports[_0x1284('0xb')]=CropFilter,module[_0x1284('0x5')]=exports[_0x1284('0xb')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3370:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x5d23=['gl_FragColor\x20=\x20vec4(cur.rgb,1.0);','join','uniform\x20vec2\x20crop_start_end_x;','varying\x20vec2\x20textureCoordinate;','fragmentShader','vec4\x20cur\x20=\x20texture2D(inputImageTexture,\x20crop_coordinate);','input_uniforms','uniform\x20sampler2D\x20inputImageTexture;','float\x20crop_range_x\x20=\x20crop_start_end_x.y\x20-\x20crop_start_end_x.x;','exports','void\x20main()\x20{','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','vec2\x20crop_coordinate\x20=\x20vec2(crop_start_end_x.x\x20+\x20textureCoordinate.x\x20*\x20crop_range_x,\x20textureCoordinate.y);','defineProperty','Vector2','default','__esModule'];(function(_0x45df5e,_0x5d234b){var _0x3a4d07=function(_0x4401fc){while(--_0x4401fc){_0x45df5e['push'](_0x45df5e['shift']());}};_0x3a4d07(++_0x5d234b);}(_0x5d23,0x189));var _0x3a4d=function(_0x45df5e,_0x5d234b){_0x45df5e=_0x45df5e-0x0;var _0x3a4d07=_0x5d23[_0x45df5e];return _0x3a4d07;};'use strict';Object[_0x3a4d('0xb')](exports,_0x3a4d('0xe'),{'value':!![]}),exports[_0x3a4d('0xd')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x1c7a88){return _0x1c7a88&&_0x1c7a88['__esModule']?_0x1c7a88:{'default':_0x1c7a88};}var CropShader=function CropShader(){(0x0,_classCallCheck3['default'])(this,CropShader),this[_0x3a4d('0x4')]={'inputImageTexture':{'type':'t','value':null},'crop_start_end_x':{'type':'v2','value':new _three[(_0x3a4d('0xc'))](0x0,0x1)}},this['vertexShader']=[_0x3a4d('0x1'),_0x3a4d('0x8'),'textureCoordinate\x20=\x20uv;',_0x3a4d('0x9'),'}'][_0x3a4d('0x10')]('\x0a'),this[_0x3a4d('0x2')]=[_0x3a4d('0x5'),_0x3a4d('0x0'),'varying\x20vec2\x20textureCoordinate;',_0x3a4d('0x8'),_0x3a4d('0x6'),_0x3a4d('0xa'),_0x3a4d('0x3'),_0x3a4d('0xf'),'}']['join']('\x0a');};exports[_0x3a4d('0xd')]=CropShader,module[_0x3a4d('0x7')]=exports[_0x3a4d('0xd')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3371:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x5d8b=['default','depthTest','ShaderMaterial','m_geometry','call','input_uniforms','add','__esModule','Mesh','__proto__','vertexShader','Scene','m_scene','depthWrite','fragmentShader','exports','m_mesh','defineProperty','material'];(function(_0x347fa7,_0x5d8b16){var _0xc4de2c=function(_0x3edb18){while(--_0x3edb18){_0x347fa7['push'](_0x347fa7['shift']());}};_0xc4de2c(++_0x5d8b16);}(_0x5d8b,0x71));var _0xc4de=function(_0x347fa7,_0x5d8b16){_0x347fa7=_0x347fa7-0x0;var _0xc4de2c=_0x5d8b[_0x347fa7];return _0xc4de2c;};'use strict';Object[_0xc4de('0x12')](exports,_0xc4de('0x8'),{'value':!![]}),exports[_0xc4de('0x1')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3372),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x10e8ae){return _0x10e8ae&&_0x10e8ae[_0xc4de('0x8')]?_0x10e8ae:{'default':_0x10e8ae};}var UpscaleFilter=function(_0x45f585){(0x0,_inherits3[_0xc4de('0x1')])(_0xdb3d4e,_0x45f585);function _0xdb3d4e(_0x5d2e9d,_0x5c51a5){(0x0,_classCallCheck3[_0xc4de('0x1')])(this,_0xdb3d4e);var _0x14fb67=(0x0,_possibleConstructorReturn3[_0xc4de('0x1')])(this,(_0xdb3d4e[_0xc4de('0xa')]||(0x0,_getPrototypeOf2[_0xc4de('0x1')])(_0xdb3d4e))[_0xc4de('0x5')](this,_0x5d2e9d,_0x5c51a5)),_0x298466=new _shader2[(_0xc4de('0x1'))](),_0x387812=new _three[(_0xc4de('0x3'))]({'uniforms':_0x298466[_0xc4de('0x6')],'vertexShader':_0x298466[_0xc4de('0xb')],'fragmentShader':_0x298466[_0xc4de('0xf')]});return _0x14fb67[_0xc4de('0x11')]=new _three[(_0xc4de('0x9'))](_0x14fb67[_0xc4de('0x4')],_0x387812),_0x14fb67[_0xc4de('0x11')][_0xc4de('0x0')][_0xc4de('0x2')]=![],_0x14fb67[_0xc4de('0x11')][_0xc4de('0x0')][_0xc4de('0xe')]=![],_0x14fb67[_0xc4de('0xd')]=new _three[(_0xc4de('0xc'))](),_0x14fb67[_0xc4de('0xd')][_0xc4de('0x7')](_0x14fb67['m_mesh']),_0x14fb67;}return _0xdb3d4e;}(_basefilter2[_0xc4de('0x1')]);exports[_0xc4de('0x1')]=UpscaleFilter,module[_0xc4de('0x10')]=exports[_0xc4de('0x1')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3372:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x4b4b=['__esModule','input_uniforms','uniform\x20vec2\x20end_xy;','Vector2','textureCoordinate\x20=\x20uv;','varying\x20vec2\x20textureCoordinate;','\x20\x20\x20\x20vec2\x20roi_width_height\x20=\x20max(end_xy\x20-\x20start_xy,\x20vec2(0.01));','default','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','uniform\x20sampler2D\x20inputImageTexture;','vertexShader','\x20\x20\x20\x20vec4\x20cur\x20=\x20texture2D(inputImageTexture,\x20new_texture_coordinate);','fragmentShader','uniform\x20vec2\x20start_xy;','exports','defineProperty','\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(cur.rgb,\x201.0);'];(function(_0x52ae3f,_0x4b4bba){var _0x1d3b95=function(_0x501a05){while(--_0x501a05){_0x52ae3f['push'](_0x52ae3f['shift']());}};_0x1d3b95(++_0x4b4bba);}(_0x4b4b,0x1bf));var _0x1d3b=function(_0x52ae3f,_0x4b4bba){_0x52ae3f=_0x52ae3f-0x0;var _0x1d3b95=_0x4b4b[_0x52ae3f];return _0x1d3b95;};'use strict';Object[_0x1d3b('0xa')](exports,_0x1d3b('0xc'),{'value':!![]}),exports['default']=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_three=__webpack_require__(705);function _interopRequireDefault(_0x1c57d2){return _0x1c57d2&&_0x1c57d2[_0x1d3b('0xc')]?_0x1c57d2:{'default':_0x1c57d2};}var UpscaleShader=function UpscaleShader(){(0x0,_classCallCheck3[_0x1d3b('0x2')])(this,UpscaleShader),this[_0x1d3b('0xd')]={'inputImageTexture':{'type':'t','value':null},'start_xy':{'type':'v2','value':new _three[(_0x1d3b('0xf'))](0x0,0x0)},'end_xy':{'type':'v2','value':new _three[(_0x1d3b('0xf'))](0x1,0x1)}},this[_0x1d3b('0x5')]=['varying\x20vec2\x20textureCoordinate;','void\x20main()\x20{',_0x1d3b('0x10'),_0x1d3b('0x3'),'}']['join']('\x0a'),this[_0x1d3b('0x7')]=[_0x1d3b('0x4'),_0x1d3b('0x0'),_0x1d3b('0x8'),_0x1d3b('0xe'),'void\x20main()\x20{',_0x1d3b('0x1'),'\x20\x20\x20\x20vec2\x20new_texture_coordinate\x20=\x20(textureCoordinate\x20*\x20roi_width_height\x20+\x20start_xy);',_0x1d3b('0x6'),_0x1d3b('0xb'),'}']['join']('\x0a');};exports[_0x1d3b('0x2')]=UpscaleShader,module[_0x1d3b('0x9')]=exports[_0x1d3b('0x2')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3373:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x551e=['__proto__','value','ShaderMaterial','material','m_mesh','depthTest','Mesh','fragmentShader','add','vertexShader','defineProperty','m_geometry','SetIsFrontCamera','__esModule','exports','uniforms','input_uniforms','default','is_front_camera','Scene','m_scene'];(function(_0x1c4e8a,_0x551e6c){var _0x14bc7e=function(_0x5621d1){while(--_0x5621d1){_0x1c4e8a['push'](_0x1c4e8a['shift']());}};_0x14bc7e(++_0x551e6c);}(_0x551e,0xda));var _0x14bc=function(_0x1c4e8a,_0x551e6c){_0x1c4e8a=_0x1c4e8a-0x0;var _0x14bc7e=_0x551e[_0x1c4e8a];return _0x14bc7e;};'use strict';Object[_0x14bc('0x2')](exports,_0x14bc('0x5'),{'value':!![]}),exports['default']=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3374),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x26b3ef){return _0x26b3ef&&_0x26b3ef[_0x14bc('0x5')]?_0x26b3ef:{'default':_0x26b3ef};}var FlipFilter=function(_0x3dd1cb){(0x0,_inherits3[_0x14bc('0x9')])(_0x36bc3a,_0x3dd1cb);function _0x36bc3a(_0x4f70cd,_0x4b551d){(0x0,_classCallCheck3[_0x14bc('0x9')])(this,_0x36bc3a);var _0x3014e6=(0x0,_possibleConstructorReturn3[_0x14bc('0x9')])(this,(_0x36bc3a[_0x14bc('0xd')]||(0x0,_getPrototypeOf2[_0x14bc('0x9')])(_0x36bc3a))['call'](this,_0x4f70cd,_0x4b551d));_0x3014e6[_0x14bc('0x4')]=function(_0x31fd0b){return _0x3014e6[_0x14bc('0x11')][_0x14bc('0x10')][_0x14bc('0x7')][_0x14bc('0xa')][_0x14bc('0xe')]=_0x31fd0b;};var _0x529f84=new _shader2[(_0x14bc('0x9'))](),_0x7e32cc=new _three[(_0x14bc('0xf'))]({'uniforms':_0x529f84[_0x14bc('0x8')],'vertexShader':_0x529f84[_0x14bc('0x1')],'fragmentShader':_0x529f84[_0x14bc('0x14')]});return _0x3014e6['m_mesh']=new _three[(_0x14bc('0x13'))](_0x3014e6[_0x14bc('0x3')],_0x7e32cc),_0x3014e6['m_mesh'][_0x14bc('0x10')][_0x14bc('0x12')]=![],_0x3014e6[_0x14bc('0x11')][_0x14bc('0x10')]['depthWrite']=![],_0x3014e6[_0x14bc('0xc')]=new _three[(_0x14bc('0xb'))](),_0x3014e6[_0x14bc('0xc')][_0x14bc('0x0')](_0x3014e6[_0x14bc('0x11')]),_0x3014e6;}return _0x36bc3a;}(_basefilter2['default']);exports[_0x14bc('0x9')]=FlipFilter,module[_0x14bc('0x6')]=exports[_0x14bc('0x9')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3374:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x245e=['vec4\x20cur\x20=\x20texture2D(inputImageTexture,\x20p);','void\x20main()\x20{','vertexShader','textureCoordinate\x20=\x20uv;','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','__esModule','exports','defineProperty','varying\x20vec2\x20textureCoordinate;','uniform\x20sampler2D\x20inputImageTexture;','vec2\x20p\x20=\x20vec2(texcoord_x,\x201.0\x20-\x20textureCoordinate.y);','default','join','gl_FragColor\x20=\x20vec4(cur.rgb,1.0);','input_uniforms'];(function(_0x146f5f,_0x245e84){var _0x23cd84=function(_0x481489){while(--_0x481489){_0x146f5f['push'](_0x146f5f['shift']());}};_0x23cd84(++_0x245e84);}(_0x245e,0xb9));var _0x23cd=function(_0x146f5f,_0x245e84){_0x146f5f=_0x146f5f-0x0;var _0x23cd84=_0x245e[_0x146f5f];return _0x23cd84;};'use strict';Object[_0x23cd('0x2')](exports,_0x23cd('0x0'),{'value':!![]}),exports[_0x23cd('0x6')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x2233d4){return _0x2233d4&&_0x2233d4['__esModule']?_0x2233d4:{'default':_0x2233d4};}var FlipShader=function FlipShader(){(0x0,_classCallCheck3[_0x23cd('0x6')])(this,FlipShader),this[_0x23cd('0x9')]={'inputImageTexture':{'type':'t','value':null},'is_front_camera':{'type':'i','value':0x1}},this[_0x23cd('0xc')]=[_0x23cd('0x3'),_0x23cd('0xb'),_0x23cd('0xd'),_0x23cd('0xe'),'}'][_0x23cd('0x7')]('\x0a'),this['fragmentShader']=[_0x23cd('0x4'),'uniform\x20int\x20is_front_camera;','varying\x20vec2\x20textureCoordinate;','void\x20main()\x20{','float\x20texcoord_x\x20=\x20(is_front_camera\x20==\x201)?\x201.0\x20-\x20textureCoordinate.x\x20:\x20textureCoordinate.x;',_0x23cd('0x5'),_0x23cd('0xa'),_0x23cd('0x8'),'}'][_0x23cd('0x7')]('\x0a');};exports['default']=FlipShader,module[_0x23cd('0x1')]=exports[_0x23cd('0x6')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3375:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x291c=['frameWidth','measure_desc_texture','measure_offset_default_value','UnsignedByteType','show_hint_view_or_not','ShaderMaterial','now','value','uniforms','manual_desc_texture_value','m_most_pos_offset_value','DataTexture','hint_hand_rotate_texture','hint_face_texture','SetMeasurePosition','depthWrite','is_show_manual','is_need_hand_open','magFilter','height','process_end_y','SetInputTexture','SetProcessRange','fragmentShader','GetAnimationEnd','hint_hand_open_texture_value','is_face_stable','__esModule','current_manual_animation_texture_value_index','hint_hand_rotate_texture_value','SetShowHintView','needsUpdate','defineProperty','SetIsEstimateLeftHand','default','m_mesh','manual_animation_texture_value','is_estimate_left_hand','ResetMeasurePosition','render','WebGLRenderTarget','m_width','map','m_geometry','exports','min','manual_blend_weight','material','LinearFilter','is_need_hand_roll_more','m_camera','m_four_way_index','RGBAFormat','dispose','is_hand_stable','hint_hand_clockwise_texture_value','hint_hand_texture','measure_desc_texture_value','m_height','m_most_neg_offset_value','measure_line_texture','apply','generateMipmaps','measure_line_texture_value','measure_offset','is_need_hand_roll_less','animation_end','RenderFrame','minFilter','width','add','hint_hand_anticlockwise_texture_value','frameHeight','process_end_x','PlaneGeometry','hint_face_texture_value','Scene','hint_hand_texture_value','ResetWidthHeight','manual_desc_texture','process_start_x','SetFourWayInfo','length','m_target','Mesh','vertexShader','m_scene','min_measure_offset','ArrangeAnimationIndexAndTime','SetHintViewType','m_is_four_way','image','call','manual_animation_texture','Camera','hint_view_type','SetHintViewEffect','lastAnimationTime','GetMeasureResultInPixel','is_measure_size','__proto__'];(function(_0x574e19,_0x291c29){var _0x2eb275=function(_0x42f410){while(--_0x42f410){_0x574e19['push'](_0x574e19['shift']());}};_0x2eb275(++_0x291c29);}(_0x291c,0x1d3));var _0x2eb2=function(_0x574e19,_0x291c29){_0x574e19=_0x574e19-0x0;var _0x2eb275=_0x291c[_0x574e19];return _0x2eb275;};'use strict';Object[_0x2eb2('0x46')](exports,_0x2eb2('0x41'),{'value':!![]}),exports[_0x2eb2('0x48')]=undefined;var _getPrototypeOf=__webpack_require__(57),_getPrototypeOf2=_interopRequireDefault(_getPrototypeOf),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_possibleConstructorReturn2=__webpack_require__(55),_possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2),_inherits2=__webpack_require__(56),_inherits3=_interopRequireDefault(_inherits2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_basefilter=__webpack_require__(851),_basefilter2=_interopRequireDefault(_basefilter),_shader=__webpack_require__(3376),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x5d4b8b){return _0x5d4b8b&&_0x5d4b8b[_0x2eb2('0x41')]?_0x5d4b8b:{'default':_0x5d4b8b};}var HintViewFilter=(_temp=_class=function(_0x36a4f5){(0x0,_inherits3[_0x2eb2('0x48')])(_0x3014cb,_0x36a4f5);function _0x3014cb(_0x81208c,_0x173327,_0x298f1e){(0x0,_classCallCheck3['default'])(this,_0x3014cb);var _0xf5c73f=(0x0,_possibleConstructorReturn3[_0x2eb2('0x48')])(this,(_0x3014cb[_0x2eb2('0x25')]||(0x0,_getPrototypeOf2[_0x2eb2('0x48')])(_0x3014cb))['call'](this,_0x81208c,_0x173327));_initialiseProps[_0x2eb2('0x1d')](_0xf5c73f),_0xf5c73f[_0x2eb2('0x4f')]=_0x81208c,_0xf5c73f[_0x2eb2('0x60')]=_0x173327,_0xf5c73f[_0x2eb2('0x58')]=new _three[(_0x2eb2('0x1f'))](),_0xf5c73f[_0x2eb2('0x14')]=new _three[(_0x2eb2('0x4e'))](_0x81208c,_0x173327,{'minFilter':_three[_0x2eb2('0x56')],'magFilter':_three[_0x2eb2('0x56')],'format':_three[_0x2eb2('0x5a')]}),_0xf5c73f['m_geometry']=new _three[(_0x2eb2('0xb'))](0x2,0x2);var _0x1f3f5a=new _shader2[(_0x2eb2('0x48'))](),_0x181fd5=new _three[(_0x2eb2('0x2b'))]({'uniforms':_0x1f3f5a['input_uniforms'],'vertexShader':_0x1f3f5a[_0x2eb2('0x16')],'fragmentShader':_0x1f3f5a[_0x2eb2('0x3d')]});return _0xf5c73f[_0x2eb2('0x49')]=new _three[(_0x2eb2('0x15'))](_0xf5c73f[_0x2eb2('0x51')],_0x181fd5),_0xf5c73f[_0x2eb2('0x49')][_0x2eb2('0x55')]['depthTest']=![],_0xf5c73f['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x35')]=![],_0xf5c73f[_0x2eb2('0xe')]=null,_0xf5c73f['hint_hand_rotate_texture_value']=null,_0xf5c73f[_0x2eb2('0x3f')]=null,_0xf5c73f[_0x2eb2('0x8')]=null,_0xf5c73f[_0x2eb2('0x5d')]=null,_0xf5c73f[_0x2eb2('0xc')]=null,_0xf5c73f['manual_animation_texture_value']=Array['apply'](null,Array(_0x298f1e))[_0x2eb2('0x50')](function(){}),_0xf5c73f['current_manual_animation_texture_value_index']=0x0,_0xf5c73f[_0x2eb2('0x2f')]=null,_0xf5c73f[_0x2eb2('0x0')]=null,_0xf5c73f[_0x2eb2('0x5f')]=null,_0xf5c73f[_0x2eb2('0x22')]=null,_0xf5c73f[_0x2eb2('0x17')]=new _three[(_0x2eb2('0xd'))](),_0xf5c73f[_0x2eb2('0x17')][_0x2eb2('0x7')](_0xf5c73f[_0x2eb2('0x49')]),_0xf5c73f[_0x2eb2('0x1b')]=![],_0xf5c73f['m_four_way_index']=-0x1,_0xf5c73f[_0x2eb2('0x2a')]=![],_0xf5c73f[_0x2eb2('0x5c')]=![],_0xf5c73f[_0x2eb2('0x57')]=![],_0xf5c73f[_0x2eb2('0x2')]=![],_0xf5c73f[_0x2eb2('0x40')]=![],_0xf5c73f['is_show_manual']=![],_0xf5c73f[_0x2eb2('0x3')]=![],_0xf5c73f[_0x2eb2('0x24')]=![],_0xf5c73f[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x26')][_0x2eb2('0x2d')]=_0x81208c,_0xf5c73f[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x9')][_0x2eb2('0x2d')]=_0x173327,_0xf5c73f[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')]['manual_blend_weight'][_0x2eb2('0x2d')]=0x1,_0xf5c73f['measure_offset_default_value']=0x0,_0xf5c73f['m_mesh'][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x18')][_0x2eb2('0x2d')]=-0.7,_0xf5c73f[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1')][_0x2eb2('0x2d')]=_0xf5c73f['measure_offset_default_value'],_0xf5c73f['is_estimate_left_hand']=!![],_0xf5c73f;}return _0x3014cb;}(_basefilter2[_0x2eb2('0x48')]),_initialiseProps=function _initialiseProps(){var _0xc7bf11=this;this[_0x2eb2('0x44')]=function(_0x144515){return _0xc7bf11[_0x2eb2('0x2a')]=_0x144515;},this[_0x2eb2('0x21')]=function(_0x4cbcc9,_0x2926e3,_0x5e9397,_0x377bce,_0x512c1e,_0x36b2a7,_0x2075cc){_0xc7bf11[_0x2eb2('0x36')]=_0x36b2a7,_0xc7bf11[_0x2eb2('0x5c')]=_0x4cbcc9,_0xc7bf11[_0x2eb2('0x37')]=_0x2926e3,_0xc7bf11[_0x2eb2('0x57')]=_0x5e9397,_0xc7bf11[_0x2eb2('0x2')]=_0x377bce,_0xc7bf11[_0x2eb2('0x40')]=_0x512c1e,_0xc7bf11[_0x2eb2('0x24')]=_0x2075cc;},this[_0x2eb2('0x3b')]=function(_0x38f120){return _0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')]['inputImageTexture'][_0x2eb2('0x2d')]=_0x38f120;},this[_0x2eb2('0x34')]=function(_0x3e9462,_0x4416ae){var _0x4c225a=_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1')]['value'];_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1')][_0x2eb2('0x2d')]=Math[_0x2eb2('0x53')](_0xc7bf11[_0x2eb2('0x30')],Math['max'](_0xc7bf11[_0x2eb2('0x61')],_0x4c225a-_0x3e9462/_0x4416ae));},this[_0x2eb2('0x4c')]=function(){return _0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x1')][_0x2eb2('0x2d')]=_0xc7bf11['measure_offset_default_value'];},this[_0x2eb2('0x23')]=function(_0x19ae3b){return(_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1')][_0x2eb2('0x2d')]-_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x18')][_0x2eb2('0x2d')])*_0x19ae3b;},this[_0x2eb2('0x47')]=function(_0x41019b){return _0xc7bf11[_0x2eb2('0x4b')]=_0x41019b;},this[_0x2eb2('0x3e')]=function(){return _0xc7bf11[_0x2eb2('0x3')];},this[_0x2eb2('0x19')]=function(){if(_0xc7bf11[_0x2eb2('0x42')]==_0xc7bf11[_0x2eb2('0x4a')]['length']-0x1){if(_0xc7bf11[_0x2eb2('0x36')]&&_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x54')][_0x2eb2('0x2d')]>0x0){_0xc7bf11[_0x2eb2('0x2a')]=!![],_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x54')][_0x2eb2('0x2d')]-=0.0125,_0xc7bf11[_0x2eb2('0x22')]=null;return;}_0xc7bf11['animation_end']=!![],_0xc7bf11['current_manual_animation_texture_value_index']=0x0,_0xc7bf11[_0x2eb2('0x22')]=null;return;}if(_0xc7bf11[_0x2eb2('0x22')]==null)_0xc7bf11[_0x2eb2('0x22')]=Date[_0x2eb2('0x2c')]();if(!_0xc7bf11[_0x2eb2('0x36')])_0xc7bf11[_0x2eb2('0x3')]=![],_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x54')][_0x2eb2('0x2d')]=0x1,_0xc7bf11['current_manual_animation_texture_value_index']=0x0,_0xc7bf11[_0x2eb2('0x22')]=null;else{var _0x559fd3=Date[_0x2eb2('0x2c')]();_0x559fd3-_0xc7bf11[_0x2eb2('0x22')]>0x64&&(_0xc7bf11[_0x2eb2('0x22')]=_0x559fd3,_0xc7bf11[_0x2eb2('0x42')]=_0xc7bf11[_0x2eb2('0x42')]==_0xc7bf11[_0x2eb2('0x4a')][_0x2eb2('0x13')]-0x1?0x0:_0xc7bf11[_0x2eb2('0x42')]+0x1);}},this[_0x2eb2('0x4')]=function(_0x56620b,_0x2fe17a){_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x36')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x36')]?0x1:0x0,_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x5c')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x5c')]?0x1:0x0,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x40')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x40')]?0x1:0x0,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x24')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x24')]?0x1:0x0,_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x4b')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x4b')]?0x1:0x0;if(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x32')][_0x2eb2('0x2d')]!=null)_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x32')][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x32')][_0x2eb2('0x2d')]=_0xc7bf11['hint_hand_rotate_texture_value'];if(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x5e')][_0x2eb2('0x2d')]!=null)_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x5e')][_0x2eb2('0x2d')]['dispose']();_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x5e')][_0x2eb2('0x2d')]=_0xc7bf11['is_need_hand_roll_less']?_0xc7bf11[_0x2eb2('0x4b')]?_0xc7bf11[_0x2eb2('0x8')]:_0xc7bf11[_0x2eb2('0x8')]:_0xc7bf11[_0x2eb2('0x57')]?_0xc7bf11['is_estimate_left_hand']?_0xc7bf11[_0x2eb2('0x5d')]:_0xc7bf11[_0x2eb2('0x5d')]:_0xc7bf11[_0x2eb2('0x37')]?_0xc7bf11[_0x2eb2('0x3f')]:_0xc7bf11[_0x2eb2('0x2a')]?_0xc7bf11[_0x2eb2('0xe')]:null;if(_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x33')][_0x2eb2('0x2d')]!=null)_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')]['hint_face_texture'][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x33')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x2a')]?_0xc7bf11[_0x2eb2('0xc')]:null;if(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1e')]['value']!=null)_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1e')][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x19')](),_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1e')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x36')]?_0xc7bf11[_0x2eb2('0x4a')][_0xc7bf11[_0x2eb2('0x42')]]:null;if(_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms'][_0x2eb2('0x10')]['value']!=null)_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x10')][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms']['manual_desc_texture'][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x36')]?_0xc7bf11[_0x2eb2('0x2f')]:null;if(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x62')][_0x2eb2('0x2d')]!=null)_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')]['measure_line_texture'][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms'][_0x2eb2('0x62')][_0x2eb2('0x2d')]=_0xc7bf11[_0x2eb2('0x24')]?_0xc7bf11[_0x2eb2('0x0')]:null;if(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x27')][_0x2eb2('0x2d')]!=null)_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x27')][_0x2eb2('0x2d')][_0x2eb2('0x5b')]();_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x27')][_0x2eb2('0x2d')]=_0xc7bf11['is_measure_size']?_0xc7bf11[_0x2eb2('0x5f')]:null,_0x2fe17a?_0x56620b[_0x2eb2('0x4d')](_0xc7bf11[_0x2eb2('0x17')],_0xc7bf11['m_camera'],_0xc7bf11[_0x2eb2('0x14')],!![]):_0x56620b[_0x2eb2('0x4d')](_0xc7bf11[_0x2eb2('0x17')],_0xc7bf11[_0x2eb2('0x58')]);},this[_0x2eb2('0xf')]=function(_0x37a47c,_0x4324fa){_0xc7bf11['m_target']!=null&&_0xc7bf11[_0x2eb2('0x14')]['dispose'](),_0xc7bf11[_0x2eb2('0x4f')]=_0x37a47c,_0xc7bf11[_0x2eb2('0x60')]=_0x4324fa,_0xc7bf11[_0x2eb2('0x14')]=new _three['WebGLRenderTarget'](_0x37a47c,_0x4324fa,{'minFilter':_three[_0x2eb2('0x56')],'magFilter':_three[_0x2eb2('0x56')],'format':_three['RGBAFormat']});},this[_0x2eb2('0x1a')]=function(_0xdd9fcb){_0xc7bf11[_0x2eb2('0x28')]=_0xdd9fcb==0x0?-0.45:0x0,_0xc7bf11[_0x2eb2('0x61')]=_0xdd9fcb==0x0?-0.57:-0.4,_0xc7bf11[_0x2eb2('0x30')]=_0xdd9fcb==0x0?-0.4:0.175,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x1')]['value']=_0xc7bf11['measure_offset_default_value'],_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x20')][_0x2eb2('0x2d')]=_0xdd9fcb;},this['SetHintViewTexture']=function(_0x4f0661,_0x387773,_0x3c3738,_0x44b890,_0x56d3b3,_0xe2b6c7,_0xfe3e1,_0x242689,_0x509155,_0xc29d10){_0xc7bf11[_0x2eb2('0xe')]=new _three[(_0x2eb2('0x31'))](_0x4f0661[_0x2eb2('0x1c')],_0x4f0661[_0x2eb2('0x6')],_0x4f0661[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0xe')]['generateMipmaps']=!![],_0xc7bf11[_0x2eb2('0xe')]['minFilter']=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0xe')]['magFilter']=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0xe')][_0x2eb2('0x45')]=!![],_0xc7bf11[_0x2eb2('0x43')]=new _three['DataTexture'](_0x387773[_0x2eb2('0x1c')],_0x387773['width'],_0x387773[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x43')][_0x2eb2('0x64')]=!![],_0xc7bf11[_0x2eb2('0x43')][_0x2eb2('0x5')]=_three[_0x2eb2('0x56')],_0xc7bf11['hint_hand_rotate_texture_value'][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x43')]['needsUpdate']=!![],_0xc7bf11[_0x2eb2('0x3f')]=new _three[(_0x2eb2('0x31'))](_0x3c3738[_0x2eb2('0x1c')],_0x3c3738[_0x2eb2('0x6')],_0x3c3738[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11['hint_hand_open_texture_value'][_0x2eb2('0x64')]=!![],_0xc7bf11[_0x2eb2('0x3f')][_0x2eb2('0x5')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x3f')][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x3f')]['needsUpdate']=!![],_0xc7bf11[_0x2eb2('0xc')]=new _three[(_0x2eb2('0x31'))](_0x44b890[_0x2eb2('0x1c')],_0x44b890[_0x2eb2('0x6')],_0x44b890[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11['hint_face_texture_value'][_0x2eb2('0x64')]=!![],_0xc7bf11[_0x2eb2('0xc')][_0x2eb2('0x5')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0xc')][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0xc')][_0x2eb2('0x45')]=!![];_0x56d3b3[_0x2eb2('0x13')]!=_0xc7bf11[_0x2eb2('0x4a')][_0x2eb2('0x13')]&&(_0xc7bf11[_0x2eb2('0x4a')]=Array[_0x2eb2('0x63')](null,Array(_0xc7bf11[_0x2eb2('0x4a')][_0x2eb2('0x13')]))['map'](function(){}));for(var _0x446c0a=0x0;_0x446c0a<_0x56d3b3[_0x2eb2('0x13')];_0x446c0a++){_0xc7bf11[_0x2eb2('0x4a')][_0x446c0a]=new _three[(_0x2eb2('0x31'))](_0x56d3b3[_0x446c0a]['image'],_0x56d3b3[_0x446c0a][_0x2eb2('0x6')],_0x56d3b3[_0x446c0a][_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x4a')][_0x446c0a]['generateMipmaps']=!![],_0xc7bf11[_0x2eb2('0x4a')][_0x446c0a][_0x2eb2('0x5')]=_three['LinearFilter'],_0xc7bf11[_0x2eb2('0x4a')][_0x446c0a][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x4a')][_0x446c0a][_0x2eb2('0x45')]=!![];}_0xc7bf11[_0x2eb2('0x2f')]=new _three[(_0x2eb2('0x31'))](_0xe2b6c7[_0x2eb2('0x1c')],_0xe2b6c7['width'],_0xe2b6c7[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three['UnsignedByteType']),_0xc7bf11[_0x2eb2('0x2f')]['generateMipmaps']=!![],_0xc7bf11[_0x2eb2('0x2f')][_0x2eb2('0x5')]=_three['LinearFilter'],_0xc7bf11[_0x2eb2('0x2f')][_0x2eb2('0x38')]=_three['LinearFilter'],_0xc7bf11[_0x2eb2('0x2f')][_0x2eb2('0x45')]=!![],_0xc7bf11[_0x2eb2('0x0')]=new _three[(_0x2eb2('0x31'))](_0xfe3e1['image'],_0xfe3e1[_0x2eb2('0x6')],_0xfe3e1[_0x2eb2('0x39')],_three['RGBAFormat'],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x0')]['generateMipmaps']=!![],_0xc7bf11[_0x2eb2('0x0')][_0x2eb2('0x5')]=_three['LinearFilter'],_0xc7bf11[_0x2eb2('0x0')][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11['measure_line_texture_value'][_0x2eb2('0x45')]=!![],_0xc7bf11[_0x2eb2('0x5f')]=new _three[(_0x2eb2('0x31'))](_0x242689[_0x2eb2('0x1c')],_0x242689[_0x2eb2('0x6')],_0x242689[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x5f')]['generateMipmaps']=!![],_0xc7bf11[_0x2eb2('0x5f')][_0x2eb2('0x5')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x5f')][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x5f')][_0x2eb2('0x45')]=!![],_0xc7bf11[_0x2eb2('0x5d')]=new _three[(_0x2eb2('0x31'))](_0x509155[_0x2eb2('0x1c')],_0x509155[_0x2eb2('0x6')],_0x509155[_0x2eb2('0x39')],_three[_0x2eb2('0x5a')],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x5d')][_0x2eb2('0x64')]=!![],_0xc7bf11['hint_hand_clockwise_texture_value'][_0x2eb2('0x5')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x5d')]['magFilter']=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x5d')][_0x2eb2('0x45')]=!![],_0xc7bf11[_0x2eb2('0x8')]=new _three[(_0x2eb2('0x31'))](_0xc29d10[_0x2eb2('0x1c')],_0xc29d10[_0x2eb2('0x6')],_0xc29d10[_0x2eb2('0x39')],_three['RGBAFormat'],_three[_0x2eb2('0x29')]),_0xc7bf11[_0x2eb2('0x8')][_0x2eb2('0x64')]=!![],_0xc7bf11['hint_hand_anticlockwise_texture_value']['minFilter']=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x8')][_0x2eb2('0x38')]=_three[_0x2eb2('0x56')],_0xc7bf11[_0x2eb2('0x8')][_0x2eb2('0x45')]=!![];},this['DisposeTexture']=function(){_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x5e')][_0x2eb2('0x2d')]!=null&&(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x5e')][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms'][_0x2eb2('0x5e')][_0x2eb2('0x2d')]=null),_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x32')][_0x2eb2('0x2d')]!=null&&(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')]['hint_hand_rotate_texture'][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x32')][_0x2eb2('0x2d')]=null),_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x33')][_0x2eb2('0x2d')]!=null&&(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x33')][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')]['hint_face_texture']['value']=null),_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')]['manual_animation_texture'][_0x2eb2('0x2d')]!=null&&(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x1e')][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms'][_0x2eb2('0x1e')]['value']=null),_0xc7bf11[_0x2eb2('0x49')]['material']['uniforms'][_0x2eb2('0x10')][_0x2eb2('0x2d')]!=null&&(_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x10')][_0x2eb2('0x2d')]['dispose'](),_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x10')][_0x2eb2('0x2d')]=null),_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x62')]['value']!=null&&(_0xc7bf11['m_mesh'][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x62')][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11['m_mesh'][_0x2eb2('0x55')]['uniforms'][_0x2eb2('0x62')][_0x2eb2('0x2d')]=null),_0xc7bf11[_0x2eb2('0x49')]['material'][_0x2eb2('0x2e')][_0x2eb2('0x27')][_0x2eb2('0x2d')]!=null&&(_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x27')][_0x2eb2('0x2d')][_0x2eb2('0x5b')](),_0xc7bf11['m_mesh']['material']['uniforms'][_0x2eb2('0x27')][_0x2eb2('0x2d')]=null);},this[_0x2eb2('0x12')]=function(_0x99347c,_0x3fb44a){_0xc7bf11[_0x2eb2('0x1b')]=_0x99347c,_0xc7bf11[_0x2eb2('0x59')]=_0x3fb44a;},this[_0x2eb2('0x3c')]=function(_0x59f58e,_0x407e9d,_0x399c94,_0x27bbe4){_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x11')][_0x2eb2('0x2d')]=_0x59f58e,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0xa')][_0x2eb2('0x2d')]=_0x407e9d,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')]['process_start_y'][_0x2eb2('0x2d')]=_0x399c94,_0xc7bf11[_0x2eb2('0x49')][_0x2eb2('0x55')][_0x2eb2('0x2e')][_0x2eb2('0x3a')][_0x2eb2('0x2d')]=_0x27bbe4;};},_temp);exports[_0x2eb2('0x48')]=HintViewFilter,module[_0x2eb2('0x52')]=exports[_0x2eb2('0x48')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3376:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _0x5c28=['\x20\x20\x20\x20\x20\x20\x20float\x20manual_desc_y_scale\x20=\x201.00;','\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(blend_result,\x201.0);','gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);','join','\x20\x20\x20\x20\x20\x20\x20float\x20face_flip_shift\x20=\x20(is_estimate_left_hand\x20==\x200)\x20?\x200.427\x20:\x200.00;','\x20\x20\x20\x20\x20\x20\x20vec4\x20face_hint_view\x20=\x20setTexture2D(hint_face_texture,\x20face_scale,\x20face_x_scale,\x20face_x_shift,\x20face_y_scale,\x20face_y_shift,\x20-1,\x20is_apply_shift_after_flip,\x20is_raw_photo_upside_down);','\x20\x20\x20\x20\x20\x20\x20if\x20(is_hand_stable\x20==\x201\x20&&\x20hand_hint_view.r\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(0.0,\x200.0,\x200.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20float\x20hand_y_scale\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20is_apply_shift_after_flip\x20=\x200;','\x20\x20\x20\x20\x20\x20\x20float\x20manual_y_scale\x20=\x200.80;','input_uniforms','\x20\x20\x20\x20\x20\x20\x20float\x20manual_scale\x20=\x20(hint_view_type\x20==\x200)\x20?\x201.0\x20+\x20min(0.20,\x20(1.0\x20-\x20manual_blend_weight))\x20:\x20','\x20\x20\x20\x20\x20\x20\x20vec3\x20manual_total_view_rgb\x20=\x20(manual_hint_view\x20+\x20manual_desc_hint_view).rgb\x20*\x20manual_blend_weight\x20+\x20(cur.rgb\x20+\x20hint_view_for_blending)\x20*\x20(1.0\x20-\x20manual_blend_weight);','\x20\x20\x20\x20\x20\x20\x20float\x20hand_x_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x200.00\x20:\x20-0.15\x20*\x20((is_estimate_left_hand\x20==\x200)\x20?\x20-1.00\x20:\x201.00);','\x20\x20\x20\x20\x20\x20\x20float\x20face_x_shift\x20=\x20-0.210\x20+\x20face_flip_shift;','\x20\x20\x20\x20\x20\x20\x20vec3\x20blend_result\x20=\x20(is_measure_size\x20==\x201)\x20?\x20measure_hint_view_static.rgb\x20+\x20measure_hint_view_dynamic.rgb\x20+\x20measure_hint_view_desc.rgb\x20*\x20measure_blend_weight\x20:\x20','uniform\x20float\x20frameHeight;','\x20\x20\x20\x20\x20\x20\x20vec3\x20blend_result\x20=\x20cur.rgb\x20+\x20hand_hint_view.rgb\x20*\x20estimate_blend_weight;','uniform\x20sampler2D\x20measure_line_texture;','\x20\x20\x20\x20\x20\x20\x20float\x20hand_x_scale\x20=\x201.0;','\x20\x20\x20\x20\x20\x20\x20float\x20face_y_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x20-0.25\x20:\x20-0.40;','\x20\x20\x20\x20\x20\x20\x20is_raw_photo_upside_down\x20=\x201;','\x20\x20\x20\x20\x20\x20\x20float\x20hand_scale\x20=\x201.5;','\x20\x20\x20\x20\x20\x20\x20float\x20hand_y_scale\x20=\x200.75;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20face_hint_view.rgb\x20=\x20vec3(0.0,\x201.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20vec4\x20manual_desc_hint_view\x20=\x20(is_show_manual\x20==\x201)\x20?\x20setTexture2D(manual_desc_texture,\x20manual_desc_scale,\x20manual_desc_x_scale,\x20manual_desc_x_shift,\x20manual_desc_y_scale,\x20manual_desc_y_shift,\x20-1,\x20is_apply_shift_after_flip,\x20is_raw_photo_upside_down)\x20:\x20','\x20\x20\x20\x20\x20\x20\x20vec4\x20hand_hint_view\x20=\x20setTexture2D(hint_hand_rotate_texture,\x20hand_scale,\x20hand_x_scale,\x20hand_x_shift,\x20hand_y_scale,\x20hand_y_shift,\x20-1,\x20is_apply_shift_after_flip,\x20is_raw_photo_upside_down);','\x20\x20\x20\x20\x20\x20\x20vec4\x20measure_hint_view_dynamic\x20=\x20(is_measure_size\x20==\x201)\x20?\x20texture2D(measure_line_texture,\x20measure_hint_view_dynamic_textcoord)\x20:\x20vec4(0.0,\x200.0,\x200.0,\x200.0);','default','varying\x20vec2\x20textureCoordinate;','uniform\x20sampler2D\x20manual_desc_texture;','\x20\x20\x20\x20\x20\x20\x20is_apply_shift_after_flip\x20=\x201;','\x20\x20\x20\x20\x20\x20\x20float\x20flip_shift\x20=\x20(is_apply_shift_after_flip\x20==\x201)\x20?\x20-1.0\x20:\x200.0;','\x20\x20\x20\x20\x20\x20\x20vec4\x20measure_hint_view_static\x20=\x20(is_measure_size\x20==\x201)\x20?\x20texture2D(measure_line_texture,\x20measure_hint_view_static_textcoord)\x20:\x20vec4(0.0,\x200.0,\x200.0,\x200.0);','\x20\x20\x20if\x20(is_estimate_left_hand\x20==\x200)\x20{','fragmentShader','\x20\x20\x20if\x20(hint_view_type\x20==\x200\x20||\x20hint_view_type\x20==\x201)\x20{','\x20\x20\x20\x20\x20\x20\x20float\x20hand_y_shift\x20=\x200.15;','uniform\x20sampler2D\x20hint_face_texture;','uniform\x20float\x20measure_offset;','\x20\x20\x20textcoord\x20=\x20vec2(textcoord.x\x20/\x20x_scale\x20+\x20x_shift,\x20(is_raw_photo_upside_down\x20==\x201)\x20?\x20textcoord.y\x20/\x20y_scale\x20+\x20y_shift\x20:\x20(1.0\x20-\x20textcoord.y\x20/\x20y_scale\x20+\x20y_shift));','\x20\x20\x20else\x20if\x20(hint_view_type\x20==\x202)\x20{','uniform\x20int\x20hint_view_type;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(0.0,\x200.0,\x200.0,\x200.0);','exports','uniform\x20sampler2D\x20hint_hand_texture;','uniform\x20float\x20min_measure_offset;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20(-0.03\x20-\x20min(0.075,\x20(1.0\x20-\x20manual_blend_weight)\x20*\x200.38)\x20*\x20((is_estimate_left_hand\x20==\x200)\x20?\x20-1.0\x20:\x201.0)\x20+\x20((is_estimate_left_hand\x20==\x200)\x20?\x200.05\x20:\x200.0));','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x200.20\x20-\x20min(0.07,\x20(1.0\x20-\x20manual_blend_weight)\x20*\x200.36);','\x20\x20\x20}','uniform\x20float\x20frameWidth;','\x20\x20\x20\x20\x20\x20\x20float\x20face_x_scale\x20=\x201.00;','\x20\x20\x20\x20\x20\x20\x20vec2\x20measure_hint_view_static_textcoord\x20=\x20textureCoordinate\x20+\x20vec2(0.0,\x20min_measure_offset);','void\x20main()\x20{','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20cur.rgb\x20+\x20hint_view\x20*\x20estimate_blend_weight;','uniform\x20int\x20is_face_stable;','\x20\x20\x20\x20\x20\x20\x20is_raw_photo_upside_down\x20=\x200;','\x20\x20\x20int\x20is_raw_photo_upside_down\x20=\x200;','\x20\x20\x20int\x20is_apply_shift_after_flip\x20=\x200;','defineProperty','\x20\x20\x20\x20\x20\x20\x20vec3\x20hint_view\x20=\x20hand_hint_view.rgb\x20+\x20face_hint_view.rgb;','uniform\x20int\x20is_show_manual;','\x20\x20\x20\x20\x20\x20\x20vec2\x20measure_hint_view_desc_textcoord\x20=\x20vec2(textureCoordinate.x,\x201.0\x20-\x20textureCoordinate.y);','__esModule','\x20\x20\x20\x20\x20\x20\x20float\x20hand_scale\x20=\x20(hint_view_type\x20==\x200)\x20?\x201.45\x20:\x201.00;','uniform\x20sampler2D\x20measure_desc_texture;','\x20\x20\x20\x20\x20\x20\x20float\x20hand_x_scale\x20=\x200.50;','vec4\x20setTexture2D(in\x20sampler2D\x20texture,\x20float\x20global_scale,\x20float\x20x_scale,\x20float\x20x_shift,\x20float\x20y_scale,\x20float\x20y_shift,\x20int\x20is_estimate_left_hand,\x20int\x20is_apply_shift_after_flip,\x20int\x20is_raw_photo_upside_down)\x20{','\x20\x20\x20\x20\x20\x20\x20textcoord.x\x20=\x201.0\x20-\x20(textcoord.x\x20+\x20flip_shift);','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x201.2\x20-\x20min(0.00,\x20(1.0\x20-\x20manual_blend_weight)\x20*\x201.10);','\x20\x20\x20\x20\x20\x20\x20if\x20(is_face_stable\x20==\x201\x20&&\x20face_hint_view.r\x20>\x200.0)','\x20\x20\x20\x20\x20\x20\x20float\x20hand_y_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x200.15\x20:\x200.20;','\x20\x20\x20\x20\x20\x20\x20float\x20face_scale\x20=\x20(hint_view_type\x20==\x200)\x20?\x200.80\x20:\x200.60;','\x20\x20\x20\x20\x20\x20\x20vec4\x20measure_hint_view_desc\x20=\x20(is_measure_size\x20==\x201)\x20?\x20texture2D(measure_desc_texture,\x20measure_hint_view_desc_textcoord)\x20:\x20vec4(0.0,\x200.0,\x200.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20float\x20manual_y_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x200.20\x20-\x20min(0.05,\x20(1.0\x20-\x20manual_blend_weight)\x20*\x200.24)\x20:\x20','\x20\x20\x20\x20\x20\x20\x20float\x20manual_desc_y_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x200.020\x20:\x200.012;','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20hand_hint_view.rgb\x20=\x20vec3(0.0,\x201.0,\x200.0);','\x20\x20\x20\x20\x20\x20\x20float\x20hand_x_shift\x20=\x200.15;','\x20\x20\x20\x20\x20\x20\x20float\x20manual_desc_scale\x20=\x201.00;','\x20\x20\x20\x20\x20\x20\x20float\x20measure_blend_weight\x20=\x200.5;','uniform\x20int\x20is_measure_size;','uniform\x20sampler2D\x20inputImageTexture;','\x20\x20\x20\x20\x20\x20\x20vec4\x20hand_hint_view\x20=\x20setTexture2D(hint_hand_texture,\x20hand_scale,\x20hand_x_scale,\x20hand_x_shift,\x20hand_y_scale,\x20hand_y_shift,\x20is_estimate_left_hand,\x20is_apply_shift_after_flip,\x20is_raw_photo_upside_down);','\x20\x20\x20\x20\x20\x20\x20float\x20manual_desc_x_shift\x20=\x200.125;','\x20\x20\x20float\x20estimate_blend_weight\x20=\x200.3;','uniform\x20int\x20is_estimate_left_hand;','uniform\x20sampler2D\x20hint_hand_rotate_texture;','\x20\x20\x20return\x20texture2D(texture,\x20textcoord);','uniform\x20sampler2D\x20manual_animation_texture;','\x20\x20\x20\x20\x20\x20\x20float\x20face_y_scale\x20=\x200.75;','\x20\x20\x20\x20\x20\x20\x20float\x20manual_desc_x_scale\x20=\x201.35;'];(function(_0x4d20b1,_0x5c2809){var _0x21098d=function(_0x1c36bd){while(--_0x1c36bd){_0x4d20b1['push'](_0x4d20b1['shift']());}};_0x21098d(++_0x5c2809);}(_0x5c28,0x1a8));var _0x2109=function(_0x4d20b1,_0x5c2809){_0x4d20b1=_0x4d20b1-0x0;var _0x21098d=_0x5c28[_0x4d20b1];return _0x21098d;};'use strict';Object[_0x2109('0x4')](exports,'__esModule',{'value':!![]}),exports[_0x2109('0x41')]=undefined;var _classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(_0x5aa63a){return _0x5aa63a&&_0x5aa63a[_0x2109('0x8')]?_0x5aa63a:{'default':_0x5aa63a};}var Shader=function Shader(){(0x0,_classCallCheck3[_0x2109('0x41')])(this,Shader),this[_0x2109('0x2f')]={'inputImageTexture':{'type':'t','value':null},'hint_hand_texture':{'type':'t','value':null},'hint_hand_rotate_texture':{'type':'t','value':null},'hint_face_texture':{'type':'t','value':null},'manual_animation_texture':{'type':'t','value':null},'manual_desc_texture':{'type':'t','value':null},'measure_line_texture':{'type':'t','value':null},'measure_desc_texture':{'type':'t','value':null},'is_hand_stable':{'type':'i','value':0x0},'is_face_stable':{'type':'i','value':0x0},'is_show_manual':{'type':'i','value':0x0},'is_measure_size':{'type':'i','value':0x0},'frameWidth':{'type':'f','value':0x0},'frameHeight':{'type':'f','value':0x0},'measure_offset':{'type':'f','value':0x0},'min_measure_offset':{'type':'f','value':0x0},'manual_blend_weight':{'type':'f','value':0x1},'is_estimate_left_hand':{'type':'i','value':0x1},'hint_view_type':{'type':'i','value':0x0}},this['vertexShader']=[_0x2109('0x42'),'void\x20main()\x20{','textureCoordinate\x20=\x20uv;',_0x2109('0x26'),'}'][_0x2109('0x27')]('\x0a'),this[_0x2109('0x48')]=[_0x2109('0x1a'),_0x2109('0x52'),_0x2109('0x1f'),_0x2109('0x4b'),_0x2109('0x21'),_0x2109('0x43'),_0x2109('0x37'),_0x2109('0xa'),'uniform\x20int\x20is_hand_stable;',_0x2109('0x0'),_0x2109('0x6'),_0x2109('0x19'),_0x2109('0x57'),_0x2109('0x35'),_0x2109('0x4c'),_0x2109('0x53'),'uniform\x20float\x20manual_blend_weight;',_0x2109('0x1e'),_0x2109('0x4f'),_0x2109('0x42'),_0x2109('0xc'),'\x20\x20\x20vec2\x20textcoord\x20=\x20(textureCoordinate\x20-\x20vec2(0.5))\x20/\x20vec2(global_scale)\x20+\x20vec2(0.5);',_0x2109('0x4d'),_0x2109('0x47'),_0x2109('0x45'),_0x2109('0xd'),_0x2109('0x56'),_0x2109('0x20'),'}',_0x2109('0x5a'),'\x20\x20\x20vec4\x20cur\x20=\x20texture2D(inputImageTexture,\x20textureCoordinate);',_0x2109('0x3'),_0x2109('0x2'),_0x2109('0x1d'),_0x2109('0x49'),_0x2109('0x9'),_0x2109('0xb'),_0x2109('0x32'),_0x2109('0x3c'),_0x2109('0x10'),_0x2109('0x44'),_0x2109('0x3a'),_0x2109('0x1b'),_0x2109('0x11'),_0x2109('0x28'),_0x2109('0x58'),_0x2109('0x33'),_0x2109('0x22'),_0x2109('0x39'),_0x2109('0x2d'),_0x2109('0x3a'),_0x2109('0x29'),_0x2109('0x30'),_0x2109('0xe'),'\x20\x20\x20\x20\x20\x20\x20float\x20manual_x_scale\x20=\x201.00;','\x20\x20\x20\x20\x20\x20\x20float\x20manual_x_shift\x20=\x20(hint_view_type\x20==\x200)\x20?\x20(0.00\x20-\x20min(0.035,\x20(1.0\x20-\x20manual_blend_weight)\x20*\x200.17)\x20*\x20((is_estimate_left_hand\x20==\x200)\x20?\x20-1.0\x20:\x201.0))\x20:\x20',_0x2109('0x54'),_0x2109('0x2e'),_0x2109('0x13'),_0x2109('0x55'),_0x2109('0x2d'),_0x2109('0x1'),'\x20\x20\x20\x20\x20\x20\x20vec4\x20manual_hint_view\x20=\x20(is_show_manual\x20==\x201)\x20?\x20setTexture2D(manual_animation_texture,\x20manual_scale,\x20manual_x_scale,\x20manual_x_shift,\x20manual_y_scale,\x20manual_y_shift,\x20is_estimate_left_hand,\x20is_apply_shift_after_flip,\x20is_raw_photo_upside_down)\x20:\x20',_0x2109('0x2b'),_0x2109('0x17'),_0x2109('0x23'),_0x2109('0x1c'),_0x2109('0x24'),_0x2109('0x14'),_0x2109('0x2d'),_0x2109('0x1'),_0x2109('0x3e'),_0x2109('0x50'),_0x2109('0x59'),_0x2109('0x46'),'\x20\x20\x20\x20\x20\x20\x20vec2\x20measure_hint_view_dynamic_textcoord\x20=\x20textureCoordinate\x20+\x20vec2(0.0,\x20measure_offset);',_0x2109('0x40'),_0x2109('0x7'),_0x2109('0x12'),'\x20\x20\x20\x20\x20\x20\x20vec3\x20hint_view_for_blending\x20=\x20(hand_hint_view.rgb\x20+\x20face_hint_view.rgb)\x20*\x20estimate_blend_weight;',_0x2109('0x2a'),_0x2109('0x15'),_0x2109('0xf'),_0x2109('0x3d'),_0x2109('0x5'),_0x2109('0x18'),_0x2109('0x31'),_0x2109('0x34'),'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20(is_show_manual\x20==\x201)\x20?\x20manual_total_view_rgb\x20:\x20',_0x2109('0x5b'),'\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20\x20vec4(blend_result,\x201.0);',_0x2109('0x56'),_0x2109('0x4e'),_0x2109('0x3b'),_0x2109('0x38'),_0x2109('0x16'),_0x2109('0x2c'),_0x2109('0x4a'),_0x2109('0x2d'),_0x2109('0x3a'),_0x2109('0x3f'),_0x2109('0x2a'),_0x2109('0x15'),_0x2109('0x36'),_0x2109('0x25'),_0x2109('0x56'),'}'][_0x2109('0x27')]('\x0a');};exports[_0x2109('0x41')]=Shader,module[_0x2109('0x51')]=exports[_0x2109('0x41')];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),

/***/ 3377:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _toConsumableArray2 = __webpack_require__(184);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _three = __webpack_require__(705);

var _throttle2 = __webpack_require__(25);

var _throttle3 = _interopRequireDefault(_throttle2);

var _round2 = __webpack_require__(186);

var _round3 = _interopRequireDefault(_round2);

var _media = __webpack_require__(1988);

var _media2 = _interopRequireDefault(_media);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _mixwith = __webpack_require__(786);

var _ImageOperations = __webpack_require__(872);

var _ImageOperations2 = _interopRequireDefault(_ImageOperations);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _fileUtils = __webpack_require__(137);

var _fileUtils2 = _interopRequireDefault(_fileUtils);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _ceil2 = __webpack_require__(1097);

var _ceil3 = _interopRequireDefault(_ceil2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_SIZE_OF_FRAME_BUFFER = 600 * 900 * 2 * 2 * 4;

var ImageSource = function (_mix$with) {
  (0, _inherits3.default)(ImageSource, _mix$with);

  function ImageSource(params) {
    var _this2 = this;

    (0, _classCallCheck3.default)(this, ImageSource);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ImageSource.__proto__ || (0, _getPrototypeOf2.default)(ImageSource)).call(this, params));

    _this.isChooseModel = function () {
      return _this.featurePoints && _this.masks;
    };

    _this.handleHandFingerSwitch = function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(handOrFinger) {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (_this.isChooseModel()) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return');

              case 2:
                if (!(handOrFinger === 'finger' && !(0, _get3.default)(_this.modelConfig, 'fingerUrl'))) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt('return');

              case 4:
                if (!(handOrFinger === 'hand' && !(0, _get3.default)(_this.modelConfig, 'handUrl'))) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt('return');

              case 6:
                if (!(handOrFinger === 'finger')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 9;
                return _this._switchMode((0, _get3.default)(_this.modelConfig, 'fingerPoints'), (0, _get3.default)(_this.modelConfig, 'fingerMasks'), (0, _get3.default)(_this.modelConfig, 'fingerUrl'));

              case 9:
                _context.next = 13;
                break;

              case 11:
                _context.next = 13;
                return _this._switchMode((0, _get3.default)(_this.modelConfig, 'points'), (0, _get3.default)(_this.modelConfig, 'masks'), (0, _get3.default)(_this.modelConfig, 'handUrl'));

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    _this._switchMode = function () {
      var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(featurePoints, masks, url) {
        var image, adjustedImage;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!featurePoints || !masks || !url)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return');

              case 2:
                _this.featurePoints = featurePoints;
                _this.masks = masks;
                _context2.next = 6;
                return _this._loadImage(url);

              case 6:
                image = _context2.sent;
                _context2.next = 9;
                return _mediaUtils2.default.resizeAndAddBackgroundToImage(image, _this.originalImage.width, _this.originalImage.height, _this.cropLeftOfModel, _this._getModelBgColor && _this._getModelBgColor(), _this.document);

              case 9:
                adjustedImage = _context2.sent;
                _context2.t0 = _this;
                _context2.next = 13;
                return _mediaUtils2.default.flipImage(adjustedImage, _this.document);

              case 13:
                _context2.t1 = _context2.sent;
                _context2.t2 = _this.originalImage.width;
                _context2.t3 = _this.originalImage.height;
                _context2.t4 = _this.render_width;
                _context2.t5 = _this.render_height;
                _context2.t6 = {
                  image: _context2.t1,
                  x: 0,
                  y: 0,
                  w: _context2.t2,
                  h: _context2.t3,
                  width: _context2.t4,
                  height: _context2.t5
                };
                _this.imageData = _context2.t0.extractImageData.call(_context2.t0, _context2.t6);

                _this.frame_array = new Uint8Array(_this.imageData.data);
                _context2.next = 23;
                return _this._preloadMasks();

              case 23:
                _context2.next = 25;
                return _this.update();

              case 25:
                _context2.next = 27;
                return _this.update();

              case 27:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this2);
      }));

      return function (_x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }();

    _this._adjustFeaturePoints = function (fps) {
      if (!_this.cropLeftOfModel) {
        return fps;
      }
      return fps.map(function (fp) {
        return (0, _extends3.default)({}, fp, {
          x: fp.x + _this.cropLeftOfModel
        });
      });
    };

    _this._loadImage = function (uri) {
      return _fileUtils2.default.loadImage(_browserUtils2.default.changeHost('' + "https://plugins-media.makeupar.com" + uri), _this.document);
    };

    _this._AllocateFrameBuffer = function () {
      var viewport = new _three.Vector4(0, 0, _this.render_width, _this.render_height);
      // const viewport = new Vector4(43, 0, this.render_width, this.render_height);
      _this.makeup_live_filter.SetViewport(viewport);
      _this.renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
      var crop_width = (_this.render_width - _this.settings.displayWidth) / 4;
      _this.makeup_live_filter.SetCropWidth(crop_width);
      if (_this.canvas.width > 1000 || _this.canvas.height > 1000) {
        _this.frame_buffer = _this.YMKModule._malloc(MAX_SIZE_OF_FRAME_BUFFER * 2);
      } else {
        _this.frame_buffer = _this.YMKModule._malloc(MAX_SIZE_OF_FRAME_BUFFER);
      }
      _this.frame_rgb_buffer = _this.YMKModule._malloc(MAX_SIZE_OF_FRAME_BUFFER * 2);
    };

    _this.update = function () {
      return _this._update();
    };

    _this._preloadMasks = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
      var tempMasks;
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(!_this.masks || !_this.masks.length)) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt('return');

            case 2:
              tempMasks = [].concat((0, _toConsumableArray3.default)(_this.masks));
              _context4.next = 5;
              return _promise2.default.all(tempMasks.map(function () {
                var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(url) {
                  return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.t0 = _mediaUtils2.default;
                          _context3.t1 = _mediaUtils2.default;
                          _context3.next = 4;
                          return _this._loadImage(url);

                        case 4:
                          _context3.t2 = _context3.sent;
                          _context3.t3 = _this.originalImage.width;
                          _context3.t4 = _this.originalImage.height;
                          _context3.t5 = _this.cropLeftOfModel;
                          _context3.t6 = _this.document;
                          _context3.next = 11;
                          return _context3.t1.resizeAndAddBackgroundToImage.call(_context3.t1, _context3.t2, _context3.t3, _context3.t4, _context3.t5, 'rgba(0,0,0,255)', _context3.t6);

                        case 11:
                          _context3.t7 = _context3.sent;
                          _context3.t8 = _this._getModelWidth();
                          _context3.t9 = _this._getModelHeight();
                          _context3.t10 = _this.document;
                          return _context3.abrupt('return', _context3.t0.image2FlippedImageData.call(_context3.t0, _context3.t7, _context3.t8, _context3.t9, _context3.t10));

                        case 16:
                        case 'end':
                          return _context3.stop();
                      }
                    }
                  }, _callee3, _this2);
                }));

                return function (_x5) {
                  return _ref4.apply(this, arguments);
                };
              }()));

            case 5:
              _this.maskImages = _context4.sent;

            case 6:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, _this2);
    }));

    _this._getModelWidth = function () {
      return (0, _round3.default)(_this.originalImage.width * _this.imageScale);
    };

    _this._getModelHeight = function () {
      return (0, _ceil3.default)(_this.originalImage.height * _this.imageScale);
    };

    _this._getModelBgColor = function () {
      return (0, _get3.default)(_this.modelConfig, 'backgroundColor');
    };

    _this.getFormattedFeaturePoints = function () {
      if (!_this.featurePoints) {
        return false;
      }
      return _this.featurePoints.map(function (_ref5) {
        var x = _ref5.x,
            y = _ref5.y;
        return { x: x * _this.imageScale, y: y * _this.imageScale };
      });
    };

    _this._render4Model = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
      var model_width, model_height, buffers, points, nail_points, i;
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (_this.controller.isNail()) {
                _this.venus_makeup_live.SetIsEditingMode(false);
              }

              if (_this.isLoadEngineCompleteTriggered) {
                _context5.next = 4;
                break;
              }

              _context5.next = 4;
              return _this._preloadMasks();

            case 4:
              _this.venus_makeup_live.ResetNailDetectionSmooth();
              _this.SetHandARParameters();
              _this.YMKModule.HEAPU8.set(_this.frame_array, _this.frame_buffer);
              _this.makeup_live_filter.SetFeatureEnableArray(_this.m_feature_enable_arrays[0]);
              _this.image_texture.image.data = _this.frame_array;
              _this.image_texture.needsUpdate = true;
              model_width = _this._getModelWidth();
              model_height = _this._getModelHeight();

              _this.nail_model_buffers.vto_mode = _this.nail_vto_mode;
              buffers = _this.maskImages.map(function (mi) {
                var buffer = _this.YMKModule._malloc(model_width * model_height * 4);
                new Uint8Array(_this.YMKModule.HEAPU8.buffer, buffer, model_width * model_height * 4).set(mi.data);
                return buffer;
              });
              points = _this.getFormattedFeaturePoints();
              nail_points = _this.YMKModule.CreateVector_float(20);

              for (i = 0; i < 10; i++) {
                nail_points.set(i * 2 + 0, parseInt(model_width - points[i].x + _this.cropLeftOfModel * _this.imageScale));
                nail_points.set(i * 2 + 1, parseInt(points[i].y));
              }

              _this.venus_makeup_live.RGBAToRGB(_this.frame_buffer, _this.render_width, _this.render_height, false, _this.frame_rgb_buffer);
              _this.hand_ar_metadata.frame_width = _this.render_width;
              _this.hand_ar_metadata.frame_height = _this.render_height;
              _this.hand_ar_metadata.is_camera_front = false;
              _this.hand_ar_metadata.is_nail_art_changed = true;
              _this.hand_ar_metadata.vto_mode = _this.nail_vto_mode;
              _this.nail_model_metadata.vto_mode = _this.nail_vto_mode;
              //this.venus_makeup_live.GetWebHandARMetadataWithModelData(buffers[0], buffers[1], buffers[2], buffers[3], buffers[4], model_width, model_height, nail_points, this.nail_model_metadata);
              _this.venus_makeup_live.GetWebHandARMetadataWithModelData(buffers[0], buffers[1], buffers[2], buffers[3], buffers[4], model_width, model_height, nail_points, _this.nail_model_metadata);
              _this.nail_model_metadata.is_nail_art_changed = true;
              _this.nail_model_metadata.is_nail_tip_changed = true;
              _this.nail_model_metadata.is_four_way = _this.controller.splitFourWayEnabled;
              _this.makeup_live_filter.SetHandARMetadata(_this.nail_model_metadata);
              nail_points.delete();
              buffers.map(_this.YMKModule._free);
              _this.makeup_live_filter.SetFeatureEnableArray(_this.m_feature_enable_arrays[0]);
              _this.makeup_live_filter.SetIsFrontCamera(true);
              if (!_this.isLoadEngineCompleteTriggered) {
                _this.isLoadEngineCompleteTriggered = true;
                _this.hasFace = true;
                _this.loaded = true;
                _this.emitter.trigger(_events2.default.loading, [100]);
                _this.emitter.trigger(_events2.default.loadEngineComplete);
              }
              if (_this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE]) {
                _this.makeup_live_filter.SetProcessRange(0.0, Math.abs(1 - _this.m_compare_parameter));
              } else {
                _this.makeup_live_filter.SetProcessRange(0.0, 1.0);
              }
              _this.makeup_live_filter.SetRenderCenter(_this.m_smoothed_center_x / _this.render_width);
              _this.makeup_live_filter.SetBypassMode(false);
              //this.makeup_live_filter.SetZoomRatio(this.getConvertedZoomRatio());
              // this.makeup_live_filter.SetIsNailDebug(true);
              _this.makeup_live_filter.RenderFrame();

              return _context5.abrupt('return', _this._result2Blob());

            case 39:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this2);
    }));
    _this._render4UploadedImage = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (_this.controller.isNail()) {
                _this.venus_makeup_live.SetIsEditingMode(false);
              }
              _this.venus_makeup_live.ResetNailDetectionSmooth();
              _this.YMKModule.HEAPU8.set(_this.frame_array, _this.frame_buffer);
              _this.makeup_live_filter.SetFeatureEnableArray(_this.m_feature_enable_arrays[0]);
              _this.image_texture.image.data = _this.frame_array;
              _this.image_texture.needsUpdate = true;
              _this.venus_makeup_live.RGBAToRGB(_this.frame_buffer, _this.render_width, _this.render_height, false, _this.frame_rgb_buffer);
              _this.hand_ar_metadata.frame_width = _this.render_width;
              _this.hand_ar_metadata.frame_height = _this.render_height;
              if (_this.isWatchFeature()) {
                _this.hand_ar_metadata.vto_mode = _this.YMKModule.VN_VTOMode.WRIST_VTO;
                _this.hand_ar_metadata.is_wrist_ratio_adjustable = _this.is_wrist_ratio_adjustable;
                _this.hand_ar_metadata.is_camera_front = true;
              } else if (_this.isRingFeature()) {
                _this.hand_ar_metadata.vto_mode = _this.YMKModule.VN_VTOMode.RING_VTO;
                _this.hand_ar_metadata.is_camera_front = true;
              } else if (_this.controller.isNail()) {
                _this.SetHandARParameters();
                _this.hand_ar_metadata.vto_mode = _this.nail_vto_mode;
                _this.venus_makeup_live.SetIsSmoothNailAnchors(true);
                _this.makeup_live_filter.SetIsFrontCamera(false);
              }

              if (_this.isLoadEngineCompleteTriggered) {
                _context6.next = 17;
                break;
              }

              _context6.next = 13;
              return _this.trackHand(_this.render_width, _this.render_height, _this.frame_buffer);

            case 13:
              _context6.next = 15;
              return _this.trackHand(_this.render_width, _this.render_height, _this.frame_buffer);

            case 15:
              _context6.next = 17;
              return _this.trackHand(_this.render_width, _this.render_height, _this.frame_buffer);

            case 17:
              _context6.next = 19;
              return _this.trackHand(_this.render_width, _this.render_height, _this.frame_buffer);

            case 19:
              _this.makeup_live_filter.SetFeatureEnableArray(_this.m_feature_enable_arrays[0]);
              if (!_this.isLoadEngineCompleteTriggered) {
                _this.isLoadEngineCompleteTriggered = true;
                _this.hasFace = true;
                _this.loaded = true;
                _this.emitter.trigger(_events2.default.loading, [100]);
                _this.emitter.trigger(_events2.default.loadEngineComplete);
              }
              _this.makeup_live_filter.SetProcessRange(0.0, 0.5);
              if (_this.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_COMPARE]) {
                _this.makeup_live_filter.SetProcessRange(0.0, Math.abs(1 - _this.m_compare_parameter));
              } else {
                _this.makeup_live_filter.SetProcessRange(0.0, 1.0);
              }
              _this.makeup_live_filter.SetRenderCenter(_this.m_smoothed_center_x / _this.render_width);
              _this.makeup_live_filter.SetBypassMode(false);
              //this.makeup_live_filter.SetZoomRatio(this.getConvertedZoomRatio());
              _this.makeup_live_filter.RenderFrame();
              return _context6.abrupt('return', _this._result2Blob());

            case 27:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, _this2);
    }));
    _this.render = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!_this.isChooseModel()) {
                _context7.next = 6;
                break;
              }

              _context7.next = 3;
              return _this._render4Model();

            case 3:
              _context7.next = 5;
              return _this._render4Model();

            case 5:
              return _context7.abrupt('return', _context7.sent);

            case 6:
              _context7.next = 8;
              return _this._render4UploadedImage();

            case 8:
              return _context7.abrupt('return', _context7.sent);

            case 9:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, _this2);
    }));
    _this.splitFourWay = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _this.zoomLevel = 0;
              _this.comparing = false;
              _this.splitFourWayEnabled = true;
              _context8.next = 5;
              return _this.update();

            case 5:
              _context8.next = 7;
              return _this.update();

            case 7:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, _this2);
    }));
    _this.splitFourWayOff = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _this.zoomLevel = 0;
              _this.comparing = false;
              _this.splitFourWayEnabled = false;
              _context9.next = 5;
              return _this.update();

            case 5:
              _context9.next = 7;
              return _this.update();

            case 7:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, _this2);
    }));
    _this.freeResources = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _this.hasFace = false;
              _this.resized = false;
              _context10.next = 4;
              return _browserUtils2.default.sleep(1000);

            case 4:
              if (_this.image_texture && _this.image_texture.image && _this.image_texture.image.data) {
                _this.image_texture.image.data = null;
              }
              _this.blob = null;
              _this.imageData = null;
              _this.originalImage = null;
              _this.targetContainer.removeChild(_this.targetImage);
              _this.targetImage = null;
              _this.previousImage = null;
              _this.compareImage = null;
              if (_this.frame_buffer) {
                _this.YMKModule._free(_this.frame_buffer);
                _this.frame_buffer = null;
              }
              if (_this.frame_rgb_buffer) {
                _this.YMKModule._free(_this.frame_rgb_buffer);
                _this.frame_rgb_buffer = null;
              }
              _context10.next = 16;
              return _this.FreeResources();

            case 16:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, _this2);
    }));

    _this.getWidth = function () {
      return _this.render_width;
    };

    _this.getHeight = function () {
      return _this.render_height;
    };

    _this.getFrameBuffer = function () {
      return _this.frame_buffer;
    };

    _this.maxLooks = 2;
    _this.throttledUpdate = (0, _throttle3.default)(_this.update, _this.getWaitOfThrottle(), { leading: false });
    _this.isLoadEngineCompleteTriggered = false;
    _this.modelConfig = params.modelConfig;
    return _this;
  }

  return ImageSource;
}((0, _mixwith.mix)(_media2.default).with(_ImageOperations2.default));

exports.default = ImageSource;
module.exports = exports['default'];

/***/ }),

/***/ 3378:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _class, _temp, _initialiseProps;

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _isArray2 = __webpack_require__(7);

var _isArray3 = _interopRequireDefault(_isArray2);

var _utils = __webpack_require__(3379);

var _utils2 = _interopRequireDefault(_utils);

var _indexOf2 = __webpack_require__(337);

var _indexOf3 = _interopRequireDefault(_indexOf2);

var _toLower2 = __webpack_require__(41);

var _toLower3 = _interopRequireDefault(_toLower2);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _toNumber2 = __webpack_require__(27);

var _toNumber3 = _interopRequireDefault(_toNumber2);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FINGERS = ['thumb', 'index_finger', 'middle_finger', 'ring_finger', 'little_finger'];
var OBB_URLS = {
  pbr: "https://plugins-media.makeupar.com" + '/webconsultation/nails/nail_pbr_230608/nail_pbr_230608.obb',
  non_pbr: "https://plugins-media.makeupar.com" + '/webconsultation/nails/230511/nail/nail_230313.obb',
  non_pbr2: "https://plugins-media.makeupar.com" + '/webconsultation/patterns/nails/20230314/nail_02.obb',
  fake_user_nail: "https://plugins-media.makeupar.com" + '/webconsultation/patterns/nails/nail_01.obb',
  tip: "https://plugins-media.makeupar.com" + '/webconsultation/nails/nail_tip_230612/nail_tip_230612.obb'
};
var FINGER_NUM = 5;
var MAX_LOOKS = 4;
var MAX_HEIGHT = 600;
var MAX_WIDTH = 295;
var NailUpdater = (_temp = _class = function NailUpdater(YMKModule, venus_makeup_live, source, makeup_live_filter, document) {
  (0, _classCallCheck3.default)(this, NailUpdater);

  _initialiseProps.call(this);

  this.YMKModule = YMKModule;
  this.venus_makeup_live = venus_makeup_live;
  this.makeup_live_filter = makeup_live_filter;
  this.document = document;
  this.source = source;
  this.texture_image_hash_map = {};
  this.is3DObjectLoaded = false;
  this.obb_url = '';
  this.hdrCache = {};
  this.contentCache = {};
}, _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.clean = function () {
    return _this.freeResources();
  };

  this.reset = function (faceIndex) {
    return _this._disableFingers(faceIndex);
  };

  this._load3DObject = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(url) {
      var object3d_data_vec, texture_image_hash_map, _ref2, render_texture_key_array;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _utils2.default.loadObb(url, false, 'nail', _this.venus_makeup_live, _this.YMKModule);

            case 2:
              object3d_data_vec = _context.sent;
              texture_image_hash_map = {};
              _context.next = 6;
              return _this.loadTextImages(_this.getUrlPrefix(url), object3d_data_vec, texture_image_hash_map, _this.document, _this.YMKModule);

            case 6:
              _ref2 = _context.sent;
              render_texture_key_array = _ref2.render_texture_key_array;

              _this.makeup_live_filter.SetObject3DRenderData([object3d_data_vec], [texture_image_hash_map], [render_texture_key_array], [object3d_data_vec], true, false);
              _this.freeResources();
              _this.object3d_data_vec = object3d_data_vec;
              _this.texture_image_hash_map = texture_image_hash_map;

            case 12:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this._loadFakeUserNailsIfNecessary = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
    var image, i, vn_image, _i;

    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (_this.source.isUserNailReplacement()) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt('return');

          case 2:
            image = { data: 0, width: 0, height: 0 };
            _context2.next = 5;
            return _utils2.default.Load4CImageDynamic(OBB_URLS.fake_user_nail, _this.document, _this.YMKModule, image, true);

          case 5:
            for (i = 0; i < FINGER_NUM * MAX_LOOKS; i++) {
              vn_image = _this.source.nail_art_image_vec.get(i);

              vn_image.p_data = image.data;
              vn_image.width = image.width;
              vn_image.height = image.height;
              vn_image.stride = image.width * 4;
              _this.source.nail_art_image_vec.set(i, vn_image);
            }
            _this.source.hand_ar_parameters.nail_art_images = _this.source.nail_art_image_vec;
            for (_i = 0; _i < FINGER_NUM * MAX_LOOKS; _i++) {
              _this.source.is_nail_art_image_changed_vec.set(_i, true);
            }

          case 8:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  this._isValid = function (skuItem, pattern) {
    if (((0, _get3.default)(skuItem, 'subtype') === 'tip' || (0, _get3.default)(skuItem, 'sub_type') === 'tip') && (0, _get3.default)(pattern, 'pattern.pattern_mask.mask.0.url')) {
      return true;
    }
    if (!!(0, _get3.default)(skuItem, 'colors')) {
      var rgb = _utils2.default.hexToRgb((0, _get3.default)(skuItem, 'colors.color'));
      if (!rgb) {
        return false;
      }
    }

    return true;
  };

  this._isCustom = function (skuItem) {
    return (0, _get3.default)(skuItem, 'obbUrl');
  };

  this._isFinishType = function (skuItem, pattern, value) {
    if ((0, _get3.default)(pattern, 'finish_type') === value) {
      return true;
    }
    return (0, _get3.default)(skuItem, 'finish_type' === value);
  };

  this._getObbUrlAndSetNailPbrMode = function (skuItem, pattern) {
    if (_this._isCustom(skuItem)) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_CUSTOMIZED;
      return (0, _get3.default)(skuItem, 'obbUrl');
    }
    if (_this._isNailTip(skuItem)) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.tip;
    }
    if (_this._isFinishType(skuItem, pattern, 'PearlV2')) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.pbr;
    }
    if (_this._isFinishType(skuItem, pattern, 'ShimmerCoarseV2')) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.pbr;
    }
    if (_this._isFinishType(skuItem, pattern, 'ShimmerFineV2')) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.pbr;
    }
    if (_this._isFinishType(skuItem, pattern, 'TexturedV2')) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.pbr;
    }
    if (_this._isPbr(skuItem) || _this._isPbr(pattern && pattern.pattern)) {
      _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_DEFAULT;
      return OBB_URLS.pbr;
    }
    _this.source.nail_pbr_mode = _this.YMKModule.VN_NailPbrMode.NAIL_PBR_NONE;
    return OBB_URLS.non_pbr2;
  };

  this.update = function () {
    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(skuItem, pattern, faceIndex) {
      var obb_url;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!_this.source || !_this.source.hand_ar_parameters)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return');

            case 2:
              if (_this._isValid(skuItem, pattern)) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt('return');

            case 4:
              _this.freeContentCache(faceIndex);
              obb_url = _this._getObbUrlAndSetNailPbrMode(skuItem, pattern);

              if (obb_url !== _this.obb_url) {
                _this.is3DObjectLoaded = false;
              }
              _this.obb_url = obb_url;

              if (_this.is3DObjectLoaded) {
                _context3.next = 19;
                break;
              }

              _this.is3DObjectLoaded = true;
              if (!_this.source.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_OBJECT3D]) {
                _this.source.disableTracking = true;
              }
              _context3.prev = 11;
              _context3.next = 14;
              return _this._load3DObject(_this.obb_url);

            case 14:
              _context3.prev = 14;

              _this.source.disableTracking = false;
              return _context3.finish(14);

            case 17:
              _context3.next = 19;
              return _this._loadFakeUserNailsIfNecessary();

            case 19:
              _this.source.nail_vto_mode = _this.YMKModule.VN_VTOMode.NAIL_POLISH;
              _this._disableFingers(faceIndex);

              if (!(0, _isArray3.default)(skuItem.fingers)) {
                _context3.next = 32;
                break;
              }

              if (skuItem.fingers.length !== 5) {
                _this._disableFingers(faceIndex);
              }
              _context3.next = 25;
              return _promise2.default.all(skuItem.fingers.map(function (si) {
                return _this._preloadContent(si, pattern, _this._convertPosition(si.position || si.nail_position), faceIndex);
              }));

            case 25:
              _context3.next = 27;
              return _promise2.default.all(skuItem.fingers.map(function (si) {
                return _this._updateFinger(si, pattern, _this._convertPosition(si.position || si.nail_position), faceIndex);
              }));

            case 27:
              _this.source.hand_ar_parameters.nail_art_images = _this.source.nail_art_image_vec;
              _this.source.hand_ar_parameters.nail_tip_shapes = _this.source.nail_tip_shape_vec;
              _this._updateNailArtImageChangeFlagsIfNecessary(skuItem, faceIndex);
              _this._updateNailTipShapeChangeFlagsIfNecessary(skuItem, faceIndex);
              return _context3.abrupt('return', true);

            case 32:
              _context3.next = 34;
              return _promise2.default.all(FINGERS.map(function (f) {
                return _this._preloadContent(skuItem, pattern, f, faceIndex);
              }));

            case 34:
              _context3.next = 36;
              return _promise2.default.all(FINGERS.map(function (f) {
                return _this._updateFinger(skuItem, pattern, f, faceIndex);
              }));

            case 36:
              _this.source.hand_ar_parameters.nail_art_images = _this.source.nail_art_image_vec;
              _this.source.hand_ar_parameters.nail_tip_shapes = _this.source.nail_tip_shape_vec;
              _this._updateNailArtImageChangeFlagsIfNecessary(skuItem, faceIndex);
              _this._updateNailTipShapeChangeFlagsIfNecessary(skuItem, faceIndex);
              return _context3.abrupt('return', true);

            case 41:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this, [[11,, 14, 17]]);
    }));

    return function (_x2, _x3, _x4) {
      return _ref4.apply(this, arguments);
    };
  }();

  this._updateNailArtImageChangeFlagsIfNecessary = function (skuItem, faceIndex) {
    if (_this._isNailTip(skuItem)) {
      FINGERS.map(function (finger) {
        var nail_art_image_index = _this._getNailArtImageIndex(_this._convertPosition(finger), faceIndex);
        _this.source.is_nail_art_image_changed_vec.set(nail_art_image_index, true);
      });
      return;
    }

    var fingers = (0, _get3.default)(skuItem, 'fingers');
    if (!(0, _isArray3.default)(fingers) && !_this._isNailTip(skuItem)) {
      return;
    }

    fingers.map(function (finger) {
      if (!finger.nail_design_url) {
        return;
      }
      var nail_art_image_index = _this._getNailArtImageIndex(_this._convertPosition(finger.nail_position || finger.position), faceIndex);
      _this.source.is_nail_art_image_changed_vec.set(nail_art_image_index, true);
    });
  };

  this._updateNailTipShapeChangeFlagsIfNecessary = function (skuItem, faceIndex) {
    if (!_this._isNailTip(skuItem)) {
      return;
    }
    FINGERS.map(function (finger) {
      var nail_art_image_index = _this._getNailArtImageIndex(_this._convertPosition(finger), faceIndex);
      _this.source.is_nail_tip_shape_changed_vec.set(nail_art_image_index, true);
    });
  };

  this._disableFingers = function () {
    var faceIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return FINGERS.map(function (f) {
      return _this._disableFinger(f, faceIndex);
    });
  };

  this._disableFinger = function (finger, faceIndex) {
    var nail_art_image_index = _this._getNailArtImageIndex(finger, faceIndex);
    _this.source.nail_vto_mode = _this.YMKModule.VN_VTOMode.NAIL_POLISH;
    _this.source.is_nail_pbr = false;
    _this.source.is_nail_art_image_changed_vec.set(nail_art_image_index, false);
    _this.source.is_nail_tip_shape_changed_vec.set(nail_art_image_index, false);
    _this.source.fingers[faceIndex][finger] = {
      is_enabled: false,
      is_nail_art: false,
      color: { r: 0, g: 0, b: 0 },
      transparency: 0,
      light_intensity: 0,
      diffuse: 0
    };
    _this.source.pbr_fingers[faceIndex][finger] = {
      finish_type: 0,
      is_enabled: false,
      color: { r: 0, g: 0, b: 0 },
      transparency: 100,
      light_intensity: 0,
      roughness: 0,
      reflection: 0,
      contrast: 0,
      is_nail_art: false,
      textured_granularity: 0,
      shimmer_opacity: 0,
      shimmer_granularity: 0
    };
    _this.source.tip_fingers[faceIndex][finger] = {
      m_aspect_ratio: 1.3,
      m_aspect_ratio_adjuster: 1.0,
      m_nail_tip_mode: _this.YMKModule.VN_NailTipMode.NAIL_TIP_DEFAULT
    };
  };

  this.setAspectRatioAdjuster = function (adjuster) {
    var faceIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (adjuster > 1.5) {
      return;
    }
    if (adjuster < 0.5) {
      return;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(FINGERS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var finger = _step.value;

        var tip_finish = _this.source.tip_fingers[faceIndex][finger];
        tip_finish.m_aspect_ratio_adjuster = adjuster;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(FINGERS), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _finger = _step2.value;

        var nail_art_image_index = _this._getNailArtImageIndex(_finger, faceIndex);
        _this.source.is_nail_tip_shape_changed_vec.set(nail_art_image_index, true);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  };

  this._isTip = function (skuItem) {
    return (0, _get3.default)(skuItem, 'subtype', '') === 'tip' || (0, _get3.default)(skuItem, 'sub_type', '') === 'tip';
  };

  this._preloadContent = function () {
    var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(skuItem, pattern, finger, faceIndex) {
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!_this._isCustom(skuItem)) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt('return');

            case 2:
              if (!(!_this._isTip(skuItem) && !skuItem.nail_design_url)) {
                _context4.next = 4;
                break;
              }

              return _context4.abrupt('return');

            case 4:
              if (!skuItem.nail_design_url) {
                _context4.next = 8;
                break;
              }

              _context4.next = 7;
              return _this._preloadContentByDesign(skuItem, pattern, finger, faceIndex);

            case 7:
              return _context4.abrupt('return', _context4.sent);

            case 8:
              _context4.next = 10;
              return _this._preloadContentByTip(skuItem, pattern, finger, faceIndex);

            case 10:
              return _context4.abrupt('return', _context4.sent);

            case 11:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, _this);
    }));

    return function (_x7, _x8, _x9, _x10) {
      return _ref5.apply(this, arguments);
    };
  }();

  this._updateFinger = function () {
    var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(skuItem, pattern, finger, faceIndex) {
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!_this._isCustom(skuItem)) {
                _context5.next = 4;
                break;
              }

              _context5.next = 3;
              return _this._updateFingerByCustom(skuItem, pattern, finger, faceIndex);

            case 3:
              return _context5.abrupt('return', _context5.sent);

            case 4:
              if (!_this._isTip(skuItem)) {
                _context5.next = 8;
                break;
              }

              _context5.next = 7;
              return _this._updateFingerByTip(skuItem, pattern, finger, faceIndex);

            case 7:
              return _context5.abrupt('return', _context5.sent);

            case 8:
              if (!skuItem.nail_design_url) {
                _context5.next = 12;
                break;
              }

              _context5.next = 11;
              return _this._updateFingerByDesign(skuItem, pattern, finger, faceIndex);

            case 11:
              return _context5.abrupt('return', _context5.sent);

            case 12:
              return _context5.abrupt('return', _this._updateFingerByColor(skuItem, pattern, finger, faceIndex));

            case 13:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this);
    }));

    return function (_x11, _x12, _x13, _x14) {
      return _ref6.apply(this, arguments);
    };
  }();

  this._isNailTip = function (skuItem) {
    return (0, _get3.default)(skuItem, 'subtype') === 'tip' || (0, _get3.default)(skuItem, 'sub_type') === 'tip';
  };

  this._getNailArtImageIndex = function (finger, faceIndex) {
    return faceIndex * 5 + (0, _indexOf3.default)(FINGERS, finger);
  };

  this._isPbr = function (skuItem) {
    return !(0, _isUndefined3.default)((0, _get3.default)(skuItem, 'contrast')) || !(0, _isUndefined3.default)((0, _get3.default)(skuItem, 'fingers.0.contrast'));
  };

  this._getFinishType = function (type) {
    switch (type) {
      case 'Cream':
      case 'CreamV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_CREAM;
      case 'Jelly':
      case 'JellyV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_JELLY;
      case 'Sheer':
      case 'SheerV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHEER;
      case 'Matte':
      case 'MatteV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_MATTE;
      case 'Metallic':
      case 'MetallicV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_METALLIC;
      case 'PearlV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_PEARL;
      case 'TexturedV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_TEXTURED;
      case 'ShimmerCoarseV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHIMMER_COARSE;
      case 'ShimmerFineV2':
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_SHIMMER_FINE;
      default:
        return _this.YMKModule.VN_NailFinishType.NAIL_FINISH_CREAM;
    }
  };

  this._updateFingerByCustom = function () {
    var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(skuItem, pattern, finger, faceIndex) {
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!_this.source.isUserNailReplacement()) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt('return');

            case 2:
              _this.source.pbr_fingers[faceIndex][finger].enabled = true;
              _this.source.pbr_fingers[faceIndex][finger].is_nail_art = false;
              _this.source.pbr_fingers[faceIndex][finger].contrast = 50;
              _this.source.pbr_fingers[faceIndex][finger].reflection = 50;
              _this.source.pbr_fingers[faceIndex][finger].roughness = 0;
              _this.source.pbr_fingers[faceIndex][finger].transparency = 0;
              _this.source.pbr_fingers[faceIndex][finger].is_enabled = true;
              _this.source.pbr_fingers[faceIndex][finger].finish_type = _this.YMKModule.VN_NailFinishType.NAIL_FINISH_CREAM;

              _this.source.is_nail_pbr = true;

            case 11:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, _this);
    }));

    return function (_x15, _x16, _x17, _x18) {
      return _ref7.apply(this, arguments);
    };
  }();

  this._isTipShape = function (values) {
    return (0, _get3.default)(values, 'texture_mode') === 'TipShape';
  };

  this._getTipRatioName = function (finger) {
    switch (finger) {
      case FINGERS[0]:
        return 'tip_ratio_thumb';
      case FINGERS[1]:
        return 'tip_ratio_fore';
      case FINGERS[2]:
        return 'tip_ratio_middle';
      case FINGERS[3]:
        return 'tip_ratio_ring';
      case FINGERS[4]:
        return 'tip_ratio_little';
      default:
        return 'tip_ratio_thumb';
    }
  };

  this._getTipAspectRatio = function (values, finger) {
    return (0, _toNumber3.default)((0, _get3.default)(values, _this._getTipRatioName(finger), '1.0'));
  };

  this._preloadContentByTip = function () {
    var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(skuItem, pattern, finger, faceIndex) {
      var index, image;
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!_this.source.isUserNailReplacement()) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt('return');

            case 2:
              index = _this._getNailArtImageIndex(finger, faceIndex);
              image = { data: 0, width: 0, height: 0 };
              _context7.next = 6;
              return _utils2.default.Load4CImageDynamicWithMaxHeight(skuItem.nail_design_url || (0, _get3.default)(pattern, 'pattern.pattern_mask.mask.0.url'), _this.document, _this.YMKModule, image, true, MAX_HEIGHT);

            case 6:
              _this.contentCache[index] = image;

            case 7:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, _this);
    }));

    return function (_x19, _x20, _x21, _x22) {
      return _ref8.apply(this, arguments);
    };
  }();

  this._updateFingerByTip = function () {
    var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(skuItem, pattern, finger, faceIndex) {
      var values, finish, tip_finish, nail_art_image_index, color, _image, art_image, image, tip_image;

      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!_this.source.isUserNailReplacement()) {
                _context8.next = 2;
                break;
              }

              return _context8.abrupt('return');

            case 2:
              values = (0, _extends3.default)({}, pattern.pattern, skuItem);

              _this.source.nail_vto_mode = _this.YMKModule.VN_VTOMode.NAIL_TIP;
              finish = _this.source.pbr_fingers[faceIndex][finger];
              tip_finish = _this.source.tip_fingers[faceIndex][finger];

              finish.is_nail_art = false;
              if (_this._isTipShape(values)) {
                tip_finish.m_nail_tip_mode = _this.YMKModule.VN_NailTipMode.NAIL_TIP_DEFAULT;
                tip_finish.m_aspect_ratio = _this._getTipAspectRatio(values, finger);
              } else {
                tip_finish.m_nail_tip_mode = _this.YMKModule.VN_NailTipMode.NAIL_TIP_CUSTOMIZED;
              }
              _this.source.is_nail_pbr = true;
              nail_art_image_index = _this._getNailArtImageIndex(finger, faceIndex);
              color = (0, _get3.default)(values, 'color');

              if (!!color) {
                _image = { data: 0, width: 0, height: 0 };

                _image.data = _utils2.default.getImageDataByColor(_utils2.default.stringToHex(color), MAX_WIDTH, MAX_HEIGHT, _this.document, _this.YMKModule);
                art_image = _this.source.nail_art_image_vec.get(nail_art_image_index);

                if (art_image.p_data) {
                  _this.YMKModule._free(art_image.p_data);
                  art_image.p_data = null;
                }
                art_image.p_data = _image.data;
                art_image.width = MAX_WIDTH;
                art_image.height = MAX_HEIGHT;
                art_image.stride = MAX_WIDTH * 4;
                _this.source.nail_art_image_vec.set(nail_art_image_index, art_image);
              }
              image = { data: 0, width: 0, height: 0 };

              if (!_this.contentCache[nail_art_image_index]) {
                _context8.next = 17;
                break;
              }

              image = _this.contentCache[nail_art_image_index];
              _context8.next = 19;
              break;

            case 17:
              _context8.next = 19;
              return _utils2.default.Load4CImageDynamicWithMaxHeight(skuItem.nail_design_url || (0, _get3.default)(pattern, 'pattern.pattern_mask.mask.0.url'), _this.document, _this.YMKModule, image, true, MAX_HEIGHT);

            case 19:
              tip_image = _this.source.nail_tip_shape_vec.get(nail_art_image_index);

              if (tip_image.p_data) {
                _this.YMKModule._free(tip_image.p_data);
                tip_image.p_data = null;
              }
              tip_image.p_data = image.data;
              tip_image.width = image.width;
              tip_image.height = image.height;
              tip_image.stride = image.width * 4;
              _this.source.nail_tip_shape_vec.set(nail_art_image_index, tip_image);
              finish.finish_type = _this._getFinishType((0, _get3.default)(values, 'finish_type', undefined));
              finish.transparency = (0, _toInteger3.default)((0, _get3.default)(values, 'transparency', 0));
              finish.light_intensity = (0, _toInteger3.default)((0, _get3.default)(values, 'light', 0));
              if (!(0, _isUndefined3.default)((0, _get3.default)(values, 'roughness', undefined))) {
                finish.roughness = (0, _toInteger3.default)((0, _get3.default)(values, 'roughness', 0));
              } else if (!(0, _isUndefined3.default)((0, _get3.default)(values, 'diffuse', undefined))) {
                finish.roughness = (0, _toInteger3.default)((0, _get3.default)(values, 'diffuse', 0));
              } else {
                finish.roughness = 0;
              }
              finish.reflection = (0, _toInteger3.default)((0, _get3.default)(values, 'reflection', 0));
              finish.contrast = (0, _toInteger3.default)((0, _get3.default)(values, 'contrast', 0));
              finish.shimmer_opacity = (0, _toInteger3.default)((0, _get3.default)(values, 'shimmer_opacity', 0));
              finish.textured_granularity = (0, _toInteger3.default)((0, _get3.default)(values, 'textured_granularity', 0));
              finish.shimmer_granularity = (0, _toInteger3.default)((0, _get3.default)(values, 'shimmer_granularity', 0));
              finish.enabled = true;
              finish.is_enabled = true;

            case 37:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, _this);
    }));

    return function (_x23, _x24, _x25, _x26) {
      return _ref9.apply(this, arguments);
    };
  }();

  this._preloadContentByDesign = function () {
    var _ref10 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(skuItem, pattern, finger, faceIndex) {
      var index, image;
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!_this.source.isUserNailReplacement()) {
                _context9.next = 2;
                break;
              }

              return _context9.abrupt('return');

            case 2:
              index = _this._getNailArtImageIndex(finger, faceIndex);
              image = { data: 0, width: 0, height: 0 };
              _context9.next = 6;
              return _utils2.default.Load4CImageDynamicWithMaxHeight(skuItem.nail_design_url, _this.document, _this.YMKModule, image, true, MAX_HEIGHT);

            case 6:
              _this.contentCache[index] = image;

            case 7:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, _this);
    }));

    return function (_x27, _x28, _x29, _x30) {
      return _ref10.apply(this, arguments);
    };
  }();

  this._updateFingerByDesign = function () {
    var _ref11 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10(skuItem, pattern, finger, faceIndex) {
      var is_nail_pbr, finish, nail_art_image_index, image, vn_image;
      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!_this.source.isUserNailReplacement()) {
                _context10.next = 2;
                break;
              }

              return _context10.abrupt('return');

            case 2:
              is_nail_pbr = _this._isPbr(skuItem);
              finish = is_nail_pbr ? _this.source.pbr_fingers[faceIndex][finger] : _this.source.fingers[faceIndex][finger];

              finish.is_nail_art = true;
              _this.source.is_nail_pbr = is_nail_pbr;

              nail_art_image_index = _this._getNailArtImageIndex(finger, faceIndex);
              image = { data: 0, width: 0, height: 0 };

              if (!_this.contentCache[nail_art_image_index]) {
                _context10.next = 12;
                break;
              }

              image = _this.contentCache[nail_art_image_index];
              _context10.next = 14;
              break;

            case 12:
              _context10.next = 14;
              return _utils2.default.Load4CImageDynamicWithMaxHeight(skuItem.nail_design_url, _this.document, _this.YMKModule, image, true, MAX_HEIGHT);

            case 14:
              vn_image = _this.source.nail_art_image_vec.get(nail_art_image_index);

              if (vn_image.p_data) {
                _this.YMKModule._free(vn_image.p_data);
                vn_image.p_data = null;
              }
              vn_image.p_data = image.data;
              vn_image.width = image.width;
              vn_image.height = image.height;
              vn_image.stride = image.width * 4;
              _this.source.nail_art_image_vec.set(nail_art_image_index, vn_image);
              if (is_nail_pbr) {
                finish.finish_type = _this._getFinishType((0, _get3.default)(skuItem, 'finish_type', undefined));
              }
              finish.transparency = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'transparency', 0));
              finish.light_intensity = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'light', 0));
              if (is_nail_pbr) {
                if (!(0, _isUndefined3.default)((0, _get3.default)(skuItem, 'roughness', undefined))) {
                  finish.roughness = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'roughness', 0));
                } else if (!(0, _isUndefined3.default)((0, _get3.default)(skuItem, 'diffuse', undefined))) {
                  finish.roughness = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'diffuse', 0));
                } else {
                  finish.roughness = 0;
                }
              } else {
                if (!(0, _isUndefined3.default)((0, _get3.default)(skuItem, 'diffuse', undefined))) {
                  finish.diffuse = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'diffuse', 0));
                }
              }
              if (is_nail_pbr) {
                finish.reflection = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'reflection', 0));
                finish.contrast = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'contrast', 0));
                finish.shimmer_opacity = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'shimmer_opacity', 0));
                finish.textured_granularity = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'textured_granularity', 0));
                finish.shimmer_granularity = (0, _toInteger3.default)((0, _get3.default)(skuItem, 'shimmer_granularity', 0));
              }
              finish.enabled = true;
              finish.is_enabled = true;

            case 28:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, _this);
    }));

    return function (_x31, _x32, _x33, _x34) {
      return _ref11.apply(this, arguments);
    };
  }();

  this._updateFingerByColor = function (skuItem, pattern, finger, faceIndex) {
    var rgb = _utils2.default.hexToRgb(skuItem.colors.color) || _utils2.default.hexToRgb((0, _get3.default)(skuItem, 'color')) || _utils2.default.hexToRgb((0, _get3.default)(pattern, 'pattern.color'));
    var values = pattern && pattern.pattern ? (0, _extends3.default)({}, pattern.pattern, skuItem) : (0, _extends3.default)({}, skuItem);
    var is_nail_pbr = _this._isPbr(values);
    _this.source.is_nail_pbr = is_nail_pbr;
    var finish = is_nail_pbr ? _this.source.pbr_fingers[faceIndex][finger] : _this.source.fingers[faceIndex][finger];
    finish.is_enabled = true;
    finish.color = (0, _extends3.default)({}, rgb);
    finish.is_nail_art = false;
    if (is_nail_pbr) {
      finish.finish_type = _this._getFinishType((0, _get3.default)(values, 'finish_type', undefined));
    }
    finish.transparency = (0, _toInteger3.default)((0, _get3.default)(values, 'transparency', 0));
    finish.light_intensity = (0, _toInteger3.default)((0, _get3.default)(values, 'light', (0, _get3.default)(values, 'gloss', 0)));
    if (is_nail_pbr) {
      finish.roughness = (0, _toInteger3.default)((0, _get3.default)(values, 'roughness', (0, _get3.default)(values, 'diffuse', 0)));
      finish.reflection = (0, _toInteger3.default)((0, _get3.default)(values, 'reflection', 0));
      finish.contrast = (0, _toInteger3.default)((0, _get3.default)(values, 'contrast', 0));
      finish.shimmer_opacity = (0, _toInteger3.default)((0, _get3.default)(values, 'shimmer_opacity', 0));
      finish.textured_granularity = (0, _toInteger3.default)((0, _get3.default)(values, 'textured_granularity', 0));
      finish.shimmer_granularity = (0, _toInteger3.default)((0, _get3.default)(values, 'shimmer_granularity', 0));
    } else {
      finish.diffuse = (0, _toInteger3.default)((0, _get3.default)(values, 'diffuse', 0));
    }
  };

  this._convertPosition = function (input) {
    switch (input) {
      case 'thumb':
        return FINGERS[0];
      case 'fore':
      case 'index':
      case 'index_finger':
        return FINGERS[1];
      case 'middle':
      case 'middle_finger':
        return FINGERS[2];
      case 'ring':
      case 'ring_finger':
        return FINGERS[3];
      case 'little':
      case 'little_finger':
        return FINGERS[4];
    }
  };

  this.freeContentCache = function () {
    var faceIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(FINGERS), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var finger = _step3.value;

        var index = _this._getNailArtImageIndex(finger, faceIndex);
        if (_this.contentCache[index]) {
          _this.YMKModule._free(_this.contentCache[index]);
          _this.contentCache[index] = null;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };

  this.freeResources = function () {
    _utils2.default.freeObb(_this.object3d_data_vec, _this.YMKModule);
    _this.object3d_data_vec = null;
    _utils2.default.freeTextImages(_this.texture_image_hash_map);
    _this.hdrCache = {};
    _this.freeContentCache(0);
    _this.freeContentCache(1);
    _this.freeContentCache(2);
    _this.freeContentCache(3);
  };

  this.getUrlPrefix = function (url) {
    return url && url.substring(0, url.lastIndexOf('/') + 1);
  };

  this.loadTextImages = function () {
    var _ref12 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(urlPrefix, render_data_vec, texture_image_hash_map, document, YMKModule) {
      var render_texture_key_array, promises, i, curr_model, render_texture_key, hdr_env_maps;
      return _regenerator2.default.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              render_texture_key_array = [];
              promises = [];
              i = 0;

            case 3:
              if (!(i < render_data_vec.size())) {
                _context11.next = 22;
                break;
              }

              curr_model = render_data_vec.get(i);
              render_texture_key = {
                ambient: '',
                diffuse: '',
                specular: '',
                environment: '',
                environment_weight: '',
                normal_map: '',
                orm: '',
                trans: '',
                opa: ''
              };

              render_texture_key_array.push(render_texture_key);
              _context11.next = 9;
              return _this.loadHDRImage(render_texture_key, urlPrefix, curr_model, texture_image_hash_map, YMKModule);

            case 9:
              hdr_env_maps = _context11.sent;

              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'ambient', texture_image_hash_map, document, YMKModule));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'diffuse', texture_image_hash_map, document, YMKModule));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'specular', texture_image_hash_map, document, YMKModule));
              if (!hdr_env_maps) {
                promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'environment', texture_image_hash_map, document, YMKModule));
              }
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'environment_weight', texture_image_hash_map, document, YMKModule));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'normal_map', texture_image_hash_map, document, YMKModule, i > 0 && render_data_vec.get(i - 1)));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'orm', texture_image_hash_map, document, YMKModule));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'trans', texture_image_hash_map, document, YMKModule));
              promises.push(_utils2.default.loadImage(render_texture_key, urlPrefix, curr_model, 'opa', texture_image_hash_map, document, YMKModule));

            case 19:
              i++;
              _context11.next = 3;
              break;

            case 22:
              _context11.next = 24;
              return _promise2.default.all(promises);

            case 24:
              return _context11.abrupt('return', { render_texture_key_array: render_texture_key_array });

            case 25:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee11, _this);
    }));

    return function (_x36, _x37, _x38, _x39, _x40) {
      return _ref12.apply(this, arguments);
    };
  }();

  this.loadHDRImage = function () {
    var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(render_texture_key, urlPrefix, curr_model, texture_image_hash_map, YMKModule) {
      var image_name, total_string, j, file_name;
      return _regenerator2.default.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              image_name = new Uint8Array(YMKModule.HEAPU8.buffer, curr_model['environment_data'].texture_image_name, 256);
              total_string = '';

              for (j = 0; j < image_name.length; j++) {
                total_string += String.fromCharCode(image_name[j]);
              }

              if (total_string.includes('.hdr')) {
                _context12.next = 5;
                break;
              }

              return _context12.abrupt('return');

            case 5:
              file_name = _utils2.default.getFilename(total_string, urlPrefix);

              render_texture_key.environment = file_name;

              if (file_name in texture_image_hash_map) {
                _context12.next = 16;
                break;
              }

              _context12.next = 10;
              return _utils2.default.loadHDR((0, _toLower3.default)(file_name));

            case 10:
              _context12.t0 = _context12.sent;

              if (_context12.t0) {
                _context12.next = 15;
                break;
              }

              _context12.next = 14;
              return _utils2.default.loadHDR(file_name);

            case 14:
              _context12.t0 = _context12.sent;

            case 15:
              texture_image_hash_map[file_name] = _context12.t0;

            case 16:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee12, _this);
    }));

    return function (_x41, _x42, _x43, _x44, _x45) {
      return _ref13.apply(this, arguments);
    };
  }();
}, _temp);
exports.default = NailUpdater;
module.exports = exports['default'];

/***/ }),

/***/ 3379:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _isomorphicFetch = __webpack_require__(61);

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _isArray2 = __webpack_require__(7);

var _isArray3 = _interopRequireDefault(_isArray2);

var _split2 = __webpack_require__(104);

var _split3 = _interopRequireDefault(_split2);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _isInteger2 = __webpack_require__(80);

var _isInteger3 = _interopRequireDefault(_isInteger2);

var _has2 = __webpack_require__(745);

var _has3 = _interopRequireDefault(_has2);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _hdrpng = __webpack_require__(938);

var _hdrpng2 = _interopRequireDefault(_hdrpng);

var _toLower2 = __webpack_require__(41);

var _toLower3 = _interopRequireDefault(_toLower2);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _dao = __webpack_require__(63);

var _uniq2 = __webpack_require__(138);

var _uniq3 = _interopRequireDefault(_uniq2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_WIDTH_HEIGHT = 1536;
var HDR_CACHE = {};
var utils = {
  getUnusedObjects: function getUnusedObjects(masks) {
    var dataCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var urls = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(masks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var mask = _step.value;

        if (!mask || !mask.obb_url) {
          continue;
        }
        urls[mask.obb_url] = true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var r = [];
    var keys = (0, _keys2.default)(dataCache);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(keys), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var key = _step2.value;

        if (!urls[key]) {
          r.push(dataCache[key]);
          delete dataCache[key];
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return r;
  },
  loadMasks: function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(masks, loadMask) {
      var dataCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var r, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, mask, obb_url, rr, urls, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _mask, _obb_url;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              r = {};
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context.prev = 4;
              _iterator3 = (0, _getIterator3.default)(masks);

            case 6:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context.next = 17;
                break;
              }

              mask = _step3.value;
              obb_url = mask.obb_url;

              if (dataCache[obb_url]) {
                _context.next = 13;
                break;
              }

              _context.next = 12;
              return loadMask(mask);

            case 12:
              dataCache[obb_url] = _context.sent;

            case 13:
              r[obb_url] = dataCache[obb_url];

            case 14:
              _iteratorNormalCompletion3 = true;
              _context.next = 6;
              break;

            case 17:
              _context.next = 23;
              break;

            case 19:
              _context.prev = 19;
              _context.t0 = _context['catch'](4);
              _didIteratorError3 = true;
              _iteratorError3 = _context.t0;

            case 23:
              _context.prev = 23;
              _context.prev = 24;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 26:
              _context.prev = 26;

              if (!_didIteratorError3) {
                _context.next = 29;
                break;
              }

              throw _iteratorError3;

            case 29:
              return _context.finish(26);

            case 30:
              return _context.finish(23);

            case 31:
              rr = [];
              urls = [];
              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context.prev = 36;

              for (_iterator4 = (0, _getIterator3.default)(masks); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                _mask = _step4.value;
                _obb_url = _mask.obb_url;

                rr.push(r[_obb_url]);
                urls.push(_obb_url);
              }
              _context.next = 44;
              break;

            case 40:
              _context.prev = 40;
              _context.t1 = _context['catch'](36);
              _didIteratorError4 = true;
              _iteratorError4 = _context.t1;

            case 44:
              _context.prev = 44;
              _context.prev = 45;

              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }

            case 47:
              _context.prev = 47;

              if (!_didIteratorError4) {
                _context.next = 50;
                break;
              }

              throw _iteratorError4;

            case 50:
              return _context.finish(47);

            case 51:
              return _context.finish(44);

            case 52:
              return _context.abrupt('return', [rr, urls]);

            case 53:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined, [[4, 19, 23, 31], [24,, 26, 30], [36, 40, 44, 52], [45,, 47, 51]]);
    }));

    return function loadMasks(_x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }(),
  loadHDRImage: function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(file_name) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!_browserUtils2.default.isPerfectConsole()) {
                _context2.next = 9;
                break;
              }

              _context2.next = 3;
              return utils.loadHDR(file_name);

            case 3:
              _context2.t0 = _context2.sent;

              if (_context2.t0) {
                _context2.next = 8;
                break;
              }

              _context2.next = 7;
              return utils.loadHDR((0, _toLower3.default)(file_name));

            case 7:
              _context2.t0 = _context2.sent;

            case 8:
              return _context2.abrupt('return', _context2.t0);

            case 9:
              _context2.next = 11;
              return utils.loadHDR((0, _toLower3.default)(file_name));

            case 11:
              _context2.t1 = _context2.sent;

              if (_context2.t1) {
                _context2.next = 16;
                break;
              }

              _context2.next = 15;
              return utils.loadHDR(file_name);

            case 15:
              _context2.t1 = _context2.sent;

            case 16:
              return _context2.abrupt('return', _context2.t1);

            case 17:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, undefined);
    }));

    return function loadHDRImage(_x5) {
      return _ref2.apply(this, arguments);
    };
  }(),
  cleanHdrCache: function cleanHdrCache() {
    (0, _keys2.default)(HDR_CACHE).map(function (key) {
      var c = HDR_CACHE[key];
      _mediaUtils2.default.releaseCanvas(c);
      delete HDR_CACHE[key];
    });
  },
  loadHDR: function loadHDR(path) {
    return new _promise2.default(function (resolve) {
      if (HDR_CACHE[path]) {
        resolve(HDR_CACHE[path]);
        return;
      }
      var r = new _hdrpng2.default();
      r.onload = function () {
        if (r && r.width !== 0) {
          HDR_CACHE[path] = r;
          return resolve(r);
        }
        resolve(null);
      };
      r.onerror = function () {
        return resolve(null);
      };
      r.src = _browserUtils2.default.changeHost(path);
    });
  },
  MakeVN_Object3DMaterialData: function MakeVN_Object3DMaterialData(_r, _g, _b, _texture_image_name) {
    return {
      color: [_r, _g, _b],
      texture_image_name: _texture_image_name
    };
  },
  LoadOneChannelAlphaImage: function LoadOneChannelAlphaImage(path, document, YMKModule, venus_makeup_live) {
    return new _promise2.default(function (resolve) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onerror = function () {
        return resolve({ data: 0, width: 0, height: 0 });
      };
      img.onload = function () {
        var canvas = document.createElement('canvas');
        var width = img.width;
        var height = img.height;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, width, height);
        context.drawImage(img, 0, 0, width, height);
        var image_4c_array = new Uint8Array(context.getImageData(0, 0, width, height).data);
        var data = YMKModule._malloc(width * height);
        var temp_4c_buffer = YMKModule._malloc(width * height * 4);
        var temp_4c_array = new Uint8Array(YMKModule.HEAPU8.buffer, temp_4c_buffer, width * height * 4);
        temp_4c_array.set(image_4c_array);
        // Workaround to load 1-channel alpha mask: AFAIK there seems to be no way to directly load an 1-channel
        // mask in JS. If the source image is 1-channel, then JS will copy them to RGB channel and leave A channel
        // fully opaque. If this is the case, we have to get alpha pixels from one of RGB channels.
        venus_makeup_live.Convert4to1Channel(temp_4c_buffer, data, width, height, width * 4, width, 0);
        YMKModule._free(temp_4c_buffer);
        var r = { data: data, width: width, height: height };
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve(r);
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },
  LoadImageDynamic: function LoadImageDynamic(path, document, canvasId, YMKModule, venus_makeup_live) {
    return new _promise2.default(function (resolve) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onerror = function () {
        return resolve({ data: 0, width: 0, height: 0 });
      };
      img.onload = function () {
        var c = document.getElementById(canvasId);
        var canvas = document.createElement('canvas');
        canvas.width = c.width;
        canvas.height = c.height;
        var width = img.width;
        var height = img.height;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, width, height);
        context.drawImage(img, 0, 0, width, height);
        var image_4c_array = new Uint8Array(context.getImageData(0, 0, width, height).data);
        var data = YMKModule._malloc(width * height);
        var temp_4c_buffer = YMKModule._malloc(width * height * 4);
        var temp_4c_array = new Uint8Array(YMKModule.HEAPU8.buffer, temp_4c_buffer, width * height * 4);
        temp_4c_array.set(image_4c_array);
        venus_makeup_live.Convert4to1Channel(temp_4c_buffer, data, width, height, width * 4, width, 3);
        YMKModule._free(temp_4c_buffer);
        var r = { data: data, width: width, height: height };
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve(r);
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },
  Load4CImageDynamic: function Load4CImageDynamic(path, document, YMKModule, result, is_native_buffer) {
    return new _promise2.default(function (resolve) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function () {
        var canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(img, 0, 0, canvas.width, canvas.height);
        var image_4c_array = new Uint8Array(context.getImageData(0, 0, canvas.width, canvas.height).data);
        if (is_native_buffer) {
          var output_buffer = YMKModule._malloc(canvas.width * canvas.height * 4);
          var temp_4c_array = new Uint8Array(YMKModule.HEAPU8.buffer, output_buffer, canvas.width * canvas.height * 4);
          temp_4c_array.set(image_4c_array);
          result.data = output_buffer;
        } else {
          result.data = image_4c_array.slice();
        }
        result.width = canvas.width;
        result.height = canvas.height;
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve();
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },
  Load4CImageDynamicWithMaxHeight: function Load4CImageDynamicWithMaxHeight(path, document, YMKModule, result, is_native_buffer) {
    var maxHeight = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 600;
    return new _promise2.default(function (resolve) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function () {
        var canvas = document.createElement('canvas');
        var ratio = 1.0;
        if (img.height > maxHeight) {
          ratio = img.height / maxHeight;
        }

        canvas.width = _mathUtils2.default.toEvenNumber(img.width / ratio);
        canvas.height = _mathUtils2.default.toEvenNumber(img.height / ratio);
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
        var image_4c_array = new Uint8Array(context.getImageData(0, 0, canvas.width, canvas.height).data);
        if (is_native_buffer) {
          var output_buffer = YMKModule._malloc(canvas.width * canvas.height * 4);
          var temp_4c_array = new Uint8Array(YMKModule.HEAPU8.buffer, output_buffer, canvas.width * canvas.height * 4);
          temp_4c_array.set(image_4c_array);
          result.data = output_buffer;
        } else {
          result.data = image_4c_array.slice();
        }
        result.width = canvas.width;
        result.height = canvas.height;
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve();
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },
  getImageDataByColor: function getImageDataByColor(color, width, height, document, YMKModule) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = color;
    context.fillRect(0, 0, width, height);
    var image_4c_array = new Uint8Array(context.getImageData(0, 0, canvas.width, canvas.height).data);
    var output_buffer = YMKModule._malloc(canvas.width * canvas.height * 4);
    var temp_4c_array = new Uint8Array(YMKModule.HEAPU8.buffer, output_buffer, canvas.width * canvas.height * 4);
    temp_4c_array.set(image_4c_array);
    _mediaUtils2.default.releaseCanvas(canvas);
    return output_buffer;
  },
  makeVNMaskImage: function makeVNMaskImage(_width, _height, _stride, _buffer, _YMKModule) {
    return {
      width: _width,
      height: _height,
      stride: _stride,
      pxfmt: _YMKModule.VN_Mask_PixelFormat.VN_MASK_PXFMT_GRAY8,
      p_data: _buffer
    };
  },
  makeVNImage: function makeVNImage(_width, _height, _stride, _buffer, _YMKModule) {
    return {
      width: _width,
      height: _height,
      stride: _stride,
      pxfmt: _YMKModule.VN_PixelFormat.VN_PXFMT_BGRA32,
      p_data: _buffer
    };
  },
  getLevelMax: function getLevelMax(levelColor) {
    if (levelColor.length === 12) {
      var result = /^([a-f\d]{2})/i.exec(levelColor);
      if (result) {
        return parseInt(result[1], 16);
      }
    }
    return 100;
  },
  getLevelDefault: function getLevelDefault(levelColor) {
    if (levelColor.length === 12) {
      var result = /^[a-f\d]{2}([a-f\d]{2})/i.exec(levelColor);
      if (result) {
        return parseInt(result[1], 16);
      }
    }
    return 64;
  },
  stringToHex: function stringToHex(str) {
    if (!str) {
      return str;
    }
    if (str.length === 7) {
      return str;
    }
    if (str.length === 6) {
      return '#' + str;
    }
    if (str.length > 6) {
      return '#' + str.substring(str.length - 6);
    }
    return str;
  },
  hexToRgb: function hexToRgb(hex) {
    var result = /([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
      return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      };
    }
    if (hex && hex.content) {
      return utils.hexToRgb(hex.content);
    }
    return null;
  },
  getEyebrowAttr: function getEyebrowAttr(itemPattern, mask, key) {
    var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (!!itemPattern && (0, _has3.default)(itemPattern, key)) {
      return (0, _toInteger3.default)(itemPattern[key]);
    }
    if (!!mask && (0, _has3.default)(mask, key)) {
      return (0, _toInteger3.default)(mask[key]);
    }
    return defaultValue;
  },
  getMaskAttrs: function getMaskAttrs(mask, key, index) {
    if (!mask) {
      return 0;
    }
    if (!mask[key] && !mask[key + '3d']) {
      return 0;
    }
    var buff = void 0;
    if (!!mask[key + '3d']) {
      buff = (0, _split3.default)(mask[key + '3d'], ',');
    } else if (!!mask[key]) {
      buff = (0, _split3.default)(mask[key], ',');
    }

    if (buff && buff.length === 2) {
      return (0, _toInteger3.default)(buff[index]);
    }
    return 0;
  },
  getIntensity: function getIntensity(pattern, skuItem) {
    if (skuItem && skuItem.color_intensities && skuItem.color_intensities.color_intensity) {
      if ((0, _isArray3.default)(skuItem.color_intensities.color_intensity)) {
        return (0, _toInteger3.default)(skuItem.color_intensities.color_intensity[0]);
      }
      return (0, _toInteger3.default)(skuItem.color_intensities.color_intensity);
    }
    if (!!pattern.color_intensity) {
      return (0, _toInteger3.default)(pattern.color_intensity);
    }

    if ((0, _isArray3.default)(pattern.color_intensities)) {
      return (0, _toInteger3.default)(pattern.color_intensities[0]);
    }

    if ((0, _isInteger3.default)(pattern.color_intensities)) {
      return pattern.color_intensities;
    }

    if (pattern.color_intensities) {
      try {
        return (0, _toInteger3.default)(pattern.color_intensities);
      } catch (err) {
        console.log('err', err);
      }
    }
    return 50;
  },
  MakeVN_Object3DRenderData: function MakeVN_Object3DRenderData(YMKModule, _vertex_array_size, _normal_array_size, _texcoord_array_size, _tangnet_array_size, _index_array_size, _p_vertex_array, _p_normal_array, _p_texcoord_array, _p_tangent_array, _p_index_array, _ambient_data, _diffuse_data, _specular_data, _environment_data, _environment_weight_data, _normal_map_data, _orm_data, _trans_data, _opa_data, _earring_matrix_index, _hand_ar_matrix_index) {
    var mtl_name = YMKModule._malloc(256);
    new Uint8Array(YMKModule.HEAPU8.buffer, mtl_name, 256).fill(0);
    return {
      vertex_array_size: _vertex_array_size,
      normal_array_size: _normal_array_size,
      texcoord_array_size: _texcoord_array_size,
      tangent_array_size: _tangnet_array_size,
      index_array_size: _index_array_size,
      p_vertex_array: _p_vertex_array,
      p_normal_array: _p_normal_array,
      p_texcoord_array: _p_texcoord_array,
      p_tangent_array: _p_tangent_array,
      p_index_array: _p_index_array,

      p_mtl_name: mtl_name,
      dissolve: 0.0,
      transmission_filter: [0.0, 0.0, 0.0],

      environment_mode: 0.0,
      environment_intensity: 0.0,
      environment_tile_x: 0.0,
      environment_tile_y: 0.0,

      shadow_intensity: 0.0,
      shadow_offset: 0.5,
      is_pbr: false,
      exposure: 1.0,
      p_brdf_lut: 0,
      brdf_lut_width: 0,
      brdf_lut_height: 0,
      p_small_gem_norm_map: 0,
      small_gem_norm_map_width: 0,
      small_gem_norm_map_height: 0,
      p_small_gem_pos_map: 0,
      small_gem_pos_map_width: 0,
      small_gem_pos_map_height: 0,
      fresnel_intensity: 1.0,
      hori_orien: 0.0,
      vert_orien: 0.0,
      is_enable_mirror_hdr: false,
      is_gem: false,
      gem_center: { x: 0.0, y: 0.0, z: 0.0 },
      gem_pos_scale: { x: 0.0, y: 0.0, z: 0.0 },
      gem_pos_shift: { x: 0.0, y: 0.0, z: 0.0 },
      is_small_gem: false,
      gem_absorption: 0.0,
      gem_bounces: 0,
      gem_color: { x: 0.0, y: 0.0, z: 0.0 },
      gem_dispersion: 0.0,
      gem_ior: 0.0,
      bloom_scale: -1.0,
      bloom_intensity: -1.0,
      bloom_threshold: -1.0,
      is_glass: false,
      nail_glitter: 0.0,
      nail_type_id: -1,
      inverse_tone_mapping: 0,
      small_gem_rotation_mat: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
      is_referenced_small_gem: false,
      small_gem_id: -1,
      small_gem_original_group: -1,
      referencing_small_gem_id: -1,
      bbox_start: { x: 0.0, y: 0.0, z: 0.0 },
      bbox_end: { x: 0.0, y: 0.0, z: 0.0 },

      watch_time_component_parameter: utils.MakeVN_WatchTimeComponentParameters(YMKModule),
      watch_digital_time_component_parameter: utils.MakeVN_WatchTimeDigitalComponentParameters(YMKModule),

      ambient_data: _ambient_data,
      diffuse_data: _diffuse_data,
      specular_data: _specular_data,
      environment_data: _environment_data,
      environment_weight_data: _environment_weight_data,
      normal_map_data: _normal_map_data,
      orm_data: _orm_data,
      trans_data: _trans_data,
      opa_data: _opa_data,

      earring_matrix_index: _earring_matrix_index,
      hand_ar_matrix_index: _hand_ar_matrix_index
    };
  },
  MakeVN_WatchTimeComponentParameters: function MakeVN_WatchTimeComponentParameters(YMKModule) {
    return {
      is_time_component: false,
      component_type: YMKModule.VN_WatchObjectTimeComponentType.WATCH_OBJECT_TIME_COMPONENT_SECOND,
      rotate_center: { x: 0.0, y: 0.0, z: 0.0 },
      rotate_axis: { x: 0.0, y: 0.0, z: 0.0 },
      rotate_cycle: 1000.0
    };
  },
  MakeVN_WatchTimeDigitalComponentParameters: function MakeVN_WatchTimeDigitalComponentParameters(YMKModule) {
    return {
      is_time_component: false,
      component_type: YMKModule.VN_WatchObjectDigitalTimeComponentType.WATCH_OBJECT_DIGITAL_TIME_COMPONENT_SECOND_TENS,
      time_system: -1,
      text_count: 1,
      p_text_offset_array: YMKModule._malloc(26 * 2 * 4)
    };
  },

  createObject3DRenderDataVec: function createObject3DRenderDataVec(venus_makeup_live, YMKModule) {
    var object_count = new YMKModule.IntObject();
    object_count.value = 0;
    venus_makeup_live.GetObject3DCount(object_count);
    var render_data_vec = YMKModule.CreateVector_WebVN_Object3DRenderData(object_count.value);
    var total_size_mb = 0;
    var total_triangles = 0;
    for (var i = 0; i < object_count.value; i++) {
      var vertex_array_size = new YMKModule.IntObject();
      vertex_array_size.value = 0;
      var normal_array_size = new YMKModule.IntObject();
      normal_array_size.value = 0;
      var texcoord_array_size = new YMKModule.IntObject();
      texcoord_array_size.value = 0;
      var tangent_array_size = new YMKModule.IntObject();
      tangent_array_size.value = 0;
      var index_array_size = new YMKModule.IntObject();
      index_array_size.value = 0;
      venus_makeup_live.GetObject3DInfo(i, vertex_array_size, normal_array_size, texcoord_array_size, tangent_array_size, index_array_size);
      var p_vertex_array = YMKModule._malloc(vertex_array_size.value * 4);
      var p_normal_array = YMKModule._malloc(normal_array_size.value * 4);
      var p_texcoord_array = YMKModule._malloc(texcoord_array_size.value * 4);
      var p_tangent_array = YMKModule._malloc(tangent_array_size.value * 4);
      var p_index_array = YMKModule._malloc(index_array_size.value * 4);

      var sub_object_size = (vertex_array_size.value + normal_array_size.value + texcoord_array_size.value + tangent_array_size.value + index_array_size.value) * 4 * 0.001 * 0.001;
      total_size_mb += sub_object_size;
      var triangle_count = index_array_size.value == 0 ? vertex_array_size.value / 9 : index_array_size.value / 3;
      total_triangles += triangle_count;

      var ambient_image_name = YMKModule._malloc(256);
      var diffuse_image_name = YMKModule._malloc(256);
      var specular_image_name = YMKModule._malloc(256);
      var environment_image_name = YMKModule._malloc(256);
      var environment_weight_image_name = YMKModule._malloc(256);
      var normal_image_name = YMKModule._malloc(256);
      var orm_image_name = YMKModule._malloc(256);
      var trans_image_name = YMKModule._malloc(256);
      var opa_image_name = YMKModule._malloc(256);
      new Uint8Array(YMKModule.HEAPU8.buffer, ambient_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, diffuse_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, specular_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, environment_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, environment_weight_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, normal_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, orm_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, trans_image_name, 256).fill(0);
      new Uint8Array(YMKModule.HEAPU8.buffer, opa_image_name, 256).fill(0);
      var p_render_data = utils.MakeVN_Object3DRenderData(YMKModule, vertex_array_size.value, normal_array_size.value, texcoord_array_size.value, tangent_array_size.value, index_array_size.value, p_vertex_array, p_normal_array, p_texcoord_array, p_tangent_array, p_index_array, utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, ambient_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, diffuse_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, specular_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, environment_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, environment_weight_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, normal_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, orm_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, trans_image_name), utils.MakeVN_Object3DMaterialData(128.0, 128.0, 128.0, opa_image_name), 0, 0);
      render_data_vec.set(i, p_render_data);
      vertex_array_size.delete();
      normal_array_size.delete();
      texcoord_array_size.delete();
      tangent_array_size.delete();
      index_array_size.delete();
    }
    object_count.delete();
    render_data_vec.num_triangles = total_triangles;
    return render_data_vec;
  },
  loadObb: function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(url) {
      var is_occluder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var skuType = arguments[2];
      var venus_makeup_live = arguments[3];
      var YMKModule = arguments[4];
      var templateInfo = arguments[5];
      var module_setting = arguments[6];
      var r, tmp_obb_array, obb_buffer, web_obb_array, object_type, render_data_vec;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return (0, _dao.downloadObb)(_browserUtils2.default.changeHost(url));

            case 2:
              r = _context3.sent;
              tmp_obb_array = new Uint8Array(r);
              obb_buffer = YMKModule._malloc(tmp_obb_array.length);
              web_obb_array = new Uint8Array(YMKModule.HEAPU8.buffer, obb_buffer, tmp_obb_array.length);

              web_obb_array.set(tmp_obb_array);

              object_type = new YMKModule.IntObject();

              object_type.value = 0;
              venus_makeup_live.SetObject3DModelBuffer(obb_buffer, tmp_obb_array.length, is_occluder, object_type);
              YMKModule._free(obb_buffer);
              object_type.delete();

              render_data_vec = utils.createObject3DRenderDataVec(venus_makeup_live, YMKModule);

              if (!is_occluder) {
                _context3.next = 16;
                break;
              }

              if (skuType === 'ring') {
                venus_makeup_live.GetWatchObject3DRenderData(render_data_vec);
              } else {
                venus_makeup_live.GetObject3DRenderData(render_data_vec);
              }
              return _context3.abrupt('return', render_data_vec);

            case 16:
              if (skuType === 'watch') {
                venus_makeup_live.SetWatchSizeAdjustmentSetting(templateInfo && templateInfo.watch_size_adjustment_enable || false, templateInfo && templateInfo.watch_size_adjustment_left_anchor_x || 0.0, templateInfo && templateInfo.watch_size_adjustment_left_anchor_z || 0.0, templateInfo && templateInfo.watch_size_adjustment_right_anchor_x || 0.0, templateInfo && templateInfo.watch_size_adjustment_right_anchor_z || 0.0, templateInfo && templateInfo.default_wrist_size || 5.0);
                venus_makeup_live.GetWatchObject3DRenderData(render_data_vec);
              } else if (skuType === 'bracelet') {
                venus_makeup_live.GetPendantRenderData(render_data_vec, module_setting);
              } else {
                venus_makeup_live.GetObject3DRenderData(render_data_vec);
              }
              return _context3.abrupt('return', render_data_vec);

            case 18:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, undefined);
    }));

    return function loadObb(_x8) {
      return _ref3.apply(this, arguments);
    };
  }(),
  freeObb: function freeObb(data, YMKModule) {
    if (!data) {
      return;
    }
    for (var i = 0; i < data.size(); i++) {
      var obj = data.get(data.size() - i - 1);
      YMKModule._free(obj.p_vertex_array);
      YMKModule._free(obj.p_normal_array);
      YMKModule._free(obj.p_texcoord_array);
      YMKModule._free(obj.p_tangent_array);
      YMKModule._free(obj.p_index_array);
      YMKModule._free(obj.p_mtl_name);
      YMKModule._free(obj.ambient_data.texture_image_name);
      YMKModule._free(obj.diffuse_data.texture_image_name);
      YMKModule._free(obj.specular_data.texture_image_name);
      YMKModule._free(obj.environment_data.texture_image_name);
      YMKModule._free(obj.environment_weight_data.texture_image_name);
      YMKModule._free(obj.normal_map_data.texture_image_name);
      YMKModule._free(obj.orm_data.texture_image_name);
      YMKModule._free(obj.trans_data.texture_image_name);
      YMKModule._free(obj.opa_data.texture_image_name);
      YMKModule._free(obj.watch_digital_time_component_parameter.p_text_offset_array);
    }
    data.delete();
  },
  freeTextImages: function freeTextImages(texture_image_hash_map) {
    (0, _keys2.default)(texture_image_hash_map).map(function (k) {
      if (texture_image_hash_map[k].image) {
        texture_image_hash_map[k].image = null;
      }
      delete texture_image_hash_map[k];
    });
    texture_image_hash_map = {};
  },
  preloadTextImages: function () {
    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(urlPrefix, render_data_vec, YMKModule) {
      var urls, names, i, curr_model, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, name;

      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              urls = [];
              names = ['ambient', 'diffuse', 'specular', 'environment', 'environment_weight', 'normal_map', 'opa', 'orm', 'trans'];
              i = 0;

            case 3:
              if (!(i < render_data_vec.size())) {
                _context4.next = 27;
                break;
              }

              curr_model = render_data_vec.get(i);
              _iteratorNormalCompletion5 = true;
              _didIteratorError5 = false;
              _iteratorError5 = undefined;
              _context4.prev = 8;

              for (_iterator5 = (0, _getIterator3.default)(names); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                name = _step5.value;

                urls.push(utils.getImageUrl(urlPrefix, curr_model, name, YMKModule));
              }
              _context4.next = 16;
              break;

            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4['catch'](8);
              _didIteratorError5 = true;
              _iteratorError5 = _context4.t0;

            case 16:
              _context4.prev = 16;
              _context4.prev = 17;

              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }

            case 19:
              _context4.prev = 19;

              if (!_didIteratorError5) {
                _context4.next = 22;
                break;
              }

              throw _iteratorError5;

            case 22:
              return _context4.finish(19);

            case 23:
              return _context4.finish(16);

            case 24:
              i++;
              _context4.next = 3;
              break;

            case 27:
              _context4.prev = 27;
              _context4.next = 30;
              return _promise2.default.all((0, _uniq3.default)(urls).map(function (url) {
                return url && (0, _isomorphicFetch2.default)(_browserUtils2.default.changeHost((0, _toLower3.default)(url)));
              }));

            case 30:
              _context4.next = 35;
              break;

            case 32:
              _context4.prev = 32;
              _context4.t1 = _context4['catch'](27);

              console.log({ err: _context4.t1 });

            case 35:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, undefined, [[8, 12, 16, 24], [17,, 19, 23], [27, 32]]);
    }));

    return function preloadTextImages(_x10, _x11, _x12) {
      return _ref4.apply(this, arguments);
    };
  }(),
  loadTextImages: function () {
    var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(urlPrefix, render_data_vec, texture_image_hash_map, document, YMKModule) {
      var render_texture_key_array, promises, i, curr_model, render_texture_key;
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              render_texture_key_array = [];
              promises = [];
              i = 0;

            case 3:
              if (!(i < render_data_vec.size())) {
                _context5.next = 20;
                break;
              }

              curr_model = render_data_vec.get(i);
              render_texture_key = {
                ambient: '',
                diffuse: '',
                specular: '',
                environment: '',
                environment_weight: '',
                normal_map: '',
                orm: '',
                trans: '',
                opa: ''
              };

              render_texture_key_array.push(render_texture_key);
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'ambient', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'diffuse', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'specular', texture_image_hash_map, document, YMKModule));
              _context5.next = 12;
              return utils.loadImage(render_texture_key, urlPrefix, curr_model, 'environment', texture_image_hash_map, document, YMKModule);

            case 12:
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'environment_weight', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'normal_map', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImage(render_texture_key, urlPrefix, curr_model, 'opa', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImageResized(render_texture_key, urlPrefix, curr_model, 'orm', texture_image_hash_map, document, YMKModule));
              promises.push(utils.loadImageResized(render_texture_key, urlPrefix, curr_model, 'trans', texture_image_hash_map, document, YMKModule));

            case 17:
              i++;
              _context5.next = 3;
              break;

            case 20:
              _context5.next = 22;
              return _promise2.default.all(promises);

            case 22:
              return _context5.abrupt('return', render_texture_key_array);

            case 23:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, undefined);
    }));

    return function loadTextImages(_x13, _x14, _x15, _x16, _x17) {
      return _ref5.apply(this, arguments);
    };
  }(),
  getFilename: function getFilename(total_string) {
    var urlPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var t = total_string.replaceAll('\x00', '');
    if (total_string.includes('.hdr')) {
      return urlPrefix + t;
    }
    if (total_string.includes('.png')) {
      return urlPrefix + t;
    }
    if (total_string.includes('.jpg')) {
      return urlPrefix + t;
    }
    if (total_string.includes('.jpeg')) {
      return urlPrefix + t;
    }
    return '';
  },
  getImageUrl: function getImageUrl(urlPrefix, curr_model, key, YMKModule) {
    var image_name = new Uint8Array(YMKModule.HEAPU8.buffer, curr_model[key + '_data'].texture_image_name, 256);
    var total_string = '';
    for (var j = 0; j < image_name.length; j++) {
      total_string += String.fromCharCode(image_name[j]);
    }
    return utils.getFilename(total_string, urlPrefix);
  },
  loadImage: function () {
    var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(render_texture_key, urlPrefix, curr_model, key, texture_image_hash_map, document, YMKModule) {
      var image_name, total_string, j, file_name;
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              image_name = new Uint8Array(YMKModule.HEAPU8.buffer, curr_model[key + '_data'].texture_image_name, 256);
              total_string = '';

              for (j = 0; j < image_name.length; j++) {
                total_string += String.fromCharCode(image_name[j]);
              }
              file_name = utils.getFilename(total_string, urlPrefix);

              render_texture_key[key] = file_name;

              if (!total_string.includes('.hdr')) {
                _context6.next = 11;
                break;
              }

              if (file_name in texture_image_hash_map) {
                _context6.next = 10;
                break;
              }

              _context6.next = 9;
              return utils.loadHDRImage(file_name);

            case 9:
              texture_image_hash_map[file_name] = _context6.sent;

            case 10:
              return _context6.abrupt('return');

            case 11:
              if (!(total_string.includes('.png') || total_string.includes('.jpg') || total_string.includes('.jpeg'))) {
                _context6.next = 34;
                break;
              }

              if (file_name in texture_image_hash_map) {
                _context6.next = 34;
                break;
              }

              texture_image_hash_map[file_name] = { image: null, width: 0, height: 0 };

              if (!_browserUtils2.default.isPerfectConsole()) {
                _context6.next = 23;
                break;
              }

              _context6.prev = 15;
              _context6.next = 18;
              return utils.Load4CImage(file_name, texture_image_hash_map[file_name], document);

            case 18:
              return _context6.abrupt('return', _context6.sent);

            case 21:
              _context6.prev = 21;
              _context6.t0 = _context6['catch'](15);

            case 23:
              _context6.prev = 23;
              _context6.next = 26;
              return utils.Load4CImage((0, _toLower3.default)(file_name), texture_image_hash_map[file_name], document);

            case 26:
              return _context6.abrupt('return', _context6.sent);

            case 29:
              _context6.prev = 29;
              _context6.t1 = _context6['catch'](23);
              _context6.next = 33;
              return utils.Load4CImage(file_name, texture_image_hash_map[file_name], document);

            case 33:
              return _context6.abrupt('return', _context6.sent);

            case 34:
              return _context6.abrupt('return', null);

            case 35:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, undefined, [[15, 21], [23, 29]]);
    }));

    return function loadImage(_x19, _x20, _x21, _x22, _x23, _x24, _x25) {
      return _ref6.apply(this, arguments);
    };
  }(),
  loadImageResized: function () {
    var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(render_texture_key, urlPrefix, curr_model, key, texture_image_hash_map, document, YMKModule) {
      var image_name, total_string, j, file_name;
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              image_name = new Uint8Array(YMKModule.HEAPU8.buffer, curr_model[key + '_data'].texture_image_name, 256);
              total_string = '';

              for (j = 0; j < image_name.length; j++) {
                total_string += String.fromCharCode(image_name[j]);
              }
              file_name = utils.getFilename(total_string, urlPrefix);

              render_texture_key[key] = file_name;

              if (!total_string.includes('.hdr')) {
                _context7.next = 11;
                break;
              }

              if (file_name in texture_image_hash_map) {
                _context7.next = 10;
                break;
              }

              _context7.next = 9;
              return utils.loadHDRImage(file_name);

            case 9:
              texture_image_hash_map[file_name] = _context7.sent;

            case 10:
              return _context7.abrupt('return');

            case 11:
              if (!(total_string.includes('.png') || total_string.includes('.jpg') || total_string.includes('.jpeg'))) {
                _context7.next = 34;
                break;
              }

              if (file_name in texture_image_hash_map) {
                _context7.next = 34;
                break;
              }

              texture_image_hash_map[file_name] = { image: null, width: 0, height: 0 };

              if (!_browserUtils2.default.isPerfectConsole()) {
                _context7.next = 23;
                break;
              }

              _context7.prev = 15;
              _context7.next = 18;
              return utils.Load4CImageResized(file_name, texture_image_hash_map[file_name], document);

            case 18:
              return _context7.abrupt('return', _context7.sent);

            case 21:
              _context7.prev = 21;
              _context7.t0 = _context7['catch'](15);

            case 23:
              _context7.prev = 23;
              _context7.next = 26;
              return utils.Load4CImageResized((0, _toLower3.default)(file_name), texture_image_hash_map[file_name], document);

            case 26:
              return _context7.abrupt('return', _context7.sent);

            case 29:
              _context7.prev = 29;
              _context7.t1 = _context7['catch'](23);
              _context7.next = 33;
              return utils.Load4CImageResized(file_name, texture_image_hash_map[file_name], document);

            case 33:
              return _context7.abrupt('return', _context7.sent);

            case 34:
              return _context7.abrupt('return', null);

            case 35:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, undefined, [[15, 21], [23, 29]]);
    }));

    return function loadImageResized(_x26, _x27, _x28, _x29, _x30, _x31, _x32) {
      return _ref7.apply(this, arguments);
    };
  }(),

  Load4CImage: function Load4CImage(path, texture, document) {
    return new _promise2.default(function (resolve, reject) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onerror = reject;
      img.onload = function () {
        var width = 0;
        var height = 0;
        if (img.width > img.height) {
          width = Math.min(MAX_WIDTH_HEIGHT, img.width);
          height = (0, _toInteger3.default)(width / img.width * img.height);
        } else {
          height = Math.min(MAX_WIDTH_HEIGHT, img.height);
          width = (0, _toInteger3.default)(height / img.height * img.width);
        }
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, width, height);
        context.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
        var buffer = new Uint8Array(width * height * 4);
        buffer.set(new Uint8Array(context.getImageData(0, 0, width, height).data));
        texture.image = buffer;
        texture.width = width;
        texture.height = height;
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve();
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },

  Load4CImageResized: function Load4CImageResized(path, texture, document) {
    return new _promise2.default(function (resolve, reject) {
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.onerror = reject;
      img.onload = function () {
        var width = 512;
        var height = 512;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, width, height);
        context.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
        var buffer = new Uint8Array(width * height * 4);
        buffer.set(new Uint8Array(context.getImageData(0, 0, width, height).data));
        texture.image = buffer;
        texture.width = width;
        texture.height = height;
        _mediaUtils2.default.releaseCanvas(canvas);
        resolve();
      };
      img.src = _browserUtils2.default.changeHost(path);
    });
  },
  getIsUpdateArray: function getIsUpdateArray() {
    var last = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var r = [];
    for (var i = 0; i < current.length; i++) {
      if (i >= last.length) {
        r[i] = true;
      }
      r[i] = current[i] !== last[i];
    }
    console.log({ r: r });
    return r;
  }
};

exports.default = utils;
module.exports = exports['default'];

/***/ }),

/***/ 687:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newInstance = exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(100);

var _stringify2 = _interopRequireDefault(_stringify);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp, _initialiseProps;

var _three = __webpack_require__(705);

var _lockmanager = __webpack_require__(315);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _sum2 = __webpack_require__(1250);

var _sum3 = _interopRequireDefault(_sum2);

var _isNumber2 = __webpack_require__(136);

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _VideoSourceLoader = __webpack_require__(3338);

var _VideoSourceLoader2 = _interopRequireDefault(_VideoSourceLoader);

var _makeuplivefilter = __webpack_require__(3341);

var _makeuplivefilter2 = _interopRequireDefault(_makeuplivefilter);

var _image = __webpack_require__(3377);

var _image2 = _interopRequireDefault(_image);

var _fileUtils = __webpack_require__(137);

var _fileUtils2 = _interopRequireDefault(_fileUtils);

var _sortBy2 = __webpack_require__(802);

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _AbstractMakeupController = __webpack_require__(908);

var _AbstractMakeupController2 = _interopRequireDefault(_AbstractMakeupController);

var _nail = __webpack_require__(3378);

var _nail2 = _interopRequireDefault(_nail);

var _skuUtils = __webpack_require__(60);

var _skuUtils2 = _interopRequireDefault(_skuUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _venusloader = __webpack_require__(314);

var _venusloader2 = _interopRequireDefault(_venusloader);

var _pbrUtils = __webpack_require__(335);

var _pbrUtils2 = _interopRequireDefault(_pbrUtils);

var _find2 = __webpack_require__(48);

var _find3 = _interopRequireDefault(_find2);

var _filter2 = __webpack_require__(44);

var _filter3 = _interopRequireDefault(_filter2);

var _throttle2 = __webpack_require__(25);

var _throttle3 = _interopRequireDefault(_throttle2);

var _values2 = __webpack_require__(84);

var _values3 = _interopRequireDefault(_values2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_TRANSLATE_Y = -5.0;
var TRANSLATE_Y_PER_WHEEL = 0.5;

var NailController = (_temp = _class = function (_AbstractMakeupContro) {
  (0, _inherits3.default)(NailController, _AbstractMakeupContro);

  function NailController(props) {
    (0, _classCallCheck3.default)(this, NailController);

    var _this = (0, _possibleConstructorReturn3.default)(this, (NailController.__proto__ || (0, _getPrototypeOf2.default)(NailController)).call(this, props));

    _initialiseProps.call(_this);

    _this.MakeupLiveFilter = _makeuplivefilter2.default;
    _this.engine_pointer = null;
    _this.updating = false;
    _this.handleMouseMove = (0, _throttle3.default)(_this._handleMouseMove, 50, { heading: true, trailing: false });
    _this.loaded = false;

    _this.addAfterSourceInitTask(_this.afterSourceInit4TryOn);
    return _this;
  }

  return NailController;
}(_AbstractMakeupController2.default), _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.setArgs = function (props) {
    _this2.braking = false;
    _this2.updating = false;
    _this2.camera_width = props.cameraWidth;
    _this2.camera_height = props.cameraHeight;
    _this2.display_width = _mathUtils2.default.toEvenNumber(props.displayWidth);
    _this2.display_height = _mathUtils2.default.toEvenNumber(props.displayHeight);
    if (!_this2.isPbr()) {
      _this2.fourWayFaceIndex = 0;
      _this2.VideoSourceLoader = _VideoSourceLoader2.default;
      _this2.ImageSource = _image2.default;
      _this2.m_feature_enable_array = [];
      for (var i = 0; i < _featureenum2.default.FEATURE_SIZE; i++) {
        _this2.m_feature_enable_array.push(false);
      }
    }

    if (_this2.isPbr()) {
      _this2.frameId = props.frameId;
      _this2.outputId = props.outputId;
      _this2.canvasId = props.canvasId;
      _this2.display_width = _mathUtils2.default.toEvenNumber(props.displayWidth * props.settings.devicePixelRatio);
      _this2.display_height = _mathUtils2.default.toEvenNumber(props.displayHeight * props.settings.devicePixelRatio);
      _this2.original_display_width = props.displayWidth;
      _this2.original_display_height = props.displayHeight;
      _this2.document = props.document;
      _this2.moduleElement = _this2.document.getElementById('YMK-module');
      _this2.emitter = props.emitter;
      _this2.renderer = null;
      _this2.allUpdaters = [];
      _this2.settings = props;
      _this2.terminalized = false;
      _this2.m_feature_enable_array = [];
      for (var _i = 0; _i < _featureenum2.default.FEATURE_SIZE; _i++) {
        _this2.m_feature_enable_array.push(false);
      }
      _this2.m_feature_enable_array[_featureenum2.default.FEATURE_UPSCALE] = true;
      _this2.m_object_3d_rotation = [0.0, 0.0, 0.0];

      _this2.m_drag_x = 0;
      _this2.m_drag_y = 0;

      _this2.translateY = DEFAULT_TRANSLATE_Y;
      _this2.autoRotate = false;
      _this2.autoRotateX = 0;
      _this2.autoRotateY = 0;
      _this2.project = props && props.project;
      _this2.sumOfMoving = 0;
      _this2.count = 0;
      _this2.moving = true;
      _this2.bloomIntensityRatio = 1.0;
    }
  };

  this._load = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(type, media, _skuTypes, featurePoints, mediaSource, earlobePoints, masks, leftEarlobePoints, rightEarlobePoints, removeBgMask, modelConfig) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!_this2.loaded) {
                _context2.next = 5;
                break;
              }

              _context2.next = 3;
              return _this2.close();

            case 3:
              _context2.next = 5;
              return (0, _lockmanager.getLockManager)().waitForResolve('controller-close');

            case 5:
              _this2.loaded = true;
              _venusloader2.default.load(_this2.settings, _this2.emitter, function () {
                var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(m) {
                  var b;
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _this2.YMKModule = m;
                          _this2.emitter.trigger(_events2.default.loading, [80]);
                          _context.prev = 2;
                          b = performance.now();

                          _this2.initWebcam(type);
                          _this2.emitter.trigger(_events2.default.engineLoading, ['camera', b, performance.now()]);
                          _context.next = 8;
                          return _this2.init({
                            type: type,
                            media: media,
                            featurePoints: featurePoints,
                            mediaSource: mediaSource,
                            earlobePoints: earlobePoints,
                            masks: masks,
                            leftEarlobePoints: leftEarlobePoints,
                            rightEarlobePoints: rightEarlobePoints,
                            removeBgMask: removeBgMask,
                            modelConfig: modelConfig
                          });

                        case 8:
                          _context.next = 13;
                          break;

                        case 10:
                          _context.prev = 10;
                          _context.t0 = _context['catch'](2);

                          console.log(_context.t0);

                        case 13:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, _this2, [[2, 10]]);
                }));

                return function (_x12) {
                  return _ref2.apply(this, arguments);
                };
              }());

            case 7:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this2);
    }));

    return function (_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11) {
      return _ref.apply(this, arguments);
    };
  }();

  this._loadByPbr = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!_this2.loaded) {
              _context4.next = 5;
              break;
            }

            _context4.next = 3;
            return _this2.close();

          case 3:
            _context4.next = 5;
            return (0, _lockmanager.getLockManager)().waitForResolve('controller-close');

          case 5:
            _this2.loaded = true;
            _this2.terminalized = false;
            _venusloader2.default.load(_this2.settings, _this2.emitter, function () {
              var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(m) {
                var viewport;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _this2.YMKModule = m;
                        _this2.videoCanvas = _this2.document.createElement('canvas');
                        _this2.videoContext = _this2.videoCanvas.getContext('2d');
                        _this2.videoTexture = new _three.DataTexture([], _this2.display_width, _this2.display_height);
                        _this2.videoTexture.minFilter = _three.LinearFilter;
                        _this2.videoTexture.magFilter = _three.LinearFilter;

                        _this2.emitter.trigger(_events2.default.loading, [80]);
                        _this2.renderer = new _three.WebGLRenderer({ preserveDrawingBuffer: true, alpha: true });
                        _this2.renderer.setSize(_this2.display_width, _this2.display_height);
                        _this2.renderer.domElement.id = 'canvas123';
                        _this2.getFrameDocument(_this2.document, _this2.frameId).getElementById(_this2.outputId).innerHTML = '';
                        _this2.getFrameDocument(_this2.document, _this2.frameId).getElementById(_this2.outputId).appendChild(_this2.renderer.domElement);
                        _this2.makeup_live_filter = new _this2.MakeupLiveFilter(_this2.display_width, _this2.display_height, false, _this2.renderer, _this2.YMKModule, _this2.settings);
                        _this2.renderer.domElement.style.width = _mathUtils2.default.toEvenNumber(_this2.display_width / _this2.settings.devicePixelRatio) + 'px';
                        _this2.renderer.domElement.style.height = _mathUtils2.default.toEvenNumber(_this2.display_height / _this2.settings.devicePixelRatio) + 'px';
                        if (_this2.isPbr() && _mathUtils2.default.isHexColor(_this2.settings.backgroundColorFor3DViewer)) {
                          _this2.setBackgroundColor(_this2.settings.backgroundColorFor3DViewer || '#ffffff');
                        }
                        _this2.makeup_live_filter.SetFeatureEnableArray(_this2.m_feature_enable_array);
                        _this2.makeup_live_filter.SetIsFrontCamera(false);
                        _this2.makeup_live_filter.SetInputTexture(_this2.videoTexture);
                        viewport = new _three.Vector4(0.0, 0.0, _this2.display_width, _this2.display_height);

                        _this2.makeup_live_filter.SetViewport(viewport);
                        _this2.renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);

                        _this2.allocateResources();
                        _this2.setParameterFromSetting();
                        _this2.updaters = {};
                        _context3.next = 27;
                        return _this2.loadProject();

                      case 27:
                        _this2.emitter.trigger(_events2.default.loading, [100]);
                        _this2.emitter.trigger(_events2.default.loadEngineComplete);
                        _this2.makeup_live_filter.setGetBloomIntensityRatioFunc(function () {
                          return _this2.bloomIntensityRatio;
                        });
                        _this2.render();

                      case 31:
                      case 'end':
                        return _context3.stop();
                    }
                  }
                }, _callee3, _this2);
              }));

              return function (_x13) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 8:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, _this2);
  }));

  this.load = function () {
    var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(type, media, _skuTypes, featurePoints, mediaSource, earlobePoints, masks, leftEarlobePoints, rightEarlobePoints, removeBgMask, modelConfig) {
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!_this2.isPbr()) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt('return', _this2._loadByPbr());

            case 2:
              _context5.next = 4;
              return _this2._load(type, media, _skuTypes, featurePoints, mediaSource, earlobePoints, masks, leftEarlobePoints, rightEarlobePoints, removeBgMask, modelConfig);

            case 4:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this2);
    }));

    return function (_x14, _x15, _x16, _x17, _x18, _x19, _x20, _x21, _x22, _x23, _x24) {
      return _ref5.apply(this, arguments);
    };
  }();

  this.setParameterFromSetting = function () {
    if (!_this2.isPbr()) {
      return;
    }
    _this2.m_dragged_rotate.set(0, _mathUtils2.default.degreesToEuler(_this2.settings.rotateXFor3DViewer));
    _this2.m_dragged_rotate.set(1, _mathUtils2.default.degreesToEuler(_this2.settings.rotateYFor3DViewer));
    _this2.m_dragged_rotate.set(2, _mathUtils2.default.degreesToEuler(_this2.settings.rotateZFor3DViewer));
    var parameterTranslateY = (0, _get3.default)(_this2.settings, 'defaultTranslateYFor3DViewer', DEFAULT_TRANSLATE_Y);
    var denormalizedTranslateYFor3DViewer = _this2.denormalizeTranslateYFor3DViewer(parameterTranslateY);
    _this2.translateY = denormalizedTranslateYFor3DViewer < _this2.settings.minTranslateYFor3DViewer ? _this2.settings.minTranslateYFor3DViewer : denormalizedTranslateYFor3DViewer > _this2.settings.maxTranslateYFor3DViewer ? _this2.settings.maxTranslateYFor3DViewer : denormalizedTranslateYFor3DViewer;
  };

  this.denormalizeTranslateYFor3DViewer = function (translateY) {
    var d = Math.abs(_this2.settings.maxTranslateYFor3DViewer - _this2.settings.minTranslateYFor3DViewer);
    return translateY * (d / 100) + _this2.settings.minTranslateYFor3DViewer;
  };

  this.loadProject = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
    var r, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, style;

    return _regenerator2.default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (_this2.isPbr()) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return');

          case 2:
            if (_this2.project) {
              _context6.next = 4;
              break;
            }

            return _context6.abrupt('return');

          case 4:
            _context6.next = 6;
            return _this2.loadObj(_this2.project.objUrl);

          case 6:
            r = _context6.sent;

            if (!(0, _get3.default)(_this2.project, 'defaultStyles')) {
              _context6.next = 34;
              break;
            }

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context6.prev = 11;
            _iterator = (0, _getIterator3.default)((0, _get3.default)(_this2.project, 'defaultStyles', []));

          case 13:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context6.next = 20;
              break;
            }

            style = _step.value;
            _context6.next = 17;
            return _this2.updateStyle(style);

          case 17:
            _iteratorNormalCompletion = true;
            _context6.next = 13;
            break;

          case 20:
            _context6.next = 26;
            break;

          case 22:
            _context6.prev = 22;
            _context6.t0 = _context6['catch'](11);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 26:
            _context6.prev = 26;
            _context6.prev = 27;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 29:
            _context6.prev = 29;

            if (!_didIteratorError) {
              _context6.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context6.finish(29);

          case 33:
            return _context6.finish(26);

          case 34:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee6, _this2, [[11, 22, 26, 34], [27,, 29, 33]]);
  }));

  this.updateProject = function () {
    var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(project, styles, _ref8) {
      var rotateXFor3DViewer = _ref8.rotateXFor3DViewer,
          rotateYFor3DViewer = _ref8.rotateYFor3DViewer,
          rotateZFor3DViewer = _ref8.rotateZFor3DViewer;

      var r, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, style;

      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (_this2.isPbr()) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt('return');

            case 2:
              if (!_this2.updating) {
                _context7.next = 4;
                break;
              }

              return _context7.abrupt('return');

            case 4:
              _this2.updating = true;
              _context7.prev = 5;

              if (_this2.project) {
                _this2.emitter.trigger(_events2.default.viewer3DObjectLoading);
              }
              _this2.project = project;
              _this2.pause();
              _context7.next = 11;
              return _this2.loadObj(project.objUrl);

            case 11:
              r = _context7.sent;

              _this2.resume();

              if (!(styles && styles.length > 0)) {
                _context7.next = 42;
                break;
              }

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context7.prev = 17;
              _iterator2 = (0, _getIterator3.default)(styles);

            case 19:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context7.next = 26;
                break;
              }

              style = _step2.value;
              _context7.next = 23;
              return _this2.updateStyle(style);

            case 23:
              _iteratorNormalCompletion2 = true;
              _context7.next = 19;
              break;

            case 26:
              _context7.next = 32;
              break;

            case 28:
              _context7.prev = 28;
              _context7.t0 = _context7['catch'](17);
              _didIteratorError2 = true;
              _iteratorError2 = _context7.t0;

            case 32:
              _context7.prev = 32;
              _context7.prev = 33;

              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }

            case 35:
              _context7.prev = 35;

              if (!_didIteratorError2) {
                _context7.next = 38;
                break;
              }

              throw _iteratorError2;

            case 38:
              return _context7.finish(35);

            case 39:
              return _context7.finish(32);

            case 40:
              _context7.next = 45;
              break;

            case 42:
              if (!((0, _get3.default)(project, 'styles', []).length > 0)) {
                _context7.next = 45;
                break;
              }

              _context7.next = 45;
              return _this2.updateAsDefaultStyle(project.elements.length, project.styles, project.elements, (0, _get3.default)(project, 'project.isMultiStylesEnabled'));

            case 45:

              _this2.updateRotation({ rotateXFor3DViewer: rotateXFor3DViewer, rotateYFor3DViewer: rotateYFor3DViewer, rotateZFor3DViewer: rotateZFor3DViewer });
              _this2.emitter.trigger(_events2.default.viewer3DObjectLoaded);
              _context7.next = 52;
              break;

            case 49:
              _context7.prev = 49;
              _context7.t1 = _context7['catch'](5);

              console.log(_context7.t1);

            case 52:
              _this2.updating = false;

            case 53:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, _this2, [[5, 49], [17, 28, 32, 40], [33,, 35, 39]]);
    }));

    return function (_x25, _x26, _x27) {
      return _ref7.apply(this, arguments);
    };
  }();

  this.updateAsDefaultStyle = function () {
    var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(elementNum, styles, elements) {
      var isMultiStylesEnabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var applied, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, style, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, element, material;

      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              applied = Array(elementNum).fill(0);
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context8.prev = 4;
              _iterator3 = (0, _getIterator3.default)(styles);

            case 6:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context8.next = 16;
                break;
              }

              style = _step3.value;

              if (!(((0, _get3.default)(style, 'parent') || !isMultiStylesEnabled) && _this2.isNeedUpdateStyle(applied, style))) {
                _context8.next = 11;
                break;
              }

              _context8.next = 11;
              return _this2.updateStyle((0, _get3.default)(style, 'styleCode'));

            case 11:
              if (applied.includes(0)) {
                _context8.next = 13;
                break;
              }

              return _context8.abrupt('break', 16);

            case 13:
              _iteratorNormalCompletion3 = true;
              _context8.next = 6;
              break;

            case 16:
              _context8.next = 22;
              break;

            case 18:
              _context8.prev = 18;
              _context8.t0 = _context8['catch'](4);
              _didIteratorError3 = true;
              _iteratorError3 = _context8.t0;

            case 22:
              _context8.prev = 22;
              _context8.prev = 23;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 25:
              _context8.prev = 25;

              if (!_didIteratorError3) {
                _context8.next = 28;
                break;
              }

              throw _iteratorError3;

            case 28:
              return _context8.finish(25);

            case 29:
              return _context8.finish(22);

            case 30:
              if (!applied.includes(0)) {
                _context8.next = 63;
                break;
              }

              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context8.prev = 34;
              _iterator4 = (0, _getIterator3.default)(elements);

            case 36:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                _context8.next = 49;
                break;
              }

              element = _step4.value;
              material = _this2._getMaterial((0, _get3.default)(element, 'materialIds[0]'));
              _context8.prev = 39;
              _context8.next = 42;
              return _this2.getUpdater()._updateSubObject((0, _get3.default)(element, 'id.elementIndex'), (0, _extends3.default)({}, material, {
                element: element,
                texture: _pbrUtils2.default.convertTextures((0, _get3.default)(material, 'textures', []))
              }));

            case 42:
              _context8.next = 46;
              break;

            case 44:
              _context8.prev = 44;
              _context8.t1 = _context8['catch'](39);

            case 46:
              _iteratorNormalCompletion4 = true;
              _context8.next = 36;
              break;

            case 49:
              _context8.next = 55;
              break;

            case 51:
              _context8.prev = 51;
              _context8.t2 = _context8['catch'](34);
              _didIteratorError4 = true;
              _iteratorError4 = _context8.t2;

            case 55:
              _context8.prev = 55;
              _context8.prev = 56;

              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }

            case 58:
              _context8.prev = 58;

              if (!_didIteratorError4) {
                _context8.next = 61;
                break;
              }

              throw _iteratorError4;

            case 61:
              return _context8.finish(58);

            case 62:
              return _context8.finish(55);

            case 63:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, _this2, [[4, 18, 22, 30], [23,, 25, 29], [34, 51, 55, 63], [39, 44], [56,, 58, 62]]);
    }));

    return function (_x28, _x29, _x30) {
      return _ref9.apply(this, arguments);
    };
  }();

  this.isNeedUpdateStyle = function (applied, style) {
    var flag = false;
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = (0, _getIterator3.default)((0, _get3.default)(style, 'elementIndexes', [])), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var index = _step5.value;

        if (applied[index] === 0) {
          applied[index] = 1;
          flag = true;
        }
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    return flag;
  };

  this.updateRotation = function (_ref10) {
    var rotateXFor3DViewer = _ref10.rotateXFor3DViewer,
        rotateYFor3DViewer = _ref10.rotateYFor3DViewer,
        rotateZFor3DViewer = _ref10.rotateZFor3DViewer;

    if (!_this2.isPbr()) {
      return;
    }
    if ((0, _isNumber3.default)(rotateXFor3DViewer)) {
      _this2.settings.rotateXFor3DViewer = rotateXFor3DViewer;
      _this2.m_dragged_rotate.set(0, _mathUtils2.default.degreesToEuler(_this2.settings.rotateXFor3DViewer));
    }
    if ((0, _isNumber3.default)(rotateYFor3DViewer)) {
      _this2.settings.rotateYFor3DViewer = rotateYFor3DViewer;
      _this2.m_dragged_rotate.set(1, _mathUtils2.default.degreesToEuler(_this2.settings.rotateYFor3DViewer));
    }
    if ((0, _isNumber3.default)(rotateZFor3DViewer)) {
      _this2.settings.rotateZFor3DViewer = rotateZFor3DViewer;
      _this2.m_dragged_rotate.set(2, _mathUtils2.default.degreesToEuler(_this2.settings.rotateZFor3DViewer));
    }
  };

  this._getStyle = function (styleCode) {
    return _this2.isPbr() && (0, _find3.default)(_this2.project.styles, function (style) {
      return (0, _get3.default)(style, 'styleCode') === styleCode;
    });
  };

  this._getElement = function (elementIndex) {
    return _this2.isPbr() && (0, _get3.default)(_this2.project, 'elements[' + elementIndex + ']');
  };

  this._getMaterial = function (materialId) {
    return _this2.isPbr() && (0, _find3.default)(_this2.project.materials, function (material) {
      return (0, _get3.default)(material, 'id') === materialId;
    });
  };

  this.updateElement = function () {
    var _ref11 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(elementIndex, data) {
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!_this2.isPbr()) {
                _context9.next = 5;
                break;
              }

              _context9.next = 3;
              return _this2.getUpdater()._updateSubObject(elementIndex, data);

            case 3:
              _context9.next = 5;
              return _this2._render();

            case 5:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, _this2);
    }));

    return function (_x32, _x33) {
      return _ref11.apply(this, arguments);
    };
  }();

  this.updateStyle = function () {
    var _ref12 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10(style) {
      var s, styleMaterials, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, styleMaterial, material, element;

      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (_this2.isPbr()) {
                _context10.next = 2;
                break;
              }

              return _context10.abrupt('return', false);

            case 2:
              if (_this2.project) {
                _context10.next = 4;
                break;
              }

              return _context10.abrupt('return', false);

            case 4:
              s = _this2._getStyle(style);

              if (s) {
                _context10.next = 7;
                break;
              }

              return _context10.abrupt('return', false);

            case 7:
              styleMaterials = (0, _filter3.default)(_this2.project.styleMaterials, function (styleMaterial) {
                return (0, _get3.default)(styleMaterial, 'styleId') === s.id;
              });

              if (styleMaterials) {
                _context10.next = 10;
                break;
              }

              return _context10.abrupt('return', false);

            case 10:
              _iteratorNormalCompletion6 = true;
              _didIteratorError6 = false;
              _iteratorError6 = undefined;
              _context10.prev = 13;
              _iterator6 = (0, _getIterator3.default)(styleMaterials);

            case 15:
              if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                _context10.next = 30;
                break;
              }

              styleMaterial = _step6.value;
              material = _this2._getMaterial(styleMaterial.materialId);
              element = _this2._getElement(styleMaterial.elementIndex);
              _context10.prev = 19;
              _context10.next = 22;
              return _this2.getUpdater()._updateSubObject(styleMaterial.elementIndex, (0, _extends3.default)({}, material, {
                element: element,
                texture: _pbrUtils2.default.convertTextures((0, _get3.default)(material, 'textures', []))
              }));

            case 22:
              _context10.next = 27;
              break;

            case 24:
              _context10.prev = 24;
              _context10.t0 = _context10['catch'](19);

              console.log(_context10.t0);

            case 27:
              _iteratorNormalCompletion6 = true;
              _context10.next = 15;
              break;

            case 30:
              _context10.next = 36;
              break;

            case 32:
              _context10.prev = 32;
              _context10.t1 = _context10['catch'](13);
              _didIteratorError6 = true;
              _iteratorError6 = _context10.t1;

            case 36:
              _context10.prev = 36;
              _context10.prev = 37;

              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }

            case 39:
              _context10.prev = 39;

              if (!_didIteratorError6) {
                _context10.next = 42;
                break;
              }

              throw _iteratorError6;

            case 42:
              return _context10.finish(39);

            case 43:
              return _context10.finish(36);

            case 44:
              return _context10.abrupt('return', { revisionNo: (0, _get3.default)(_this2.project, 'revisionNo') });

            case 45:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, _this2, [[13, 32, 36, 44], [19, 24], [37,, 39, 43]]);
    }));

    return function (_x34) {
      return _ref12.apply(this, arguments);
    };
  }();

  this.pause = function () {
    var stopWebcam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (_this2.isPbr()) {
      _this2.pausing = true;
      return;
    }
    _this2.source && _this2.source.pause(stopWebcam);
  };

  this.resume = function () {
    if (_this2.isPbr()) {
      _this2.pausing = false;
      return;
    }
    _this2.source && _this2.source.resume();
  };

  this.render = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
    return _regenerator2.default.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (_this2.isPbr()) {
              _context11.next = 2;
              break;
            }

            return _context11.abrupt('return');

          case 2:
            if (!_this2.terminalized) {
              _context11.next = 4;
              break;
            }

            return _context11.abrupt('return');

          case 4:
            if (!_this2.rendering) {
              _context11.next = 6;
              break;
            }

            return _context11.abrupt('return');

          case 6:

            _this2.rendering = true;

            if (_this2.pausing) {
              _context11.next = 10;
              break;
            }

            _context11.next = 10;
            return _this2._render();

          case 10:
            _this2.rendering = false;
            _this2.dumpDebugMessage();
            _this2.timer = window.requestFrame(_this2.render);

          case 13:
          case 'end':
            return _context11.stop();
        }
      }
    }, _callee11, _this2);
  }));

  this.checkMoving = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (_this2.count % 10 !== 0) {
      return _this2.moving;
    }
    var sumOfMoving = (0, _sum3.default)([_this2.translateY, _this2.m_object_3d_rotation[0], _this2.m_object_3d_rotation[2], _this2.m_object_3d_rotation[2]]);
    _this2.moving = _this2.lastSumOfMoving !== sumOfMoving;
    _this2.lastSumOfMoving = sumOfMoving;
  };

  this._render = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
    var fov;
    return _regenerator2.default.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            if (_this2.isPbr()) {
              _context12.next = 2;
              break;
            }

            return _context12.abrupt('return');

          case 2:
            if (_this2.makeup_live_filter) {
              _context12.next = 4;
              break;
            }

            return _context12.abrupt('return');

          case 4:
            _this2.makeup_live_filter.SetFeatureEnableArray(_this2.m_feature_enable_array);
            _this2.obj_translate.set(0, 0.0);
            _this2.obj_translate.set(1, 0.0);
            _this2.obj_translate.set(2, _this2.translateY);
            _this2.obj_scale.set(0, 1.0);
            _this2.obj_scale.set(1, 1.0);
            _this2.obj_scale.set(2, 1.0);
            _this2.dampingMove();
            _this2.obj_rotate.set(0, _this2.m_object_3d_rotation[0]);
            _this2.obj_rotate.set(1, _this2.m_object_3d_rotation[1]);
            _this2.obj_rotate.set(2, _this2.m_object_3d_rotation[2]);
            fov = 35.0;

            _this2.tz.value = _this2.translateY;
            _this2.venus_makeup_live.GetObject3DViewerMetadata(_this2.display_width, _this2.display_height, 0, _this2.obj_translate, _this2.obj_rotate, _this2.obj_scale, _this2.m_drag_x, _this2.m_drag_y, fov, -1, 0, _this2.m_dragged_rotate, _this2.tz, _this2.object_3d_metadata);
            _this2.makeup_live_filter.SetObject3DViewerMetadata(_this2.object_3d_metadata);
            _this2.makeup_live_filter.RenderFrame();
            _this2.checkMoving();
            _this2.adjustBloomIntensityRatioIfNecessary();
            _this2.count++;

          case 23:
          case 'end':
            return _context12.stop();
        }
      }
    }, _callee12, _this2);
  }));

  this.adjustBloomIntensityRatioIfNecessary = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (_this2.moving) {
      _this2.bloomIntensityRatio = 1.0;
    } else {
      if (_this2.bloomIntensityRatio > 0.1) {
        _this2.bloomIntensityRatio = _this2.bloomIntensityRatio - 0.01;
      }
    }
  };

  this.dumpDebugMessage = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (!_this2.settings.debug) {
      return;
    }
    if (!_this2.document.getElementById('timed')) {
      return;
    }
    if (!_this2._time || !_this2._count) {
      _this2._count = 1;
      _this2._time = performance.now();
    }
    _this2._count++;
    if (_this2._count % 20 !== 0) {
      return;
    }
    var fps = Math.round(1000 / ((performance.now() - _this2._time) / 20));
    _this2._time = performance.now();
    var r = {
      fps: fps
    };
    _this2.document.getElementById('timed').innerText = (0, _stringify2.default)(r);
  };

  this.update = function (subObjectIndex, data) {
    return _this2.isPbr() && _this2.getUpdater().updateSubObject(subObjectIndex, data);
  };

  this.update3DObject = function () {
    var _ref15 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13(urlOrBase64) {
      return _regenerator2.default.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _this2.emitter.trigger(_events2.default.viewer3DObjectLoading);
              _context13.next = 3;
              return _this2.loadObb(urlOrBase64);

            case 3:
              _this2.emitter.trigger(_events2.default.viewer3DObjectLoaded);

            case 4:
            case 'end':
              return _context13.stop();
          }
        }
      }, _callee13, _this2);
    }));

    return function (_x36) {
      return _ref15.apply(this, arguments);
    };
  }();

  this.loadObj = function () {
    var _ref16 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(urlOrBase64) {
      var r;
      return _regenerator2.default.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (_this2.isPbr()) {
                _context14.next = 2;
                break;
              }

              return _context14.abrupt('return');

            case 2:
              _context14.next = 4;
              return _this2.getUpdater().loadObj(urlOrBase64, _this2.project);

            case 4:
              r = _context14.sent;

              _this2.m_feature_enable_array[_featureenum2.default.FEATURE_OBJECT3D] = true;
              return _context14.abrupt('return', r);

            case 7:
            case 'end':
              return _context14.stop();
          }
        }
      }, _callee14, _this2);
    }));

    return function (_x37) {
      return _ref16.apply(this, arguments);
    };
  }();

  this.getUpdater = function () {
    return _this2.updaters['nail'];
  };

  this.setBackgroundColor = function (hex) {
    if (!_this2.isPbr()) {
      return;
    }
    var rgb = _mathUtils2.default.hexToRgb(hex);
    _this2.makeup_live_filter.SetObject3DViewerBackgroundColor(rgb.r, rgb.g, rgb.b, 255);
  };

  this.isFeatureApplied = function (feature) {
    return _this2.m_feature_enable_array[feature];
  };

  this.loadObb = function () {
    var _ref17 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(urlOrBase64) {
      var r;
      return _regenerator2.default.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (_this2.isPbr()) {
                _context15.next = 2;
                break;
              }

              return _context15.abrupt('return');

            case 2:
              _this2.emitter.trigger(_events2.default.viewer3DObjectLoading);
              _context15.next = 5;
              return _this2.getUpdater().loadObb(urlOrBase64);

            case 5:
              r = _context15.sent;

              _this2.m_feature_enable_array[_featureenum2.default.FEATURE_OBJECT3D] = true;
              _this2.emitter.trigger(_events2.default.viewer3DObjectLoaded);
              return _context15.abrupt('return', r);

            case 9:
            case 'end':
              return _context15.stop();
          }
        }
      }, _callee15, _this2);
    }));

    return function (_x38) {
      return _ref17.apply(this, arguments);
    };
  }();

  this._handleMouseMove = function (dxRate, dyRate) {
    if (!_this2.isPbr()) {
      return;
    }
    if (!_this2.isFeatureApplied(_featureenum2.default.FEATURE_OBJECT3D)) {
      return;
    }
    _this2.braking = false;
    if (_this2.brakingTimer) {
      clearTimeout(_this2.brakingTimer);
      _this2.brakingTimer = null;
    }
    _this2.brakingTimer = setTimeout(function () {
      return _this2.braking = true;
    }, 100);
    _this2.m_drag_x = dxRate * Math.abs(_this2.translateY / -8);
    _this2.m_drag_y = dyRate * Math.abs(_this2.translateY / -8);
    _this2.m_object_3d_rotation[0] = _this2.m_dragged_rotate.get(0);
    _this2.m_object_3d_rotation[1] = _this2.m_dragged_rotate.get(1);
    _this2.m_object_3d_rotation[2] = _this2.m_dragged_rotate.get(2);
  };

  this.dampingMove = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (!_this2.isFeatureApplied(_featureenum2.default.FEATURE_OBJECT3D)) {
      return;
    }
    _this2.m_object_3d_rotation[0] = _this2.m_dragged_rotate.get(0);
    _this2.m_object_3d_rotation[1] = _this2.m_dragged_rotate.get(1);
    _this2.m_object_3d_rotation[2] = _this2.m_dragged_rotate.get(2);
    _this2.damp();
  };

  this.enableAutoRotate = function (x, y) {
    if (!_this2.isPbr()) {
      return;
    }
    _this2.autoRotate = true;
    _this2.autoRotateX = x;
    _this2.autoRotateY = y;
  };

  this.disableAutoRotate = function () {
    return _this2.isPbr() && (_this2.autoRotate = false);
  };

  this.setFullScreen = function () {
    var _ref18 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(fullScreen) {
      var windowScreenWidth, windowScreenHeight, fullScreenWidth, fullScreenHeight, browserDevicePixelRatio, width, height;
      return _regenerator2.default.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (_this2.isPbr()) {
                _context16.next = 2;
                break;
              }

              return _context16.abrupt('return');

            case 2:
              windowScreenWidth = window.screen.width;
              windowScreenHeight = window.screen.height;

              if (!(fullScreen && _browserUtils2.default.isRequestFullscreenSupported(_this2.moduleElement))) {
                _context16.next = 9;
                break;
              }

              _context16.next = 7;
              return _browserUtils2.default.requestFullscreen(_this2.moduleElement);

            case 7:
              _context16.next = 12;
              break;

            case 9:
              if (!_browserUtils2.default.isInFullScreen()) {
                _context16.next = 12;
                break;
              }

              _context16.next = 12;
              return _browserUtils2.default.exitFullscreen(_this2.document);

            case 12:
              fullScreenWidth = window.innerWidth;
              fullScreenHeight = window.innerHeight;
              // Note: Using window.devicePixelRatio will cause problems if the windows dpi has been adjusted

              browserDevicePixelRatio = window.screen.height / window.innerHeight;

              if (_browserUtils2.default.isRequestFullscreenSupported(_this2.moduleElement)) {
                fullScreenWidth = windowScreenWidth / browserDevicePixelRatio;
                fullScreenHeight = windowScreenHeight / browserDevicePixelRatio;
              }
              width = fullScreen ? fullScreenWidth : _this2.original_display_width;
              height = fullScreen ? fullScreenHeight : _this2.original_display_height;

              // viewer

              _this2.resize(width, height);

              // module view
              _this2.settings.displayWidth = width;
              _this2.settings.displayHeight = height;
              _this2.emitter.trigger(_events2.default.sizeChanged, [width, height]);

            case 22:
            case 'end':
              return _context16.stop();
          }
        }
      }, _callee16, _this2);
    }));

    return function (_x39) {
      return _ref18.apply(this, arguments);
    };
  }();

  this.resize = function (width, height) {
    if (!_this2.isPbr()) {
      return;
    }
    var nw = _mathUtils2.default.toEvenNumber(width * _this2.settings.devicePixelRatio);
    var nh = _mathUtils2.default.toEvenNumber(height * _this2.settings.devicePixelRatio);
    _this2.display_width = nw;
    _this2.display_height = nh;

    _this2.renderer.setSize(_this2.display_width, _this2.display_height);
    _this2.makeup_live_filter.ResetWidthHeight(_this2.display_width, _this2.display_height);
    _this2.renderer.domElement.style.width = _mathUtils2.default.toEvenNumber(_this2.display_width / _this2.settings.devicePixelRatio) + 'px';
    _this2.renderer.domElement.style.height = _mathUtils2.default.toEvenNumber(_this2.display_height / _this2.settings.devicePixelRatio) + 'px';
  };

  this.damp = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (_this2.autoRotate) {
      _this2.m_drag_x = _this2.autoRotateX;
      _this2.m_drag_y = _this2.autoRotateY;
    }
    if (_this2.braking) {
      _this2.m_drag_x = _pbrUtils2.default.brake(_this2.m_drag_x);
      _this2.m_drag_y = _pbrUtils2.default.brake(_this2.m_drag_y);
    }
  };

  this.handleMouseWheel = function () {
    var up = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (!_this2.isPbr()) {
      return;
    }
    if (up) {
      _this2.translateY = Math.max(_this2.obj_translate.get(2) - TRANSLATE_Y_PER_WHEEL, _this2.settings.minTranslateYFor3DViewer);
    } else {
      _this2.translateY = Math.min(_this2.obj_translate.get(2) + TRANSLATE_Y_PER_WHEEL, _this2.settings.maxTranslateYFor3DViewer);
    }
  };

  this.allocateResources = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (!_this2.engine_pointer) {
      var t = new _this2.YMKModule.ValObject();
      _this2.YMKModule.CreateVenusLiveObject(_this2.YMKModule.IID_VENUS_MAKEUP_LIVE, t);
      _this2.engine_pointer = t.value;
    }
    _this2.venus_makeup_live = _this2.engine_pointer;

    _this2.object_3d_metadata_buffers = _this2.createObject3DViewerMetadataBuffers();
    _this2.object_3d_metadata = new _this2.YMKModule.WebObject3DViewerMetadata();
    _this2.object_3d_metadata.SetMatrixInputValues(_this2.object_3d_metadata_buffers.p_camera_matrix, _this2.object_3d_metadata_buffers.p_transform_matrices, _this2.object_3d_metadata_buffers.p_normal_matrices);
    _this2.object_3d_metadata.SetWatchTimeComponentTransformMatrixInputValues(_this2.object_3d_metadata_buffers.watch_time_component_buffer);
    _this2.obj_translate = _this2.YMKModule.CreateVector_float(3);
    _this2.obj_rotate = _this2.YMKModule.CreateVector_float(3);
    _this2.obj_scale = _this2.YMKModule.CreateVector_float(3);
    _this2.m_dragged_rotate = _this2.YMKModule.CreateVector_float(3);
    _this2.tz = new _this2.YMKModule.FloatObject();
  };

  this.createObject3DViewerMetadataBuffers = function () {
    if (!_this2.isPbr()) {
      return;
    }
    var sizeof_float = 4;
    var watch_time_component_vector = _this2.YMKModule.CreateVector_WatchTimeComponentTransformMatrices(5);
    for (var i = 0; i < 5; i++) {
      var matrix_buffers = {
        p_second_transform_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_second_normal_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_minute_transform_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_minute_normal_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_hour_transform_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_hour_normal_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_day_transform_matrix: _this2.YMKModule._malloc(sizeof_float * 16),
        p_day_normal_matrix: _this2.YMKModule._malloc(sizeof_float * 16)
      };
      watch_time_component_vector.set(i, matrix_buffers);
    }

    return {
      p_camera_matrix: _this2.YMKModule._malloc(sizeof_float * 9),
      p_transform_matrices: _this2.YMKModule._malloc(sizeof_float * 12),
      p_normal_matrices: _this2.YMKModule._malloc(sizeof_float * 16),
      watch_time_component_buffer: watch_time_component_vector
    };
  };

  this.freeObject3DMetadataBuffers = function (b) {
    if (b.p_camera_matrix) {
      _this2.YMKModule._free(b.p_camera_matrix);
      b.p_camera_matrix = null;
    }
    if (b.p_transform_matrices) {
      _this2.YMKModule._free(b.p_transform_matrices);
      b.p_transform_matrices = null;
    }
    if (b.p_normal_matrices) {
      _this2.YMKModule._free(b.p_normal_matrices);
      b.p_normal_matrices = null;
    }
    if (b.watch_time_component_buffer) {
      for (var i = 0; i < 5; i++) {
        var bb = b.watch_time_component_buffer.get(i);
        _this2.YMKModule._free(bb.p_second_transform_matrix);
        bb.p_second_transform_matrix = null;
        _this2.YMKModule._free(bb.p_second_normal_matrix);
        bb.p_second_normal_matrix = null;
        _this2.YMKModule._free(bb.p_minute_transform_matrix);
        bb.p_minute_transform_matrix = null;
        _this2.YMKModule._free(bb.p_minute_normal_matrix);
        bb.p_minute_normal_matrix = null;
        _this2.YMKModule._free(bb.p_hour_transform_matrix);
        bb.p_hour_transform_matrix = null;
        _this2.YMKModule._free(bb.p_hour_normal_matrix);
        bb.p_hour_normal_matrix = null;
        _this2.YMKModule._free(bb.p_day_transform_matrix);
        bb.p_day_transform_matrix = null;
        _this2.YMKModule._free(bb.p_day_normal_matrix);
        bb.p_day_normal_matrix = null;
      }
      b.watch_time_component_buffer.delete();
      b.watch_time_component_buffer = null;
    }
  };

  this.close = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17() {
    var resolve;
    return _regenerator2.default.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            if (!((0, _get3.default)(_this2, 'source.type') === 'video')) {
              _context17.next = 4;
              break;
            }

            _this2.source && _this2.source.pause && _this2.source.pause();
            _context17.next = 4;
            return _browserUtils2.default.sleep();

          case 4:
            _this2.releaseStream();
            _context17.next = 7;
            return (0, _lockmanager.getLockManager)().createPromise('controller-close');

          case 7:
            resolve = _context17.sent;
            _context17.next = 10;
            return _browserUtils2.default.sleep();

          case 10:
            _context17.prev = 10;

            if (_this2.renderer) {
              _this2.renderer.setSize(1, 1);
              try {
                _this2.renderer.forceContextLoss();
                _this2.renderer.dispose();
                _this2.renderer = null;
              } catch (err) {
                console.log({ err: err });
              }
            }
            (0, _values3.default)(_this2.updaters).map(function (updater) {
              updater && updater.clean && updater.clean();
            });

            _this2.freeResources();

            if (!_this2.source) {
              _context17.next = 19;
              break;
            }

            try {
              if (_this2.source.handTrackingManager) {
                if ((0, _isFunction3.default)(_this2.source.handTrackingManager.close)) {
                  _this2.source.handTrackingManager.close();
                }
              }
            } catch (err) {
              console.log(err);
            }
            _context17.next = 18;
            return _this2.source.freeResources();

          case 18:
            _this2.source = null;

          case 19:
            if (_this2.makeup_live_filter) {
              try {
                (0, _isFunction3.default)(_this2.makeup_live_filter.disposeFilters) && _this2.makeup_live_filter.disposeFilters();
              } catch (err) {
                console.log(err);
              }
              try {
                (0, _isFunction3.default)(_this2.makeup_live_filter.Destroy) && _this2.makeup_live_filter.Destroy();
              } catch (err) {
                console.log(err);
              }
              _this2.makeup_live_filter = null;
            }
            delete _this2.YMKModule;
            _this2.YMKModule = null;

          case 22:
            _context17.prev = 22;

            resolve && resolve();
            return _context17.finish(22);

          case 25:
          case 'end':
            return _context17.stop();
        }
      }
    }, _callee17, _this2, [[10,, 22, 25]]);
  }));

  this.freeResources = function () {
    if (!_this2.isPbr()) {
      return;
    }
    if (_this2.object_3d_metadata_buffers) {
      _this2.freeObject3DMetadataBuffers(_this2.object_3d_metadata_buffers);
      _this2.object_3d_metadata_buffers = null;
    }
    if (_this2.obj_translate) {
      _this2.obj_translate && _this2.obj_translate.delete();
      _this2.obj_translate = null;
    }
    if (_this2.obj_rotate) {
      _this2.obj_rotate && _this2.obj_rotate.delete();
      _this2.obj_rotate = null;
    }
    if (_this2.obj_scale) {
      _this2.obj_scale && _this2.obj_scale.delete();
      _this2.obj_scale = null;
    }
    if (_this2.m_dragged_rotate) {
      _this2.m_dragged_rotate && _this2.m_dragged_rotate.delete();
      _this2.m_dragged_rotate = null;
    }
    if (_this2.videoTexture) {
      delete _this2.videoTexture.image.data;
      delete _this2.videoTexture.image;
      (0, _isFunction3.default)(_this2.videoTexture.dispose) && _this2.videoTexture.dispose();
      _this2.videoTexture = null;
    }
    if (_this2.tz) {
      _this2.tz.delete();
      _this2.tz = null;
    }
    // this.venus_makeup_live = null;
    // this.YMKModule.ReleaseVenusLiveObject(this.engine_pointer);
    // this.engine_pointer.delete();
  };

  this.setHandTrackingManagerLoaderInstance = function (instance) {
    return _this2.handTrackingManagerLoaderInstance = instance;
  };

  this.afterSourceInit4TryOn = function () {
    var _ref20 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(source) {
      var venus_makeup_live;
      return _regenerator2.default.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (!_this2.isPbr()) {
                _context18.next = 2;
                break;
              }

              return _context18.abrupt('return');

            case 2:
              _this2.splitFourWayEnabled = false;
              _this2.fourWayFaceIndex = 0;
              _context18.next = 6;
              return _this2.handTrackingManagerLoaderInstance.getHandTrackingManager(_this2.settings);

            case 6:
              _this2.handTrackingManager = _context18.sent;

              if (source.isChooseModel()) {
                _context18.next = 10;
                break;
              }

              _context18.next = 10;
              return _this2.handTrackingManager.init();

            case 10:
              source.handTrackingManager = _this2.handTrackingManager;
              venus_makeup_live = source.venus_makeup_live;

              _this2.updaters = {
                nail: new _nail2.default(_this2.YMKModule, venus_makeup_live, source, _this2.makeup_live_filter, _this2.document, _this2.settings)
              };
              _this2.reset(null, null, false);
              _this2.skuTypes = {};

            case 15:
            case 'end':
              return _context18.stop();
          }
        }
      }, _callee18, _this2);
    }));

    return function (_x41) {
      return _ref20.apply(this, arguments);
    };
  }();

  this.setFourWayFaceIndex = function (index) {
    return _this2.fourWayFaceIndex = index;
  };

  this.reset4FourWay = function () {
    var _arr = [1, 2, 3];

    for (var _i2 = 0; _i2 < _arr.length; _i2++) {
      var faceIndex = _arr[_i2];
      _this2.reset(null, faceIndex, true);
      _this2.currentEffectsHolder.reset(null, faceIndex, false);
    }
  };

  this.splitFourWay = function () {
    _this2.comparing = false;
    _this2.splitFourWayEnabled = true;
    _this2.reset4FourWay();
    _this2.source && _this2.source.splitFourWay();
  };

  this.splitFourWayOff = function () {
    _this2.comparing = false;
    _this2.splitFourWayEnabled = false;
    _this2.reset4FourWay();
    _this2.source && _this2.source.splitFourWayOff();
  };

  this.compare = function () {
    _this2.comparing = true;
    _this2.splitFourWayEnabled = false;
    _this2.reset(null, 1, false);
    return _this2.source && _this2.source.compare();
  };

  this.compareOff = function () {
    _this2.reset(null, 1, false);
    _this2.comparing = false;
    _this2.splitFourWayEnabled = false;
    _this2.source && _this2.source.compareOff();
    _this2.source.update();
  };

  this.savePhoto = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19() {
    var currentEffects, effects, savePhoto;
    return _regenerator2.default.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            currentEffects = _this2.currentEffectsHolder.get();
            effects = (0, _sortBy3.default)((0, _keys2.default)(currentEffects)).map(function (type) {
              return (0, _extends3.default)({
                type: type
              }, currentEffects[type], {
                info: (0, _isFunction3.default)(_this2.getUpdater(type, 0).getInfo) && _this2.getUpdater(type, 0).getInfo(currentEffects[type].skuItem, currentEffects[type].patternInfo)
              });
            });
            _context19.next = 4;
            return _this2.source.savePhoto();

          case 4:
            savePhoto = _context19.sent;

            if (savePhoto.before) {
              _fileUtils2.default.toBase64(savePhoto.before, function (before) {
                return _fileUtils2.default.toBase64(savePhoto.after, function (after) {
                  _this2.emitter.trigger(_events2.default.savePhotoResult, [(0, _extends3.default)({}, savePhoto, {
                    before: before,
                    after: after,
                    effects: effects
                  })]);
                });
              });
            } else {
              _fileUtils2.default.toBase64(savePhoto.after, function (after) {
                _this2.emitter.trigger(_events2.default.savePhotoResult, [(0, _extends3.default)({}, savePhoto, {
                  after: after,
                  effects: effects
                })]);
              });
            }

          case 6:
          case 'end':
            return _context19.stop();
        }
      }
    }, _callee19, _this2);
  }));

  this.reset = function (skuType, faceIndex) {
    var forceUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (_this2.isPbr()) {
      _this2.m_drag_x = 0;
      _this2.m_drag_y = 0;
      _this2.translateY = DEFAULT_TRANSLATE_Y;
      _this2.setParameterFromSetting();
      return;
    }
    _this2.source.setRingFingerType('');
    if (skuType) {
      _this2.source.m_feature_enable_arrays[0][_this2.getFeature(skuType)] = false;
      _this2.source.m_feature_enable_arrays[1][_this2.getFeature(skuType)] = false;
      _this2.source.m_feature_enable_arrays[2][_this2.getFeature(skuType)] = false;
      _this2.source.m_feature_enable_arrays[3][_this2.getFeature(skuType)] = false;
      _this2.getUpdater(skuType, 0) && _this2.getUpdater(skuType, 0).reset();
      _this2.source.update();
    } else {
      _this2.source.m_feature_enable_arrays = _this2.source.m_feature_enable_arrays || [[], []];
      var features = [];
      for (var i = 0; i < _featureenum2.default.FEATURE_SIZE; i++) {
        if (i === 0) {
          features.push(true);
        } else if (i > _featureenum2.default.FEATURE_SIZE - 3) {
          features.push(_this2.source.m_feature_enable_arrays[0][i] || false);
        } else {
          features.push(false);
        }
      }
      if (faceIndex === 0) {
        _this2.source.m_feature_enable_arrays[0] = [].concat(features);
      } else if (faceIndex === 1) {
        _this2.source.m_feature_enable_arrays[1] = [].concat(features);
      } else if (faceIndex === 2) {
        _this2.source.m_feature_enable_arrays[2] = [].concat(features);
      } else if (faceIndex === 3) {
        _this2.source.m_feature_enable_arrays[3] = [].concat(features);
      } else {
        _this2.source.m_feature_enable_arrays[0] = [].concat(features);
        _this2.source.m_feature_enable_arrays[1] = [].concat(features);
        _this2.source.m_feature_enable_arrays[2] = [].concat(features);
        _this2.source.m_feature_enable_arrays[3] = [].concat(features);
        _this2.applyPreviousMakeup = function (callback) {
          return callback();
        };
      }
      if (forceUpdate) {
        _this2.getUpdater() && _this2.getUpdater().reset && _this2.getUpdater().reset(faceIndex);
        _this2.source.update();
      }
    }
  };

  this._containsNailArt = function (skuItem) {
    if (skuItem.fingers) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator3.default)(skuItem.fingers), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var finger = _step7.value;

          if (finger.nail_design_url) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
    return false;
  };

  this._needToDisableFeature = function (type, skuItem) {
    if (_this2.settings.enableTrackingWhileApplying3DobjectsOnHandAR) {
      return false;
    }
    if (['watch', 'bracelet', 'ring'].includes(type)) {
      return true;
    }
    if (_this2.source && _this2.source.type !== 'video') {
      return false;
    }
    if (type !== 'nail') {
      return false;
    }
    if (!_this2.settings.disableNailsTakePhotoMode && !_browserUtils2.default.isMobile()) {
      return false;
    }
    if (_this2.splitFourWayEnabled) {
      return false;
    }
    return _this2._containsNailArt(skuItem);
  };

  this._applyMakeupBySku = function () {
    var _ref22 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(type, skuGuid, skuItem, patterns, faceIndex) {
      var success;
      return _regenerator2.default.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              if (_this2._needToDisableFeature(type, skuItem)) {
                _this2.source.m_feature_enable_arrays[faceIndex][_this2.getFeature(type)] = false;
                if (_this2.settings.isWristTryonEnableOnRingFeature()) {
                  _this2.source.m_feature_enable_arrays[1][_this2.getFeature(type)] = false;
                }
              }
              _context20.next = 3;
              return _this2.getUpdater(type, faceIndex).update(skuItem, patterns, faceIndex);

            case 3:
              success = _context20.sent;

              if (success) {
                _this2.emitter.trigger(_events2.default.makeupEffectApplied, [type, skuItem, patterns, faceIndex]);
                if (!_this2.settings.isWristTryonEnableOnRingFeature()) {
                  _this2.source.m_feature_enable_arrays[faceIndex][_this2.getFeature(type)] = true;
                } else {
                  _this2.source.m_feature_enable_arrays[0][_this2.getFeature(type)] = type === 'ring' || _this2.source.isRingApplied();
                  _this2.source.m_feature_enable_arrays[1][_this2.getFeature(type)] = type === 'watch' || type === 'bracelet' || _this2.source.isWatchApplied() || _this2.source.isBraceletApplied();
                }
              }

            case 5:
            case 'end':
              return _context20.stop();
          }
        }
      }, _callee20, _this2);
    }));

    return function (_x43, _x44, _x45, _x46, _x47) {
      return _ref22.apply(this, arguments);
    };
  }();

  this.handleCompareMode = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee21() {
    return _regenerator2.default.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            if (!(!_this2.comparing && !_this2.splitFourWayEnabled)) {
              _context21.next = 2;
              break;
            }

            return _context21.abrupt('return');

          case 2:
            if (!(_this2.comparing && _this2.settings.disable2ColorComparison)) {
              _context21.next = 4;
              break;
            }

            return _context21.abrupt('return');

          case 4:
            if (!(_this2.splitFourWayEnabled && _this2.settings.fourWayMode === 'manual')) {
              _context21.next = 6;
              break;
            }

            return _context21.abrupt('return');

          case 6:
            if (!_this2.comparing) {
              _context21.next = 10;
              break;
            }

            _context21.next = 9;
            return _this2.applyMakeupByFaceIndex([1]);

          case 9:
            return _context21.abrupt('return', _context21.sent);

          case 10:
            if (!_this2.splitFourWayEnabled) {
              _context21.next = 14;
              break;
            }

            _context21.next = 13;
            return _this2.applyMakeupByFaceIndex([1, 2, 3]);

          case 13:
            return _context21.abrupt('return', _context21.sent);

          case 14:
          case 'end':
            return _context21.stop();
        }
      }
    }, _callee21, _this2);
  }));

  this.applyMakeupByFaceIndex = function () {
    var _ref24 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee22(faceIndexes) {
      var promises, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, faceIndex, effects, types, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, type, effect;

      return _regenerator2.default.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              promises = [];
              _iteratorNormalCompletion8 = true;
              _didIteratorError8 = false;
              _iteratorError8 = undefined;
              _context22.prev = 4;
              _iterator8 = (0, _getIterator3.default)(faceIndexes);

            case 6:
              if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                _context22.next = 32;
                break;
              }

              faceIndex = _step8.value;
              effects = _this2.currentEffectsHolder.get(faceIndex);
              types = (0, _keys2.default)(effects);
              _iteratorNormalCompletion9 = true;
              _didIteratorError9 = false;
              _iteratorError9 = undefined;
              _context22.prev = 13;

              for (_iterator9 = (0, _getIterator3.default)(types); !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                type = _step9.value;
                effect = effects[type];

                promises.push(_this2.getUpdater(type, faceIndex).update(effect.skuItem, effect.patternInfo, faceIndex));
              }
              _context22.next = 21;
              break;

            case 17:
              _context22.prev = 17;
              _context22.t0 = _context22['catch'](13);
              _didIteratorError9 = true;
              _iteratorError9 = _context22.t0;

            case 21:
              _context22.prev = 21;
              _context22.prev = 22;

              if (!_iteratorNormalCompletion9 && _iterator9.return) {
                _iterator9.return();
              }

            case 24:
              _context22.prev = 24;

              if (!_didIteratorError9) {
                _context22.next = 27;
                break;
              }

              throw _iteratorError9;

            case 27:
              return _context22.finish(24);

            case 28:
              return _context22.finish(21);

            case 29:
              _iteratorNormalCompletion8 = true;
              _context22.next = 6;
              break;

            case 32:
              _context22.next = 38;
              break;

            case 34:
              _context22.prev = 34;
              _context22.t1 = _context22['catch'](4);
              _didIteratorError8 = true;
              _iteratorError8 = _context22.t1;

            case 38:
              _context22.prev = 38;
              _context22.prev = 39;

              if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
              }

            case 41:
              _context22.prev = 41;

              if (!_didIteratorError8) {
                _context22.next = 44;
                break;
              }

              throw _iteratorError8;

            case 44:
              return _context22.finish(41);

            case 45:
              return _context22.finish(38);

            case 46:
              _context22.next = 48;
              return _promise2.default.all(promises);

            case 48:
            case 'end':
              return _context22.stop();
          }
        }
      }, _callee22, _this2, [[4, 34, 38, 46], [13, 17, 21, 29], [22,, 24, 28], [39,, 41, 45]]);
    }));

    return function (_x48) {
      return _ref24.apply(this, arguments);
    };
  }();

  this.getFaceIndex = function () {
    if (!_this2.splitFourWayEnabled) {
      return 0;
    }
    if (_this2.settings.fourWayMode === 'auto') {
      return 0;
    }
    return _this2.fourWayFaceIndex;
  };

  this.applyMakeupBySku = function () {
    var _ref25 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee23(type, skuGuid, skuItem, patterns, callback) {
      return _regenerator2.default.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              if (_this2.isReadyToApply()) {
                _context23.next = 2;
                break;
              }

              return _context23.abrupt('return');

            case 2:
              if (!_this2.updating) {
                _context23.next = 5;
                break;
              }

              callback && callback(false);
              return _context23.abrupt('return', false);

            case 5:
              _this2.updating = true;
              _context23.prev = 6;

              _this2.emitter.trigger(_events2.default.makeupEffectStartToApply);
              _context23.next = 10;
              return _this2._applyMakeupBySku(type, skuGuid, skuItem, patterns, _this2.getFaceIndex());

            case 10:
              _context23.next = 12;
              return _this2.handleCompareMode();

            case 12:
              _this2.source.throttledUpdate && _this2.source.throttledUpdate();

              if (!(_this2.source && _this2.source.isPaused)) {
                _context23.next = 20;
                break;
              }

              _context23.next = 16;
              return _browserUtils2.default.sleep(100);

            case 16:
              _this2.source.throttledUpdate && _this2.source.throttledUpdate();
              _context23.next = 19;
              return _browserUtils2.default.sleep(200);

            case 19:
              _this2.source.throttledUpdate && _this2.source.throttledUpdate();

            case 20:
              callback && callback(true);
              _context23.t0 = _this2.source.saveBlob;

              if (!_context23.t0) {
                _context23.next = 25;
                break;
              }

              _context23.next = 25;
              return _this2.source.saveBlob();

            case 25:
              return _context23.abrupt('return', true);

            case 26:
              _context23.prev = 26;

              _this2.updating = false;
              return _context23.finish(26);

            case 29:
            case 'end':
              return _context23.stop();
          }
        }
      }, _callee23, _this2, [[6,, 26, 29]]);
    }));

    return function (_x49, _x50, _x51, _x52, _x53) {
      return _ref25.apply(this, arguments);
    };
  }();

  this.applyMakeupByLook = function () {
    var _ref26 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee24(lookGuid, lookBuiltInPatterns, effects, callback) {
      return _regenerator2.default.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              if (_this2.isReadyToApply()) {
                _context24.next = 2;
                break;
              }

              return _context24.abrupt('return');

            case 2:
              _this2.emitter.trigger(_events2.default.makeupEffectStartToApply);
              _context24.next = 5;
              return _this2._applyMakeupByLook(lookGuid, lookBuiltInPatterns, effects, callback, _this2.getFaceIndex());

            case 5:
              _context24.next = 7;
              return _this2.handleCompareMode();

            case 7:
              _this2.source.update();

              if (!(_this2.source && _this2.source.isPaused)) {
                _context24.next = 15;
                break;
              }

              _context24.next = 11;
              return _browserUtils2.default.sleep(100);

            case 11:
              _this2.source.throttledUpdate && _this2.source.throttledUpdate();
              _context24.next = 14;
              return _browserUtils2.default.sleep(200);

            case 14:
              _this2.source.throttledUpdate && _this2.source.throttledUpdate();

            case 15:
              _context24.t0 = _this2.source.saveBlob;

              if (!_context24.t0) {
                _context24.next = 19;
                break;
              }

              _context24.next = 19;
              return _this2.source.saveBlob();

            case 19:
              callback && callback();

            case 20:
            case 'end':
              return _context24.stop();
          }
        }
      }, _callee24, _this2);
    }));

    return function (_x54, _x55, _x56, _x57) {
      return _ref26.apply(this, arguments);
    };
  }();

  this._applyMakeupByLook = function () {
    var _ref27 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee25(lookGuid, lookBuiltInPatterns, effects, callback) {
      var faceIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

      var _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, effect, effectType, skuItem, patternInfo, success;

      return _regenerator2.default.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              if (_this2.isRing() && !_this2.settings.enableTrackingWhileApplying3DobjectsOnHandAR) {
                _this2.reset(null, 0, false);
                _this2.reset(null, 1, false);
              }
              _iteratorNormalCompletion10 = true;
              _didIteratorError10 = false;
              _iteratorError10 = undefined;
              _context25.prev = 4;
              _iterator10 = (0, _getIterator3.default)(effects);

            case 6:
              if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                _context25.next = 18;
                break;
              }

              effect = _step10.value;
              effectType = effect.sku_type;
              skuItem = _skuUtils2.default.getSkuItemByEffect(effect);
              patternInfo = _skuUtils2.default.getSkuPatternsByEffect(effect, lookBuiltInPatterns);
              _context25.next = 13;
              return _this2.getUpdater(effectType, faceIndex).update(skuItem, patternInfo, faceIndex);

            case 13:
              success = _context25.sent;

              success && _this2.emitter.trigger(_events2.default.makeupEffectApplied, [effectType, skuItem, patternInfo, faceIndex]);

            case 15:
              _iteratorNormalCompletion10 = true;
              _context25.next = 6;
              break;

            case 18:
              _context25.next = 24;
              break;

            case 20:
              _context25.prev = 20;
              _context25.t0 = _context25['catch'](4);
              _didIteratorError10 = true;
              _iteratorError10 = _context25.t0;

            case 24:
              _context25.prev = 24;
              _context25.prev = 25;

              if (!_iteratorNormalCompletion10 && _iterator10.return) {
                _iterator10.return();
              }

            case 27:
              _context25.prev = 27;

              if (!_didIteratorError10) {
                _context25.next = 30;
                break;
              }

              throw _iteratorError10;

            case 30:
              return _context25.finish(27);

            case 31:
              return _context25.finish(24);

            case 32:
              if (_this2.isRing() && _this2.source.isWristTryonEnableOnRingFeature()) {
                _this2.source.m_feature_enable_arrays[0][_featureenum2.default.FEATURE_OBJECT3D] = _this2._containsSkuType(effects, ['ring']);
                _this2.source.m_feature_enable_arrays[1][_featureenum2.default.FEATURE_OBJECT3D] = _this2._containsSkuType(effects, ['watch', 'bracelet']);
              } else {
                _this2.source.m_feature_enable_arrays[faceIndex][_featureenum2.default.FEATURE_OBJECT3D] = true;
              }

            case 33:
            case 'end':
              return _context25.stop();
          }
        }
      }, _callee25, _this2, [[4, 20, 24, 32], [25,, 27, 31]]);
    }));

    return function (_x58, _x59, _x60, _x61) {
      return _ref27.apply(this, arguments);
    };
  }();

  this._containsSkuType = function (effects, skuTypes) {
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = (0, _getIterator3.default)(effects), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var effect = _step11.value;

        if (skuTypes.includes(effect.sku_type)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11.return) {
          _iterator11.return();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }

    return false;
  };

  this.setZoomRatio = function (zoomRatio) {
    if (!_this2.isReadyToApply()) {
      return;
    }
    if ((0, _isFunction3.default)(_this2.source.setZoomRatio)) {
      _this2.source.setZoomRatio(zoomRatio);
    }
  };

  this.handleHandFingerSwitch = function (handOrFinger) {
    if (!_this2.isReadyToApply()) {
      return;
    }
    if ((0, _isFunction3.default)(_this2.source.handleHandFingerSwitch)) {
      _this2.source.handleHandFingerSwitch(handOrFinger);
    }
  };

  this.handleRingFingerTypeChanged = function (ringFingerType) {
    return _this2.source.handleRingFingerTypeChanged && _this2.source.handleRingFingerTypeChanged(ringFingerType);
  };

  this.isPbr = function () {
    return _this2.settings.isPbr();
  };

  this.isRing = function () {
    return _this2.settings.isRing();
  };

  this.isWrist = function () {
    return _this2.settings.isWatch();
  };

  this.isNail = function () {
    return _this2.settings.isNail();
  };

  this.isLoaded = function () {
    if (_this2.isPbr()) {
      return _this2.loaded;
    }
    return _this2.source && _this2.source.loaded;
  };

  this.handRingFingTypeChange = function (ringFingerType) {
    if (!_this2.source) {
      return;
    }
    (0, _isFunction3.default)(_this2.source.setRingFingerType) && _this2.source.setRingFingerType(ringFingerType);
  };

  this.createWebGLRenderer = function () {
    return new _three.WebGLRenderer();
  };
}, _temp);
exports.default = NailController;

var INSTANCE = null;
var newInstance = function newInstance(args) {
  if (!INSTANCE) {
    INSTANCE = new NailController(args);
  }
  INSTANCE.setArgs(args);
  return INSTANCE;
};
exports.newInstance = newInstance;

/***/ }),

/***/ 705:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryIdCount", function() { return GeometryIdCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return _Math; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MorphBlendMesh", function() { return MorphBlendMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexNormalsHelper", function() { return VertexNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLightHelper", function() { return RectAreaLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceNormalsHelper", function() { return FaceNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projector", function() { return Projector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

if ( Number.isInteger === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

	Number.isInteger = function ( value ) {

		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

	};

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

var REVISION = '86';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function generateUUID() {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Object.defineProperties( Vector2.prototype, {

	"width" : {

		get: function () {

			return this.x;

		},

		set: function ( value ) {

			this.x = value;

		}

	},

	"height" : {

		get: function () {

			return this.y;

		},

		set: function ( value ) {

			this.y = value;

		}

	}

} );

Object.assign( Vector2.prototype, {

	isVector2: true,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min = new Vector2();
		var max = new Vector2();

		return function clampScalar( minVal, maxVal ) {

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) angle += 2 * Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Object.defineProperty( Texture.prototype, "needsUpdate", {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( Texture.prototype, EventDispatcher.prototype, {

	constructor: Texture,

	isTexture: true,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

} );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Object.assign( Vector4.prototype, {

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector4();
				max = new Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

} );

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.uuid = _Math.generateUUID();

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com
 */

function WebGLRenderTargetCube( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	this.activeMipMapLevel = 0;

}

WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this.onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this.onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this.onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this.onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// assumes direction vectors vFrom and vTo are normalized

		var v1 = new Vector3();
		var r;

		var EPS = 0.000001;

		return function setFromUnitVectors( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			return this.normalize();

		};

	}(),

	inverse: function () {

		return this.conjugate().normalize();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion = new Quaternion();

		return function applyEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

		};

	}(),

	applyAxisAngle: function () {

		var quaternion = new Quaternion();

		return function applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix = new Matrix4();

		return function project( camera ) {

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyMatrix4( matrix );

		};

	}(),

	unproject: function () {

		var matrix = new Matrix4();

		return function unproject( camera ) {

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyMatrix4( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min = new Vector3();
		var max = new Vector3();

		return function clampScalar( minVal, maxVal ) {

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( vector ) {

		var scalar = vector.dot( this ) / vector.lengthSq();

		return this.copy( vector ).multiplyScalar( scalar );

	},

	projectOnPlane: function () {

		var v1 = new Vector3();

		return function projectOnPlane( planeNormal ) {

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1 = new Vector3();

		return function reflect( normal ) {

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		this.x = c.radius * Math.sin( c.theta );
		this.y = c.y;
		this.z = c.radius * Math.cos( c.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1 = new Vector3();

		return function extractRotation( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q._x, y = q._y, z = q._z, w = q._w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x = new Vector3();
		var y = new Vector3();
		var z = new Vector3();

		return function lookAt( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target );

			if ( z.lengthSq() === 0 ) {

				// eye and target are in the same position

				z.z = 1;

			}

			z.normalize();
			x.crossVectors( up, z );

			if ( x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					z.x += 0.0001;

				} else {

					z.z += 0.0001;

				}

				z.normalize();
				x.crossVectors( up, z );

			}

			x.normalize();
			y.crossVectors( z, x );

			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToBufferAttribute: function () {

		var v1 = new Vector3();

		return function applyToBufferAttribute( attribute ) {

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix4( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new Vector3();
		var matrix = new Matrix4();

		return function decompose( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			matrix.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author tschw
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();

// --- Base for inner nodes (including the root) ---

function UniformContainer() {

	this.seq = [];
	this.map = {};

}

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array( 16 );
var mat3array = new Float32Array( 9 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

// Texture unit allocation

function allocTexUnits( renderer, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		r[ i ] = renderer.allocTextureUnit();

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

// Single float vector (from flat array or THREE.VectorN)

function setValue2fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
	else gl.uniform2f( this.addr, v.x, v.y );

}

function setValue3fv( gl, v ) {

	if ( v.x !== undefined )
		gl.uniform3f( this.addr, v.x, v.y, v.z );
	else if ( v.r !== undefined )
		gl.uniform3f( this.addr, v.r, v.g, v.b );
	else
		gl.uniform3fv( this.addr, v );

}

function setValue4fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

}

// Single matrix (from flat array or MatrixN)

function setValue2fm( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

}

function setValue3fm( gl, v ) {

	if ( v.elements === undefined ) {

		gl.uniformMatrix3fv( this.addr, false, v );

	} else {

		mat3array.set( v.elements );
		gl.uniformMatrix3fv( this.addr, false, mat3array );

	}

}

function setValue4fm( gl, v ) {

	if ( v.elements === undefined ) {

		gl.uniformMatrix4fv( this.addr, false, v );

	} else {

		mat4array.set( v.elements );
		gl.uniformMatrix4fv( this.addr, false, mat4array );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTexture2D( v || emptyTexture, unit );

}

function setValueT6( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1f; // FLOAT
		case 0x8b50: return setValue2fv; // _VEC2
		case 0x8b51: return setValue3fv; // _VEC3
		case 0x8b52: return setValue4fv; // _VEC4

		case 0x8b5a: return setValue2fm; // _MAT2
		case 0x8b5b: return setValue3fm; // _MAT3
		case 0x8b5c: return setValue4fm; // _MAT4

		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
		case 0x8b60: return setValueT6; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// Array of scalars

function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

// Array of vectors (flat or from THREE classes)

function setValueV2a( gl, v ) {

	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

}

function setValueV3a( gl, v ) {

	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

}

function setValueV4a( gl, v ) {

	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

}

// Array of matrices (flat or from THREE clases)

function setValueM2a( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

}

function setValueM3a( gl, v ) {

	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

}

function setValueM4a( gl, v ) {

	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

}

// Array of textures (2D / Cube)

function setValueT1a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1fv; // FLOAT
		case 0x8b50: return setValueV2a; // _VEC2
		case 0x8b51: return setValueV3a; // _VEC3
		case 0x8b52: return setValueV4a; // _VEC4

		case 0x8b5a: return setValueM2a; // _MAT2
		case 0x8b5b: return setValueM3a; // _MAT3
		case 0x8b5c: return setValueM4a; // _MAT4

		case 0x8b5e: return setValueT1a; // SAMPLER_2D
		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function StructuredUniform( id ) {

	this.id = id;

	UniformContainer.call( this ); // mix-in

}

StructuredUniform.prototype.setValue = function ( gl, value ) {

	// Note: Don't need an extra 'renderer' parameter, since samplers
	// are not allowed in structured uniforms.

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ] );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	for ( ; ; ) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			var map = container.map, next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program, renderer ) {

	UniformContainer.call( this );

	this.renderer = renderer;

	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			path = info.name,
			addr = gl.getUniformLocation( program, path );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, renderer );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

Object.assign( Color.prototype, {

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = _Math.euclideanModulo( h, 1 );
			s = _Math.clamp( s, 0, 1 );
			l = _Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

} );

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

		specularMap: { value: null },
		alphaMap: { value: null },

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

	}

};

/**
 * Uniform Utilities
 */

var UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src && ( parameter_src.isColor ||
					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
					parameter_src.isTexture ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "\nvec3 transformed = vec3( position );\n";

var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";

var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars: lights_pars,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_template: lights_template,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_flip: normal_flip,
	normal_fragment: normal_fragment,
	normalmap_pars_fragment: normalmap_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert
};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0.5 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	points: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	equirect: {

		uniforms: {
			tEquirect: { value: null },
			tFlip: { value: - 1 }
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: {
			lightPos: { value: new Vector3() }
		},

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	}

};

ShaderLib.physical = {

	uniforms: UniformsUtils.merge( [
		ShaderLib.standard.uniforms,
		{
			clearCoat: { value: 0 },
			clearCoatRoughness: { value: 0 }
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author bhouston / http://clara.io
 */

function Box2( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

}

Object.assign( Box2.prototype, {

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector2();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector2();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlarePlugin( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		shader = {

			vertexShader: [

				"uniform lowp int renderType;",

				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",

				"uniform sampler2D occlusionMap;",

				"attribute vec2 position;",
				"attribute vec2 uv;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",

						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform lowp int renderType;",

				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

						"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",

					"}",

				"}"

			].join( "\n" )

		};

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewport ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new Vector3();

		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;

		var size = 16 / viewport.w,
			scale = new Vector2( size * invAspect, size );

		var screenPosition = new Vector3( 1, 1, 0 ),
			screenPositionPixels = new Vector2( 1, 1 );

		var validArea = new Box2();

		validArea.min.set( viewport.x, viewport.y );
		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		state.buffers.depth.setMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewport.w;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyMatrix4( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

			// screen cull

			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewport.w;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture2D( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.buffers.depth.setMask( true );

		renderer.resetGLState();

	};

	function createProgram( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

}

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function SpritePlugin( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new Vector3();
	var spriteRotation = new Quaternion();
	var spriteScale = new Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog.isFog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog.isFogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			if ( material.visible === false ) continue;

			sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
			state.buffers.depth.setTest( material.depthTest );
			state.buffers.depth.setMask( material.depthWrite );

			if ( material.map ) {

				renderer.setTexture2D( material.map, 0 );

			} else {

				renderer.setTexture2D( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram() {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'#define SHADER_NAME ' + 'SpriteMaterial',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'#define SHADER_NAME ' + 'SpriteMaterial',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

}

Object.assign( Material.prototype, EventDispatcher.prototype, {

	isMaterial: true,

	onBeforeCompile: function () {},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = meta === undefined;

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
		if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();

		}
		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.shading !== SmoothShading ) data.shading = this.shading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		data.skinning = this.skinning;
		data.morphTargets = this.morphTargets;

		data.dithering = this.dithering;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.shading = source.shading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;

		this.premultipliedAlpha = source.premultipliedAlpha;

		this.overdraw = source.overdraw;

		this.visible = source.visible;
		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = UniformsUtils.clone( source.uniforms );

	this.defines = source.defines;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}

Object.assign( Box3.prototype, {

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector3();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	expandByObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new Vector3();

		return function expandByObject( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			object.traverse( function ( node ) {

				var i, l;

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			} );

			return this;

		};

	}(),

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: ( function () {

		var closestPoint = new Vector3();

		return function intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= plane.constant && max >= plane.constant );

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector3();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new Vector3();

		return function getBoundingSphere( optionalTarget ) {

			var result = optionalTarget || new Sphere();

			this.getCenter( result.center );

			result.radius = this.getSize( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];

		return function applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

}

Object.assign( Sphere.prototype, {

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new Box3();

		return function setFromPoints( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).getCenter( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		// We use the following equation to compute the signed distance from
		// the center of the sphere to the plane.
		//
		// distance = q * n - d
		//
		// If this distance is greater than the radius of the sphere,
		// then there is no intersection.

		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new Vector3();

		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[  8 ],
			me[ 1 ], me[ 5 ], me[  9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToBufferAttribute: function () {

		var v1 = new Vector3();

		return function applyToBufferAttribute( attribute ) {

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix3( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );

/**
 * @author bhouston / http://clara.io
 */

function Plane( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Object.assign( Plane.prototype, {

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function setFromCoplanarPoints( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	intersectLine: function () {

		var v1 = new Vector3();

		return function intersectLine( line, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new Vector3();
		var m1 = new Matrix3();

		return function applyMatrix4( matrix, optionalNormalMatrix ) {

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			// transform normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			// recalculate constant (like in setFromNormalAndCoplanarPoint)
			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Object.assign( Frustum.prototype, {

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new Sphere();

		return function intersectsObject( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSprite: function () {

		var sphere = new Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new Vector3(),
			p2 = new Vector3();

		return function intersectsBox( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),

	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

	var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new Frustum(),
		_projScreenMatrix = new Matrix4(),

		_lightShadows = _lights.shadows,

		_shadowMapSize = new Vector2(),
		_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

		_lookTarget = new Vector3(),
		_lightPositionWorld = new Vector3(),

		_MorphingFlag = 1,
		_SkinningFlag = 2,

		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants ),

		_materialCache = {};

	var cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new Vector4(), new Vector4(), new Vector4(),
		new Vector4(), new Vector4(), new Vector4()
	];

	// init

	var depthMaterialTemplate = new MeshDepthMaterial();
	depthMaterialTemplate.depthPacking = RGBADepthPacking;
	depthMaterialTemplate.clipping = true;

	var distanceShader = ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = depthMaterialTemplate.clone();
		depthMaterial.morphTargets = useMorphing;
		depthMaterial.skinning = useSkinning;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new ShaderMaterial( {
			defines: {
				'USE_SHADOWMAP': ''
			},
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning,
			clipping: true
		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.renderReverseSided = true;
	this.renderSingleSided = true;

	this.render = function ( scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( _lightShadows.length === 0 ) return;

		// Set GL state for depth map.
		_state.disable( _gl.BLEND );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount;

		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

			var light = _lightShadows[ i ];
			var shadow = light.shadow;
			var isPointLight = light && light.isPointLight;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );
			_shadowMapSize.min( _maxShadowMapSize );

			if ( isPointLight ) {

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow.isSpotLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			if ( isPointLight ) {

				faceCount = 6;

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position

				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			} else {

				faceCount = 1;

				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _lookTarget );
				shadowCamera.updateMatrixWorld();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			}

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				}

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				renderObject( scene, camera, shadowCamera, isPointLight );

			}

		}

		// Restore GL state.
		var clearColor = _renderer.getClearColor();
		var clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = false;

			if ( material.morphTargets ) {

				if ( geometry && geometry.isBufferGeometry ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				} else if ( geometry && geometry.isGeometry ) {

					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

				}

			}

			if ( object.isSkinnedMesh && material.skinning === false ) {

				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

			}

			var useSkinning = object.isSkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		var side = material.side;

		if ( scope.renderSingleSided && side == DoubleSide ) {

			side = FrontSide;

		}

		if ( scope.renderReverseSided ) {

			if ( side === FrontSide ) side = BackSide;
			else if ( side === BackSide ) side = FrontSide;

		}

		result.side = side;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

			result.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, isPointLight ) {

		if ( object.visible === false ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				var geometry = _objects.update( object );
				var material = object.material;

				if ( Array.isArray( material ) ) {

					var groups = geometry.groups;

					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

						var group = groups[ k ];
						var groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, isPointLight );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAttributes( gl ) {

	var buffers = {};

	function createBuffer( attribute, bufferType ) {

		var array = attribute.array;
		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		var buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		var type = gl.FLOAT;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		var array = attribute.array;
		var updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( attribute.dynamic === false ) {

			gl.bufferData( bufferType, array, gl.STATIC_DRAW );

		} else if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else if ( updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			updateRange.count = -1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers[ attribute.uuid ];

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
		
		var data = buffers[ attribute.uuid ];

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			delete buffers[ attribute.uuid ];

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		var data = buffers[ attribute.uuid ];

		if ( data === undefined ) {

			buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this.onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this.onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this.onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this.onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix = new Matrix4();

		return function setFromQuaternion( q, order, update ) {

			matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( matrix, order, update );

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new Quaternion();

		return function reorder( newOrder ) {

			q.setFromEuler( this );

			return this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {

	Object.defineProperty( this, 'id', { value: object3DId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};
}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object.assign( Object3D.prototype, EventDispatcher.prototype, {

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new Quaternion();

		return function rotateOnAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function rotateX( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function rotateY( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function rotateZ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new Vector3();

		return function translateOnAxis( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function translateX( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function translateY( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function translateZ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new Matrix4();

		return function worldToLocal( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This method does not support objects with rotated and/or translated parent(s)

		var m1 = new Matrix4();

		return function lookAt( vector ) {

			if ( this.isCamera ) {

				m1.lookAt( this.position, vector, this.up );

			} else {

				m1.lookAt( vector, this.position, this.up );

			}

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

		return this;
		
	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new Vector3();
		var scale = new Vector3();

		return function getWorldQuaternion( optionalTarget ) {

			var result = optionalTarget || new Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new Quaternion();

		return function getWorldRotation( optionalTarget ) {

			var result = optionalTarget || new Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new Vector3();
		var quaternion = new Quaternion();

		return function getWorldScale( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new Quaternion();

		return function getWorldDirection( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		// meta is '' when called from JSON.stringify
		var isRootObject = ( meta === undefined || meta === '' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.geometry !== undefined ) {

			object.geometry = serialize( meta.geometries, this.geometry );

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();
	this.projectionMatrix = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );

		return this;

	},

	getWorldDirection: function () {

		var quaternion = new Quaternion();

		return function getWorldDirection( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		};

	}(),

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null ) {

			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;

			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( view !== null ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = ( color && color.isColor ) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Object.assign( Face3.prototype, {

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var count = 0;
function GeometryIdCount() { return count++; }

function Geometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( Geometry.prototype, EventDispatcher.prototype, {

	isGeometry: true,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1 = new Matrix4();

		return function rotateX( angle ) {

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1 = new Matrix4();

		return function rotateY( angle ) {

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1 = new Matrix4();

		return function rotateZ( angle ) {

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1 = new Matrix4();

		return function translate( x, y, z ) {

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1 = new Matrix4();

		return function scale( x, y, z ) {

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj = new Object3D();

		return function lookAt( vector ) {

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		}

		var groups = geometry.groups;

		if ( groups.length > 0 ) {

			for ( var i = 0; i < groups.length; i ++ ) {

				var group = groups[ i ];

				var start = group.start;
				var count = group.count;

				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

					if ( indices !== undefined ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

					} else {

						addFace( j, j + 1, j + 2, group.materialIndex );

					}

				}

			}

		} else {

			if ( indices !== undefined ) {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			} else {

				for ( var i = 0; i < positions.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( ! ( geometry && geometry.isGeometry ) ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ],
			colors1 = this.colors,
			colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ! ( mesh && mesh.isMesh ) ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		var i, il, j, jl, k, kl;

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		var vertices = source.vertices;

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		var colors = source.colors;

		for ( i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		var faces = source.faces;

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		var morphTargets = source.morphTargets;

		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		var morphNormals = source.morphNormals;

		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

			var morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		var skinWeights = source.skinWeights;

		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		var skinIndices = source.skinIndices;

		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		var lineDistances = source.lineDistances;

		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.uuid = _Math.generateUUID();
	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

} );

//

function Int8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	}

} );

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	var max = array[ 0 ];

	for ( var i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

}

BufferGeometry.MaxIndex = 65535;

Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

	},

	addAttribute: function ( name, attribute ) {

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToBufferAttribute( position );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToBufferAttribute( normal );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1 = new Matrix4();

		return function rotateX( angle ) {

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1 = new Matrix4();

		return function rotateY( angle ) {

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1 = new Matrix4();

		return function rotateZ( angle ) {

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1 = new Matrix4();

		return function translate( x, y, z ) {

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1 = new Matrix4();

		return function scale( x, y, z ) {

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj = new Object3D();

		return function lookAt( vector ) {

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new Box3();
		var vector = new Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;

			if ( position ) {

				var center = this.boundingSphere.center;

				box.setFromBufferAttribute( position );
				box.getCenter( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = position.count; i < il; i ++ ) {

					vector.x = position.getX( i );
					vector.y = position.getY( i );
					vector.z = position.getZ( i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal;

		var x, y, z, n;

		for ( var i = 0, il = normals.count; i < il; i ++ ) {

			x = normals.getX( i );
			y = normals.getY( i );
			z = normals.getZ( i );

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals.setXYZ( i, x * n, y * n, z * n );

		}

	},

	toNonIndexed: function () {

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var name, i, l;

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// index

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		var attributes = source.attributes;

		for ( name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		// morph attributes

		var morphAttributes = source.morphAttributes;

		for ( name in morphAttributes ) {

			var array = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone() );

			}

			this.morphAttributes[ name ] = array;

		}

		// groups

		var groups = source.groups;

		for ( i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// BoxGeometry

function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

}

BoxGeometry.prototype = Object.create( Geometry.prototype );
BoxGeometry.prototype.constructor = BoxGeometry;

// BoxBufferGeometry

function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	// segments

	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var numberOfVertices = 0;
	var groupStart = 0;

	// build each side of the box geometry

	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth = width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var ix, iy;

		var vector = new Vector3();

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component

				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer

				vertices.push( vector.x, vector.y, vector.z );

				// set values to correct vector component

				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer

				normals.push( vector.x, vector.y, vector.z );

				// uvs

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

				// counters

				vertexCounter += 1;

			}

		}

		// indices

		// 1. you need three indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// increase counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups

		groupStart += groupCount;

		// update total number of vertices

		numberOfVertices += vertexCounter;

	}

}

BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// PlaneGeometry

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	this.mergeVertices();

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

// PlaneBufferGeometry

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices.push( x, - y, 0 );

			normals.push( 0, 0, 1 );

			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );

		}

	}

	// indices

	for ( iy = 0; iy < gridY; iy ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3();

}

Object.assign( Ray.prototype, {

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function () {

		var v1 = new Vector3();

		return function recast( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new Vector3();

		return function distanceSqToPoint( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new Vector3();
		var segDir = new Vector3();
		var diff = new Vector3();

		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new Vector3();

		return function intersectSphere( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},

	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, optionalTarget ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectsBox: ( function () {

		var v = new Vector3();

		return function intersectsBox( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new Vector3();
		var edge1 = new Vector3();
		var edge2 = new Vector3();
		var normal = new Vector3();

		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

function Line3( start, end ) {

	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();

}

Object.assign( Line3.prototype, {

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new Vector3();
		var startEnd = new Vector3();

		return function closestPointToPointParameter( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = _Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Object.assign( Triangle, {

	normal: function () {

		var v0 = new Vector3();

		return function normal( a, b, c, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}(),

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	barycoordFromPoint: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();
		var v2 = new Vector3();

		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new Vector3();

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}(),

	containsPoint: function () {

		var v1 = new Vector3();

		return function containsPoint( point, a, b, c ) {

			var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}()

} );

Object.assign( Triangle.prototype, {

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();

		return function area() {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	closestPointToPoint: function () {

		var plane = new Plane();
		var edgeList = [ new Line3(), new Line3(), new Line3() ];
		var projectedPoint = new Vector3();
		var closestPoint = new Vector3();

		return function closestPointToPoint( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();
			var minDistance = Infinity;

			// project the point onto the plane of the triangle

			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );

			// check if the projection lies within the triangle

			if( this.containsPoint( projectedPoint ) === true ) {

				// if so, this is the closest point

				result.copy( projectedPoint );

			} else {

				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );

				for( var i = 0; i < edgeList.length; i ++ ) {

					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

					var distance = projectedPoint.distanceToSquared( closestPoint );

					if( distance < minDistance ) {

						minDistance = distance;

						result.copy( closestPoint );

					}

				}

			}

			return result;

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = TrianglesDrawMode;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	setDrawMode: function ( value ) {

		this.drawMode = value;

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.drawMode = source.drawMode;

		return this;

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

					name = morphTargets[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	},

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		var vA = new Vector3();
		var vB = new Vector3();
		var vC = new Vector3();

		var tempA = new Vector3();
		var tempB = new Vector3();
		var tempC = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		var barycoord = new Vector3();

		var intersectionPoint = new Vector3();
		var intersectionPointWorld = new Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

			var intersect;
			var material = object.material;

			if ( material.side === BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

			}

			if ( intersect === null ) return null;

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

			vA.fromBufferAttribute( position, a );
			vB.fromBufferAttribute( position, b );
			vC.fromBufferAttribute( position, c );

			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uv ) {

					uvA.fromBufferAttribute( uv, a );
					uvB.fromBufferAttribute( uv, b );
					uvC.fromBufferAttribute( uv, c );

					intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

				}

				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			var intersection;

			if ( geometry.isBufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var position = geometry.attributes.position;
				var uv = geometry.attributes.uv;
				var i, l;

				if ( index !== null ) {

					// indexed buffer geometry

					for ( i = 0, l = index.count; i < l; i += 3 ) {

						a = index.getX( i );
						b = index.getX( i + 1 );
						c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );

						}

					}

				} else {

					// non-indexed buffer geometry

					for ( i = 0, l = position.count; i < l; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

						if ( intersection ) {

							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				var fvA, fvB, fvC;
				var isMultiMaterial = Array.isArray( material );

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;

				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs && uvs[ f ] ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

	var clearColor = new Color( 0x000000 );
	var clearAlpha = 0;

	var planeCamera, planeMesh;
	var boxCamera, boxMesh;

	function render( scene, camera, forceClear ) {

		var background = scene.background;

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && background.isCubeTexture ) {

			if ( boxCamera === undefined ) {

				boxCamera = new PerspectiveCamera();

				boxMesh = new Mesh(
					new BoxBufferGeometry( 5, 5, 5 ),
					new ShaderMaterial( {
						uniforms: ShaderLib.cube.uniforms,
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

			}

			boxCamera.projectionMatrix.copy( camera.projectionMatrix );

			boxCamera.matrixWorld.extractRotation( camera.matrixWorld );
			boxCamera.matrixWorldInverse.getInverse( boxCamera.matrixWorld );

			boxMesh.material.uniforms[ "tCube" ].value = background;
			boxMesh.modelViewMatrix.multiplyMatrices( boxCamera.matrixWorldInverse, boxMesh.matrixWorld );

			objects.update( boxMesh );

			renderer.renderBufferDirect( boxCamera, null, boxMesh.geometry, boxMesh.material, boxMesh, null );

		} else if ( background && background.isTexture ) {

			if ( planeCamera === undefined ) {

				planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
				);

			}

			planeMesh.material.map = background;

			objects.update( planeMesh );

			renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha ) {

			clearColor.set( color );
			clearAlpha = alpha !== undefined ? alpha : 1;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function painterSortStable( a, b ) {

	if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program && b.program && a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}

function WebGLRenderList() {

	var opaque = [];
	var opaqueLastIndex = - 1;

	var transparent = [];
	var transparentLastIndex = - 1;

	function init() {

		opaqueLastIndex = - 1;
		transparentLastIndex = - 1;

	}

	function push( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparent;
			index = ++ transparentLastIndex;

		} else {

			array = opaque;
			index = ++ opaqueLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	function finish() {

		opaque.length = opaqueLastIndex + 1;
		transparent.length = transparentLastIndex + 1;

	}

	function sort() {

		opaque.sort( painterSortStable );
		transparent.sort( reversePainterSortStable );

	}

	return {
		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	var lists = {};

	function get( scene, camera ) {

		var hash = scene.id + ',' + camera.id;
		var list = lists[ hash ];

		if ( list === undefined ) {

			// console.log( 'THREE.WebGLRenderLists:', hash );

			list = new WebGLRenderList();
			lists[ hash ] = list;

		}

		return list;

	}

	function dispose() {

		lists = {};

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		if ( position.isInterleavedBufferAttribute ) {

			count = position.data.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		} else {

			extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

		}

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, attributes, infoMemory ) {

	var geometries = {};
	var wireframeAttributes = {};

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			attributes.remove( buffergeometry.index );

		}

		for ( var name in buffergeometry.attributes ) {

			attributes.remove( buffergeometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		// TODO Remove duplicate code

		var attribute = wireframeAttributes[ geometry.id ];

		if ( attribute ) {

			attributes.remove( attribute );
			delete wireframeAttributes[ geometry.id ];

		}

		attribute = wireframeAttributes[ buffergeometry.id ];

		if ( attribute ) {

			attributes.remove( attribute );
			delete wireframeAttributes[ buffergeometry.id ];

		}

		//

		infoMemory.geometries --;

	}

	function get( object, geometry ) {

		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry ) return buffergeometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		if ( geometry.isBufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry.isGeometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		infoMemory.geometries ++;

		return buffergeometry;

	}

	function update( geometry ) {

		var index = geometry.index;
		var geometryAttributes = geometry.attributes;

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], gl.ARRAY_BUFFER );

			}

		}

	}

	function getWireframeAttribute( geometry ) {

		var attribute = wireframeAttributes[ geometry.id ];

		if ( attribute ) return attribute;

		var indices = [];

		var geometryIndex = geometry.index;
		var geometryAttributes = geometry.attributes;

		// console.time( 'wireframe' );

		if ( geometryIndex !== null ) {

			var array = geometryIndex.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = geometryAttributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

		wireframeAttributes[ geometry.id ] = attribute;

		return attribute;

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLLights() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
						// TODO (abelnation): set RectAreaLight shadow uniforms
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( gl, geometries, infoRender ) {

	var updateList = {};

	function update( object ) {

		var frame = infoRender.frame;

		var geometry = object.geometry;
		var buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateList[ buffergeometry.id ] !== frame ) {

			if ( geometry.isGeometry ) {

				buffergeometry.updateFromObject( object );

			}

			geometries.update( buffergeometry );

			updateList[ buffergeometry.id ] = frame;

		}

		return buffergeometry;

	}

	function clear() {

		updateList = {};

	}

	return {

		update: update,
		clear: clear

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

	}

	if ( gl.getShaderInfoLog( shader ) !== '' ) {

		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

	}

	// --enable-privileged-webgl-extension
	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear','( value )' ];
		case sRGBEncoding:
			return [ 'sRGB','( value )' ];
		case RGBEEncoding:
			return [ 'RGBE','( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM','( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM','( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD','( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = "Linear";
			break;

		case ReinhardToneMapping:
			toneMappingName = "Reinhard";
			break;

		case Uncharted2ToneMapping:
			toneMappingName = "Uncharted2";
			break;

		case CineonToneMapping:
			toneMappingName = "OptimizedCineon";
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

}

function generateExtensions( extensions, parameters, rendererExtensions ) {

	extensions = extensions || {};

	var chunks = [
		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program, identifiers ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

}

function parseIncludes( string ) {

	var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

	function replace( match, include ) {

		var replace = ShaderChunk[ include ];

		if ( replace === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return parseIncludes( replace );

	}

	return string.replace( pattern, replace );

}

function unrollLoops( string ) {

	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function replace( match, start, end, snippet ) {

		var unroll = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

		}

		return unroll;

	}

	return string.replace( pattern, replace );

}

function WebGLProgram( renderer, code, material, shader, parameters ) {

	var gl = renderer.context;

	var extensions = material.extensions;
	var defines = material.defines;

	var vertexShader = shader.vertexShader;
	var fragmentShader = shader.fragmentShader;

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	}

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

	if ( parameters.envMap ) {

		switch ( material.envMap.mapping ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

		switch ( material.envMap.mapping ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

		switch ( material.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	// console.log( 'building new program ' );

	//

	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

	var customDefines = generateDefines( defines );

	//

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( material.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,
			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	} else {

		prefixVertex = [

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + shader.name,

			customDefines,

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + shader.name,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
			'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',

			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = parseIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );

	fragmentShader = parseIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );

	if ( ! material.isShaderMaterial ) {

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( material.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, material.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	var programLog = gl.getProgramInfoLog( program );
	var vertexLog = gl.getShaderInfoLog( glVertexShader );
	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

	var runnable = true;
	var haveDiagnostics = true;

	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

		runnable = false;

		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

	} else if ( programLog !== '' ) {

		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

	} else if ( vertexLog === '' || fragmentLog === '' ) {

		haveDiagnostics = false;

	}

	if ( haveDiagnostics ) {

		this.diagnostics = {

			runnable: runnable,
			material: material,

			programLog: programLog,

			vertexShader: {

				log: vertexLog,
				prefix: prefixVertex

			},

			fragmentShader: {

				log: fragmentLog,
				prefix: prefixFragment

			}

		};

	}

	// clean up

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function() {

		if ( cachedUniforms === undefined ) {

			cachedUniforms =
				new WebGLUniforms( gl, program, renderer );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function() {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function() {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	// DEPRECATED

	Object.defineProperties( this, {

		uniforms: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
				return this.getUniforms();

			}
		},

		attributes: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
				return this.getAttributes();

			}
		}

	} );


	//

	this.id = programIdCount ++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
	];


	function allocateBones( object ) {

		var skeleton = object.skeleton;
		var bones = skeleton.bones;

		if ( capabilities.floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

			encoding = GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var currentRenderTarget = renderer.getRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: !! fog,
			useFog: material.fog,
			fogExp: ( fog && fog.isFogExp2 ),

			flatShading: material.shading === FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		array.push( material.onBeforeCompile.toString() );

		array.push( renderer.gammaOutput );

		return array.join();

	};

	this.acquireProgram = function ( material, shader, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, code, material, shader, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function ( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, infoMemory ) {

	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

	//

	function clampToMaxSize( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = _Math.nearestPowerOfTwo( image.width );
			canvas.height = _Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function textureNeedsPowerOfTwo( texture ) {

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

		return texture.generateMipmaps && isPowerOfTwo &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		infoMemory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

		}

		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );

	}

	//



	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = ( texture && texture.isCompressedTexture );
				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

		var extension;

		if ( isPowerOfTwoImage ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

			image = makePowerOfTwo( image );

		}

		var isPowerOfTwoImage = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			var internalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === FloatType ) {

				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
				internalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( _isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				internalFormat = _gl.DEPTH_COMPONENT16;

			}

			if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

				        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = paramThreeToGL( texture.type );

				}

			}

			// Depth stencil textures need the DEPTH_STENCIL internal format
			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
			if ( texture.format === DepthStencilFormat ) {

				internalFormat = _gl.DEPTH_STENCIL;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = paramThreeToGL( texture.type );

				}

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = paramThreeToGL( renderTarget.texture.format );
		var glType = paramThreeToGL( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			// FIXME: We don't support !depth !stencil
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

		}

		// upload an empty depth texture with framebuffer size
		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else {

			throw new Error('Unknown depthTexture format')

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		infoMemory.textures ++;

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

		if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );

		}

	}

	this.setTexture2D = setTexture2D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = {};

	function get( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	}

	function remove( object ) {

		delete properties[ object.uuid ];

	}

	function clear() {

		properties = {};

	}

	return {
		get: get,
		remove: remove,
		clear: clear
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, paramThreeToGL ) {

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4();

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( 0, 0, 0, 1 );

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

					} else {

						gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( stencilTest ) {

					enable( gl.STENCIL_TEST );

				} else {

					disable( gl.STENCIL_TEST );

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var currentScissorTest = null;

	var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
	var lineWidthAvailable = parseFloat( version ) >= 1.0;

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	//

	function init() {

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

	}

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function enable( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	}

	function getCompressedTextureFormats() {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	}

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending !== NoBlending ) {

			enable( gl.BLEND );

		} else {

			disable( gl.BLEND );

		}

		if ( ( blending !== CustomBlending ) && ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) ) {

			if ( blending === AdditiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				}

			} else if ( blending === SubtractiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				}

			} else if ( blending === MultiplyBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				}

			} else {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		if ( blending === CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	}

	function setMaterial( material ) {

		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		setFlipSided( material.side === BackSide );

		material.transparent === true
			? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
			: setBlending( NoBlending );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function getScissorTest() {

		return currentScissorTest;

	}

	function setScissorTest( scissorTest ) {

		currentScissorTest = scissorTest;

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		init: init,
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,
		getCompressedTextureFormats: getCompressedTextureFormats,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		getScissorTest: getScissorTest,
		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	return {

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera( array ) {

	PerspectiveCamera.call( this );

	this.cameras = array || [];

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebVRManager( renderer ) {

	var scope = this;

	var device = null;
	var frameData = null;

	if ( 'VRFrameData' in window ) {

		frameData = new window.VRFrameData();

	}

	var matrixWorldInverse = new Matrix4();

	var standingMatrix = new Matrix4();
	var standingMatrixInverse = new Matrix4();

	var cameraL = new PerspectiveCamera();
	cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
	cameraL.layers.enable( 1 );

	var cameraR = new PerspectiveCamera();
	cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
	cameraR.layers.enable( 2 );

	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	//

	var currentSize, currentPixelRatio;

	function onVRDisplayPresentChange() {

		if ( device.isPresenting ) {

			var eyeParameters = device.getEyeParameters( 'left' );
			var renderWidth = eyeParameters.renderWidth;
			var renderHeight = eyeParameters.renderHeight;

			currentPixelRatio = renderer.getPixelRatio();
			currentSize = renderer.getSize();

			renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

		} else if ( scope.enabled ) {

			renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

		}

	}

	window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

	//

	this.enabled = false;
	this.standing = false;

	this.getDevice = function () {

		return device;

	};

	this.setDevice = function ( value ) {

		if ( value !== undefined ) device = value;

	};

	this.getCamera = function ( camera ) {

		if ( device === null ) return camera;

		device.depthNear = camera.near;
		device.depthFar = camera.far;

		device.getFrameData( frameData );

		//

		var pose = frameData.pose;

		if ( pose.position !== null ) {

			camera.position.fromArray( pose.position );

		} else {

			camera.position.set( 0, 0, 0 );

		}

		if ( pose.orientation !== null ) {

			camera.quaternion.fromArray( pose.orientation );

		}

		camera.updateMatrixWorld();

		var stageParameters = device.stageParameters;

		if ( this.standing && stageParameters ) {

			standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
			standingMatrixInverse.getInverse( standingMatrix );

			camera.matrixWorld.multiply( standingMatrix );
			camera.matrixWorldInverse.multiply( standingMatrixInverse );

		}

		if ( device.isPresenting === false ) return camera;

		//

		cameraVR.matrixWorld.copy( camera.matrixWorld );
		cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

		if ( this.standing && stageParameters ) {

			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

		}

		var parent = camera.parent;

		if ( parent !== null ) {

			matrixWorldInverse.getInverse( parent.matrixWorld );

			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

		}

		// envMap and Mirror needs camera.matrixWorld

		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

		// HACK @mrdoob
		// https://github.com/w3c/webvr/issues/203

		cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		//

		var layers = device.getLayers();

		if ( layers.length ) {

			var layer = layers[ 0 ];

			if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

				cameraL.bounds.fromArray( layer.leftBounds );

			}

			if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

				cameraR.bounds.fromArray( layer.rightBounds );

			}

		}

		return cameraVR;

	};

	this.getStandingMatrix = function () {

		return standingMatrix;

	};

	this.submitFrame = function () {

		if ( device && device.isPresenting ) device.submitFrame();

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function() {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function() {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled ||
				planes === null || planes.length === 0 ||
				renderingShadows && ! clipShadows ) {
			// there's no local clipping

			if ( renderingShadows ) {
				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();
			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset;
									i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).
							applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		
		return dstArray;

	}

}

// import { Sphere } from '../math/Sphere';
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	console.log( 'THREE.WebGLRenderer', REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

	var lights = [];

	var currentRenderList = null;

	var morphInfluences = new Float32Array( 8 );

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',

		_currentCamera = null,
		_currentArrayCamera = null,

		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		_currentViewport = new Vector4(),

		//

		_usedTextureUnits = 0,

		//

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,

		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		_viewport = new Vector4( 0, 0, _width, _height ),

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3(),
		_matrix4 = new Matrix4(),
		_matrix42 = new Matrix4(),

		// light arrays cache

		_lights = {

			hash: '',

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],

			shadows: []

		},

		// info

		_infoMemory = {
			geometries: 0,
			textures: 0
		},

		_infoRender = {

			frame: 0,
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

	this.info = {

		render: _infoRender,
		memory: _infoMemory,
		programs: null

	};


	// initialize

	var _gl;

	try {

		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new WebGLExtensions( _gl );

	extensions.get( 'WEBGL_depth_texture' );
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

	var state = new WebGLState( _gl, extensions, paramThreeToGL );

	var properties = new WebGLProperties();
	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory );
	var attributes = new WebGLAttributes( _gl );
	var geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
	var objects = new WebGLObjects( _gl, geometries, _infoRender );
	var programCache = new WebGLPrograms( this, capabilities );
	var lightCache = new WebGLLights();
	var renderLists = new WebGLRenderLists();

	var background = new WebGLBackground( this, state, objects, _premultipliedAlpha );
	var vr = new WebVRManager( this );

	this.info.programs = programCache.programs;

	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	function setDefaultGLState() {

		state.init();

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.properties = properties;
	this.renderLists = renderLists;
	this.state = state;
	this.vr = vr;

	// shadow map

	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new SpritePlugin( this, sprites );
	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.getMaxAnisotropy = function () {

		return capabilities.getMaxAnisotropy();

	};

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		var device = vr.getDevice();

		if ( device && device.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function () {

		return {
			width: _width * _pixelRatio,
			height: _height * _pixelRatio
		};

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewport.set( x, _height - y - height, width, height );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		_scissor.set( x, _height - y - height, width, height );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = background.getClearColor;
	this.setClearColor = background.setClearColor;
	this.getClearAlpha = background.getClearAlpha;
	this.setClearAlpha = background.setClearAlpha;

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

		renderLists.dispose();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();
		objects.clear();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program, material ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program, material );

		} );

	}

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( ! material.isMeshPhongMaterial &&
				! material.isMeshStandardMaterial &&
				! material.isMeshNormalMaterial &&
				material.shading === FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.normal );

			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.color );

			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

	}

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		state.setMaterial( material );

		var program = setProgram( camera, fog, material, object );
		var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

		var updateBuffers = false;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			// TODO Remove allocations

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( absNumericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

				morphInfluences[ i ] = 0.0;

			}

			program.getUniforms().setValue( _gl, 'morphTargetInfluences', morphInfluences );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;
		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var attribute;
		var renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

			}

		}

		//

		var dataCount = 0;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( _gl.LINES );

			} else if ( object.isLineLoop ) {

				renderer.setMode( _gl.LINE_LOOP );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( _gl.POINTS );

		}

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attribute = attributes.get( geometryAttribute );

					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Compile

	this.compile = function ( scene, camera ) {

		lights = [];

		scene.traverse( function ( object ) {

			if ( object.isLight ) {

				lights.push( object );

			}

		} );

		setupLights( lights, camera );

		scene.traverse( function ( object ) {

			if ( object.material ) {

				if ( Array.isArray( object.material ) ) {

					for ( var i = 0; i < object.material.length; i ++ ) {

						initMaterial( object.material[ i ], scene.fog, object );

					}

				} else {

					initMaterial( object.material, scene.fog, object );

				}

			}

		} );

	};

	// Rendering

	this.animate = function ( callback ) {

		function onFrame() {

			callback();

			( vr.getDevice() || window ).requestAnimationFrame( onFrame );

		}

		( vr.getDevice() || window ).requestAnimationFrame( onFrame );

	};

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( ! ( camera && camera.isCamera ) ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( vr.enabled ) {

			camera = vr.getCamera( camera );

		}

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;
		sprites.length = 0;
		lensFlares.length = 0;

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();

		projectObject( scene, camera, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort();

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		setupShadows( lights );

		shadowMap.render( scene, camera );

		setupLights( lights, camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		_infoRender.frame ++;
		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		//

		background.render( scene, camera, forceClear );

		// render scene

		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

			// transparent pass (back-to-front order)

			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentViewport );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			textures.updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		if ( camera.isArrayCamera ) {

			_this.setScissorTest( false );

		}

		if ( vr.enabled ) {

			vr.submitFrame();

		}

		// _gl.finish();

	};

	/*
	// TODO Duplicated code (Frustum)

	var _sphere = new Sphere();

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).
		applyMatrix4( object.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSpriteViewable( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSphereViewable( sphere ) {

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

		var numPlanes = _clipping.numPlanes;

		if ( numPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== numPlanes );

		return true;

	}
	*/

	function projectObject( object, camera, sortObjects ) {

		if ( ! object.visible ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isLight ) {

				lights.push( object );

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					sprites.push( object );

				}

			} else if ( object.isLensFlare ) {

				lensFlares.push( object );

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					object.skeleton.update();

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var i = 0, l = groups.length; i < l; i ++ ) {

							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, _vector3.z, null );

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			if ( camera.isArrayCamera ) {

				_currentArrayCamera = camera;

				var cameras = camera.cameras;

				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

					var camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						var bounds = camera2.bounds;

						var x = bounds.x * _width;
						var y = bounds.y * _height;
						var width = bounds.z * _width;
						var height = bounds.w * _height;

						_this.setViewport( x, y, width, height );
						_this.setScissor( x, y, width, height );
						_this.setScissorTest( true );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				_currentArrayCamera = null;

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		if ( object.isImmediateRenderObject ) {

			state.setMaterial( material );

			var program = setProgram( camera, scene.fog, material, object );

			_currentGeometryProgram = '';

			renderObjectImmediate( object, program, material );

		} else {

			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters(
			material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = ShaderLib[ parameters.shaderID ];

				materialProperties.shader = {
					name: material.type,
					uniforms: UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.shader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.onBeforeCompile( materialProperties.shader );

			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var programAttributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.shader.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.fog = fog;

		// store the light setup it was created for

		materialProperties.lightsHash = _lights.hash;

		if ( material.lights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = _lights.ambient;
			uniforms.directionalLights.value = _lights.directional;
			uniforms.spotLights.value = _lights.spot;
			uniforms.rectAreaLights.value = _lights.rectArea;
			uniforms.pointLights.value = _lights.point;
			uniforms.hemisphereLights.value = _lights.hemi;

			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
			uniforms.spotShadowMap.value = _lights.spotShadowMap;
			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
			uniforms.pointShadowMap.value = _lights.pointShadowMap;
			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.needsUpdate === false ) {

			if ( materialProperties.program === undefined ) {

				material.needsUpdate = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				material.needsUpdate = true;

			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

				material.needsUpdate = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

				material.needsUpdate = true;

			}

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.shader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			// Avoid unneeded uniform updates per ArrayCamera's sub-camera

			if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

				_currentCamera = ( _currentArrayCamera || camera );

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				var bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === undefined ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = _Math.nextPowerOfTwo( Math.ceil( size ) );
						size = Math.max( size, 4 );

						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

			if ( material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshBasicMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.isMeshNormalMaterial ||
				material.isMeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material.isLineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsToon( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsStandard( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				if ( material.displacementMap ) {

					m_uniforms.displacementMap.value = material.displacementMap;
					m_uniforms.displacementScale.value = material.displacementScale;
					m_uniforms.displacementBias.value = material.displacementBias;

				}

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsNormal( m_uniforms, material );

			}

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
			if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

			WebGLUniforms.upload(
				_gl, materialProperties.uniformsList, m_uniforms, _this );

		}


		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;

		// don't flip CubeTexture envMaps, flip everything else:
		//  WebGLRenderTargetCube will be flipped for backwards compatibility
		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		refreshUniformsPhong( uniforms, material );

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		refreshUniformsStandard( uniforms, material );

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Lighting

	function setupShadows( lights ) {

		var lightShadowsLength = 0;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			if ( light.castShadow ) {

				_lights.shadows[ lightShadowsLength ] = light;
				lightShadowsLength ++;

			}

		}

		_lights.shadows.length = lightShadowsLength;

	}

	function setupLights( lights, camera ) {

		var l, ll, light, shadow,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
			shadowMap,

			viewMatrix = camera.matrixWorldInverse,

			directionalLength = 0,
			pointLength = 0,
			spotLength = 0,
			rectAreaLength = 0,
			hemiLength = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isDirectionalLight ) {

				var uniforms = lightCache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;

				}

				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				_lights.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;

				}

				_lights.spotShadowMap[ spotLength ] = shadowMap;
				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				_lights.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				var uniforms = lightCache.get( light );

				// (a) intensity controls irradiance of entire light
				uniforms.color
					.copy( color )
					.multiplyScalar( intensity / ( light.width * light.height ) );

				// (b) intensity controls the radiance per light area
				// uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				_matrix42.identity();
				_matrix4.copy( light.matrixWorld );
				_matrix4.premultiply( viewMatrix );
				_matrix42.extractRotation( _matrix4 );

				uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
				uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( _matrix42 );
				uniforms.halfHeight.applyMatrix4( _matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				_lights.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;

				}

				_lights.pointShadowMap[ pointLength ] = shadowMap;
				_lights.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
				_lights.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				var uniforms = lightCache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				_lights.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		_lights.ambient[ 0 ] = r;
		_lights.ambient[ 1 ] = g;
		_lights.ambient[ 2 ] = b;

		_lights.directional.length = directionalLength;
		_lights.spot.length = spotLength;
		_lights.rectArea.length = rectAreaLength;
		_lights.point.length = pointLength;
		_lights.hemi.length = hemiLength;

		// TODO (sam-g-steel) why aren't we using join
		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		state.setCullFace( cullFace );
		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

	};

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	this.allocTextureUnit = allocTextureUnit;

	// this.setTexture2D = setTexture2D;
	this.setTexture2D = ( function () {

		var warned = false;

		// backwards compatibility: peel texture.texture
		return function setTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTexture = ( function () {

		var warned = false;

		return function setTexture( texture, slot ) {

			if ( ! warned ) {

				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTextureCube = ( function () {

		var warned = false;

		return function setTextureCube( texture, slot ) {

			// backwards compatibility: peel texture.texture
			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				textures.setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube

				textures.setTextureCubeDynamic( texture, slot );

			}

		};

	}() );

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		var framebuffer;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

			_currentViewport.copy( renderTarget.viewport );

		} else {

			framebuffer = null;

			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		state.viewport( _currentViewport );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL( p ) {

		var extension;

		if ( p === RepeatWrapping ) return _gl.REPEAT;
		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === NearestFilter ) return _gl.NEAREST;
		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === LinearFilter ) return _gl.LINEAR;
		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === ByteType ) return _gl.BYTE;
		if ( p === ShortType ) return _gl.SHORT;
		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === IntType ) return _gl.INT;
		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === FloatType ) return _gl.FLOAT;

		if ( p === HalfFloatType ) {

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) return extension.HALF_FLOAT_OES;

		}

		if ( p === AlphaFormat ) return _gl.ALPHA;
		if ( p === RGBFormat ) return _gl.RGB;
		if ( p === RGBAFormat ) return _gl.RGBA;
		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

		if ( p === AddEquation ) return _gl.FUNC_ADD;
		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === ZeroFactor ) return _gl.ZERO;
		if ( p === OneFactor ) return _gl.ONE;
		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === DstColorFactor ) return _gl.DST_COLOR;
		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

		}

		if ( p === MinEquation || p === MaxEquation ) {

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === MinEquation ) return extension.MIN_EXT;
				if ( p === MaxEquation ) return extension.MAX_EXT;

			}

		}

		if ( p === UnsignedInt248Type ) {

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

		}

		return 0;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2 ( color, density ) {

	this.name = '';

	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

}

FogExp2.prototype.isFogExp2 = true;

FogExp2.prototype.clone = function () {

	return new FogExp2( this.color.getHex(), this.density );

};

FogExp2.prototype.toJSON = function ( meta ) {

	return {
		type: 'FogExp2',
		color: this.color.getHex(),
		density: this.density
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog ( color, near, far ) {

	this.name = '';

	this.color = new Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

}

Fog.prototype.isFog = true;

Fog.prototype.clone = function () {

	return new Fog( this.color.getHex(), this.near, this.far );

};

Fog.prototype.toJSON = function ( meta ) {

	return {
		type: 'Fog',
		color: this.color.getHex(),
		near: this.near,
		far: this.far
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene () {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

}

Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Scene,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlare( texture, size, distance, blending, color ) {

	Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

}

LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LensFlare,

	isLensFlare: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	},

	add: function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new Color( 0xffffff );
		if ( blending === undefined ) blending = NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	},

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	updateLensFlares: function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2()
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: ( function () {

		var intersectPoint = new Vector3();
		var worldPosition = new Vector3();
		var worldScale = new Vector3();

		return function raycast( raycaster, intersects ) {

			worldPosition.setFromMatrixPosition( this.matrixWorld );
			raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

			worldScale.setFromMatrixScale( this.matrixWorld );
			var guessSizeSq = worldScale.x * worldScale.y / 4;

			if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;

			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				point: intersectPoint.clone(),
				face: null,
				object: this

			} );

		};

	}() ),

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function LOD() {

	Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

}

LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	},

	raycast: ( function () {

		var matrixPosition = new Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() ),

	update: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}(),

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

function Skeleton( bones, boneInverses ) {

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );
	this.boneMatrices = new Float32Array( this.bones.length * 16 );

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.getInverse( this.bones[ i ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone, i, il;

		// recover the bind-time world matrices

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ i ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: ( function () {

		var offsetMatrix = new Matrix4();
		var identityMatrix = new Matrix4();

		return function update() {

			var bones = this.bones;
			var boneInverses = this.boneInverses;
			var boneMatrices = this.boneMatrices;
			var boneTexture = this.boneTexture;

			// flatten bone matrices to array

			for ( var i = 0, il = bones.length; i < il; i ++ ) {

				// compute the offset between the current and the original transform

				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
				offsetMatrix.toArray( boneMatrices, i * 16 );

			}

			if ( boneTexture !== undefined ) {

				boneTexture.needsUpdate = true;

			}

		};

	} )(),

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

	var bones = this.initBones();
	var skeleton = new Skeleton( bones );

	this.bind( skeleton, this.matrixWorld );

	this.normalizeSkinWeights();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	initBones: function () {

		var bones = [], bone, gbone;
		var i, il;

		if ( this.geometry && this.geometry.bones !== undefined ) {

			// first, create array of 'Bone' objects from geometry data

			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

				gbone = this.geometry.bones[ i ];

				// create new 'Bone' object

				bone = new Bone();
				bones.push( bone );

				// apply values

				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

			}

			// second, create bone hierarchy

			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

				gbone = this.geometry.bones[ i ];

				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

					// subsequent bones in the hierarchy

					bones[ gbone.parent ].add( bones[ i ] );

				} else {

					// topmost bone, immediate child of the skinned mesh

					this.add( bones[ i ] );

				}

			}

		}

		// now the bones are part of the scene graph and children of the skinned mesh.
		// let's update the corresponding matrices

		this.updateMatrixWorld( true );

		return bones;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		var scale, i;

		if ( this.geometry && this.geometry.isGeometry ) {

			for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1, 0, 0, 0 ); // do something reasonable

				}

			}

		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

			var vec = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( i = 0; i < skinWeight.count; i ++ ) {

				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );

				scale = 1.0 / vec.lengthManhattan();

				if ( scale !== Infinity ) {

					vec.multiplyScalar( scale );

				} else {

					vec.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

			}

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new LineSegments( geometry, material );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = (this && this.isLineSegments) ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true

} );

/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineLoop';

}

LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineLoop,

	isLineLoop: true,

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.lights = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

}

VideoTexture.prototype = Object.create( Texture.prototype );
VideoTexture.prototype.constructor = VideoTexture;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps	= false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry( geometry ) {

	BufferGeometry.call( this );

	this.type = 'WireframeGeometry';

	// buffer

	var vertices = [];

	// helper variables

	var i, j, l, o, ol;
	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];
	var vertex;

	// different logic for Geometry and BufferGeometry

	if ( geometry && geometry.isGeometry ) {

		// create a data structure that contains all edges without duplicates

		var faces = geometry.faces;

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			e = edges[ key ];

			vertex = geometry.vertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = geometry.vertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	} else if ( geometry && geometry.isBufferGeometry ) {

		var position, indices, groups;
		var group, start, count;
		var index1, index2;

		vertex = new Vector3();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			position = geometry.attributes.position;
			indices = geometry.index;
			groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

				group = groups[ o ];

				start = group.start;
				count = group.count;

				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( j = 0; j < 3; j ++ ) {

						edge1 = indices.getX( i + j );
						edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			position = geometry.attributes.position;

			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

	}

	// build geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

// ParametricGeometry

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

// ParametricBufferGeometry

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	var EPS = 0.00001;

	var normal = new Vector3();

	var p0 = new Vector3(), p1 = new Vector3();
	var pu = new Vector3(), pv = new Vector3();

	var i, j;

	// generate vertices, normals and uvs

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		var v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			var u = j / slices;

			// vertex

			p0 = func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				p1 = func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				p1 = func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				p1 = func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				p1 = func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			var a = i * sliceCount + j;
			var b = i * sliceCount + j + 1;
			var c = ( i + 1 ) * sliceCount + j + 1;
			var d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

// PolyhedronGeometry

function PolyhedronGeometry( vertices, indices, radius, detail ) {

	Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();

}

PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

// PolyhedronBufferGeometry

function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

	BufferGeometry.call( this );

	this.type = 'PolyhedronBufferGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	// default buffer data

	var vertexBuffer = [];
	var uvBuffer = [];

	// the subdivision creates the vertex buffer data

	subdivide( detail );

	// all vertices should lie on a conceptual sphere with a given radius

	appplyRadius( radius );

	// finally, create the uv data

	generateUVs();

	// build non-indexed geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

	if ( detail === 0 ) {

		this.computeVertexNormals(); // flat normals

	} else {

		this.normalizeNormals(); // smooth normals

	}

	// helper functions

	function subdivide( detail ) {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		// iterate over all faces and apply a subdivison with the given detail value

		for ( var i = 0; i < indices.length; i += 3 ) {

			// get the vertices of the face

			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );

			// perform subdivision

			subdivideFace( a, b, c, detail );

		}

	}

	function subdivideFace( a, b, c, detail ) {

		var cols = Math.pow( 2, detail );

		// we use this multidimensional array as a data structure for creating the subdivision

		var v = [];

		var i, j;

		// construct all of the vertices for this subdivision

		for ( i = 0; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );

			var rows = cols - i;

			for ( j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

				}

			}

		}

		// construct all of the faces

		for ( i = 0; i < cols; i ++ ) {

			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );

				} else {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );

				}

			}

		}

	}

	function appplyRadius( radius ) {

		var vertex = new Vector3();

		// iterate over the entire buffer and apply the radius to each vertex

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			vertex.normalize().multiplyScalar( radius );

			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;

		}

	}

	function generateUVs() {

		var vertex = new Vector3();

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );

		}

		correctUVs();

		correctSeam();

	}

	function correctSeam() {

		// handle case when face straddles the seam, see #3269

		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

			// uv data of a single face

			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			// 0.9 is somewhat arbitrary

			if ( max > 0.9 && min < 0.1 ) {

				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

			}

		}

	}

	function pushVertex( vertex ) {

		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

	}

	function getVertexByIndex( index, vertex ) {

		var stride = index * 3;

		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];

	}

	function correctUVs() {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		var centroid = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

			var azi = azimuth( centroid );

			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );

		}

	}

	function correctUV( uv, stride, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

			uvBuffer[ stride ] = uv.x - 1;

		}

		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

		}

	}

	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

}

PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// TetrahedronGeometry

function TetrahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

// TetrahedronBufferGeometry

function TetrahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// OctahedronGeometry

function OctahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;

// OctahedronBufferGeometry

function OctahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// IcosahedronGeometry

function IcosahedronGeometry( radius, detail ) {

 	Geometry.call( this );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

// IcosahedronBufferGeometry

function IcosahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// DodecahedronGeometry

function DodecahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

// DodecahedronBufferGeometry

function DodecahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		  1, - 1, - 1,     1, - 1,  1,
		  1,  1, - 1,     1,  1,  1,

		// (0, 1/, )
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (1/, , 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (, 0, 1/)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */

// TubeGeometry

function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

	Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

	// expose internals

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	// create geometry

	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();

}

TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;

// TubeBufferGeometry

function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

	BufferGeometry.call( this );

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames( tubularSegments, closed );

	// expose internals

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	// helper variables

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();

	var i, j;

	// buffer

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	// create buffer data

	generateBufferData();

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// functions

	function generateBufferData() {

		for ( i = 0; i < tubularSegments; i ++ ) {

			generateSegment( i );

		}

		// if the geometry is not closed, generate the last row of vertices and normals
		// at the regular position on the given path
		//
		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

		generateSegment( ( closed === false ) ? tubularSegments : 0 );

		// uvs are generated in a separate function.
		// this makes it easy compute correct values for closed geometries

		generateUVs();

		// finally create faces

		generateIndices();

	}

	function generateSegment( i ) {

		// we use getPointAt to sample evenly distributed points from the given path

		var P = path.getPointAt( i / tubularSegments );

		// retrieve corresponding normal and binormal

		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];

		// generate normals and vertices for the current segment

		for ( j = 0; j <= radialSegments; j ++ ) {

			var v = j / radialSegments * Math.PI * 2;

			var sin =   Math.sin( v );
			var cos = - Math.cos( v );

			// normal

			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();

			normals.push( normal.x, normal.y, normal.z );

			// vertex

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	function generateIndices() {

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

	}

	function generateUVs() {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			for ( j = 0; j <= radialSegments; j ++ ) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push( uv.x, uv.y );

			}

		}

	}

}

TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */

// TorusKnotGeometry

function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

}

TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

// TorusKnotBufferGeometry

function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

	BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 100;
	tube = tube || 40;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, j;

	var vertex = new Vector3();
	var normal = new Vector3();

	var P1 = new Vector3();
	var P2 = new Vector3();

	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

			normal.subVectors( vertex, P1 ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices

			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

}

TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// TorusGeometry

function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	this.mergeVertices();

}

TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;

// TorusBufferGeometry

function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex

			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );
			normal.subVectors( vertex, center ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function triangulate( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function removeDupEndPts(points) {

			var l = points.length;

			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

				points.pop();

			}

		}

		removeDupEndPts( contour );
		holes.forEach( removeDupEndPts );

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *  frames: <Object> // containing arrays of tangents, normals, binormals
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

// ExtrudeGeometry

function ExtrudeGeometry( shapes, options ) {

	Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	this.parameters = {
		shapes: shapes,
		options: options
	};

	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
	this.mergeVertices();

}

ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

// ExtrudeBufferGeometry

function ExtrudeBufferGeometry( shapes, options ) {

	if ( typeof ( shapes ) === "undefined" ) {

		return;

	}

	BufferGeometry.call( this );

	this.type = 'ExtrudeBufferGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeVertexNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

}

ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.getArrays = function () {

	var positionAttribute = this.getAttribute( "position" );
	var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

	var uvAttribute = this.getAttribute( "uv" );
	var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

	var IndexAttribute = this.index;
	var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

	return {
		position: verticesArray,
		uv: uvArray,
		index: indicesArray
	};

};

ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;
	options.arrays = this.getArrays();

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

	this.setIndex( options.arrays.index );
	this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

};

ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {

	var arrays = options.arrays ? options.arrays : this.getArrays();
	var verticesArray = arrays.position;
	var indicesArray = arrays.index;
	var uvArray = arrays.uv;

	var placeholder = [];


	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new Vector3();
		normal = new Vector3();
		position2 = new Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

	}


	var faces = ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x,
			v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x,
			v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
					( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
				( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return new Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false; // assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y = v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [],
		oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y, - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y, - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y, amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		var start = verticesArray.length/3;

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

		scope.addGroup( start, verticesArray.length/3 -start, options.material !== undefined ? options.material : 0);

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var start = verticesArray.length/3;
		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}


		scope.addGroup( start, verticesArray.length/3 -start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);


	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0,
				sl = steps + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}

	function v( x, y, z ) {

		placeholder.push( x );
		placeholder.push( y );
		placeholder.push( z );

	}


	function f3( a, b, c ) {

		addVertex( a );
		addVertex( b );
		addVertex( c );

		var nextIndex = verticesArray.length / 3;
		var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

		addUV( uvs[ 0 ] );
		addUV( uvs[ 1 ] );
		addUV( uvs[ 2 ] );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		addVertex( a );
		addVertex( b );
		addVertex( d );

		addVertex( b );
		addVertex( c );
		addVertex( d );


		var nextIndex = verticesArray.length / 3;
		var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

		addUV( uvs[ 0 ] );
		addUV( uvs[ 1 ] );
		addUV( uvs[ 3 ] );

		addUV( uvs[ 1 ] );
		addUV( uvs[ 2 ] );
		addUV( uvs[ 3 ] );

	}

	function addVertex( index ) {

		indicesArray.push( verticesArray.length / 3 );
		verticesArray.push( placeholder[ index * 3 + 0 ] );
		verticesArray.push( placeholder[ index * 3 + 1 ] );
		verticesArray.push( placeholder[ index * 3 + 2 ] );

	}


	function addUV( vector2 ) {

		uvArray.push( vector2.x );
		uvArray.push( vector2.y );

	}

	if ( ! options.arrays ) {

		this.setIndex( indicesArray );
		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

	}

};

ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var a_z = vertices[ indexA * 3 + 2 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var b_z = vertices[ indexB * 3 + 2 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];
		var c_z = vertices[ indexC * 3 + 2 ];
		var d_x = vertices[ indexD * 3 ];
		var d_y = vertices[ indexD * 3 + 1 ];
		var d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}
};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */

// TextGeometry

function TextGeometry(  text, parameters ) {

	Geometry.call( this );

	this.type = 'TextGeometry';

	this.parameters = {
		text: text,
		parameters: parameters
	};

	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
	this.mergeVertices();

}

TextGeometry.prototype = Object.create( Geometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;

// TextBufferGeometry

function TextBufferGeometry( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( ! ( font && font.isFont ) ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	ExtrudeBufferGeometry.call( this, shapes, parameters );

	this.type = 'TextBufferGeometry';

}

TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
TextBufferGeometry.prototype.constructor = TextBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

// SphereGeometry

function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	this.mergeVertices();

}

SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;

// SphereBufferGeometry

function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var ix, iy;

	var index = 0;
	var grid = [];

	var vertex = new Vector3();
	var normal = new Vector3();

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy <= heightSegments; iy ++ ) {

		var verticesRow = [];

		var v = iy / heightSegments;

		for ( ix = 0; ix <= widthSegments; ix ++ ) {

			var u = ix / widthSegments;

			// vertex

			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, 1 - v );

			verticesRow.push( index ++ );

		}

		grid.push( verticesRow );

	}

	// indices

	for ( iy = 0; iy < heightSegments; iy ++ ) {

		for ( ix = 0; ix < widthSegments; ix ++ ) {

			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];

			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */

// RingGeometry

function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;

// RingBufferGeometry

function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 20;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// some helper variables

	var segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			// values are generate from the inside of the ring to the outside

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uv

			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// increase the radius for next row of vertices

		radius += radiusStep;

	}

	// indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */

// LatheGeometry

function LatheGeometry( points, segments, phiStart, phiLength ) {

	Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

}

LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;

// LatheBufferGeometry

function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

	BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]

	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


	// buffers

	var indices = [];
	var vertices = [];
	var uvs = [];

	// helper variables

	var base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex

			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;

			vertices.push( vertex.x, vertex.y, vertex.z );

			// uv

			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );

			uvs.push( uv.x, uv.y );


		}

	}

	// indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if ( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();

		// this is the buffer offset for the last line of vertices

		base = segments * points.length * 3;

		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line

			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line

			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals

			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals

			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		}

	}

}

LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// ShapeGeometry

function ShapeGeometry( shapes, curveSegments ) {

	Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( typeof curveSegments === 'object' ) {

		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

		curveSegments = curveSegments.curveSegments;

	}

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();

}

ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;

// ShapeBufferGeometry

function ShapeBufferGeometry( shapes, curveSegments ) {

	BufferGeometry.call( this );

	this.type = 'ShapeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	curveSegments = curveSegments || 12;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var groupStart = 0;
	var groupCount = 0;

	// allow single and array values for "shapes" parameter

	if ( Array.isArray( shapes ) === false ) {

		addShape( shapes );

	} else {

		for ( var i = 0; i < shapes.length; i ++ ) {

			addShape( shapes[ i ] );

			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

			groupStart += groupCount;
			groupCount = 0;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


	// helper functions

	function addShape( shape ) {

		var i, l, shapeHole;

		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );

		var shapeVertices = points.shape;
		var shapeHoles = points.holes;

		// check direction of vertices

		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

			shapeVertices = shapeVertices.reverse();

			// also check if holes are in the opposite direction

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

		}

		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

		// join vertices of inner and outer paths to a single array

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );

		}

		// vertices, normals, uvs

		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

			var vertex = shapeVertices[ i ];

			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y ); // world uvs

		}

		// incides

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;

			indices.push( a, b, c );
			groupCount += 3;

		}

	}

}

ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

function EdgesGeometry( geometry, thresholdAngle ) {

	BufferGeometry.call( this );

	this.type = 'EdgesGeometry';

	this.parameters = {
		thresholdAngle: thresholdAngle
	};

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	// buffer

	var vertices = [];

	// helper variables

	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];

	// prepare source geometry

	var geometry2;

	if ( geometry.isBufferGeometry ) {

		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;

	// now create a data structure where each entry represents an edge with its adjoining faces

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge1 = face[ keys[ j ] ];
			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
			edge[ 0 ] = Math.min( edge1, edge2 );
			edge[ 1 ] = Math.max( edge1, edge2 );

			key = edge[ 0 ] + ',' + edge[ 1 ];

			if ( edges[ key ] === undefined ) {

				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				edges[ key ].face2 = i;

			}

		}

	}

	// generate vertices

	for ( key in edges ) {

		var e = edges[ key ];

		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

			var vertex = sourceVertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = sourceVertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	// build geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// CylinderGeometry

function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;

// CylinderBufferGeometry

function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var index = 0;
	var indexArray = [];
	var halfHeight = height / 2;
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function generateTorso() {

		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var slope = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row

			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var theta = u * thetaLength + thetaStart;

				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				// save index of vertex in respective row

				indexRow.push( index ++ );

			}

			// now save vertices of the row in our index array

			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices

				var a = indexArray[ y ][ x ];
				var b = indexArray[ y + 1 ][ x ];
				var c = indexArray[ y + 1 ][ x + 1 ];
				var d = indexArray[ y ][ x + 1 ];

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// update group counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new Vector2();
		var vertex = new Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex

			vertices.push( 0, halfHeight * sign, 0 );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uvs.push( 0.5, 0.5 );

			// increase index

			index ++;

		}

		// save the index of the last center vertex

		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex

			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.push( uv.x, uv.y );

			// increase index

			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top

				indices.push( i, i + 1, c );

			} else {

				// face bottom

				indices.push( i + 1, i, c );

			}

			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

}

CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

// ConeGeometry

function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;

// ConeBufferGeometry

function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */

// CircleGeometry

function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;

// CircleBufferGeometry

function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, s;
	var vertex = new Vector3();
	var uv = new Vector2();

	// center point

	vertices.push( 0, 0, 0 );
	normals.push( 0, 0, 1 );
	uvs.push( 0.5, 0.5 );

	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

		var segment = thetaStart + s / segments * thetaLength;

		// vertex

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		vertices.push( vertex.x, vertex.y, vertex.z );

		// normal

		normals.push( 0, 0, 1 );

		// uvs

		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

		uvs.push( uv.x, uv.y );

	}

	// indices

	for ( i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



var Geometries = Object.freeze({
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextBufferGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry
});

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>
 * }
 */

function ShadowMaterial( parameters ) {

	ShaderMaterial.call( this, {
		uniforms: UniformsUtils.merge( [
			UniformsLib.lights,
			{
				opacity: { value: 1.0 }
			}
		] ),
		vertexShader: ShaderChunk[ 'shadow_vert' ],
		fragmentShader: ShaderChunk[ 'shadow_frag' ]
	} );

	this.lights = true;
	this.transparent = true;

	Object.defineProperties( this, {
		opacity: {
			enumerable: true,
			get: function () {
				return this.uniforms.opacity.value;
			},
			set: function ( value ) {
				this.uniforms.opacity.value = value;
			}
		}
	} );

	this.setValues( parameters );

}

ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 0.5;
	this.metalness = 0.5;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = { 'PHYSICAL': '' };

	this.type = 'MeshPhysicalMaterial';

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.clearCoat = 0.0;
	this.clearCoatRoughness = 0.0;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = { 'PHYSICAL': '' };

	this.reflectivity = source.reflectivity;

	this.clearCoat = source.clearCoat;
	this.clearCoatRoughness = source.clearCoatRoughness;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */

function MeshToonMaterial( parameters ) {

	MeshPhongMaterial.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.gradientMap = null;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	MeshPhongMaterial.prototype.copy.call( this, source );

	this.gradientMap = source.gradientMap;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.lights = false;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( Material.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};



var Materials = Object.freeze({
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

}

var DefaultLoadingManager = new LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FileLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FileLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check for data: URI
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];

			data = window.decodeURIComponent( data );

			if ( isBase64 ) data = window.atob( data );

			try {

				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

					 	response = new ArrayBuffer( data.length );

						var view = new Uint8Array( response );

						for ( var i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ response ], { type: mimeType } );

						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}, 0 );

			}

		} else {

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = event.target.response;

				Cache.add( url, response );

				if ( this.status === 200 ) {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else if ( this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else {

					if ( onError ) onError( event );

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( var header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	},

	setRequestHeader: function ( value ) {

		this.requestHeader = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( CompressedTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new CompressedTexture();
		texture.image = images;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

function DataTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( DataTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new DataTexture();

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( ImageLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		image.addEventListener( 'load', function () {

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		/*
		image.addEventListener( 'progress', function ( event ) {

			if ( onProgress ) onProgress( event );

		}, false );
		*/

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemEnd( url );
			scope.manager.itemError( url );

		}, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( CubeTextureLoader.prototype, {

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new CubeTexture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( TextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var texture = new Texture();
		texture.image = loader.load( url, function () {

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light( color, intensity ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.matrix = new Matrix4();

}

Object.assign( LightShadow.prototype, {

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	update: function ( light ) {

		var camera = this.camera;

		var fov = _Math.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * Math.PI;
		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / Math.PI;
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / ( 4 * Math.PI );
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow( ) {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

	// TODO (abelnation): distance/decay

	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

	// TODO (abelnation): shadows

}

// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Light.prototype.toJSON.call( this, meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

} );

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[   i1   ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {
					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ;) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ;) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[   i1   ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function() {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function( i1, t0, t, t1 ) {

		throw new Error( "call to abstract method" );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function( i1, t0, t1 ) {

		// empty

	}

} );

//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = -0;
	this._offsetPrev = -0;
	this._weightNext = -0;
	this._offsetNext = -0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: 	ZeroCurvatureEnding,
		endingEnd:		ZeroCurvatureEnding

	},

	intervalChanged_: function( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
		var sN =       wN   * ppp   -           wN      * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

/**
 * @author tschw
 */

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

var KeyframeTrackPrototype;

KeyframeTrackPrototype = {

	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrackPrototype:', message );
			return;

		}

		this.createInterpolant = factoryMethod;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== - 1 && times[ to ] > endTime ) -- to;

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.
					arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			writeIndex = 1,
			lastIndex = times.length - 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else keep = true;

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

				values[ writeOffset + j ] = values[ readOffset + j ];

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		}

		return this;

	}

};

function KeyframeTrackConstructor( name, times, values, interpolation ) {

	if ( name === undefined ) throw new Error( "track name is undefined" );

	if ( times === undefined || times.length === 0 ) {

		throw new Error( "no keyframes in track named " + name );

	}

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

	this.validate();
	this.optimize();

}

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0,
					values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function( result ) {

		return new QuaternionLinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrackConstructor.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited


	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.apply( this, arguments );

}

KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;

// Static methods:

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	parse: function( json ) {

		if( json.type === undefined ) {

			throw new Error( "track type undefined, can not parse" );

		}

		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we asssume a constructor compatible with the base
			return new trackType(
					json.name, json.times, json.values, json.interpolation );

		}

	},

	toJSON: function( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	},

	_getTrackTypeForValueTypeName: function( typeName ) {

		switch( typeName.toLowerCase() ) {

			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":

				return NumberKeyframeTrack;

			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":

				return VectorKeyframeTrack;

			case "color":

				return ColorKeyframeTrack;

			case "quaternion":

				return QuaternionKeyframeTrack;

			case "bool":
			case "boolean":

				return BooleanKeyframeTrack;

			case "string":

				return StringKeyframeTrack;

		}

		throw new Error( "Unsupported typeName: " + typeName );

	}

} );

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;

	this.uuid = _Math.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

	this.optimize();

}

Object.assign( AnimationClip, {

	parse: function ( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks );

	},

	toJSON: function ( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},

	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

		}

		return new AnimationClip( name, - 1, tracks );

	},

	findByName: function ( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || - 1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};

				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

				addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );

Object.assign( AnimationClip.prototype, {

	resetDuration: function () {

		var tracks = this.tracks, duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

	},

	trim: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.textures = {};

}

Object.assign( MaterialLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	parse: function ( json ) {

		var textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		var material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		return material;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( BufferGeometryLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = new BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

} );

var TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	// Workaround for IE11 pre KB2929437. See #11440
	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader() {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

}

Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

Object.assign( Loader.prototype, {

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};

		var color = new Color();
		var textureLoader = new TextureLoader();
		var materialLoader = new MaterialLoader();

		return function createMaterial( m, texturePath, crossOrigin ) {

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = _Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: _Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {

					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = BlendingMode[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = BackSide;
						break;
					case 'doubleSided':
						json.side = DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = VertexColors;
						if ( value === 'face' ) json.vertexColors = FaceColors;
						break;
					default:
						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
						break;

				}

			}

			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function JSONLoader( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.withCredentials = false;

}

Object.assign( JSONLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

		var loader = new FileLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				var type = metadata.type;

				if ( type !== undefined ) {

					if ( type.toLowerCase() === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( type.toLowerCase() === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: ( function () {

		function parseModel( json, geometry ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

				offset, zLength,

				colorIndex, normalIndex, uvIndex, materialIndex,

				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,

				vertex, face, faceA, faceB, hex, normal,

				uvLayer, uv, u, v,

				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,

				scale = json.scale,

				nUvLayers = 0;


			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];

				isQuad = isBitSet( type, 0 );
				hasMaterial = isBitSet( type, 1 );
				hasFaceVertexUv = isBitSet( type, 3 );
				hasFaceNormal = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor = isBitSet( type, 6 );
				hasFaceVertexColor = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		}

		function parseSkin( json, geometry ) {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x = json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a = json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		}

		function parseMorphing( json, geometry ) {

			var scale = json.scale;

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations( json, geometry ) {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];

			if ( json.animation !== undefined ) {

				animations.push( json.animation );

			}

			if ( json.animations !== undefined ) {

				if ( json.animations.length ) {

					animations = animations.concat( json.animations );

				} else {

					animations.push( json.animations );

				}

			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		}

		return function ( json, texturePath ) {

			if ( json.data !== undefined ) {

				// Geometry 4.0 spec
				json = json.data;

			}

			if ( json.scale !== undefined ) {

				json.scale = 1.0 / json.scale;

			} else {

				json.scale = 1.0;

			}

			var geometry = new Geometry();

			parseModel( json, geometry );
			parseSkin( json, geometry );
			parseMorphing( json, geometry );
			parseAnimations( json, geometry );

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			if ( json.materials === undefined || json.materials.length === 0 ) {

				return { geometry: geometry };

			} else {

				var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

				return { geometry: geometry, materials: materials };

			}

		};

	} )()

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.texturePath = '';

}

Object.assign( ObjectLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			var json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			var metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new JSONLoader();
			var bufferGeometryLoader = new BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'IcosahedronGeometry':
					case 'OctahedronGeometry':
					case 'TetrahedronGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					var array = [];

					for ( var j = 0; j < data.materials.length; j ++ ) {

						array.push( loader.parse( data.materials[ j ] ) );

					}

					materials[ data.uuid ] = array;

				} else {

					materials[ data.uuid ] = loader.parse( data );

				}

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new LoadingManager( onLoad );

			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new Matrix4();

		return function parseObject( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		};

	}()

} );

var TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	SphericalReflectionMapping: SphericalReflectionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

var TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

var TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipMapNearestFilter: NearestMipMapNearestFilter,
	NearestMipMapLinearFilter: NearestMipMapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipMapNearestFilter: LinearMipMapNearestFilter,
	LinearMipMapLinearFilter: LinearMipMapLinearFilter
};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	var v0 = ( p2 - p0 ) * 0.5;
	var v1 = ( p3 - p1 ) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	var k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTangentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function () {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		var normal = new Vector3();

		var tangents = [];
		var normals = [];
		var binormals = [];

		var vec = new Vector3();
		var mat = new Matrix4();

		var i, u, theta;

		// compute the tangent vectors for each segment on the curve

		for ( i = 0; i <= segments; i ++ ) {

			u = i / segments;

			tangents[ i ] = this.getTangentAt( u );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

} );

function LineCurve( v1, v2 ) {

	Curve.call( this );

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t ) {

	if ( t === 1 ) {

		return this.v2.clone();

	}

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

LineCurve.prototype.getTangent = function ( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	Curve.call( this );

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 40;

		var points = [];

		for ( var i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var points = [], last;

		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

			var curve = curves[ i ];
			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
				: (curve && curve.isLineCurve) ? 1
				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
				: divisions;

			var pts = curve.getPoints( resolution );

			for ( var j = 0; j < pts.length; j++ ) {

				var point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	createPointsGeometry: function ( divisions ) {

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	// Generate geometry from equidistant sampling along the path

	createSpacedPointsGeometry: function ( divisions ) {

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		var geometry = new Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	Curve.call( this );

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function ( t ) {

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x - this.aX;
		var ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return new Vector2( x, y );

};

function SplineCurve( points /* array of Vector2 */ ) {

	Curve.call( this );

	this.points = ( points === undefined ) ? [] : points;

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	return new Vector2(
		CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
		CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
	);

};

function CubicBezierCurve( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	return new Vector2(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);

};

function QuadraticBezierCurve( v0, v1, v2 ) {

	Curve.call( this );

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	return new Vector2(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);

};

var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

	fromPoints: function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

			this.lineTo( vectors[ i ].x, vectors[ i ].y );

		}

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

	},

	lineTo: function ( x, y ) {

		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var npts = [ this.currentPoint.clone() ].concat( pts );

		var curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			var firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path( points ) {

	CurvePath.call( this );
	this.currentPoint = new Vector2();

	if ( points ) {

		this.fromPoints( points );

	}

}

Path.prototype = PathPrototype;
PathPrototype.constructor = Path;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape() {

	Path.apply( this, arguments );

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( PathPrototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// Get points of shape and holes (keypoints based on segments parameter)

	extractAllPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	extractPoints: function ( divisions ) {

		return this.extractAllPoints( divisions );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {

	this.subPaths = [];
	this.currentPath = null;

}

Object.assign( ShapePath.prototype, {

	moveTo: function ( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

	},

	lineTo: function ( x, y ) {

		this.currentPath.lineTo( x, y );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

	},

	splineThru: function ( pts ) {

		this.currentPath.splineThru( pts );

	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = ShapeUtils.isClockWise;

		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font( data ) {

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size, divisions ) {

		function createPaths( text ) {

			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

			var offsetX = 0, offsetY = 0;

			var paths = [];

			for ( var i = 0; i < chars.length; i ++ ) {

				var char = chars[ i ];

				if ( char === '\n' ) {

					offsetX = 0;
					offsetY -= line_height;

				} else {

					var ret = createPath( char, scale, offsetX, offsetY );
					offsetX += ret.offsetX;
					paths.push( ret.path );

				}

			}

			return paths;

		}

		function createPath( c, scale, offsetX, offsetY ) {

			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

			if ( ! glyph ) return;

			var path = new ShapePath();

			var pts = [];
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx  = outline[ i ++ ] * scale + offsetX;
							cpy  = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									QuadraticBezier( t, cpx0, cpx1, cpx );
									QuadraticBezier( t, cpy0, cpy1, cpy );

								}

							}

							break;

						case 'b': // bezierCurveTo

							cpx  = outline[ i ++ ] * scale + offsetX;
							cpy  = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;
							cpx2 = outline[ i ++ ] * scale + offsetX;
							cpy2 = outline[ i ++ ] * scale + offsetY;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									CubicBezier( t, cpx0, cpx1, cpx2, cpx );
									CubicBezier( t, cpy0, cpy1, cpy2, cpy );

								}

							}

							break;

					}

				}

			}

			return { offsetX: glyph.ha * scale, path: path };

		}

		//

		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;

		var data = this.data;

		var paths = createPaths( text );
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FontLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( this.manager );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

var context;

var AudioContext = {

	getContext: function () {

		if ( context === undefined ) {

			context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return context;

	},

	setContext: function ( value ) {

		context = value;

	}

};

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( AudioLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {

			var context = AudioContext.getContext();

			context.decodeAudioData( buffer, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

}

Object.assign( StereoCamera.prototype, {

	update: ( function () {

		var instance, focus, fov, aspect, near, far, zoom, eyeSep;

		var eyeRight = new Matrix4();
		var eyeLeft = new Matrix4();

		return function update( camera ) {

			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

			if ( needsUpdate ) {

				instance = this;
				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;
				zoom = camera.zoom;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				eyeSep = this.eyeSep / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
				var xmin, xmax;

				// translate xOffset

				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;

				// for left eye

				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

		};

	} )()

} );

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

function CubeCamera( near, far, cubeResolution ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	this.renderTarget.texture.name = "CubeCamera";

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioListener() {

	Object3D.call( this );

	this.type = 'AudioListener';

	this.context = AudioContext.getContext();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

}

AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.value = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();
		var quaternion = new Quaternion();
		var scale = new Vector3();

		var orientation = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			if ( listener.positionX ) {

				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
				listener.upX.setValueAtTime( up.x, this.context.currentTime );
				listener.upY.setValueAtTime( up.y, this.context.currentTime );
				listener.upZ.setValueAtTime( up.z, this.context.currentTime );

			} else {

				listener.setPosition( position.x, position.y, position.z );
				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

			}

		};

	} )()

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio( listener ) {

	Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.buffer = null;
	this.loop = false;
	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this.filters = [];

}

Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.buffer;
		source.loop = this.loop;
		source.onended = this.onEnded.bind( this );
		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
		source.start( 0, this.startTime );

		this.isPlaying = true;

		this.source = source;

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = this.context.currentTime;
		this.isPlaying = false;

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = 0;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},
	
	setVolume: function ( value ) {

		this.gain.gain.value = value;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function PositionalAudio( listener ) {

	Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

}

PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

	constructor: PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )()


} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

}

Object.assign( AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			break;

		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;

		default:
			mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, {

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function ( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function ( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function () {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function () {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

} );

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function Composite( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param  {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );

	},

	parseTrackName: function () {

		// Parent directories, delimited by '/' or ':'. Currently unused, but must
		// be matched to parse the rest of the track name.
		var directoryRe = /((?:[\w-]+[\/:])*)/;

		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
		var nodeRe = /([\w-\.]+)?/;

		// Object on target node, and accessor. Name may contain only word
		// characters. Accessor may contain any character except closing bracket.
		var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

		// Property and accessor. May contain only word characters. Accessor may
		// contain any non-bracket characters.
		var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

		var trackRe = new RegExp(''
			+ '^'
			+ directoryRe.source
			+ nodeRe.source
			+ objectRe.source
			+ propertyRe.source
			+ '$'
		);

		var supportedObjectNames = [ 'material', 'materials', 'bones' ];

		return function ( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ],     // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== -1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== -1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

	}(),

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			var searchSkeleton = function ( skeleton ) {

				for ( var i = 0; i < skeleton.bones.length; i ++ ) {

					var bone = skeleton.bones[ i ];

					if ( bone.name === nodeName ) {

						return bone;

					}

				}

				return null;

			};

			var bone = searchSkeleton( root.skeleton );

			if ( bone ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			var searchNodeSubtree = function ( children ) {

				for ( var i = 0; i < children.length; i ++ ) {

					var childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					var result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			var subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

							propertyIndex = i;
							break;

						}

					}


				} else {

					if ( ! targetObject.geometry.morphTargets ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
						return;

					}

					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

							propertyIndex = i;
							break;

						}

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup( var_args ) {

	this.uuid = _Math.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0;			// threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices;		// for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = [];					// inside: string
	this._parsedPaths = [];				// inside: { we don't care, here }
	this._bindings = []; 				// inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() { return scope._objects.length; },
			get inUse() { return this.total - scope.nCachedObjects_; }
		},

		get bindingsPerObject() { return scope._bindings.length; }

	};

}

Object.assign( AnimationObjectGroup.prototype, {

	isAnimationObjectGroup: true,

	add: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ],
				knownObject = undefined;

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push(
							new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function( var_args ) {

		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function ( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function ( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

} );

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
			endingStart: 	ZeroCurvatureEnding,
			endingEnd:		ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants;	// bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null;			// for the memory manager
	this._byClipCacheIndex = null;		// for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = LoopRepeat;
	this._loopCount = -1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; 		// no. of repetitions when looping

	this.paused = false;				// true -> zero effective time scale
	this.enabled = true;				// false -> zero effective weight

	this.clampWhenFinished 	= false;	// keep feeding the last frame?

	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

}

Object.assign( AnimationAction.prototype, {

	// State & Scheduling

	play: function() {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function() {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function() {

		this.paused = false;
		this.enabled = true;

		this.time = 0;			// restart clip
		this._loopCount = -1;	// forget previous loops
		this._startTime = null;	// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function() {

		return this._mixer._isActiveAction( this );

	},

	startAt: function( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function() {

		return this._effectiveWeight;

	},

	fadeIn: function( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function() {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 :timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function() {

		return this._effectiveTimeScale;

	},

	setDuration: function( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function() {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function() {

		return this._mixer;

	},

	getClip: function() {

		return this._clip;

	},

	getRoot: function() {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function( deltaTime ) {

		var time = this.time + deltaTime;

		if ( deltaTime === 0 ) return time;

		var duration = this._clip.duration,

			loop = this.loop,
			loopCount = this._loopCount;

		if ( loop === LoopOnce ) {

			if ( loopCount === -1 ) {
				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else break handle_stop;

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			var pingPong = ( loop === LoopPingPong );

			if ( loopCount === -1 ) {
				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings(
							true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings(
							this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {
				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending < 0 ) {
					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : -1
					} );

				} else {
					// keep running

					if ( pending === 0 ) {
						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {
				// invert time for the "pong round"

				this.time = time;
				return duration - time;

			}

		}

		this.time = time;
		return time;

	},

	_setEndings: function( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart 	= ZeroSlopeEnding;
			settings.endingEnd		= ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

		return this;

	}

} );

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

	_bindAction: function ( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 		knownActions: Array< AnimationAction >	- used as prototypes
		// 		actionByRoot: AnimationAction			- lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() { return scope._actions.length; },
				get inUse() { return scope._nActiveActions; }
			},
			bindings: {
				get total() { return scope._bindings.length; },
				get inUse() { return scope._nActiveBindings; }
			},
			controlInterpolants: {
				get total() { return scope._controlInterpolants.length; },
				get inUse() { return scope._nActiveControlInterpolants; }
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		remove_empty_map: {

			for ( var _ in bindingByName ) break remove_empty_map;

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new AnimationAction( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

}

Uniform.prototype.clone = function () {

	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.uuid = _Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer( array, stride ) {

	this.uuid = _Math.generateUUID();

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.stride : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

	BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;

	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {
				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;
			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.visible === false ) return;

	object.raycast( raycaster, intersects );

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	linePrecision: 1,

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive ) {

		var intersects = [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive ) {

		var intersects = [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Object.assign( Clock.prototype, {

	start: function () {

		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

function Spherical( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

	return this;

}

Object.assign( Spherical.prototype, {

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function() {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = vec3.length();

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
			this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

		}

		return this;

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical( radius, theta, y ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

	return this;

}

Object.assign( Cylindrical.prototype, {

	set: function ( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
		this.theta = Math.atan2( vec3.x, vec3.z );
		this.y = vec3.y;

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function MorphBlendMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

}

MorphBlendMesh.prototype = Object.create( Mesh.prototype );
MorphBlendMesh.prototype.constructor = MorphBlendMesh;

MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/i;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function VertexNormalsHelper( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count;

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

}

VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function SpotLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new BufferGeometry();

	var positions = [
		0, 0, 0,   0,   0,   1,
		0, 0, 0,   1,   0,   1,
		0, 0, 0, - 1,   0,   1,
		0, 0, 0,   0,   1,   1,
		0, 0, 0,   0, - 1,   1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

}

SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

SpotLightHelper.prototype.update = function () {

	var vector = new Vector3();
	var vector2 = new Vector3();

	return function update() {

		this.light.updateMatrixWorld();

		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color );

	};

}();

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

function getBoneList( object ) {

	var boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

function SkeletonHelper( object ) {

	var bones = getBoneList( object );

	var geometry = new BufferGeometry();

	var vertices = [];
	var colors = [];

	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );

	for ( var i = 0; i < bones.length; i ++ ) {

		var bone = bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );

		}

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	LineSegments.call( this, geometry, material );

	this.root = object;
	this.bones = bones;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.onBeforeRender();

}

SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.onBeforeRender = function () {

	var vector = new Vector3();

	var boneMatrix = new Matrix4();
	var matrixWorldInv = new Matrix4();

	return function onBeforeRender() {

		var bones = this.bones;

		var geometry = this.geometry;
		var position = geometry.getAttribute( 'position' );

		matrixWorldInv.getInverse( this.root.matrixWorld );

		for ( var i = 0, j = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j, vector.x, vector.y, vector.z );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color );

	Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 */

function RectAreaLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var material = new LineBasicMaterial( { color: light.color } );

	var geometry = new BufferGeometry();

	geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

	this.add( new Line( geometry, material ) );

	this.update();

}

RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

RectAreaLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

RectAreaLightHelper.prototype.update = function () {

	var line = this.children[ 0 ];

	// update material

	line.material.color.copy( this.light.color );

	// calculate new dimensions of the helper

	var hx = this.light.width * 0.5;
	var hy = this.light.height * 0.5;

	var position = line.geometry.attributes.position;
	var array = position.array;

	// update vertices

	array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
	array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
	array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;
	array[  9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
	array[ 12 ] =   hx; array[ 13 ] = - hy; array[ 14 ] = 0;

	position.needsUpdate = true;

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function HemisphereLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );

	var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );

	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );

	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

	this.add( new Mesh( geometry, material ) );

	this.update();

}

HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

HemisphereLightHelper.prototype.update = function () {

	var vector = new Vector3();

	var color1 = new Color();
	var color2 = new Color();

	return function update() {

		var mesh = this.children[ 0 ];

		var colors = mesh.geometry.getAttribute( 'color' );

		color1.copy( this.light.color );
		color2.copy( this.light.groundColor );

		for ( var i = 0, l = colors.count; i < l; i ++ ) {

			var color = ( i < ( l / 2 ) ) ? color1 : color2;

			colors.setXYZ( i, color.r, color.g, color.b );

		}

		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		colors.needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper( size, divisions, color1, color2 ) {

	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var center = divisions / 2;
	var step = size / divisions;
	var halfSize = size / 2;

	var vertices = [], colors = [];

	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

		vertices.push( - halfSize, 0, k, halfSize, 0, k );
		vertices.push( k, 0, - halfSize, k, 0, halfSize );

		var color = i === center ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

GridHelper.prototype = Object.create( LineSegments.prototype );
GridHelper.prototype.constructor = GridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	var x, z;
	var v, i, j, r, color;

	// create the radials

	for ( i = 0; i <= radials; i ++ ) {

		v = ( i / radials ) * ( Math.PI * 2 );

		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;

		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );

		color = ( i & 1 ) ? color1 : color2;

		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );

	}

	// create the circles

	for ( i = 0; i <= circles; i ++ ) {

		color = ( i & 1 ) ? color1 : color2;

		r = radius - ( radius / circles * i );

		for ( j = 0; j < divisions; j ++ ) {

			// first vertex

			v = ( j / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

			// second vertex

			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

		}

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function FaceNormalsHelper( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

}

FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function DirectionalLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	if ( size === undefined ) size = 1;

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [
		- size,   size, 0,
		  size,   size, 0,
		  size, - size, 0,
		- size, - size, 0,
		- size,   size, 0
	], 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.add( new Line( geometry, material ) );

	geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.add( new Line( geometry, material ));

	this.update();

}

DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {

	var lightPlane = this.children[ 0 ];
	var targetLine = this.children[ 1 ];

	lightPlane.geometry.dispose();
	lightPlane.material.dispose();
	targetLine.geometry.dispose();
	targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update = function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();

	return function update() {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		var lightPlane = this.children[ 0 ];
		var targetLine = this.children[ 1 ];

		lightPlane.lookAt( v3 );
		lightPlane.material.color.copy( this.light.color );

		targetLine.lookAt( v3 );
		targetLine.scale.z = v3.length();

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

function CameraHelper( camera ) {

	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

	var vertices = [];
	var colors = [];

	var pointMap = {};

	// colors

	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );

	// near

	addLine( "n1", "n2", colorFrustum );
	addLine( "n2", "n4", colorFrustum );
	addLine( "n4", "n3", colorFrustum );
	addLine( "n3", "n1", colorFrustum );

	// far

	addLine( "f1", "f2", colorFrustum );
	addLine( "f2", "f4", colorFrustum );
	addLine( "f4", "f3", colorFrustum );
	addLine( "f3", "f1", colorFrustum );

	// sides

	addLine( "n1", "f1", colorFrustum );
	addLine( "n2", "f2", colorFrustum );
	addLine( "n3", "f3", colorFrustum );
	addLine( "n4", "f4", colorFrustum );

	// cone

	addLine( "p", "n1", colorCone );
	addLine( "p", "n2", colorCone );
	addLine( "p", "n3", colorCone );
	addLine( "p", "n4", colorCone );

	// up

	addLine( "u1", "u2", colorUp );
	addLine( "u2", "u3", colorUp );
	addLine( "u3", "u1", colorUp );

	// target

	addLine( "c", "t", colorTarget );
	addLine( "p", "c", colorCross );

	// cross

	addLine( "cn1", "cn2", colorCross );
	addLine( "cn3", "cn4", colorCross );

	addLine( "cf1", "cf2", colorCross );
	addLine( "cf3", "cf4", colorCross );

	function addLine( a, b, color ) {

		addPoint( a, color );
		addPoint( b, color );

	}

	function addPoint( id, color ) {

		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	LineSegments.call( this, geometry, material );

	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

}

CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new Vector3();
	var camera = new Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			var position = geometry.getAttribute( 'position' );

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

			}

		}

	}

	return function update() {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */

function BoxHelper( object, color ) {

	this.object = object;

	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

	this.matrixAutoUpdate = false;

	this.update();

}

BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = ( function () {

	var box = new Box3();

	return function update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			box.setFromObject( this.object );

		}

		if ( box.isEmpty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	};

} )();

BoxHelper.prototype.setFromObject = function ( object ) {

	this.object = object;
	this.update();

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var lineGeometry;
var coneGeometry;

function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

	// dir is assumed to be normalized

	Object3D.call( this );

	if ( color === undefined ) color = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( lineGeometry === undefined ) {

		lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

	}

	this.position.copy( origin );

	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

}

ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = ( function () {

	var axis = new Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.copy( color );
	this.cone.material.color.copy( color );

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxisHelper( size ) {

	size = size || 1;

	var vertices = [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	];

	var colors = [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	];

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

AxisHelper.prototype = Object.create( LineSegments.prototype );
AxisHelper.prototype.constructor = AxisHelper;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();

function CatmullRomCurve3( points ) {

	Curve.call( this );

	if ( points.length < 2 ) console.warn( 'THREE.CatmullRomCurve3: Points array needs at least two entries.' );

	this.points = points || [];
	this.closed = false;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.getPoint = function ( t ) {

	var points = this.points;
	var l = points.length;

	var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	if ( this.closed ) {

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

	} else if ( weight === 0 && intPoint === l - 1 ) {

		intPoint = l - 2;
		weight = 1;

	}

	var p0, p1, p2, p3; // 4 points

	if ( this.closed || intPoint > 0 ) {

		p0 = points[ ( intPoint - 1 ) % l ];

	} else {

		// extrapolate first point
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;

	}

	p1 = points[ intPoint % l ];
	p2 = points[ ( intPoint + 1 ) % l ];

	if ( this.closed || intPoint + 2 < l ) {

		p3 = points[ ( intPoint + 2 ) % l ];

	} else {

		// extrapolate last point
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;

	}

	if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

		// init Centripetal / Chordal Catmull-Rom
		var pow = this.type === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

		// safety check for repeated points
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;

		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

	} else if ( this.type === 'catmullrom' ) {

		var tension = this.tension !== undefined ? this.tension : 0.5;
		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

	}

	return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );

};

function CubicBezierCurve3( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	return new Vector3(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);

};

function QuadraticBezierCurve3( v0, v1, v2 ) {

	Curve.call( this );

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.getPoint = function ( t ) {

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	return new Vector3(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);

};

function LineCurve3( v1, v2 ) {

	Curve.call( this );

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.getPoint = function ( t ) {

	if ( t === 1 ) {

		return this.v2.clone();

	}

	var vector = new Vector3();

	vector.subVectors( this.v2, this.v1 ); // diff
	vector.multiplyScalar( t );
	vector.add( this.v1 );

	return vector;

};

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

/**
 * @author alteredq / http://alteredqualia.com/
 */

var SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		child.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

var LineStrip = 0;

var LinePieces = 1;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials ) {

	if ( materials === undefined ) materials = [];

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};
	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new BufferAttribute( array, itemSize ).setDynamic( true );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function SplineCurve3( points ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function Spline( points ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

Spline.prototype = Object.create( CatmullRomCurve3.prototype );

Object.assign( Spline.prototype, {

	initFromArray: function ( a ) {

		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

	},
	getControlPointsArray: function ( optionalTarget ) {

		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

	},
	reparametrizeByArcLength: function ( samplingCoef ) {

		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

	}

} );

//
function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
	
};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

_Math.random16 = function () {

	console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( a ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.'  );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	},
	applyToVector3Array: function( array, offset, length ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		var v1;

		return function getPosition() {

			if ( v1 === undefined ) v1 = new Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
			return v1.setFromMatrixColumn( this, 3 );

		};

	}(),
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyToArray: function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( a ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.'  );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	},
	applyToVector3Array: function( array, offset, length ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	},
	makeFrustum: function( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Shape.prototype, {

	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector2.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	},
	applyProjection: function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	},
	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

Object.assign( Vector4.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	}

} );

//

Geometry.prototype.computeTangents = function () {

	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

};

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

	get: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	},
	set: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	}

} );

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	}

} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},
	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

Object.assign( WebGLRenderer.prototype, {

	getCurrentRenderTarget: function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	},

	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			return this.shadowMap.cullFace;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;

		}
	}
} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			return this.renderReverseSided ? CullFaceFront : CullFaceBack;

		},
		set: function ( cullFace ) {

			var value = ( cullFace !== CullFaceBack );
			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
			this.renderReverseSided = value;

		}
	}

} );

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	var scope = this;
	var audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

var GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		var matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

var ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	}

};

//

function Projector() {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function () {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

}

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

}




/***/ }),

/***/ 733:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  FEATURE_SMOOTH: 0,
  FEATURE_FOUNDATION: 1,
  FEATURE_CONCEALER: 2,
  FEATURE_FACE_CONTOUR: 3,
  FEATURE_FACE_ART: 4,
  FEATURE_FACE_ART_LAYER2: 5,
  FEATURE_BLUSH: 6,
  FEATURE_BLUSH3D: 7,
  FEATURE_BLUSH3D_V2: 8,
  FEATURE_BRONZER: 9,
  FEATURE_EYESHADOW: 10,
  FEATURE_EYELASH: 11,
  FEATURE_EYELINER: 12,
  FEATURE_HAIR_DYE: 13,
  FEATURE_HAIR_DYE_LOAD_MASK: 14,
  FEATURE_BEARD_DYE: 15,
  FEATURE_BEARD_DYE_LOAD_MASK: 16,
  FEATURE_EYEBROW: 17,
  FEATURE_LIPLINER: 18,
  FEATURE_LIP: 19,
  FEATURE_EYE_CONTACT: 20,
  FEATURE_FACE_RESHAPE: 21,
  FEATURE_OBJECT3D: 22,
  FEATURE_AR_GLASSES: 23,
  FEATURE_EARRING: 24,
  FEATURE_STICKER: 25,
  FEATURE_EYESHADOW_PROTECT_MASK: 26,
  FEATURE_EYELINER_PROTECT_MASK: 27,
  FEATURE_BLUSH_PROTECT_MASK: 28,
  FEATURE_FACE_CONTOUR_PROTECT_MASK: 29,
  FEATURE_EYESHADOWANIMATION: 30,
  FEATURE_EYELINERANIMATION: 31,
  FEATURE_BLUSHANIMATION: 32,
  FEATURE_BLUSH3DANIMATION: 33,
  FEATURE_BLUSH3D_V2_ANIMATION: 34,
  FEATURE_FACE_CONTOUR_ANIMATION: 35,
  FEATURE_LIPSTICK_ANIMATION: 36,
  FEATURE_HAIR_TONE: 37,
  FEATURE_LIPLINER_ANIMATION: 38,
  FEATURE_FOUNDATION_ANIMATION: 39,
  FEATURE_BACKGROUND: 40,
  FEATURE_BLUSH3D_LAYER1: 41,
  FEATURE_BLUSH3D_LAYER2: 42,
  FEATURE_BLUSH3D_LAYER3: 43,
  FEATURE_BLUSH3D_PROTECT_MASK: 44,
  FEATURE_LIP_SHAPE: 45,
  FEATURE_NECKLACE: 46,
  FEATURE_TEETH_WHITEN: 47,
  FEATURE_COMPARE: 48,
  FEATURE_UPSCALE: 49,

  // feature size
  FEATURE_SIZE: 50,
  FEATURE_OTHERS: 51
};
module.exports = exports["default"];

/***/ }),

/***/ 745:
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(806),
    hasPath = __webpack_require__(316);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ 771:
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),

/***/ 786:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.mixwith = mod.exports;
  }
})(undefined, function (exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _cachedApplicationRef = exports._cachedApplicationRef = Symbol('_cachedApplicationRef');

  var _mixinRef = exports._mixinRef = Symbol('_mixinRef');

  var _originalMixin = exports._originalMixin = Symbol('_originalMixin');

  var wrap = exports.wrap = function (mixin, wrapper) {
    Object.setPrototypeOf(wrapper, mixin);
    if (!mixin[_originalMixin]) {
      mixin[_originalMixin] = mixin;
    }
    return wrapper;
  };

  var Cached = exports.Cached = function (mixin) {
    return wrap(mixin, function (superclass) {
      // Get or create a symbol used to look up a previous application of mixin
      // to the class. This symbol is unique per mixin definition, so a class will have N
      // applicationRefs if it has had N mixins applied to it. A mixin will have
      // exactly one _cachedApplicationRef used to store its applications.
      var applicationRef = mixin[_cachedApplicationRef];
      if (!applicationRef) {
        applicationRef = mixin[_cachedApplicationRef] = Symbol(mixin.name);
      }
      // Look up an existing application of `mixin` to `c`, return it if found.
      if (superclass.hasOwnProperty(applicationRef)) {
        return superclass[applicationRef];
      }
      // Apply the mixin
      var application = mixin(superclass);
      // Cache the mixin application on the superclass
      superclass[applicationRef] = application;
      return application;
    });
  };

  var HasInstance = exports.HasInstance = function (mixin) {
    if (Symbol.hasInstance && !mixin.hasOwnProperty(Symbol.hasInstance)) {
      Object.defineProperty(mixin, Symbol.hasInstance, {
        value: function value(o) {
          var originalMixin = this[_originalMixin];
          while (o != null) {
            if (o.hasOwnProperty(_mixinRef) && o[_mixinRef] === originalMixin) {
              return true;
            }
            o = Object.getPrototypeOf(o);
          }
          return false;
        }
      });
    }
    return mixin;
  };

  var BareMixin = exports.BareMixin = function (mixin) {
    return wrap(mixin, function (superclass) {
      // Apply the mixin
      var application = mixin(superclass);

      // Attach a reference from mixin applition to wrapped mixin for RTTI
      // mixin[@@hasInstance] should use this.
      application.prototype[_mixinRef] = mixin[_originalMixin];
      return application;
    });
  };

  var Mixin = exports.Mixin = function (mixin) {
    return Cached(HasInstance(BareMixin(mixin)));
  };

  var mix = exports.mix = function (superClass) {
    return new MixinBuilder(superClass);
  };

  var MixinBuilder = function () {
    function MixinBuilder(superclass) {
      _classCallCheck(this, MixinBuilder);

      this.superclass = superclass;
    }

    _createClass(MixinBuilder, [{
      key: 'with',
      value: function _with() {
        return Array.from(arguments).reduce(function (c, m) {
          return m(c);
        }, this.superclass);
      }
    }]);

    return MixinBuilder;
  }();
});

/***/ }),

/***/ 791:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _forEach2 = __webpack_require__(59);

var _forEach3 = _interopRequireDefault(_forEach2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = {
  outputImageData: function outputImageData(imageData, id) {
    return new _promise2.default(function (resolve) {
      var image = document.getElementById(id) || new Image();
      image.id = id;
      image.onload = function () {
        document.body.appendChild(image);
        resolve();
      };
      image.src = _mediaUtils2.default.imageData2Blob(imageData, imageData.width, imageData.height, imageData.width, imageData.height, document);
    });
  },
  outputFaceRect: function outputFaceRect(r, mountId) {
    var m = document.querySelector('#' + mountId);
    var left = m.offsetLeft;
    var top = m.offsetTop;
    var div = document.createElement('div');
    div.dataset.refId = mountId;
    div.style.position = 'absolute';
    div.style.top = top + r.top + 'px';
    div.style.left = left + r.left + 'px';
    div.style.zIndex = 10000;
    div.style.width = r.right - r.left + 'px';
    div.style.height = r.bottom - r.top + 'px';
    div.style.border = '1px solid #cc0000';
    document.body.appendChild(div);
  },
  outputLandmarks: function outputLandmarks(r, width, height, mountId) {
    var m = document.querySelector('#' + mountId);
    var left = m.offsetLeft;
    var top = m.offsetTop;
    (0, _forEach3.default)(r.points, function (point, i) {
      var image = new Image(3, 3);
      image.dataset.refId = mountId;
      image.title = i;
      image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mN8s5H3PwAG5gKrDMi7hQAAAABJRU5ErkJggg==';
      image.style.position = 'absolute';
      image.style.left = left + point.x * width - 1.5 + 'px';
      image.style.top = top + point.y * height - 1.5 + 'px';
      image.style.width = '3px';
      image.style.height = '3px';
      image.width = 3;
      image.height = 3;
      image.className = 'dot';
      image.style.zIndex = 10000;
      document.body.appendChild(image);
    });
  },
  cleanOutputImageData: function cleanOutputImageData(mountId) {
    var m = document.querySelector('#' + mountId);
    if (!m) {
      return;
    }
    m.remove();
    var elements = document.querySelectorAll('[data-ref-id=' + mountId + ']');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(elements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var el = _step.value;

        el && el.remove();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  },
  sum: function sum(array) {
    var r = 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(array), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var a = _step2.value;

        r += a;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return r;
  },
  dumpEarringSetting: function dumpEarringSetting(value) {
    var keys = ['anchor_base', 'axis1', 'axis2', 'axis3', 'axis_base', 'axis_scale', 'chain_global_setting', 'chains', 'collider_sets', 'earbone_align_index', 'earbone_ear_index', 'flat_ear_version', 'inner_anchor', 'is_right', 'joints', 'objects', 'occlude_index', 'transform', 'undefined', 'undefined', 'undefined', 'undefined', 'version'];
    var r = {};
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(keys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var key = _step3.value;

        var v = value[key];
        if (v && v.size) {
          r[key] = [];
          for (var i = 0; i < v.size(); i++) {
            r[key].push(v.get(i));
          }
        } else {
          r[key] = v;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return r;
  }
};

exports.default = utils;
module.exports = exports['default'];

/***/ }),

/***/ 800:
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(101),
    baseGet = __webpack_require__(192),
    baseIteratee = __webpack_require__(79),
    baseMap = __webpack_require__(317),
    baseSortBy = __webpack_require__(803),
    baseUnary = __webpack_require__(102),
    compareMultiple = __webpack_require__(804),
    identity = __webpack_require__(64),
    isArray = __webpack_require__(7);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ 802:
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(311),
    baseOrderBy = __webpack_require__(800),
    baseRest = __webpack_require__(188),
    isIterateeCall = __webpack_require__(106);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ 803:
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ 804:
/***/ (function(module, exports, __webpack_require__) {

var compareAscending = __webpack_require__(805);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ 805:
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(78);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ 806:
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ 816:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instance = null;

var Recorder = function Recorder(source) {
  var _this = this;

  (0, _classCallCheck3.default)(this, Recorder);

  this.getMimeType = function () {
    var _arr = ['video/webm', 'video/mp4'];

    for (var _i = 0; _i < _arr.length; _i++) {
      var mt = _arr[_i];
      if (MediaRecorder.isTypeSupported(mt)) {
        return mt;
      }
    }
    return 'video/webm';
  };

  this.cancel = function () {
    if (_this.timer) {
      clearTimeout(_this.timer);
      _this.handleResolve(false);
    }
  };

  this.handleResolve = function (result) {
    _this.resolve(result);
    _this.recording = false;
  };

  this.record = function (mediaSource) {
    var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;
    var ms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;
    return new _promise2.default(function (resolve) {
      if (_this.recording) {
        resolve(false);
        return;
      }
      _this.resolve = resolve;
      _this.recording = true;
      _this.valid = false;
      try {
        var stream = mediaSource.domElement ? mediaSource.domElement.captureStream(fps) : mediaSource.streams[0];
        var recorder = new MediaRecorder(stream, { mimeType: _this.getMimeType() });
        var chunks = [];
        recorder.ondataavailable = function (e) {
          chunks.push(e.data);
        };
        recorder.onstop = function () {
          if (!_this.valid) {
            _this.handleResolve(false);
            return;
          }
          _this.handleResolve(new Blob(chunks, { type: _this.getMimeType() }));
        };
        recorder.start();
        // store ImageData for iOS under 15.4
        if (_browserUtils2.default.isIOsVersionAndMinorVersionUnder(15, 4)) {
          _this.recordImageDataForIOs15(fps, ms, performance.now());
        }
        _this.timer = setTimeout(function () {
          _this.timer = null;
          if (recorder.state === 'inactive') {
            _this.handleResolve(false);
            return;
          }
          _this.valid = true;
          recorder.stop();
        }, ms);
      } catch (err) {
        console.log('failed to record', err);
        _this.handleResolve(false);
      }
      _this.recording = false;
    });
  };

  this.recordImageDataForIOs15 = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
      var fps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;
      var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
      var startTime = arguments[2];
      var chunkImages, stopByUser;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              chunkImages = [];
              stopByUser = false;

              _this.source.emitter.once(_events2.default.recordCancelled, function () {
                return stopByUser = true;
              });

            case 3:
              if (false) {
                _context.next = 14;
                break;
              }

              if (!stopByUser) {
                _context.next = 6;
                break;
              }

              return _context.abrupt('return');

            case 6:
              if (!(performance.now() - startTime > ms)) {
                _context.next = 9;
                break;
              }

              _this.source.recordingImageDataForIOs15 = chunkImages;
              return _context.abrupt('return');

            case 9:
              chunkImages.push(_mediaUtils2.default.getImageData4Mobile(_this.source));
              _context.next = 12;
              return new _promise2.default(function (resolve) {
                return setTimeout(resolve, 500 / fps);
              });

            case 12:
              _context.next = 3;
              break;

            case 14:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function () {
      return _ref.apply(this, arguments);
    };
  }();

  if (instance) {
    return instance;
  }
  instance = this;
  this.recording = false;
  this.valid = false;
  this.source = source;
};

exports.default = Recorder;
module.exports = exports['default'];

/***/ }),

/***/ 817:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _debugUtils = __webpack_require__(791);

var _debugUtils2 = _interopRequireDefault(_debugUtils);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _settings = __webpack_require__(39);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ENGINE_POINTER = void 0;
var GOOD_FACES_THRESHOLD = 5;

var AbstractMediaSource = function AbstractMediaSource(props) {
  var _this = this;

  (0, _classCallCheck3.default)(this, AbstractMediaSource);

  this.addBeforeCloseTask = function (t) {
    return _this.beforeCloseTasks.push(t);
  };

  this.handleBeforeCloseTasks = function () {
    if (!_this.beforeCloseTasks || !_this.beforeCloseTasks.length) {
      return;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(_this.beforeCloseTasks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var t = _step.value;

        if ((0, _isFunction3.default)(t)) {
          try {
            t();
          } catch (err) {
            console.log({ t: t, err: err });
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  this.getFrameDocument = function (document, frameId) {
    var frame = document.getElementById(frameId);
    if (!frame) {
      return;
    }
    return frame.contentDocument || frame.contentWindow.document;
  };

  this.calDeltaE = function (rgb1, rgb2) {
    return _this.venus_makeup_live && _this.venus_makeup_live.CalculateDeltaE(rgb1, rgb2);
  };

  this.zoomWebGLRender = function (zoomRatio, width, height, centerX, centerY) {
    return _mediaUtils2.default.zoomWebGLRenderer(_this.renderer, zoomRatio, width, height, centerX, centerY);
  };

  this.openFaceQualityChecker = function () {
    if (!_this.faceQualityChecker) {
      return;
    }
    _this.goodFaces4Headless = 0;
    _this.settings.isGoodFacesEnough4Headless = false;
    _this.faceQualityChecker && _this.faceQualityChecker.open();
  };

  this.closeFaceQualityChecker = function () {
    if (!_this.faceQualityChecker) {
      return;
    }
    _this.faceQualityChecker && _this.faceQualityChecker.close();
    setTimeout(function () {
      return _this.face_align_data_of_face_quality_checker = null;
    }, 3000);
  };

  this.isFaceQualityChecking = function () {
    return !!_this.faceQualityChecker && _this.faceQualityChecker.opened;
  };

  this.checkFaceQuality = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(imageData) {
      var r;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (_this.faceQualityChecker) {
                _context.next = 2;
                break;
              }

              return _context.abrupt('return');

            case 2:
              if (_this.faceQualityChecker.opened) {
                _context.next = 4;
                break;
              }

              return _context.abrupt('return');

            case 4:
              _context.next = 6;
              return _this.faceQualityChecker.checkFaceQuality(imageData);

            case 6:
              r = _context.sent;

              _this.hasFace = (0, _get3.default)(r, 'face_quality.hasFace', false);
              if (r && r.face_quality) {
                _this.emitter.trigger(_events2.default.faceQualityChanged, [_this.adjustFaceQuality4Headless(r.face_quality, GOOD_FACES_THRESHOLD)]);
              }
              if (r && r.face_rect_data) {
                _this.face_rect_data = r.face_rect_data;
                _this.face_rect_data.noflip = _this.needToFlipVideoStream;
              }
              if (r && r.face_align_data) {
                _this.face_align_data_of_face_quality_checker = r.face_align_data;
              }
              return _context.abrupt('return', r);

            case 12:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this.adjustFaceQuality4Headless = function (r) {
    var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

    if (!_this.settings.isHeadlessMode() || (0, _isUndefined3.default)(r)) {
      return r;
    }
    var lightingPassed = r.lighting === 'good' || r.lighting === 'ok';
    var frontalPassed = r.frontal === 'good';
    var positionPassed = r.area === 'good' && (!r.faceangle || r.faceangle === 'good');
    if (lightingPassed && frontalPassed && positionPassed) {
      _this.goodFaces4Headless += 1;
    }
    if (_this.goodFaces4Headless < threshold) {
      r.lighting = 'notgood';
    } else {
      _this.settings.isGoodFacesEnough4Headless = true;
    }
    return r;
  };

  this.beginShadeFinder = function () {
    if (!_this.shadefinder) {
      return;
    }

    _this.shadefinder && _this.shadefinder.beginShadeFinder();
    // this.faceQualityChecker && this.faceQualityChecker.resume();
    // this.emitter.once(events.shadeFindComplete, this.faceQualityChecker.pause);
  };

  this.cancelShadeFinder = function () {
    return _this.shadefinder && _this.shadefinder.cancelShadeFinder();
  };

  this.findShadeIfNecessary = function (image_data, check_face_quality_result) {
    if (!image_data) {
      return;
    }
    if (!check_face_quality_result) {
      return;
    }
    if (!_this.shadefinder) {
      return;
    }
    var face_quality = (0, _get3.default)(check_face_quality_result, 'face_quality', {});
    if (face_quality.area === 'good' && face_quality.frontal === 'good' && (face_quality.lighting === 'good' || face_quality.lighting === 'ok')) {
      _this.shadefinder.findShade((0, _extends3.default)({ image_data: image_data }, check_face_quality_result));
    }
  };

  this.predictFaceAttribute = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
    var lastQualified, lastQualifieds, eyebrowColor, skinColor, hairColor;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (_this.faceaiattribute) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt('return');

          case 2:
            if (_this.faceQualityChecker) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt('return');

          case 4:
            lastQualified = _this.faceQualityChecker.getLastQualified();

            if ((0, _keys2.default)(lastQualified).length === 0) {
              lastQualified = _this._generateFakeLastQualified();
            }
            lastQualifieds = _this.faceQualityChecker.getLastQualifieds();

            if (!lastQualifieds || !lastQualified.length) {
              lastQualifieds = [lastQualified, lastQualified, lastQualified, lastQualified, lastQualified];
            }
            _this.dump(lastQualified);
            eyebrowColor = _this.getEyebrowColorIfNecessary(lastQualified);
            _context2.next = 12;
            return _this.getSkinColorIfNecessary(lastQualified);

          case 12:
            skinColor = _context2.sent;
            _context2.next = 15;
            return _this.getHairColorIfNecessary();

          case 15:
            hairColor = _context2.sent;

            _this.faceaiattribute.setExternalResults({ eyebrowColor: eyebrowColor, skinColor: skinColor, hairColor: hairColor });
            _this.faceaiattribute.predict(lastQualified, lastQualifieds);

          case 18:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  this.dump = function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(lq) {
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (_this.settings.debug) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return');

            case 2:
              _debugUtils2.default.cleanOutputImageData('debug-image');
              _context3.next = 5;
              return _debugUtils2.default.outputImageData(lq.imageData, 'debug-image');

            case 5:
              _debugUtils2.default.outputFaceRect(lq.result.face_rect_data, 'debug-image');
              _debugUtils2.default.outputLandmarks(lq.result.face_align_data, _this.render_width || _this.camera_width, _this.render_height || _this.camera_height, 'debug-image');

            case 7:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  this._generateFakeLastQualified = function () {
    if (_this.type !== 'image') {
      return {};
    }
    if (!_this.imageData) {
      return {};
    }
    var flipedImageData = _mediaUtils2.default.flipImageData(_this.imageData, _this.imageData.width, _this.imageData.height, document);
    return {
      imageData: flipedImageData,
      result: {
        face_quality: { area: 'good', frontal: 'good', lighting: 'good', nakedeye: 'good', hasFace: true },
        face_rect_data: _this._flipRectData(_this.face_rect_vec && _this.face_rect_vec.get(0), _this.imageData.width),
        face_align_data: _this.face_align_data_vec && _this.face_align_data_vec.get(0),
        face_check_result: {
          black_level: 62,
          face_area: 3,
          face_frontal: 2,
          lighting: 2,
          lighting_ratio: 0.5176470875740051,
          naked_eye: 0,
          white_level: 194
        }
      }
    };
  };

  this._flipRectData = function (data, width) {
    if (!data) {
      return {};
    }
    return (0, _extends3.default)({}, data, {
      left: width - data.right,
      right: width - data.left
    });
  };

  this._isFaceAttributeColorFeatureEnabled = function () {
    return (0, _get3.default)(_this, 'settings.faceAttributeFeatures.color', false);
  };

  this.getHairColor = function () {};

  this.getHairColorIfNecessary = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (_this._isFaceAttributeColorFeatureEnabled()) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt('return');

          case 2:
            _context4.next = 4;
            return _this.getHairColor();

          case 4:
            return _context4.abrupt('return', _context4.sent);

          case 5:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, _this);
  }));

  this.getSkinColorIfNecessary = function (lastQualified) {
    return new _promise2.default(function () {
      var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(resolve) {
        var i, imageData, result;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (_this._isFaceAttributeColorFeatureEnabled()) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt('return', resolve());

              case 2:
                if (_this.shadefinder) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt('return', resolve());

              case 4:
                i = 0;

              case 5:
                if (!(i < 200)) {
                  _context5.next = 15;
                  break;
                }

                if (!_this.shadefinder.report) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt('return', resolve(_this.shadeFinderReport2Hex(_this.shadefinder.report)));

              case 8:
                imageData = lastQualified.imageData, result = lastQualified.result;

                _this.shadefinder.findShade((0, _extends3.default)({ image_data: imageData }, result));
                _context5.next = 12;
                return _browserUtils2.default.sleep(200);

              case 12:
                i++;
                _context5.next = 5;
                break;

              case 15:
                return _context5.abrupt('return', resolve());

              case 16:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, _this);
      }));

      return function (_x4) {
        return _ref5.apply(this, arguments);
      };
    }());
  };

  this.shadeFinderReport2Hex = function (report) {
    var lab = (0, _get3.default)(report, 'detail.rm200qc_skin_tone_lab');
    if (_this.settings.enableFaceAttributeSkinColorAppearance) {
      lab = _mathUtils2.default.lab2AppearanceLab(lab);
    }
    return _mathUtils2.default.lab2Hex([lab.L, lab.a, lab.b]);
  };

  this.getEyebrowColorIfNecessary = function (lastQualified) {
    if (!_this._isFaceAttributeColorFeatureEnabled()) {
      return;
    }

    return _this.getEyebrowColor(lastQualified);
  };

  this.getEyebrowColor = function () {};

  this.doTracking = function () {
    var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(frameBuffer, frame, cropBuffer, cropFrame, width, height, isPhoto) {
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (_this.faceTrackingManager) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt('return');

            case 2:
              _context6.next = 4;
              return _this.faceTrackingManager.doTracking(frameBuffer, frame, cropBuffer, cropFrame, width, height, isPhoto);

            case 4:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, _this);
    }));

    return function (_x5, _x6, _x7, _x8, _x9, _x10, _x11) {
      return _ref6.apply(this, arguments);
    };
  }();

  this.getFaceRactFromFaceTrackingManager = function () {
    if (!_this.faceTrackingManager) {
      return;
    }
    var r = _this.faceTrackingManager.getLandmarkBBox();
    if (!r || !r.length) {
      return;
    }
    if (r[0] === -1) {
      return;
    }
    return {
      left: (0, _toInteger3.default)(r[0]),
      top: (0, _toInteger3.default)(r[1]),
      right: (0, _toInteger3.default)(r[0] + r[2]),
      bottom: (0, _toInteger3.default)(r[1] + r[3])
    };
  };

  this.isMouthOccluded = function () {
    return _this.faceTrackingManager && _this.faceTrackingManager.mouthOccluded;
  };

  this.createVenusMakeupLive = function () {
    if (!ENGINE_POINTER) {
      var t = new _this.YMKModule.ValObject();
      _this.YMKModule.CreateVenusLiveObject(_this.YMKModule.IID_VENUS_MAKEUP_LIVE, t);
      ENGINE_POINTER = t.value;
    }
    _this.venus_makeup_live = ENGINE_POINTER;
  };

  this.getFeatures = function () {
    return (0, _get3.default)(_this, 'settings.features', {});
  };

  this.getFunctionType = function () {
    return (0, _get3.default)(_this, 'settings.functionType');
  };

  this.changeEyewearPD = function () {
    if (!_this.resized) {
      return;
    }
    _this.update();
  };

  this.cleanUpValues = function (values) {
    if (!values) {
      return;
    }
    if (!values.length) {
      return;
    }
    for (var i = values.length - 1; i >= 0; i--) {
      if (values[i]) {
        try {
          values[i].delete();
          values[i] = null;
        } catch (err) {
          console.log(err);
        }
      }
    }
  };

  this.shadefinder = undefined;
  this.faceQualityChecker = undefined;
  this.faceaiattribute = undefined;
  this.checks = 0;
  this.faceTrackingManager = undefined;
  this.venus_makeup_live = undefined;
  this.YMKModule = props.YMKModule;
  this.document = props.document;
  this.canvasDocId = props.canvasDocId;
  if (props.settings.isHeadlessMode()) {
    this.canvas = document.createElement('canvas');
    this.compareIndicator = document.createElement('canvas'); // TODO: check whether this element is necessary
  } else {
    this.canvas = this.document.getElementById(props.canvasDocId);
    this.compareIndicator = this.getFrameDocument(props.document, props.frameId).getElementById(props.compareIndicatorId);
  }
  this.controller = props.controller;
  this.emitter = props.emitter;
  this.errorCallback = props.errorCallback;
  this.frameId = props.frameId;
  this.makeup_live_filter = props.makeup_live_filter;
  this.outputId = props.outputId;
  this.params = props.params;
  this.renderer = props.renderer;
  this.settings = props.settings;
  this.type = props.type;
  this.featurePoints = props.featurePoints;
  this.mediaSource = props.mediaSource;
  this.loaded = false;
  this.faceDetectionDetail = {};
  this.beforeCloseTasks = [];

  this._prerender = function () {};
};

exports.default = AbstractMediaSource;
module.exports = exports['default'];

/***/ }),

/***/ 818:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _class, _temp, _initialiseProps;

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _ = __webpack_require__(303);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VideoStreamTrackWebcam = (_temp = _class = function VideoStreamTrackWebcam(docId, emitter, videoStreamTrack, videoElement) {
  (0, _classCallCheck3.default)(this, VideoStreamTrackWebcam);

  _initialiseProps.call(this);

  this.emitter = emitter;
  this.streams = [];
  if (!!videoElement) {
    this.video = videoElement;
  } else {
    this.docId = docId;
    this.video = document.getElementById(this.docId);
  }
  this.type = _.TYPES.videostreamtrack;
  this.videoStreamTrack = videoStreamTrack;
}, _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.isFlipped = function () {
    return false;
  };

  this.init = function (successCallback) {
    _this.video = _this.video || document.getElementById(_this.docId);
    _this.video.ready = false;
    _this.video.oncanplaythrough = function () {
      return _this.video.ready = true;
    };
    _this.video.onerror = function () {
      return _this.stop();
    };
    _this.needReload = true;
    _this.video.onpause = function () {
      return _this.isPaused = true;
    };
    _this.video.onplay = function () {
      if (!_this.isPaused) {
        return;
      }
      _this.isPaused = false;
      if (!_this.needReload) {
        return;
      }
      _this.needReload = true;
    };
    _this.isPaused = false;
    _this.successCallback = successCallback;
    _this.gotStream(new MediaStream([_this.videoStreamTrack]));
  };

  this.gotStream = function (stream) {
    if (_browserUtils2.default.isIOs() || _browserUtils2.default.isSafari()) {
      _this.video.setAttribute('playsinline', '');
      _this.video.style.display = 'block';
      _this.video.style.float = 'left';
      _this.video.style.position = 'absolute';
      _this.video.style.zIndex = 0;
      _this.video.srcObject = stream;
      _this.video.play();
    } else if (_browserUtils2.default.isAndroid()) {
      try {
        _this.video.srcObject = stream;
        _this.video.play();
      } catch (err) {
        _this.video.src = window.URL.createObjectURL(stream);
      }
    } else if (window.URL) {
      try {
        _this.video.srcObject = stream;
      } catch (err) {
        _this.video.src = window.URL.createObjectURL(stream);
      }
    } else if (window.webkitURL) {
      _this.video.src = window.webkitURL.createObjectURL(stream);
    } else {
      _this.video.src = stream; // Opera
    }
    _this.emitter.trigger(_events2.default.cameraOpened);
    _this.successCallback && _this.successCallback();
    _this.successCallback = null;
  };

  this.changeVideoSource = function (videoStreamTrack) {
    _this.videoStreamTrack = videoStreamTrack;
    _this.gotStream(new MediaStream([_this.videoStreamTrack]));
  };

  this.isStopped = function () {
    return false;
  };

  this.stop = function () {};

  this.resume = function () {};
}, _temp);
exports.default = VideoStreamTrackWebcam;
module.exports = exports['default'];

/***/ }),

/***/ 819:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VideoFileWebcam = function VideoFileWebcam(settings, emitter, videoFile) {
  var _this = this;

  var frameRate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;
  (0, _classCallCheck3.default)(this, VideoFileWebcam);

  this.isFlipped = function () {
    return false;
  };

  this.isVideoFile = function () {
    return true;
  };

  this.init = function (successCallback) {
    _this.video = document.getElementById(_this.docId);
    _this.video.ready = false;
    _this.video.oncanplaythrough = function () {
      return _this.video.ready = true;
    };
    _this.video.onerror = function () {
      return _this.stop();
    };
    _this.needReload = true;
    _this.video.onpause = function () {
      return _this.isPaused = true;
    };
    _this.video.onplay = function () {
      if (!_this.isPaused) {
        return;
      }
      _this.isPaused = false;
      if (!_this.needReload) {
        return;
      }
      _this.needReload = true;
    };
    _this.video.setAttribute('loop', '');
    _this.isPaused = false;
    _this.successCallback = successCallback;

    _this.autoTestFrameIndex = -1;
    _this.autoTestSnapshotIndexes.length = 0;
    _this.autoTestSnapshotResult = {};
    _this.gotStream();
  };

  this.gotStream = function () {
    _this.video.src = window.URL.createObjectURL(_this.videoFile);
    _this.video.muted = true;
    _this.video.play();
    _this.emitter.trigger(_events2.default.cameraOpened);
    _this.successCallback && _this.successCallback();
    _this.successCallback = null;
  };

  this.changeVideoSource = function () {};

  this.goToNextFrame = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new _promise2.default(function (resolve) {
              _this.video.onseeked = function () {
                resolve();
              };
              _this.handleNextIndex();
              _this.video.currentTime = _this.autoTestFrameIndex * (1 / _this.frameRate) % _this.video.duration;
            });

          case 2:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.handleNextIndex = function () {
    _this.autoTestFrameIndex = Math.floor((_this.autoTestFrameIndex + 1) % (_this.video.duration * _this.frameRate));
  };

  this.handleSnapshotVideoFrame = function (frameIndexes) {
    if (!_this.settings.videoAutoTesting) {
      _this.emitter.trigger(_events2.default.snapshotVideoFrameComplete, [false]);
      return;
    }
    _this.autoTestSnapshotIndexes = frameIndexes;
  };

  this.handleSnapshotVideoFrameComplete = function (renderer) {
    if ((0, _isUndefined3.default)(_this.autoTestSnapshotResult[_this.autoTestFrameIndex])) {
      _this.autoTestSnapshotResult[_this.autoTestFrameIndex] = _mediaUtils2.default.result2Blob(renderer);
    }
    if ((0, _keys2.default)(_this.autoTestSnapshotResult).length === _this.autoTestSnapshotIndexes.length) {
      _this.emitter.trigger(_events2.default.snapshotVideoFrameComplete, [_this.autoTestSnapshotResult]);
      _this.autoTestSnapshotIndexes.length = 0;
      _this.autoTestSnapshotResult = {};
    }
  };

  this.snapshot4AutoTest = function (renderer) {
    if (_this.autoTestFrameIndex >= 0 && _this.autoTestSnapshotIndexes.includes(_this.autoTestFrameIndex)) {
      _this.handleSnapshotVideoFrameComplete(renderer);
    }
  };

  this.isStopped = function () {
    return false;
  };

  this.stop = function () {};

  this.resume = function () {};

  this.emitter = emitter;
  this.streams = [];
  this.settings = settings;
  this.docId = settings.videoId;
  this.video = document.getElementById(this.docId);
  this.videoFile = videoFile;
  this.facingMode = this.settings.videoTestingFacingMode;
  this.settings.facingMode = this.settings.videoTestingFacingMode;

  // for auto-test
  this.frameRate = frameRate;
  this.autoTestFrameIndex = -1;
  this.autoTestSnapshotIndexes = [];
  this.autoTestSnapshotResult = {};
  this.emitter.on(_events2.default.snapshotVideoFrame, this.handleSnapshotVideoFrame);
};

exports.default = VideoFileWebcam;
module.exports = exports['default'];

/***/ }),

/***/ 820:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _class, _temp, _initialiseProps;

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _index = __webpack_require__(303);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlobWebcam = (_temp = _class = function BlobWebcam(docId, emitter, blob) {
  (0, _classCallCheck3.default)(this, BlobWebcam);

  _initialiseProps.call(this);

  this.emitter = emitter;
  this.streams = [];
  this.docId = docId;
  this.type = _index.TYPES.blob;
  this.video = document.getElementById(this.docId + '1');
  this.blob = blob;
}, _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.resume = function () {
    _this.init();
  };

  this.setBlob = function (blob) {
    return _this.blob = blob;
  };

  this.isFlipped = function () {
    return false;
  };

  this.init = function (successCallback) {
    _this.video = document.getElementById(_this.docId + '1');
    _this.video.ready = false;
    _this.video.oncanplaythrough = function () {
      return _this.video.ready = true;
    };
    _this.video.onerror = function () {
      return _this.stop();
    };
    _this.video.onpause = function () {
      return _this.isPaused = true;
    };
    _this.isPaused = false;
    _this.successCallback = successCallback;
    _this.gotStream(_this.blob);
  };

  this.gotStream = function (blob) {
    var url = window.URL.createObjectURL(blob);
    _this.video.setAttribute('autoplay', 'true');
    _this.video.onplay = function () {
      return _this.emitter.trigger(_events2.default.videoSourceStarted);
    };
    _this.video.onended = function () {
      _this.emitter.trigger(_events2.default.videoSourceEnded);
      _this.video.play();
    };
    _this.video.ready = true;
    if (_browserUtils2.default.isIOs() || _browserUtils2.default.isSafari()) {
      _this.video.srcObject = null;
      _this.video.src = null;
      _this.video.setAttribute('playsinline', '');
      _this.video.style.display = 'block';
      _this.video.style.float = 'left';
      _this.video.style.position = 'absolute';
      _this.video.style.zIndex = 0;
      _this.video.src = url;
    } else {
      _this.video.srcObject = undefined;
      _this.video.src = url;
    }
    if (_browserUtils2.default.isAndroid()) {
      try {
        _this.video.play();
      } catch (err) {}
    }
    _this.emitter.trigger(_events2.default.cameraOpened);
    _this.successCallback && _this.successCallback();
    _this.successCallback = null;
  };

  this.changeVideoSource = function (blob) {
    _this.blob = blob;
    _this.gotStream(blob);
  };

  this.isStopped = function () {
    return !_this.video.ready;
  };

  this.stop = function () {
    if (!_this.video) {
      return;
    }
    try {
      _this.video.pause();
      _this.video.ready = false;
    } catch (err) {
      console.error('stop err', err);
    }
  };
}, _temp);
exports.default = BlobWebcam;
module.exports = exports['default'];

/***/ }),

/***/ 829:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(100);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _isNaN2 = __webpack_require__(135);

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _uniq2 = __webpack_require__(138);

var _uniq3 = _interopRequireDefault(_uniq2);

var _includes2 = __webpack_require__(34);

var _includes3 = _interopRequireDefault(_includes2);

var _throttle2 = __webpack_require__(25);

var _throttle3 = _interopRequireDefault(_throttle2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _recorder = __webpack_require__(816);

var _recorder2 = _interopRequireDefault(_recorder);

var _tfjsUtils = __webpack_require__(105);

var _tfjsUtils2 = _interopRequireDefault(_tfjsUtils);

var _settings = __webpack_require__(39);

var _headlessModeUtils = __webpack_require__(833);

var _headlessModeUtils2 = _interopRequireDefault(_headlessModeUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FPS_ROUNDS_PER_COUNT = 20;

exports.default = function (superclass) {
  return function (_superclass) {
    (0, _inherits3.default)(_class2, _superclass);

    function _class2(params) {
      var _this2 = this;

      (0, _classCallCheck3.default)(this, _class2);

      var _this = (0, _possibleConstructorReturn3.default)(this, (_class2.__proto__ || (0, _getPrototypeOf2.default)(_class2)).call(this, params));

      _this.getImageData = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        var context;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(_this.settings.videoAutoTesting && (0, _isFunction3.default)(_this.webcam.isVideoImages) && _this.webcam.isVideoImages())) {
                  _context.next = 4;
                  break;
                }

                _context.next = 3;
                return _this.webcam.getImageData(_this.camera_sx, _this.camera_sy, _this.camera_width, _this.camera_height);

              case 3:
                return _context.abrupt('return', _context.sent);

              case 4:
                if (!_this.webcam.isStopped()) {
                  _context.next = 7;
                  break;
                }

                context = _this.canvas.getContext('2d');
                return _context.abrupt('return', context.getImageData(0, 0, _this.camera_width, _this.camera_height));

              case 7:
                return _context.abrupt('return', _browserUtils2.default.isMobile() ? _mediaUtils2.default.getImageData4Mobile(_this) : _mediaUtils2.default.getImageData4Desktop(_this));

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));
      _this.handleOrientationChange = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _browserUtils2.default.sleep(100);

              case 2:
                _this.resized = false;

                if (!_browserUtils2.default.isIOs17AndAbove()) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 6;
                return _browserUtils2.default.sleep(500);

              case 6:
                _this.resized = false;

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this2);
      }));

      _this.handleVideoSourceChanged = function (_videoStreamTrack, needToFlipVideoStream) {
        _this.needToFlipVideoStream = needToFlipVideoStream;
        _this.resized = false;
        _this.render();
      };

      _this.setWebcam = function (webcam) {
        _this.webcam = webcam;
        _this.resized = false;
        _this.video = webcam.video;
      };

      _this.handleSizeChanged = function (width, height) {
        _this.display_width = width;
        _this.display_height = height;
        _this.resized = false;
      };

      _this.resize = function (w, h) {
        try {
          if ((0, _get3.default)(_this, 'settings.functionType') === _functionTypes2.default.shadefinder || (0, _get3.default)(_this, 'settings.functionType') === _functionTypes2.default.faceattribute || (0, _get3.default)(_this, 'settings.functionType') === _functionTypes2.default.livestream || !(0, _get3.default)(_this, 'settings.enableHeadTracking', false)) {
            _this._resize4Mobile(w, h);
            if (_browserUtils2.default.isSafari()) {
              _this._resizeStreamCanvas();
            }
            return;
          }
          return _browserUtils2.default.isMobile() ? _this._resize4Mobile(w, h) : _this._resize4Desktop(w, h);
        } finally {
          _this.emitter.trigger(_events2.default.resized);
        }
      };

      _this._resizeStreamCanvas = function () {
        _this.streamCanvas.width = _this.camera_width;
        _this.streamCanvas.height = _this.camera_height;
        _this.streamContext = _this.streamCanvas.getContext('2d');
      };

      _this.handle4LiveStream = function () {
        if (!_browserUtils2.default.isSafari()) {
          return;
        }
        if ((0, _get3.default)(_this, 'settings.functionType', '') !== _functionTypes2.default.livestream && (0, _get3.default)(_this, 'settings.moduleMode') !== _settings.moduleModes.headless) {
          return;
        }
        _this.streamContext.drawImage(_this.renderer.domElement, 0, 0, _this.camera_width, _this.camera_height);
      };

      _this._resize4Mobile = function (videoWidth, videoHeight) {
        _this.videoWidth = videoWidth;
        _this.videoHeight = videoHeight;
        if (_this.display_width / _this.display_height > videoWidth / videoHeight) {
          _this.camera_width = _mathUtils2.default.toEvenNumber(videoWidth);
          _this.camera_height = _mathUtils2.default.toEvenNumber(_this.display_height / _this.display_width * videoWidth);
          _this.camera_sx = 0;
          _this.camera_sy = Math.round((videoHeight - _this.camera_height) / 2);
        } else {
          _this.camera_width = _mathUtils2.default.toEvenNumber(_this.display_width / _this.display_height * videoHeight);
          _this.camera_height = _mathUtils2.default.toEvenNumber(videoHeight);
          _this.camera_sx = Math.round((videoWidth - _this.camera_width) / 2);
          _this.camera_sy = 0;
        }
        // if (browserUtils.isMobile() && (this.camera_width === 720 || this.camera_height === 720) && (this.camera_width > 720 || this.camera_height > 720)) {
        //   if (this.camera_width > 720) {
        //     this.camera_height = mathUtils.toEvenNumber((this.camera_height / this.camera_width) * 720);
        //     this.camera_width = 720;
        //   } else {
        //     this.camera_width = mathUtils.toEvenNumber((this.camera_width / this.camera_height) * 720);
        //     this.camera_height = 720;
        //   }
        //   this.camera_sx = Math.round((videoWidth - this.camera_width) / 2);
        //   this.camera_sy = Math.round((videoHeight - this.camera_height) / 2);
        // }

        _this.canvas.width = _this.camera_width;
        _this.canvas.height = _this.camera_height;
        _this.m_smoothed_center_x = _this.settings.compareMode === _settings.compareModes.split ? _this.display_width * 0.5 : _this.display_width;
        _this.renderer.setSize(_this.camera_width, _this.camera_height);
        _this.makeup_live_filter.ResetWidthHeight(_this.camera_width, _this.camera_height);
        _this.renderer.domElement.style.width = _this.display_width + 'px';
        _this.renderer.domElement.style.height = _this.display_height + 'px';
        _this.videoTexture = _this.makeup_live_filter.createVideoTexture(_this.camera_width, _this.camera_height);
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothStrength)) {
          _this.makeup_live_filter.SetSkinSmoothStrength(_this.settings.skinSmoothStrength);
        }
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothColorIntensity)) {
          _this.makeup_live_filter.SetSkinSmoothColorIntensity(_this.settings.skinSmoothColorIntensity);
        }
        _this.makeup_live_filter.SetInputTexture(_this.videoTexture);
        _this.makeup_live_filter.SetBypassMode(false);
        if (_this.settings.getFunctionType() !== _functionTypes2.default.handar) {
          if (_browserUtils2.default.isQQBrowser() || _this.needToFlipVideoStream || _this.settings.facingMode === 'environment' || _this.settings.isHeadlessInput()) {
            _this.videoContext.translate(_this.camera_width, 0);
            _this.videoContext.scale(-1, 1);
          }
        }
        _this._AllocateFrameBuffer(_this.camera_width, _this.camera_height);
      };

      _this._resize4Desktop = function (inputVideoWidth, inputVideoHeight) {
        var videoWidth = inputVideoWidth;
        var videoHeight = inputVideoHeight;
        _this.camera_sx = 0;
        _this.camera_sy = 0;
        var functionType = (0, _get3.default)(_this, 'settings.functionType', '');
        if ((0, _includes3.default)([_functionTypes2.default.shadefinder, _functionTypes2.default.faceattribute, _functionTypes2.default.skincare], functionType) && videoWidth > videoHeight) {
          if (videoWidth === 1280 && videoHeight === 720) {
            videoWidth = videoHeight;
            _this.camera_sx = _mathUtils2.default.toEvenNumber((inputVideoWidth - inputVideoHeight) / 2);
          }
        }
        _this.videoWidth = videoWidth;
        _this.videoHeight = videoHeight;
        _this.video_width = videoWidth;
        _this.video_height = videoHeight;
        var width = _mathUtils2.default.toEvenNumber(videoWidth * _this.display_height * _this.resizeRatio / videoHeight);
        var height = _mathUtils2.default.toEvenNumber(_this.display_height * _this.resizeRatio);
        _this.camera_width = width;
        _this.camera_height = height;
        _this.canvas.width = width;
        _this.canvas.height = height;
        _this.window_width = _this.display_width;
        _this.window_height = _this.display_height;
        _this.crop_offset = Math.round((width / _this.resizeRatio - _this.display_width) / 2);
        _this.crop_width = width;
        _this.m_smoothed_center_x = width * 0.5;
        _this.renderer.setSize(_mathUtils2.default.toEvenNumber(_this.display_width * _this.resizeRatio), height);
        _this.makeup_live_filter.ResetWidthHeight(width, height);
        if (_this.needToFlipVideoStream) {
          _this.videoContext.translate(width, 0);
          _this.videoContext.scale(-1, 1);
        }
        _this.renderer.domElement.style.width = _this.display_width + 'px';
        _this.renderer.domElement.style.height = Math.round(height / _this.resizeRatio) + 'px';
        _this.videoTexture = _this.makeup_live_filter.createVideoTexture(width, height);
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothStrength)) {
          _this.makeup_live_filter.SetSkinSmoothStrength(_this.settings.skinSmoothStrength);
        }
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothColorIntensity)) {
          _this.makeup_live_filter.SetSkinSmoothColorIntensity(_this.settings.skinSmoothColorIntensity);
        }
        _this.makeup_live_filter.SetInputTexture(_this.videoTexture);
        _this.makeup_live_filter.SetBypassMode(false);
        _this._AllocateFrameBuffer(width, height);
      };

      _this.isVideoReslutionChanged = function (w, h) {
        return _this.videoWidth !== w || _this.videoHeight !== h;
      };

      _this.getResizeRatio = _mediaUtils2.default.getResizeRatio;

      _this._AllocateFrameBuffer = function (width, height) {
        if (width === 0 || !height) {
          return;
        }
        if (_this.venus_frame_buffer) {
          _this.YMKModule._free(_this.venus_frame_buffer);
          _this.venus_frame_buffer = null;
          _this.web_frame_buffer = null;
        }
        _this.venus_frame_buffer = _this.YMKModule._malloc(width * height * 4);
        _this.web_frame_buffer = new Uint8Array(_this.YMKModule.HEAPU8.buffer, _this.venus_frame_buffer, width * height * 4);
      };

      _this.pause = function () {
        var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
          var stopWebcam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!_this.isPaused) {
                    _context3.next = 3;
                    break;
                  }

                  _this.emitter && _this.emitter.trigger(_events2.default.paused);
                  return _context3.abrupt('return');

                case 3:
                  _context3.next = 5;
                  return _this._prerender();

                case 5:
                  _this.blob = _mediaUtils2.default.result2Blob(_this.renderer);
                  _this.pauseTimer();
                  if (stopWebcam) {
                    _this.webcam.stop();
                  } else {
                    (0, _isFunction3.default)(_this.update) && _this.update();
                  }
                  _this.isPaused = true;
                  _this.emitter && _this.emitter.trigger(_events2.default.paused);
                  _context3.next = 12;
                  return _this._prerender();

                case 12:
                  _this.blob = _mediaUtils2.default.result2Blob(_this.renderer);

                case 13:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, _this2);
        }));

        return function () {
          return _ref3.apply(this, arguments);
        };
      }();

      _this.pauseTimer = function () {
        if (_this.isPaused) {
          return;
        }
        if (!_this.timer) {
          return;
        }
        window.cancelFrame(_this.timer);
        _this.timer = null;
      };

      _this.resumeTimer = function () {
        if (_this.isPaused) {
          return;
        }
        _this.timer = window.requestFrame(_this.render);
      };

      _this.resume = function (restartWebcam) {
        if (restartWebcam) {
          _this.webcam.restart();
        }
        if (!_this.isPaused) {
          return;
        }
        _this.isPaused = false;
        _this.resumeTimer();
        _this.webcam.resume();
      };

      _this.handleCameraFlipped = function () {
        if (_this.settings.getFunctionType() === _functionTypes2.default.handar) {
          return;
        }
        _mediaUtils2.default.handleCameraFlipped(_this.videoContext, _this.camera_width);
      };

      _this.isVideoResolutionChanged = function (w, h) {
        if (!_browserUtils2.default.isMobile()) {
          return false;
        }
        return _this.videoWidth !== w || _this.videoHeight !== h;
      };

      _this.render = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
        var faceTrackingManagerBegin, b, faceTrackingManagerTime, faceQualityCheckerBegin, _b, faceQualityCheckerTime;

        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!_this.terminalized) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt('return');

              case 2:
                if (!(_this.video.paused || !_this.video.ready || !_this.video.videoWidth || !_this.video.videoHeight)) {
                  _context4.next = 5;
                  break;
                }

                _this.timer = setTimeout(_this.render, 100);
                return _context4.abrupt('return');

              case 5:
                if (_this.resized) {
                  _context4.next = 47;
                  break;
                }

                if (!(_browserUtils2.default.isSogou() && _this.video.videoWidth === 2)) {
                  _context4.next = 10;
                  break;
                }

                _this.emitter.trigger(_events2.default.toastMessage, [_this.settings.i18n.getMessage('error.no.camera.available'), 'error']);
                _this.emitter.trigger(_events2.default.closeEngine);
                return _context4.abrupt('return');

              case 10:
                _this.resize(_this.video.videoWidth, _this.video.videoHeight);
                _this.resized = true;

                if (_this.isLoadEngineCompleteTriggered) {
                  _context4.next = 47;
                  break;
                }

                faceTrackingManagerBegin = performance.now();

                if (!_this.handTrackingManager) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 17;
                return _this._prerender();

              case 17:
                if (!_this.faceTrackingManager) {
                  _context4.next = 29;
                  break;
                }

                b = performance.now();
                _context4.t0 = _this.faceTrackingManager;
                _context4.t1 = _this.venus_frame_buffer;
                _context4.next = 23;
                return _this.getImageData();

              case 23:
                _context4.t2 = _context4.sent;
                _context4.t3 = _this.venus_crop_buffer;
                _context4.t4 = _this.web_crop_buffer;
                _context4.next = 28;
                return _context4.t0.warmUp.call(_context4.t0, _context4.t1, _context4.t2, _context4.t3, _context4.t4);

              case 28:
                _this.emitter.trigger(_events2.default.engineLoading, ['face-tracking', b, performance.now()]);

              case 29:
                faceTrackingManagerTime = performance.now() - faceTrackingManagerBegin;
                faceQualityCheckerBegin = performance.now();

                if (!_this.faceQualityChecker) {
                  _context4.next = 40;
                  break;
                }

                _b = performance.now();
                _context4.t5 = _this.faceQualityChecker;
                _context4.next = 36;
                return _this.getImageData();

              case 36:
                _context4.t6 = _context4.sent;
                _context4.next = 39;
                return _context4.t5.warmUp.call(_context4.t5, _context4.t6);

              case 39:
                _this.emitter.trigger(_events2.default.engineLoading, ['face-quality-checker', _b, performance.now()]);

              case 40:
                faceQualityCheckerTime = performance.now() - faceQualityCheckerBegin;

                _this.loaded = true;
                _this.emitter.trigger(_events2.default.loading, [100]);
                _this.emitter.trigger(_events2.default.loadEngineComplete, [faceTrackingManagerTime, faceQualityCheckerTime]);
                if (_this.settings.isHeadlessMode() && (_this.settings.isFaceAttribute() || _this.settings.isShadeFinder())) {
                  _this.openFaceQualityChecker();
                  if (_this.settings.isShadeFinder()) {
                    _this.beginShadeFinder();
                  }
                }
                console.log('loaded');
                _this.isLoadEngineCompleteTriggered = true;

              case 47:
                if (!_this.isVideoResolutionChanged(_this.video.videoWidth, _this.video.videoHeight)) {
                  _context4.next = 50;
                  break;
                }

                _this.timer = setTimeout(_this.render, 100);
                return _context4.abrupt('return');

              case 50:
                if (_this.web_frame_buffer) {
                  _context4.next = 52;
                  break;
                }

                return _context4.abrupt('return');

              case 52:
                if (!(_this.settings.videoAutoTesting && (0, _isFunction3.default)(_this.webcam.isVideoImages) && _this.webcam.isVideoImages())) {
                  _context4.next = 55;
                  break;
                }

                _context4.next = 55;
                return _this.webcam.goToNextFrame();

              case 55:
                _context4.next = 57;
                return _this._prerender();

              case 57:
                if (!((0, _get3.default)(_this.settings, 'canvasInputType') === 'image')) {
                  _context4.next = 60;
                  break;
                }

                if (_this.settings.isSkincare()) {
                  _context4.next = 60;
                  break;
                }

                return _context4.abrupt('return');

              case 60:
                window.cancelFrame(_this.timer);
                _this.timer = window.requestFrame(_this.render);

              case 62:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, _this2);
      }));
      _this._prerender = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
        var begin, imageData;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!_this.rendering) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt('return');

              case 2:
                _this.rendering = true;
                begin = performance.now();
                _context5.prev = 4;
                _context5.next = 7;
                return _this.getImageData();

              case 7:
                imageData = _context5.sent;

                if (imageData) {
                  _this.lastValidImageData = imageData;
                }
                _context5.next = 11;
                return _this._render(imageData || _this.lastValidImageData);

              case 11:
                _context5.next = 13;
                return _this.drawResultCanvas();

              case 13:
                _this.throttledUpdateFaceDetection();
                _this.countFps();
                _this.dumpDebugMessage();
                if (_this.settings.videoAutoTesting && (0, _isFunction3.default)(_this.webcam.isVideoImages) && _this.webcam.isVideoImages()) {
                  _this.webcam.snapshot4AutoTest(_this.renderer);
                }
                _context5.next = 22;
                break;

              case 19:
                _context5.prev = 19;
                _context5.t0 = _context5['catch'](4);

                console.error(_context5.t0);

              case 22:
                _context5.prev = 22;

                _this.rendering = false;
                _this.tutorialTimeSpentPerRender = performance.now() - begin;
                return _context5.finish(22);

              case 26:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, _this2, [[4, 19, 22, 26]]);
      }));

      _this.countFps = function () {
        if (!_this._time || !_this._count) {
          _this._count = 1;
          _this._time = performance.now();
        }
        _this._count++;
        if (_this._count % FPS_ROUNDS_PER_COUNT !== 0) {
          return;
        }
        _this.settings.info.fps = Math.round(1000 / ((performance.now() - _this._time) / FPS_ROUNDS_PER_COUNT));
        _this._time = performance.now();
      };

      _this.drawResultCanvas = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
        var canvas, _this$renderer$getSiz, width, height, context, watermark;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (_this.settings.isHeadlessMode()) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt('return');

              case 2:
                canvas = _this.settings.getResultCanvas();
                _this$renderer$getSiz = _this.renderer.getSize(), width = _this$renderer$getSiz.width, height = _this$renderer$getSiz.height;

                canvas.width = _this.settings.displayWidth;
                canvas.height = _this.settings.displayHeight;
                context = canvas.getContext('2d');

                context.drawImage(_this.renderer.domElement, 0, 0, width, height, 0, 0, _this.settings.displayWidth, _this.settings.displayHeight);
                _context6.next = 10;
                return _headlessModeUtils2.default.getWaterMark(_this.settings);

              case 10:
                watermark = _context6.sent;

                context.drawImage(watermark, (canvas.width - watermark.width) / 2, canvas.height - watermark.height);

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, _this2);
      }));

      _this._updateFaceDetection = function () {
        return _this.emitter.trigger(_events2.default.faceDetection, [_this.hasFace, _this.detectFace, _this.faceDetectionDetail]);
      };

      _this.dumpDebugMessage = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
        var r;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (_this.settings.debug) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt('return');

              case 2:
                if (_this.document.getElementById('timed')) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt('return');

              case 4:
                r = {
                  fps: (0, _get3.default)(_this.settings, 'info.fps', 0),
                  AI: _this._isAI(),
                  lib: _this._getAILib(),
                  backend: _this._getAIBackend(),
                  SIMD: _tfjsUtils2.default.isSimdSupported(),
                  Threads: _tfjsUtils2.default.isThreadsSupported(),
                  video: _this.camera_width + ' x ' + _this.camera_height,
                  display: _this.display_width + ' x ' + _this.display_height,
                  warmUp: _this.warmUpTime,
                  gpu: _browserUtils2.default.getGpu(),
                  userAgent: _browserUtils2.default.getUserAgent()
                };

                if (_this.videoWidth) {
                  r['camera'] = _this.videoWidth + ' x ' + _this.videoHeight;
                }
                _this.document.getElementById('timed').innerText = (0, _stringify2.default)(r);

              case 7:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, _this2);
      }));

      _this._isAI = function () {
        return !!_this.faceTrackingManager || !!_this.handTrackingManager;
      };

      _this._getAILib = function () {
        if (_this.faceTrackingManager) {
          return _this.faceTrackingManager.ailibrary;
        }
        if (_this.handTrackingManager) {
          return _this.handTrackingManager.ailibrary;
        }
      };

      _this._getAIBackend = function () {
        if (_this.faceTrackingManager) {
          return _this.faceTrackingManager.getBackend();
        }
        if (_this.handTrackingManager) {
          return _this.handTrackingManager.getBackend();
        }
      };

      _this.cleanUp = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _this.resized = false;
                if (_browserUtils2.default.isMobile()) {
                  window && window.removeEventListener && window.removeEventListener('orientationchange', _this.handleOrientationChange);
                }
                _this.emitter.off(_events2.default.videoSourceChanged, _this.handleVideoSourceChanged);
                _this.emitter.off(_events2.default.videoStreamTrackChanged, _this.handleVideoStreamTrackChanged);
                _this.emitter.off(_events2.default.sizeChanged, _this.handleSizeChanged);
                _context8.next = 7;
                return _browserUtils2.default.sleep(1000);

              case 7:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context8.prev = 10;

                for (_iterator = (0, _getIterator3.default)((0, _keys2.default)(_this)); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  key = _step.value;

                  if (!!_this[key]) {
                    _this[key] = null;
                    delete _this[key];
                  }
                }
                _context8.next = 18;
                break;

              case 14:
                _context8.prev = 14;
                _context8.t0 = _context8['catch'](10);
                _didIteratorError = true;
                _iteratorError = _context8.t0;

              case 18:
                _context8.prev = 18;
                _context8.prev = 19;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 21:
                _context8.prev = 21;

                if (!_didIteratorError) {
                  _context8.next = 24;
                  break;
                }

                throw _iteratorError;

              case 24:
                return _context8.finish(21);

              case 25:
                return _context8.finish(18);

              case 26:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, _this2, [[10, 14, 18, 26], [19,, 21, 25]]);
      }));

      _this.record = function () {
        var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
          var fps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;
          var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
          var type = arguments[2];
          var mediaSource, l, recorded;
          return _regenerator2.default.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  mediaSource = type === 'source' ? _this.webcam : _this.renderer;
                  l = _this.emitter.once(_events2.default.recordCancelled, function () {
                    return _this.recorder.cancel();
                  });
                  _context9.next = 4;
                  return _this.recorder.record(mediaSource, fps, ms);

                case 4:
                  recorded = _context9.sent;

                  if (!recorded) {
                    _context9.next = 15;
                    break;
                  }

                  _context9.t0 = _this.emitter;
                  _context9.t1 = _events2.default.recordComplete;
                  _context9.t2 = fps;
                  _context9.t3 = ms;
                  _context9.next = 12;
                  return recorded;

                case 12:
                  _context9.t4 = _context9.sent;
                  _context9.t5 = [_context9.t2, _context9.t3, _context9.t4];

                  _context9.t0.trigger.call(_context9.t0, _context9.t1, _context9.t5);

                case 15:
                  _this.emitter.off(l);

                case 16:
                case 'end':
                  return _context9.stop();
              }
            }
          }, _callee9, _this2);
        }));

        return function () {
          return _ref9.apply(this, arguments);
        };
      }();

      _this.dragCompareIndicator = function (x) {
        if ((0, _isNaN3.default)(x)) {
          return;
        }
        if (_this.settings.compareMode === _settings.compareModes.replace) {
          return;
        }
        _this.x = x;
        var w = _this.display_width * _mediaUtils2.default.getZoomRatio(_this.zoomLevel);
        _this.m_compare_parameter = (x + w / 2) / w;
        if (!_this.isPaused && _browserUtils2.default.isMobile()) {
          return;
        }
        _this.throttledPrerender();
      };

      _this.freeResources = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
        return _regenerator2.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _this.terminalized = true;
                _this.emitter.off(_events2.default.cameraFlipped, _this.handleCameraFlipped);
                _this.hasFace = false;
                _this.isLoadEngineCompleteTriggered = false;
                _context10.next = 6;
                return _browserUtils2.default.sleep(1000);

              case 6:
                if (_this.videoTexture && _this.videoTexture.image && _this.videoTexture.image.data) {
                  delete _this.videoTexture.image.data;
                  delete _this.videoTexture.image;
                  (0, _isFunction3.default)(_this.videoTexture.dispose) && _this.videoTexture.dispose();
                  _this.videoTexture = null;
                }
                if (!!_this.venus_frame_buffer) {
                  _this.YMKModule._free(_this.venus_frame_buffer);
                  _this.venus_frame_buffer = null;
                  _this.web_frame_buffer = null;
                }
                if (_this.streamCanvas) {
                  _mediaUtils2.default.releaseCanvas(_this.streamCanvas);
                }
                _context10.next = 11;
                return _this.FreeResources();

              case 11:
              case 'end':
                return _context10.stop();
            }
          }
        }, _callee10, _this2);
      }));

      _this._isFaceAlignDataValid = function (data) {
        var points = (0, _get3.default)(data, 'points');
        if (!points || !points.length) {
          return false;
        }
        return (0, _uniq3.default)(points.map(function (p) {
          return p.x;
        })).length > 5;
      };

      _this._flipPoints = function (data) {
        var points = (0, _get3.default)(data, 'points', []);

        return {
          points: points.map(function (_ref11) {
            var x = _ref11.x,
                y = _ref11.y;
            return {
              x: 1 - x,
              y: y
            };
          })
        };
      };

      _this.getLandmarks = function (size) {
        var align_data_vec = _this.settings.landmarkVersion === 'v2' ? _this.new_face_align_data_vec : _this.face_align_data_vec;
        var face_align_data = [];
        var tmp_align_data = align_data_vec && align_data_vec.get(0);
        if (_this._isFaceAlignDataValid(tmp_align_data)) {
          face_align_data = tmp_align_data;
        } else {
          if (_this.face_align_data_of_face_quality_checker) {
            face_align_data = _this._flipPoints(_this.face_align_data_of_face_quality_checker);
          }
        }
        if (_browserUtils2.default.isMobile() || !(0, _get3.default)(_this, 'settings.enableHeadTracking', false)) {
          return size === 'display' ? _mediaUtils2.default.getLandmarks(face_align_data, _this.display_width, _this.display_height) : _mediaUtils2.default.getLandmarks(face_align_data, _this.camera_width, _this.camera_height);
        }
        return size === 'display' ? _mediaUtils2.default.getLandmarksWithHeadTracking(face_align_data, _this.display_width, _this.display_height, _this.camera_width, _this.camera_height, _this.m_smoothed_center_x) : _mediaUtils2.default.getLandmarks(face_align_data, _this.camera_width, _this.camera_height);
      };

      _this.getFaceRect = function (size) {
        var face_rect = _this.face_rect_data;
        if (_browserUtils2.default.isMobile() || !(0, _get3.default)(_this, 'settings.enableHeadTracking', false)) {
          return size === 'display' ? _this._getFaceRect(face_rect, _this.camera_height / _this.display_height, _this.display_width) : _mediaUtils2.default.getFaceRect(face_rect, 1.0, _this.camera_width);
        }
        return size === 'display' ? _this._getFaceRectWithHeadTracking(face_rect, _this.display_width, _this.display_height, _this.camera_width, _this.camera_height, _this.m_smoothed_center_x) : _this._getFaceRect(face_rect, 1.0, _this.camera_width);
      };

      _this._getFaceRectWithHeadTracking = function (faceRect, display_width, display_height, original_width, original_height) {
        var m_smoothed_center_x = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        if (!faceRect) {
          return [];
        }
        var aspectRatio = original_height / display_height;
        if (_this.isFaceQualityChecking()) {
          var _marginLeft = m_smoothed_center_x - display_width * aspectRatio / 2;
          return {
            top: (0, _toInteger3.default)(faceRect.top / aspectRatio),
            bottom: (0, _toInteger3.default)(faceRect.bottom / aspectRatio),
            left: (0, _toInteger3.default)((faceRect.left - _marginLeft) / aspectRatio),
            right: (0, _toInteger3.default)((faceRect.right - _marginLeft) / aspectRatio)
          };
        }
        var marginLeft = Math.abs(original_width - m_smoothed_center_x) - display_width * aspectRatio / 2;
        return {
          top: (0, _toInteger3.default)(faceRect.top / aspectRatio),
          bottom: (0, _toInteger3.default)(faceRect.bottom / aspectRatio),
          right: (0, _toInteger3.default)((original_width - faceRect.left - marginLeft) / aspectRatio),
          left: (0, _toInteger3.default)((original_width - faceRect.right - marginLeft) / aspectRatio)
        };
      };

      _this._getFaceRect = function (faceRect, ratio, width) {
        if (!faceRect) {
          return [];
        }
        if (faceRect.noflip) {
          return {
            top: (0, _toInteger3.default)(faceRect.top / ratio),
            bottom: (0, _toInteger3.default)(faceRect.bottom / ratio),
            left: (0, _toInteger3.default)(faceRect.left / ratio),
            right: (0, _toInteger3.default)(faceRect.right / ratio)
          };
        }
        return {
          top: (0, _toInteger3.default)(faceRect.top / ratio),
          bottom: (0, _toInteger3.default)(faceRect.bottom / ratio),
          right: (0, _toInteger3.default)(width - faceRect.left / ratio),
          left: (0, _toInteger3.default)(width - faceRect.right / ratio)
        };
      };

      _this.updateSkinSmooth = function () {
        return _this.throttledUpdate && _this.throttledUpdate();
      };

      _this.type = 'video';
      _this.delay = 0;
      _this.videoDocId = params.videoDocId;
      _this.camera_width = params.camera_width;
      _this.camera_height = params.camera_height;
      _this.webcam = params.webcam;
      _this.display_width = params.display_width;
      _this.display_height = params.display_height;
      _this.savePhotoFlag = false;
      if (_this.settings.isHeadlessMode()) {
        _this.video = params.videoElement;
      } else {
        _this.video = params.document.getElementById(params.videoDocId);
      }
      _this.isPaused = false;
      _this.timer = null;
      _this.needToFlipVideoStream = params.needToFlipVideoStream || false;
      _this.hasFace = false;
      _this.throttledUpdate = (0, _throttle3.default)(_this._prerender, 50, { leading: false });
      _this.throttledPrerender = _this.throttledUpdate;
      _this.throttledUpdateFaceDetection = (0, _throttle3.default)(_this._updateFaceDetection, 100, { leading: false });
      _this.detectFace = true;
      _this.isLoadEngineCompleteTriggered = false;
      _this.resized = false;
      if (_browserUtils2.default.isMobile()) {
        window && window.addEventListener && window.addEventListener('orientationchange', _this.handleOrientationChange);
      }
      _this.emitter.on(_events2.default.videoSourceChanged, _this.handleVideoSourceChanged);
      _this.emitter.on(_events2.default.sizeChanged, _this.handleSizeChanged);
      _this.recorder = new _recorder2.default(_this);
      _this.streamCanvas = params.document.createElement('canvas');
      _this.recordingImageDataForIOs15 = [];
      if (_this.settings.videoAutoTesting && (0, _isFunction3.default)(_this.webcam.isVideoImages) && _this.webcam.isVideoImages()) {
        _this.video = _this.webcam.video;
      }
      _this.tutorialTimeSpentPerRender = 0;
      return _this;
    }

    return _class2;
  }(superclass);
};

module.exports = exports['default'];

/***/ }),

/***/ 833:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WATERMARK = undefined;
var utils = {
  getWaterMark: function getWaterMark(settings) {
    return new _promise2.default(function (resolve) {
      if (WATERMARK) {
        resolve(WATERMARK);
        return;
      }
      var svg = utils.getWaterMarkSvg(settings);
      var img = new Image();
      img.onload = function () {
        WATERMARK = img;
        resolve(WATERMARK);
      };
      img.src = svg;
    });
  },
  getWaterMarkSvg: function getWaterMarkSvg(settings) {
    switch (settings.language) {
      case 'cht':
        return __webpack_require__(834);
      case 'ita':
        return __webpack_require__(835);
      case 'esp':
        return __webpack_require__(836);
      default:
        return __webpack_require__(837);
    }
  }
};

exports.default = utils;
module.exports = exports['default'];

/***/ }),

/***/ 834:
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTMiIGhlaWdodD0iMTUiIHZpZXdCb3g9IjAgMCA5MyAxNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZF8yXzMyNCkiPgo8cGF0aCBvcGFjaXR5PSIwLjciIGQ9Ik01My4xODIgMi41OTJWMy40Mkg1OC4zNTRWMi41OTJINTMuMTgyWk01OS4yMDYgNi4wMTJWNi44NzZINjQuMDNWNi4wMTJINTkuMjA2Wk02MS44MSA2LjU3NlYxMi45NzJINjIuNjk4VjYuNTc2SDYxLjgxWk01OC44NTggMy4xMDhWNi4zMTJDNTguODU4IDguMTQ4IDU4LjY5IDEwLjU2IDU3LjAyMiAxMi4zMzZDNTcuMjM4IDEyLjQ0NCA1Ny41NjIgMTIuNzQ0IDU3LjY5NCAxMi45MzZDNTkuNDk0IDExLjAwNCA1OS43NDYgOC4yNTYgNTkuNzQ2IDYuMzEyVjMuNTY0QzU5LjkxNCAzLjU0IDU5Ljk3NCAzLjQ5MiA1OS45ODYgMy40MDhMNTguODU4IDMuMTA4Wk01My42MjYgNC42NjhWNy45MDhDNTMuNjI2IDkuMjg4IDUzLjU0MiAxMS4xMzYgNTIuNzAyIDEyLjQzMkM1Mi44OTQgMTIuNTQgNTMuMjY2IDEyLjgxNiA1My40MSAxMi45ODRDNTQuMzM0IDExLjU2OCA1NC40NzggOS40NDQgNTQuNDc4IDcuOTA4VjQuNjY4SDUzLjYyNlpNNjIuOTk4IDIuMDY0QzYyLjA5OCAyLjU4IDYwLjQ3OCAzLjA5NiA1OS4wNSAzLjQzMkM1OS4xNyAzLjYzNiA1OS4zMTQgMy45NiA1OS4zNjIgNC4xNjRDNjAuODYyIDMuODE2IDYyLjYwMiAzLjMyNCA2My43OSAyLjc0OEw2Mi45OTggMi4wNjRaTTU0LjExOCA0LjY2OFY1LjQ5Nkg1Ny4xNzhWNy41OTZINTQuMTE4VjguNDEySDU4LjA1NFY0LjY2OEg1NC4xMThaTTY1LjIwNiAzLjQ4VjQuMzMySDc1LjcxOFYzLjQ4SDY1LjIwNlpNNjguMTM0IDcuNzY0VjguNTQ0SDczLjc3NFY3Ljc2NEg2OC4xMzRaTTY3LjQ5OCA1LjcyNFYxMi45Nkg2OC4zODZWNi41MjhINzMuNjNWNS43MjRINjcuNDk4Wk03My40MjYgNS43MjRWMTEuODMyQzczLjQyNiAxMi4wMTIgNzMuMzU0IDEyLjA3MiA3My4xNSAxMi4wODRDNzIuOTM0IDEyLjA4NCA3Mi4yMDIgMTIuMDk2IDcxLjM5OCAxMi4wNkM3MS41MyAxMi4zMTIgNzEuNjYyIDEyLjY4NCA3MS42OTggMTIuOTM2QzcyLjczIDEyLjkzNiA3My40MDIgMTIuOTM2IDczLjc4NiAxMi43OTJDNzQuMTk0IDEyLjY0OCA3NC4zMDIgMTIuMzcyIDc0LjMwMiAxMS44NDRWNS43MjRINzMuNDI2Wk02OS4xMyAxLjkyQzY4LjQ4MiA0LjMzMiA2Ny4wNjYgNi44NzYgNjQuOTE4IDguMzUyQzY1LjA5OCA4LjUzMiA2NS4zNzQgOC44NDQgNjUuNDk0IDkuMDQ4QzY3Ljc4NiA3LjQ0IDY5LjIyNiA0Ljc3NiA3MC4wNDIgMi4xMzZMNjkuMTMgMS45MlpNNjguMTM0IDkuNzkyVjEwLjU3Mkg3My43NzRWOS43OTJINjguMTM0WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTIuNzg4MyA5LjEyOTJIMC45OTg4MzZWMTIuNzc0NUgwVjMuNTI4NDdIMi43MzdDNC44MjUyIDMuNTI4NDcgNS4yMjY1NCA1LjE5MTE5IDUuMjI2NTQgNS45ODE4MVY2LjY1Nzc2QzUuMjI2NTQgNy40Njk1IDQuODIyMTggOS4xMjkyIDIuNzg4MyA5LjEyOTJaTTQuMjM5NzggNi4wMDU5NUM0LjIzOTc4IDQuNjk2MyAzLjI1MzAxIDQuNTEyMjIgMi43MDk4NCA0LjUxMjIySDAuOTk1ODI1VjguMTQ1NDVIMi43MzM5OEMzLjI3NzE1IDguMTQ1NDUgNC4yMzk3OCA3Ljk0OTMxIDQuMjM5NzggNi42Mzk2NVY2LjAwNTk1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNNy4zNjYwNiAxMi43NzQ1VjMuNTI4NDdIMTIuMzYwMlY0LjUxNTI0SDguMzUyODNWNy4zOTQwNkgxMi4wNjE1VjguMzgwODNIOC4zNTI4M1YxMS44MDU4SDEyLjM2MDJWMTIuNzc3NUg3LjM2NjA2VjEyLjc3NDVaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik0xOS4xNTU5IDEyLjc3NDVMMTcuMzM5MyA4Ljg2OTY4SDE1LjgyMTVWMTIuNzc0NUgxNC44MjI2VjMuNTI4NDdIMTcuNTU5NkMxOS42NDc4IDMuNTI4NDcgMjAuMDY0MiA1LjE3NjEgMjAuMDY0MiA1Ljk2NjcyVjYuNDA3MjlDMjAuMDY0MiA3LjA5NTMxIDE5Ljc1MzQgOC4zNzc4MSAxOC4zOTI1IDguNzc5MTVMMjAuMjg3NSAxMi43NzQ1SDE5LjE1NTlWMTIuNzc0NVpNMTkuMDY1NCA2LjAwNTk1QzE5LjA2NTQgNC42OTYzIDE4LjA3ODYgNC41MTIyMiAxNy41MzU1IDQuNTEyMjJIMTUuODIxNVY3Ljg5ODAxSDE3LjU1OTZDMTguMTA1OCA3Ljg5ODAxIDE5LjA2NTQgNy42ODk3OSAxOS4wNjU0IDYuMzkyMjFWNi4wMDU5NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTIzLjc2MDkgNC41MTIyMlY3LjQwNjEzSDI3LjQ2OTVWOC4zOTI5SDIzLjc2MDlWMTIuNzc3NUgyMi43NzQxVjMuNTI4NDdIMjcuNzY4M1Y0LjUxNTI0SDIzLjc2MDlWNC41MTIyMloiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTI5Ljg0MTQgMTIuNzc0NVYzLjUyODQ3SDM0LjgzNTZWNC41MTUyNEgzMC44MjgyVjcuMzk0MDZIMzQuNTM2OFY4LjM4MDgzSDMwLjgyODJWMTEuODA1OEgzNC44MzU2VjEyLjc3NzVIMjkuODQxNFYxMi43NzQ1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNMzkuNzc4NCAxMi44OTIyQzM3Ljc0MTUgMTIuODkyMiAzNy4xNzEyIDExLjIyMDQgMzcuMTcxMiAxMC40MDI2VjUuODg4MjZDMzcuMTcxMiA1LjA5NzY0IDM3LjcwMjMgMy40NTAwMSAzOS43OTA1IDMuNDUwMDFDNDEuODE1MyAzLjQ1MDAxIDQyLjM5NzcgNS4wOTc2NCA0Mi4zOTc3IDUuOTAzMzVINDEuMzk4OUM0MS4zOTg5IDQuNjE3ODQgNDAuMzA5NSA0LjQyNDcxIDM5Ljc5MDUgNC40MjQ3MUMzOS4yNTk0IDQuNDI0NzEgMzguMTU3OSA0LjYyMDg1IDM4LjE1NzkgNS45MTU0MlYxMC40MDI2QzM4LjE1NzkgMTEuNzEyMyAzOS4yNTk0IDExLjkwODQgMzkuNzkwNSAxMS45MDg0QzQwLjMwOTUgMTEuOTA4NCA0MS4zOTg5IDExLjcxMjMgNDEuMzk4OSAxMC40MTc3SDQyLjM5NzdDNDIuMzk3NyAxMS4yMzI1IDQxLjg1MTUgMTIuODkyMiAzOS43Nzg0IDEyLjg5MjJaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik00Ny4xOTU4IDQuNTI3MzFWMTIuNzc3NUg0Ni4xOTdWNC41MjczMUg0My45Mzk4VjMuNTI4NDdINDkuNDVWNC41MjczMUg0Ny4xOTU4WiIgZmlsbD0iI0RDM0Q3MiIvPgo8ZyBvcGFjaXR5PSIwLjciPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTgxLjU1MTYgNC42Mjk2N0M4MS40MDg2IDQuNjI5NjcgODEuMjcxNSA0LjY4NjQ2IDgxLjE3MDQgNC43ODc1NkM4MS4wNjkzIDQuODg4NjUgODEuMDEyNSA1LjAyNTc2IDgxLjAxMjUgNS4xNjg3M1YxMS4wOTg0QzgxLjAxMjUgMTEuMjQxNCA4MS4wNjkzIDExLjM3ODUgODEuMTcwNCAxMS40Nzk2QzgxLjI3MTUgMTEuNTgwNyA4MS40MDg2IDExLjYzNzUgODEuNTUxNiAxMS42Mzc1SDg3LjQ4MTNDODcuNjI0MyAxMS42Mzc1IDg3Ljc2MTQgMTEuNTgwNyA4Ny44NjI1IDExLjQ3OTZDODcuOTYzNiAxMS4zNzg1IDg4LjAyMDQgMTEuMjQxNCA4OC4wMjA0IDExLjA5ODRWNy44NjQwNEM4OC4wMjA0IDcuNTY2MzMgODguMjYxNyA3LjMyNDk4IDg4LjU1OTQgNy4zMjQ5OEM4OC44NTcxIDcuMzI0OTggODkuMDk4NSA3LjU2NjMzIDg5LjA5ODUgNy44NjQwNFYxMS4wOTg0Qzg5LjA5ODUgMTEuNTI3MyA4OC45MjgxIDExLjkzODcgODguNjI0OCAxMi4yNDE5Qzg4LjMyMTUgMTIuNTQ1MiA4Ny45MTAyIDEyLjcxNTYgODcuNDgxMyAxMi43MTU2SDgxLjU1MTZDODEuMTIyNyAxMi43MTU2IDgwLjcxMTQgMTIuNTQ1MiA4MC40MDgxIDEyLjI0MTlDODAuMTA0OCAxMS45Mzg3IDc5LjkzNDQgMTEuNTI3MyA3OS45MzQ0IDExLjA5ODRWNS4xNjg3M0M3OS45MzQ0IDQuNzM5ODMgODAuMTA0OCA0LjMyODQ5IDgwLjQwODEgNC4wMjUyMUM4MC43MTE0IDMuNzIxOTMgODEuMTIyNyAzLjU1MTU0IDgxLjU1MTYgMy41NTE1NEg4NC43ODZDODUuMDgzNyAzLjU1MTU0IDg1LjMyNSAzLjc5Mjg5IDg1LjMyNSA0LjA5MDYxQzg1LjMyNSA0LjM4ODMyIDg1LjA4MzcgNC42Mjk2NyA4NC43ODYgNC42Mjk2N0g4MS41NTE2WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ni45NDIyIDEuOTM0MzNDODYuNjQ0NSAxLjkzNDMzIDg2LjQwMzEgMi4xNzU2NyA4Ni40MDMxIDIuNDczMzlDODYuNDAzMSAyLjc3MTEgODYuNjQ0NSAzLjAxMjQ1IDg2Ljk0MjIgMy4wMTI0NUg4OC44NzUyTDgzLjg2NTcgOC4wMjE5M0M4My42NTUyIDguMjMyNDQgODMuNjU1MiA4LjU3Mzc2IDgzLjg2NTcgOC43ODQyOEM4NC4wNzYzIDguOTk0NzkgODQuNDE3NiA4Ljk5NDc5IDg0LjYyODEgOC43ODQyOEw4OS42Mzc1IDMuNzc0ODVWNS43MDc3NkM4OS42Mzc1IDYuMDA1NDggODkuODc4OSA2LjI0NjgzIDkwLjE3NjYgNi4yNDY4M0M5MC40NzQzIDYuMjQ2ODMgOTAuNzE1NiA2LjAwNTQ4IDkwLjcxNTYgNS43MDc3NlYyLjQ3ODUyQzkwLjcxNTcgMi40NzUxMiA5MC43MTU3IDIuNDcxNzEgOTAuNzE1NiAyLjQ2ODNWMi40MDA2NkM5MC43MTU2IDIuMTAyOTQgOTAuNDc0MyAxLjkzNDMzIDkwLjE3NjYgMS45MzQzM0g4Ni45NDIyWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2RfMl8zMjQiIHg9IjAiIHk9IjAiIHdpZHRoPSI5Mi44IiBoZWlnaHQ9IjE2LjE1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHg9IjEuMTUiIGR5PSIxLjE1Ii8+CjxmZUNvbG9yTWF0cml4IHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwLjI1IDAiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3dfMl8zMjQiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMl8zMjQiIHJlc3VsdD0ic2hhcGUiLz4KPC9maWx0ZXI+CjwvZGVmcz4KPC9zdmc+Cg=="

/***/ }),

/***/ 835:
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM0IiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTM0IDE2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kXzJfMzA5KSI+CjxwYXRoIG9wYWNpdHk9IjAuNyIgZD0iTTQuNzI2NTYgMTAuNTM1MlY1LjY2MDE2SDUuODE2NDFWMTJINC43NzkzTDQuNzI2NTYgMTAuNTM1MlpNNC45MzE2NCA5LjE5OTIyTDUuMzgyODEgOS4xODc1QzUuMzgyODEgOS42MDkzOCA1LjMzNzg5IDEwIDUuMjQ4MDUgMTAuMzU5NEM1LjE2MjExIDEwLjcxNDggNS4wMjE0OCAxMS4wMjM0IDQuODI2MTcgMTEuMjg1MkM0LjYzMDg2IDExLjU0NjkgNC4zNzUgMTEuNzUyIDQuMDU4NTkgMTEuOTAwNEMzLjc0MjE5IDEyLjA0NDkgMy4zNTc0MiAxMi4xMTcyIDIuOTA0MyAxMi4xMTcyQzIuNTk1NyAxMi4xMTcyIDIuMzEyNSAxMi4wNzIzIDIuMDU0NjkgMTEuOTgyNEMxLjgwMDc4IDExLjg5MjYgMS41ODIwMyAxMS43NTM5IDEuMzk4NDQgMTEuNTY2NEMxLjIxNDg0IDExLjM3ODkgMS4wNzIyNyAxMS4xMzQ4IDAuOTcwNzAzIDEwLjgzNEMwLjg3MzA0NyAxMC41MzMyIDAuODI0MjE5IDEwLjE3MTkgMC44MjQyMTkgOS43NVY1LjY2MDE2SDEuOTA4MlY5Ljc2MTcyQzEuOTA4MiAxMC4wNDY5IDEuOTM5NDUgMTAuMjgzMiAyLjAwMTk1IDEwLjQ3MDdDMi4wNjgzNiAxMC42NTQzIDIuMTU2MjUgMTAuODAwOCAyLjI2NTYyIDEwLjkxMDJDMi4zNzg5MSAxMS4wMTU2IDIuNTAzOTEgMTEuMDg5OCAyLjY0MDYyIDExLjEzMjhDMi43ODEyNSAxMS4xNzU4IDIuOTI1NzggMTEuMTk3MyAzLjA3NDIyIDExLjE5NzNDMy41MzUxNiAxMS4xOTczIDMuOTAwMzkgMTEuMTA5NCA0LjE2OTkyIDEwLjkzMzZDNC40Mzk0NSAxMC43NTM5IDQuNjMyODEgMTAuNTEzNyA0Ljc1IDEwLjIxMjlDNC44NzEwOSA5LjkwODIgNC45MzE2NCA5LjU3MDMxIDQuOTMxNjQgOS4xOTkyMlpNOC41NTI3MyA3LjAxMzY3VjEySDcuNDY4NzVWNS42NjAxNkg4LjQ5NDE0TDguNTUyNzMgNy4wMTM2N1pNOC4yOTQ5MiA4LjU4OTg0TDcuODQzNzUgOC41NzIyN0M3Ljg0NzY2IDguMTM4NjcgNy45MTIxMSA3LjczODI4IDguMDM3MTEgNy4zNzEwOUM4LjE2MjExIDcgOC4zMzc4OSA2LjY3NzczIDguNTY0NDUgNi40MDQzQzguNzkxMDIgNi4xMzA4NiA5LjA2MDU1IDUuOTE5OTIgOS4zNzMwNSA1Ljc3MTQ4QzkuNjg5NDUgNS42MTkxNCAxMC4wMzkxIDUuNTQyOTcgMTAuNDIxOSA1LjU0Mjk3QzEwLjczNDQgNS41NDI5NyAxMS4wMTU2IDUuNTg1OTQgMTEuMjY1NiA1LjY3MTg4QzExLjUxNTYgNS43NTM5MSAxMS43Mjg1IDUuODg2NzIgMTEuOTA0MyA2LjA3MDMxQzEyLjA4NCA2LjI1MzkxIDEyLjIyMDcgNi40OTIxOSAxMi4zMTQ1IDYuNzg1MTZDMTIuNDA4MiA3LjA3NDIyIDEyLjQ1NTEgNy40Mjc3MyAxMi40NTUxIDcuODQ1N1YxMkgxMS4zNjUyVjcuODMzOThDMTEuMzY1MiA3LjUwMTk1IDExLjMxNjQgNy4yMzYzMyAxMS4yMTg4IDcuMDM3MTFDMTEuMTIxMSA2LjgzMzk4IDEwLjk3ODUgNi42ODc1IDEwLjc5MSA2LjU5NzY2QzEwLjYwMzUgNi41MDM5MSAxMC4zNzMgNi40NTcwMyAxMC4wOTk2IDYuNDU3MDNDOS44MzAwOCA2LjQ1NzAzIDkuNTgzOTggNi41MTM2NyA5LjM2MTMzIDYuNjI2OTVDOS4xNDI1OCA2Ljc0MDIzIDguOTUzMTIgNi44OTY0OCA4Ljc5Mjk3IDcuMDk1N0M4LjYzNjcyIDcuMjk0OTIgOC41MTM2NyA3LjUyMzQ0IDguNDIzODMgNy43ODEyNUM4LjMzNzg5IDguMDM1MTYgOC4yOTQ5MiA4LjMwNDY5IDguMjk0OTIgOC41ODk4NFpNMTguMTYyMSA2Ljg3ODkxVjE0LjQzNzVIMTcuMDcyM1Y1LjY2MDE2SDE4LjA2ODRMMTguMTYyMSA2Ljg3ODkxWk0yMi40MzM2IDguNzc3MzRWOC45MDAzOUMyMi40MzM2IDkuMzYxMzMgMjIuMzc4OSA5Ljc4OTA2IDIyLjI2OTUgMTAuMTgzNkMyMi4xNjAyIDEwLjU3NDIgMjIgMTAuOTE0MSAyMS43ODkxIDExLjIwMzFDMjEuNTgyIDExLjQ5MjIgMjEuMzI2MiAxMS43MTY4IDIxLjAyMTUgMTEuODc3QzIwLjcxNjggMTIuMDM3MSAyMC4zNjcyIDEyLjExNzIgMTkuOTcyNyAxMi4xMTcyQzE5LjU3MDMgMTIuMTE3MiAxOS4yMTQ4IDEyLjA1MDggMTguOTA2MiAxMS45MThDMTguNTk3NyAxMS43ODUyIDE4LjMzNTkgMTEuNTkxOCAxOC4xMjExIDExLjMzNzlDMTcuOTA2MiAxMS4wODQgMTcuNzM0NCAxMC43NzkzIDE3LjYwNTUgMTAuNDIzOEMxNy40ODA1IDEwLjA2ODQgMTcuMzk0NSA5LjY2Nzk3IDE3LjM0NzcgOS4yMjI2NlY4LjU2NjQxQzE3LjM5NDUgOC4wOTc2NiAxNy40ODI0IDcuNjc3NzMgMTcuNjExMyA3LjMwNjY0QzE3Ljc0MDIgNi45MzU1NSAxNy45MTAyIDYuNjE5MTQgMTguMTIxMSA2LjM1NzQyQzE4LjMzNTkgNi4wOTE4IDE4LjU5NTcgNS44OTA2MiAxOC45MDA0IDUuNzUzOTFDMTkuMjA1MSA1LjYxMzI4IDE5LjU1NjYgNS41NDI5NyAxOS45NTUxIDUuNTQyOTdDMjAuMzUzNSA1LjU0Mjk3IDIwLjcwNyA1LjYyMTA5IDIxLjAxNTYgNS43NzczNEMyMS4zMjQyIDUuOTI5NjkgMjEuNTg0IDYuMTQ4NDQgMjEuNzk0OSA2LjQzMzU5QzIyLjAwNTkgNi43MTg3NSAyMi4xNjQxIDcuMDYwNTUgMjIuMjY5NSA3LjQ1ODk4QzIyLjM3ODkgNy44NTM1MiAyMi40MzM2IDguMjkyOTcgMjIuNDMzNiA4Ljc3NzM0Wk0yMS4zNDM4IDguOTAwMzlWOC43NzczNEMyMS4zNDM4IDguNDYwOTQgMjEuMzEwNSA4LjE2NDA2IDIxLjI0NDEgNy44ODY3MkMyMS4xNzc3IDcuNjA1NDcgMjEuMDc0MiA3LjM1OTM4IDIwLjkzMzYgNy4xNDg0NEMyMC43OTY5IDYuOTMzNTkgMjAuNjIxMSA2Ljc2NTYyIDIwLjQwNjIgNi42NDQ1M0MyMC4xOTE0IDYuNTE5NTMgMTkuOTM1NSA2LjQ1NzAzIDE5LjYzODcgNi40NTcwM0MxOS4zNjUyIDYuNDU3MDMgMTkuMTI3IDYuNTAzOTEgMTguOTIzOCA2LjU5NzY2QzE4LjcyNDYgNi42OTE0MSAxOC41NTQ3IDYuODE4MzYgMTguNDE0MSA2Ljk3ODUyQzE4LjI3MzQgNy4xMzQ3NyAxOC4xNTgyIDcuMzE0NDUgMTguMDY4NCA3LjUxNzU4QzE3Ljk4MjQgNy43MTY4IDE3LjkxOCA3LjkyMzgzIDE3Ljg3NSA4LjEzODY3VjkuNjU2MjVDMTcuOTUzMSA5LjkyOTY5IDE4LjA2MjUgMTAuMTg3NSAxOC4yMDMxIDEwLjQyOTdDMTguMzQzOCAxMC42NjggMTguNTMxMiAxMC44NjEzIDE4Ljc2NTYgMTEuMDA5OEMxOSAxMS4xNTQzIDE5LjI5NDkgMTEuMjI2NiAxOS42NTA0IDExLjIyNjZDMTkuOTQzNCAxMS4yMjY2IDIwLjE5NTMgMTEuMTY2IDIwLjQwNjIgMTEuMDQ0OUMyMC42MjExIDEwLjkxOTkgMjAuNzk2OSAxMC43NSAyMC45MzM2IDEwLjUzNTJDMjEuMDc0MiAxMC4zMjAzIDIxLjE3NzcgMTAuMDc0MiAyMS4yNDQxIDkuNzk2ODhDMjEuMzEwNSA5LjUxNTYyIDIxLjM0MzggOS4yMTY4IDIxLjM0MzggOC45MDAzOVpNMjQuOTAwNCA2LjY1NjI1VjEySDIzLjgxNjRWNS42NjAxNkgyNC44NzExTDI0LjkwMDQgNi42NTYyNVpNMjYuODgwOSA1LjYyNUwyNi44NzUgNi42MzI4MUMyNi43ODUyIDYuNjEzMjggMjYuNjk5MiA2LjYwMTU2IDI2LjYxNzIgNi41OTc2NkMyNi41MzkxIDYuNTg5ODQgMjYuNDQ5MiA2LjU4NTk0IDI2LjM0NzcgNi41ODU5NEMyNi4wOTc3IDYuNTg1OTQgMjUuODc3IDYuNjI1IDI1LjY4NTUgNi43MDMxMkMyNS40OTQxIDYuNzgxMjUgMjUuMzMyIDYuODkwNjIgMjUuMTk5MiA3LjAzMTI1QzI1LjA2NjQgNy4xNzE4OCAyNC45NjA5IDcuMzM5ODQgMjQuODgyOCA3LjUzNTE2QzI0LjgwODYgNy43MjY1NiAyNC43NTk4IDcuOTM3NSAyNC43MzYzIDguMTY3OTdMMjQuNDMxNiA4LjM0Mzc1QzI0LjQzMTYgNy45NjA5NCAyNC40Njg4IDcuNjAxNTYgMjQuNTQzIDcuMjY1NjJDMjQuNjIxMSA2LjkyOTY5IDI0Ljc0MDIgNi42MzI4MSAyNC45MDA0IDYuMzc1QzI1LjA2MDUgNi4xMTMyOCAyNS4yNjM3IDUuOTEwMTYgMjUuNTA5OCA1Ljc2NTYyQzI1Ljc1OTggNS42MTcxOSAyNi4wNTY2IDUuNTQyOTcgMjYuNDAwNCA1LjU0Mjk3QzI2LjQ3ODUgNS41NDI5NyAyNi41Njg0IDUuNTUyNzMgMjYuNjY5OSA1LjU3MjI3QzI2Ljc3MTUgNS41ODc4OSAyNi44NDE4IDUuNjA1NDcgMjYuODgwOSA1LjYyNVpNMjcuNDc4NSA4LjkwMDM5VjguNzY1NjJDMjcuNDc4NSA4LjMwODU5IDI3LjU0NDkgNy44ODQ3NyAyNy42Nzc3IDcuNDk0MTRDMjcuODEwNSA3LjA5OTYxIDI4LjAwMiA2Ljc1NzgxIDI4LjI1MiA2LjQ2ODc1QzI4LjUwMiA2LjE3NTc4IDI4LjgwNDcgNS45NDkyMiAyOS4xNjAyIDUuNzg5MDZDMjkuNTE1NiA1LjYyNSAyOS45MTQxIDUuNTQyOTcgMzAuMzU1NSA1LjU0Mjk3QzMwLjgwMDggNS41NDI5NyAzMS4yMDEyIDUuNjI1IDMxLjU1NjYgNS43ODkwNkMzMS45MTYgNS45NDkyMiAzMi4yMjA3IDYuMTc1NzggMzIuNDcwNyA2LjQ2ODc1QzMyLjcyNDYgNi43NTc4MSAzMi45MTggNy4wOTk2MSAzMy4wNTA4IDcuNDk0MTRDMzMuMTgzNiA3Ljg4NDc3IDMzLjI1IDguMzA4NTkgMzMuMjUgOC43NjU2MlY4LjkwMDM5QzMzLjI1IDkuMzU3NDIgMzMuMTgzNiA5Ljc4MTI1IDMzLjA1MDggMTAuMTcxOUMzMi45MTggMTAuNTYyNSAzMi43MjQ2IDEwLjkwNDMgMzIuNDcwNyAxMS4xOTczQzMyLjIyMDcgMTEuNDg2MyAzMS45MTggMTEuNzEyOSAzMS41NjI1IDExLjg3N0MzMS4yMTA5IDEyLjAzNzEgMzAuODEyNSAxMi4xMTcyIDMwLjM2NzIgMTIuMTE3MkMyOS45MjE5IDEyLjExNzIgMjkuNTIxNSAxMi4wMzcxIDI5LjE2NiAxMS44NzdDMjguODEwNSAxMS43MTI5IDI4LjUwNTkgMTEuNDg2MyAyOC4yNTIgMTEuMTk3M0MyOC4wMDIgMTAuOTA0MyAyNy44MTA1IDEwLjU2MjUgMjcuNjc3NyAxMC4xNzE5QzI3LjU0NDkgOS43ODEyNSAyNy40Nzg1IDkuMzU3NDIgMjcuNDc4NSA4LjkwMDM5Wk0yOC41NjI1IDguNzY1NjJWOC45MDAzOUMyOC41NjI1IDkuMjE2OCAyOC41OTk2IDkuNTE1NjIgMjguNjczOCA5Ljc5Njg4QzI4Ljc0OCAxMC4wNzQyIDI4Ljg1OTQgMTAuMzIwMyAyOS4wMDc4IDEwLjUzNTJDMjkuMTYwMiAxMC43NSAyOS4zNDk2IDEwLjkxOTkgMjkuNTc2MiAxMS4wNDQ5QzI5LjgwMjcgMTEuMTY2IDMwLjA2NjQgMTEuMjI2NiAzMC4zNjcyIDExLjIyNjZDMzAuNjY0MSAxMS4yMjY2IDMwLjkyMzggMTEuMTY2IDMxLjE0NjUgMTEuMDQ0OUMzMS4zNzMgMTAuOTE5OSAzMS41NjA1IDEwLjc1IDMxLjcwOSAxMC41MzUyQzMxLjg1NzQgMTAuMzIwMyAzMS45Njg4IDEwLjA3NDIgMzIuMDQzIDkuNzk2ODhDMzIuMTIxMSA5LjUxNTYyIDMyLjE2MDIgOS4yMTY4IDMyLjE2MDIgOC45MDAzOVY4Ljc2NTYyQzMyLjE2MDIgOC40NTMxMiAzMi4xMjExIDguMTU4MiAzMi4wNDMgNy44ODA4NkMzMS45Njg4IDcuNTk5NjEgMzEuODU1NSA3LjM1MTU2IDMxLjcwMzEgNy4xMzY3MkMzMS41NTQ3IDYuOTE3OTcgMzEuMzY3MiA2Ljc0NjA5IDMxLjE0MDYgNi42MjEwOUMzMC45MTggNi40OTYwOSAzMC42NTYyIDYuNDMzNTkgMzAuMzU1NSA2LjQzMzU5QzMwLjA1ODYgNi40MzM1OSAyOS43OTY5IDYuNDk2MDkgMjkuNTcwMyA2LjYyMTA5QzI5LjM0NzcgNi43NDYwOSAyOS4xNjAyIDYuOTE3OTcgMjkuMDA3OCA3LjEzNjcyQzI4Ljg1OTQgNy4zNTE1NiAyOC43NDggNy41OTk2MSAyOC42NzM4IDcuODgwODZDMjguNTk5NiA4LjE1ODIgMjguNTYyNSA4LjQ1MzEyIDI4LjU2MjUgOC43NjU2MlpNMzguNjA1NSAxMC43Njk1VjNIMzkuNjk1M1YxMkgzOC42OTkyTDM4LjYwNTUgMTAuNzY5NVpNMzQuMzM5OCA4LjkwMDM5VjguNzc3MzRDMzQuMzM5OCA4LjI5Mjk3IDM0LjM5ODQgNy44NTM1MiAzNC41MTU2IDcuNDU4OThDMzQuNjM2NyA3LjA2MDU1IDM0LjgwNjYgNi43MTg3NSAzNS4wMjU0IDYuNDMzNTlDMzUuMjQ4IDYuMTQ4NDQgMzUuNTExNyA1LjkyOTY5IDM1LjgxNjQgNS43NzczNEMzNi4xMjUgNS42MjEwOSAzNi40Njg4IDUuNTQyOTcgMzYuODQ3NyA1LjU0Mjk3QzM3LjI0NjEgNS41NDI5NyAzNy41OTM4IDUuNjEzMjggMzcuODkwNiA1Ljc1MzkxQzM4LjE5MTQgNS44OTA2MiAzOC40NDUzIDYuMDkxOCAzOC42NTIzIDYuMzU3NDJDMzguODYzMyA2LjYxOTE0IDM5LjAyOTMgNi45MzU1NSAzOS4xNTA0IDcuMzA2NjRDMzkuMjcxNSA3LjY3NzczIDM5LjM1NTUgOC4wOTc2NiAzOS40MDIzIDguNTY2NDFWOS4xMDU0N0MzOS4zNTk0IDkuNTcwMzEgMzkuMjc1NCA5Ljk4ODI4IDM5LjE1MDQgMTAuMzU5NEMzOS4wMjkzIDEwLjczMDUgMzguODYzMyAxMS4wNDY5IDM4LjY1MjMgMTEuMzA4NkMzOC40NDUzIDExLjU3MDMgMzguMTkxNCAxMS43NzE1IDM3Ljg5MDYgMTEuOTEyMUMzNy41ODk4IDEyLjA0ODggMzcuMjM4MyAxMi4xMTcyIDM2LjgzNTkgMTIuMTE3MkMzNi40NjQ4IDEyLjExNzIgMzYuMTI1IDEyLjAzNzEgMzUuODE2NCAxMS44NzdDMzUuNTExNyAxMS43MTY4IDM1LjI0OCAxMS40OTIyIDM1LjAyNTQgMTEuMjAzMUMzNC44MDY2IDEwLjkxNDEgMzQuNjM2NyAxMC41NzQyIDM0LjUxNTYgMTAuMTgzNkMzNC4zOTg0IDkuNzg5MDYgMzQuMzM5OCA5LjM2MTMzIDM0LjMzOTggOC45MDAzOVpNMzUuNDI5NyA4Ljc3NzM0VjguOTAwMzlDMzUuNDI5NyA5LjIxNjggMzUuNDYwOSA5LjUxMzY3IDM1LjUyMzQgOS43OTEwMkMzNS41ODk4IDEwLjA2ODQgMzUuNjkxNCAxMC4zMTI1IDM1LjgyODEgMTAuNTIzNEMzNS45NjQ4IDEwLjczNDQgMzYuMTM4NyAxMC45MDA0IDM2LjM0OTYgMTEuMDIxNUMzNi41NjA1IDExLjEzODcgMzYuODEyNSAxMS4xOTczIDM3LjEwNTUgMTEuMTk3M0MzNy40NjQ4IDExLjE5NzMgMzcuNzU5OCAxMS4xMjExIDM3Ljk5MDIgMTAuOTY4OEMzOC4yMjQ2IDEwLjgxNjQgMzguNDEyMSAxMC42MTUyIDM4LjU1MjcgMTAuMzY1MkMzOC42OTM0IDEwLjExNTIgMzguODAyNyA5Ljg0Mzc1IDM4Ljg4MDkgOS41NTA3OFY4LjEzODY3QzM4LjgzNCA3LjkyMzgzIDM4Ljc2NTYgNy43MTY4IDM4LjY3NTggNy41MTc1OEMzOC41ODk4IDcuMzE0NDUgMzguNDc2NiA3LjEzNDc3IDM4LjMzNTkgNi45Nzg1MkMzOC4xOTkyIDYuODE4MzYgMzguMDI5MyA2LjY5MTQxIDM3LjgyNjIgNi41OTc2NkMzNy42MjcgNi41MDM5MSAzNy4zOTA2IDYuNDU3MDMgMzcuMTE3MiA2LjQ1NzAzQzM2LjgyMDMgNi40NTcwMyAzNi41NjQ1IDYuNTE5NTMgMzYuMzQ5NiA2LjY0NDUzQzM2LjEzODcgNi43NjU2MiAzNS45NjQ4IDYuOTMzNTkgMzUuODI4MSA3LjE0ODQ0QzM1LjY5MTQgNy4zNTkzOCAzNS41ODk4IDcuNjA1NDcgMzUuNTIzNCA3Ljg4NjcyQzM1LjQ2MDkgOC4xNjQwNiAzNS40Mjk3IDguNDYwOTQgMzUuNDI5NyA4Ljc3NzM0Wk00MS4wOTU3IDguOTAwMzlWOC43NjU2MkM0MS4wOTU3IDguMzA4NTkgNDEuMTYyMSA3Ljg4NDc3IDQxLjI5NDkgNy40OTQxNEM0MS40Mjc3IDcuMDk5NjEgNDEuNjE5MSA2Ljc1NzgxIDQxLjg2OTEgNi40Njg3NUM0Mi4xMTkxIDYuMTc1NzggNDIuNDIxOSA1Ljk0OTIyIDQyLjc3NzMgNS43ODkwNkM0My4xMzI4IDUuNjI1IDQzLjUzMTIgNS41NDI5NyA0My45NzI3IDUuNTQyOTdDNDQuNDE4IDUuNTQyOTcgNDQuODE4NCA1LjYyNSA0NS4xNzM4IDUuNzg5MDZDNDUuNTMzMiA1Ljk0OTIyIDQ1LjgzNzkgNi4xNzU3OCA0Ni4wODc5IDYuNDY4NzVDNDYuMzQxOCA2Ljc1NzgxIDQ2LjUzNTIgNy4wOTk2MSA0Ni42NjggNy40OTQxNEM0Ni44MDA4IDcuODg0NzcgNDYuODY3MiA4LjMwODU5IDQ2Ljg2NzIgOC43NjU2MlY4LjkwMDM5QzQ2Ljg2NzIgOS4zNTc0MiA0Ni44MDA4IDkuNzgxMjUgNDYuNjY4IDEwLjE3MTlDNDYuNTM1MiAxMC41NjI1IDQ2LjM0MTggMTAuOTA0MyA0Ni4wODc5IDExLjE5NzNDNDUuODM3OSAxMS40ODYzIDQ1LjUzNTIgMTEuNzEyOSA0NS4xNzk3IDExLjg3N0M0NC44MjgxIDEyLjAzNzEgNDQuNDI5NyAxMi4xMTcyIDQzLjk4NDQgMTIuMTE3MkM0My41MzkxIDEyLjExNzIgNDMuMTM4NyAxMi4wMzcxIDQyLjc4MzIgMTEuODc3QzQyLjQyNzcgMTEuNzEyOSA0Mi4xMjMgMTEuNDg2MyA0MS44NjkxIDExLjE5NzNDNDEuNjE5MSAxMC45MDQzIDQxLjQyNzcgMTAuNTYyNSA0MS4yOTQ5IDEwLjE3MTlDNDEuMTYyMSA5Ljc4MTI1IDQxLjA5NTcgOS4zNTc0MiA0MS4wOTU3IDguOTAwMzlaTTQyLjE3OTcgOC43NjU2MlY4LjkwMDM5QzQyLjE3OTcgOS4yMTY4IDQyLjIxNjggOS41MTU2MiA0Mi4yOTEgOS43OTY4OEM0Mi4zNjUyIDEwLjA3NDIgNDIuNDc2NiAxMC4zMjAzIDQyLjYyNSAxMC41MzUyQzQyLjc3NzMgMTAuNzUgNDIuOTY2OCAxMC45MTk5IDQzLjE5MzQgMTEuMDQ0OUM0My40MTk5IDExLjE2NiA0My42ODM2IDExLjIyNjYgNDMuOTg0NCAxMS4yMjY2QzQ0LjI4MTIgMTEuMjI2NiA0NC41NDEgMTEuMTY2IDQ0Ljc2MzcgMTEuMDQ0OUM0NC45OTAyIDEwLjkxOTkgNDUuMTc3NyAxMC43NSA0NS4zMjYyIDEwLjUzNTJDNDUuNDc0NiAxMC4zMjAzIDQ1LjU4NTkgMTAuMDc0MiA0NS42NjAyIDkuNzk2ODhDNDUuNzM4MyA5LjUxNTYyIDQ1Ljc3NzMgOS4yMTY4IDQ1Ljc3NzMgOC45MDAzOVY4Ljc2NTYyQzQ1Ljc3NzMgOC40NTMxMiA0NS43MzgzIDguMTU4MiA0NS42NjAyIDcuODgwODZDNDUuNTg1OSA3LjU5OTYxIDQ1LjQ3MjcgNy4zNTE1NiA0NS4zMjAzIDcuMTM2NzJDNDUuMTcxOSA2LjkxNzk3IDQ0Ljk4NDQgNi43NDYwOSA0NC43NTc4IDYuNjIxMDlDNDQuNTM1MiA2LjQ5NjA5IDQ0LjI3MzQgNi40MzM1OSA0My45NzI3IDYuNDMzNTlDNDMuNjc1OCA2LjQzMzU5IDQzLjQxNDEgNi40OTYwOSA0My4xODc1IDYuNjIxMDlDNDIuOTY0OCA2Ljc0NjA5IDQyLjc3NzMgNi45MTc5NyA0Mi42MjUgNy4xMzY3MkM0Mi40NzY2IDcuMzUxNTYgNDIuMzY1MiA3LjU5OTYxIDQyLjI5MSA3Ljg4MDg2QzQyLjIxNjggOC4xNTgyIDQyLjE3OTcgOC40NTMxMiA0Mi4xNzk3IDguNzY1NjJaTTUwLjg4MDkgNS42NjAxNlY2LjQ5MjE5SDQ3LjQ1MzFWNS42NjAxNkg1MC44ODA5Wk00OC42MTMzIDQuMTE5MTRINDkuNjk3M1YxMC40Mjk3QzQ5LjY5NzMgMTAuNjQ0NSA0OS43MzA1IDEwLjgwNjYgNDkuNzk2OSAxMC45MTZDNDkuODYzMyAxMS4wMjU0IDQ5Ljk0OTIgMTEuMDk3NyA1MC4wNTQ3IDExLjEzMjhDNTAuMTYwMiAxMS4xNjggNTAuMjczNCAxMS4xODU1IDUwLjM5NDUgMTEuMTg1NUM1MC40ODQ0IDExLjE4NTUgNTAuNTc4MSAxMS4xNzc3IDUwLjY3NTggMTEuMTYyMUM1MC43NzczIDExLjE0MjYgNTAuODUzNSAxMS4xMjcgNTAuOTA0MyAxMS4xMTUyTDUwLjkxMDIgMTJDNTAuODI0MiAxMi4wMjczIDUwLjcxMDkgMTIuMDUyNyA1MC41NzAzIDEyLjA3NjJDNTAuNDMzNiAxMi4xMDM1IDUwLjI2NzYgMTIuMTE3MiA1MC4wNzIzIDEyLjExNzJDNDkuODA2NiAxMi4xMTcyIDQ5LjU2MjUgMTIuMDY0NSA0OS4zMzk4IDExLjk1OUM0OS4xMTcyIDExLjg1MzUgNDguOTM5NSAxMS42Nzc3IDQ4LjgwNjYgMTEuNDMxNkM0OC42Nzc3IDExLjE4MTYgNDguNjEzMyAxMC44NDU3IDQ4LjYxMzMgMTAuNDIzOFY0LjExOTE0Wk01NC44MDY2IDUuNjYwMTZWNi40OTIxOUg1MS4zNzg5VjUuNjYwMTZINTQuODA2NlpNNTIuNTM5MSA0LjExOTE0SDUzLjYyM1YxMC40Mjk3QzUzLjYyMyAxMC42NDQ1IDUzLjY1NjIgMTAuODA2NiA1My43MjI3IDEwLjkxNkM1My43ODkxIDExLjAyNTQgNTMuODc1IDExLjA5NzcgNTMuOTgwNSAxMS4xMzI4QzU0LjA4NTkgMTEuMTY4IDU0LjE5OTIgMTEuMTg1NSA1NC4zMjAzIDExLjE4NTVDNTQuNDEwMiAxMS4xODU1IDU0LjUwMzkgMTEuMTc3NyA1NC42MDE2IDExLjE2MjFDNTQuNzAzMSAxMS4xNDI2IDU0Ljc3OTMgMTEuMTI3IDU0LjgzMDEgMTEuMTE1Mkw1NC44MzU5IDEyQzU0Ljc1IDEyLjAyNzMgNTQuNjM2NyAxMi4wNTI3IDU0LjQ5NjEgMTIuMDc2MkM1NC4zNTk0IDEyLjEwMzUgNTQuMTkzNCAxMi4xMTcyIDUzLjk5OCAxMi4xMTcyQzUzLjczMjQgMTIuMTE3MiA1My40ODgzIDEyLjA2NDUgNTMuMjY1NiAxMS45NTlDNTMuMDQzIDExLjg1MzUgNTIuODY1MiAxMS42Nzc3IDUyLjczMjQgMTEuNDMxNkM1Mi42MDM1IDExLjE4MTYgNTIuNTM5MSAxMC44NDU3IDUyLjUzOTEgMTAuNDIzOFY0LjExOTE0Wk01NS42NzM4IDguOTAwMzlWOC43NjU2MkM1NS42NzM4IDguMzA4NTkgNTUuNzQwMiA3Ljg4NDc3IDU1Ljg3MyA3LjQ5NDE0QzU2LjAwNTkgNy4wOTk2MSA1Ni4xOTczIDYuNzU3ODEgNTYuNDQ3MyA2LjQ2ODc1QzU2LjY5NzMgNi4xNzU3OCA1NyA1Ljk0OTIyIDU3LjM1NTUgNS43ODkwNkM1Ny43MTA5IDUuNjI1IDU4LjEwOTQgNS41NDI5NyA1OC41NTA4IDUuNTQyOTdDNTguOTk2MSA1LjU0Mjk3IDU5LjM5NjUgNS42MjUgNTkuNzUyIDUuNzg5MDZDNjAuMTExMyA1Ljk0OTIyIDYwLjQxNiA2LjE3NTc4IDYwLjY2NiA2LjQ2ODc1QzYwLjkxOTkgNi43NTc4MSA2MS4xMTMzIDcuMDk5NjEgNjEuMjQ2MSA3LjQ5NDE0QzYxLjM3ODkgNy44ODQ3NyA2MS40NDUzIDguMzA4NTkgNjEuNDQ1MyA4Ljc2NTYyVjguOTAwMzlDNjEuNDQ1MyA5LjM1NzQyIDYxLjM3ODkgOS43ODEyNSA2MS4yNDYxIDEwLjE3MTlDNjEuMTEzMyAxMC41NjI1IDYwLjkxOTkgMTAuOTA0MyA2MC42NjYgMTEuMTk3M0M2MC40MTYgMTEuNDg2MyA2MC4xMTMzIDExLjcxMjkgNTkuNzU3OCAxMS44NzdDNTkuNDA2MiAxMi4wMzcxIDU5LjAwNzggMTIuMTE3MiA1OC41NjI1IDEyLjExNzJDNTguMTE3MiAxMi4xMTcyIDU3LjcxNjggMTIuMDM3MSA1Ny4zNjEzIDExLjg3N0M1Ny4wMDU5IDExLjcxMjkgNTYuNzAxMiAxMS40ODYzIDU2LjQ0NzMgMTEuMTk3M0M1Ni4xOTczIDEwLjkwNDMgNTYuMDA1OSAxMC41NjI1IDU1Ljg3MyAxMC4xNzE5QzU1Ljc0MDIgOS43ODEyNSA1NS42NzM4IDkuMzU3NDIgNTUuNjczOCA4LjkwMDM5Wk01Ni43NTc4IDguNzY1NjJWOC45MDAzOUM1Ni43NTc4IDkuMjE2OCA1Ni43OTQ5IDkuNTE1NjIgNTYuODY5MSA5Ljc5Njg4QzU2Ljk0MzQgMTAuMDc0MiA1Ny4wNTQ3IDEwLjMyMDMgNTcuMjAzMSAxMC41MzUyQzU3LjM1NTUgMTAuNzUgNTcuNTQ0OSAxMC45MTk5IDU3Ljc3MTUgMTEuMDQ0OUM1Ny45OTggMTEuMTY2IDU4LjI2MTcgMTEuMjI2NiA1OC41NjI1IDExLjIyNjZDNTguODU5NCAxMS4yMjY2IDU5LjExOTEgMTEuMTY2IDU5LjM0MTggMTEuMDQ0OUM1OS41Njg0IDEwLjkxOTkgNTkuNzU1OSAxMC43NSA1OS45MDQzIDEwLjUzNTJDNjAuMDUyNyAxMC4zMjAzIDYwLjE2NDEgMTAuMDc0MiA2MC4yMzgzIDkuNzk2ODhDNjAuMzE2NCA5LjUxNTYyIDYwLjM1NTUgOS4yMTY4IDYwLjM1NTUgOC45MDAzOVY4Ljc2NTYyQzYwLjM1NTUgOC40NTMxMiA2MC4zMTY0IDguMTU4MiA2MC4yMzgzIDcuODgwODZDNjAuMTY0MSA3LjU5OTYxIDYwLjA1MDggNy4zNTE1NiA1OS44OTg0IDcuMTM2NzJDNTkuNzUgNi45MTc5NyA1OS41NjI1IDYuNzQ2MDkgNTkuMzM1OSA2LjYyMTA5QzU5LjExMzMgNi40OTYwOSA1OC44NTE2IDYuNDMzNTkgNTguNTUwOCA2LjQzMzU5QzU4LjI1MzkgNi40MzM1OSA1Ny45OTIyIDYuNDk2MDkgNTcuNzY1NiA2LjYyMTA5QzU3LjU0MyA2Ljc0NjA5IDU3LjM1NTUgNi45MTc5NyA1Ny4yMDMxIDcuMTM2NzJDNTcuMDU0NyA3LjM1MTU2IDU2Ljk0MzQgNy41OTk2MSA1Ni44NjkxIDcuODgwODZDNTYuNzk0OSA4LjE1ODIgNTYuNzU3OCA4LjQ1MzEyIDU2Ljc1NzggOC43NjU2MloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MC43ODgzIDkuMTI5Mkg2OC45OTg4VjEyLjc3NDVINjhWMy41Mjg0N0g3MC43MzdDNzIuODI1MiAzLjUyODQ3IDczLjIyNjUgNS4xOTExOSA3My4yMjY1IDUuOTgxODFWNi42NTc3NkM3My4yMjY1IDcuNDY5NSA3Mi44MjIyIDkuMTI5MiA3MC43ODgzIDkuMTI5MlpNNzIuMjM5OCA2LjAwNTk1QzcyLjIzOTggNC42OTYzIDcxLjI1MyA0LjUxMjIyIDcwLjcwOTggNC41MTIyMkg2OC45OTU4VjguMTQ1NDVINzAuNzM0QzcxLjI3NzEgOC4xNDU0NSA3Mi4yMzk4IDcuOTQ5MzEgNzIuMjM5OCA2LjYzOTY1VjYuMDA1OTVaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik03NS4zNjYxIDEyLjc3NDVWMy41Mjg0N0g4MC4zNjAyVjQuNTE1MjRINzYuMzUyOFY3LjM5NDA2SDgwLjA2MTVWOC4zODA4M0g3Ni4zNTI4VjExLjgwNThIODAuMzYwMlYxMi43Nzc1SDc1LjM2NjFWMTIuNzc0NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTg3LjE1NTkgMTIuNzc0NUw4NS4zMzkzIDguODY5NjhIODMuODIxNVYxMi43NzQ1SDgyLjgyMjZWMy41Mjg0N0g4NS41NTk2Qzg3LjY0NzggMy41Mjg0NyA4OC4wNjQyIDUuMTc2MSA4OC4wNjQyIDUuOTY2NzJWNi40MDcyOUM4OC4wNjQyIDcuMDk1MzEgODcuNzUzNCA4LjM3NzgxIDg2LjM5MjUgOC43NzkxNUw4OC4yODc1IDEyLjc3NDVIODcuMTU1OVYxMi43NzQ1Wk04Ny4wNjU0IDYuMDA1OTVDODcuMDY1NCA0LjY5NjMgODYuMDc4NiA0LjUxMjIyIDg1LjUzNTUgNC41MTIyMkg4My44MjE1VjcuODk4MDFIODUuNTU5NkM4Ni4xMDU4IDcuODk4MDEgODcuMDY1NCA3LjY4OTc5IDg3LjA2NTQgNi4zOTIyMVY2LjAwNTk1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNOTEuNzYwOSA0LjUxMjIyVjcuNDA2MTNIOTUuNDY5NVY4LjM5MjlIOTEuNzYwOVYxMi43Nzc1SDkwLjc3NDFWMy41Mjg0N0g5NS43NjgzVjQuNTE1MjRIOTEuNzYwOVY0LjUxMjIyWiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNOTcuODQxNCAxMi43NzQ1VjMuNTI4NDdIMTAyLjgzNlY0LjUxNTI0SDk4LjgyODJWNy4zOTQwNkgxMDIuNTM3VjguMzgwODNIOTguODI4MlYxMS44MDU4SDEwMi44MzZWMTIuNzc3NUg5Ny44NDE0VjEyLjc3NDVaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik0xMDcuNzc4IDEyLjg5MjJDMTA1Ljc0MiAxMi44OTIyIDEwNS4xNzEgMTEuMjIwNCAxMDUuMTcxIDEwLjQwMjZWNS44ODgyNkMxMDUuMTcxIDUuMDk3NjQgMTA1LjcwMiAzLjQ1MDAxIDEwNy43OSAzLjQ1MDAxQzEwOS44MTUgMy40NTAwMSAxMTAuMzk4IDUuMDk3NjQgMTEwLjM5OCA1LjkwMzM1SDEwOS4zOTlDMTA5LjM5OSA0LjYxNzg0IDEwOC4zMSA0LjQyNDcxIDEwNy43OSA0LjQyNDcxQzEwNy4yNTkgNC40MjQ3MSAxMDYuMTU4IDQuNjIwODUgMTA2LjE1OCA1LjkxNTQyVjEwLjQwMjZDMTA2LjE1OCAxMS43MTIzIDEwNy4yNTkgMTEuOTA4NCAxMDcuNzkgMTEuOTA4NEMxMDguMzEgMTEuOTA4NCAxMDkuMzk5IDExLjcxMjMgMTA5LjM5OSAxMC40MTc3SDExMC4zOThDMTEwLjM5OCAxMS4yMzI1IDEwOS44NTIgMTIuODkyMiAxMDcuNzc4IDEyLjg5MjJaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik0xMTUuMTk2IDQuNTI3MzFWMTIuNzc3NUgxMTQuMTk3VjQuNTI3MzFIMTExLjk0VjMuNTI4NDdIMTE3LjQ1VjQuNTI3MzFIMTE1LjE5NloiIGZpbGw9IiNEQzNENzIiLz4KPGcgb3BhY2l0eT0iMC43Ij4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMjIuNTUyIDUuNDYxNTJDMTIyLjQwOSA1LjQ2MTUyIDEyMi4yNzIgNS41MTgzMSAxMjIuMTcgNS42MTk0MUMxMjIuMDY5IDUuNzIwNSAxMjIuMDEzIDUuODU3NjEgMTIyLjAxMyA2LjAwMDU4VjExLjkzMDNDMTIyLjAxMyAxMi4wNzMyIDEyMi4wNjkgMTIuMjEwMyAxMjIuMTcgMTIuMzExNEMxMjIuMjcyIDEyLjQxMjUgMTIyLjQwOSAxMi40NjkzIDEyMi41NTIgMTIuNDY5M0gxMjguNDgxQzEyOC42MjQgMTIuNDY5MyAxMjguNzYxIDEyLjQxMjUgMTI4Ljg2MiAxMi4zMTE0QzEyOC45NjQgMTIuMjEwMyAxMjkuMDIgMTIuMDczMiAxMjkuMDIgMTEuOTMwM1Y4LjY5NTg5QzEyOS4wMiA4LjM5ODE4IDEyOS4yNjIgOC4xNTY4MyAxMjkuNTU5IDguMTU2ODNDMTI5Ljg1NyA4LjE1NjgzIDEzMC4wOTggOC4zOTgxOCAxMzAuMDk4IDguNjk1ODlWMTEuOTMwM0MxMzAuMDk4IDEyLjM1OTIgMTI5LjkyOCAxMi43NzA1IDEyOS42MjUgMTMuMDczOEMxMjkuMzIyIDEzLjM3NzEgMTI4LjkxIDEzLjU0NzUgMTI4LjQ4MSAxMy41NDc1SDEyMi41NTJDMTIyLjEyMyAxMy41NDc1IDEyMS43MTEgMTMuMzc3MSAxMjEuNDA4IDEzLjA3MzhDMTIxLjEwNSAxMi43NzA1IDEyMC45MzQgMTIuMzU5MiAxMjAuOTM0IDExLjkzMDNWNi4wMDA1OEMxMjAuOTM0IDUuNTcxNjggMTIxLjEwNSA1LjE2MDM0IDEyMS40MDggNC44NTcwNkMxMjEuNzExIDQuNTUzNzcgMTIyLjEyMyA0LjM4MzM5IDEyMi41NTIgNC4zODMzOUgxMjUuNzg2QzEyNi4wODQgNC4zODMzOSAxMjYuMzI1IDQuNjI0NzQgMTI2LjMyNSA0LjkyMjQ1QzEyNi4zMjUgNS4yMjAxNyAxMjYuMDg0IDUuNDYxNTIgMTI1Ljc4NiA1LjQ2MTUySDEyMi41NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyNy45NDIgMi43NjYxN0MxMjcuNjQ0IDIuNzY2MTcgMTI3LjQwMyAzLjAwNzUyIDEyNy40MDMgMy4zMDUyNEMxMjcuNDAzIDMuNjAyOTUgMTI3LjY0NCAzLjg0NDMgMTI3Ljk0MiAzLjg0NDNIMTI5Ljg3NUwxMjQuODY2IDguODUzNzdDMTI0LjY1NSA5LjA2NDI5IDEyNC42NTUgOS40MDU2MSAxMjQuODY2IDkuNjE2MTJDMTI1LjA3NiA5LjgyNjY0IDEyNS40MTggOS44MjY2NCAxMjUuNjI4IDkuNjE2MTJMMTMwLjYzOCA0LjYwNjdWNi41Mzk2MUMxMzAuNjM4IDYuODM3MzMgMTMwLjg3OSA3LjA3ODY3IDEzMS4xNzcgNy4wNzg2N0MxMzEuNDc0IDcuMDc4NjcgMTMxLjcxNiA2LjgzNzMzIDEzMS43MTYgNi41Mzk2MVYzLjMxMDM3QzEzMS43MTYgMy4zMDY5NyAxMzEuNzE2IDMuMzAzNTYgMTMxLjcxNiAzLjMwMDE1VjMuMjMyNTFDMTMxLjcxNiAyLjkzNDc5IDEzMS40NzQgMi43NjYxNyAxMzEuMTc3IDIuNzY2MTdIMTI3Ljk0MloiIGZpbGw9IndoaXRlIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGZpbHRlciBpZD0iZmlsdGVyMF9kXzJfMzA5IiB4PSIwLjgyNDIxOSIgeT0iMCIgd2lkdGg9IjEzMi45NzYiIGhlaWdodD0iMTYuMTUiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+CjxmZU9mZnNldCBkeD0iMS4xNSIgZHk9IjEuMTUiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd18yXzMwOSIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd18yXzMwOSIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K"

/***/ }),

/***/ 836:
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTU4IiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTU4IDE2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kXzJfMzM5KSI+CjxwYXRoIG9wYWNpdHk9IjAuNyIgZD0iTTMuNTgzOTggMTJIMS44MDI3M0wxLjgxNDQ1IDExLjA4MDFIMy41ODM5OEM0LjE5MzM2IDExLjA4MDEgNC43MDExNyAxMC45NTMxIDUuMTA3NDIgMTAuNjk5MkM1LjUxMzY3IDEwLjQ0MTQgNS44MTgzNiAxMC4wODIgNi4wMjE0OCA5LjYyMTA5QzYuMjI4NTIgOS4xNTYyNSA2LjMzMjAzIDguNjEzMjggNi4zMzIwMyA3Ljk5MjE5VjcuNDcwN0M2LjMzMjAzIDYuOTgyNDIgNi4yNzM0NCA2LjU0ODgzIDYuMTU2MjUgNi4xNjk5MkM2LjAzOTA2IDUuNzg3MTEgNS44NjcxOSA1LjQ2NDg0IDUuNjQwNjIgNS4yMDMxMkM1LjQxNDA2IDQuOTM3NSA1LjEzNjcyIDQuNzM2MzMgNC44MDg1OSA0LjU5OTYxQzQuNDg0MzggNC40NjI4OSA0LjExMTMzIDQuMzk0NTMgMy42ODk0NSA0LjM5NDUzSDEuNzY3NThWMy40Njg3NUgzLjY4OTQ1QzQuMjQ4MDUgMy40Njg3NSA0Ljc1NzgxIDMuNTYyNSA1LjIxODc1IDMuNzVDNS42Nzk2OSAzLjkzMzU5IDYuMDc2MTcgNC4yMDExNyA2LjQwODIgNC41NTI3M0M2Ljc0NDE0IDQuOTAwMzkgNy4wMDE5NSA1LjMyMjI3IDcuMTgxNjQgNS44MTgzNkM3LjM2MTMzIDYuMzEwNTUgNy40NTExNyA2Ljg2NTIzIDcuNDUxMTcgNy40ODI0MlY3Ljk5MjE5QzcuNDUxMTcgOC42MDkzOCA3LjM2MTMzIDkuMTY2MDIgNy4xODE2NCA5LjY2MjExQzcuMDAxOTUgMTAuMTU0MyA2Ljc0MjE5IDEwLjU3NDIgNi40MDIzNCAxMC45MjE5QzYuMDY2NDEgMTEuMjY5NSA1LjY2MDE2IDExLjUzNzEgNS4xODM1OSAxMS43MjQ2QzQuNzEwOTQgMTEuOTA4MiA0LjE3NzczIDEyIDMuNTgzOTggMTJaTTIuNDA2MjUgMy40Njg3NVYxMkgxLjI3NTM5VjMuNDY4NzVIMi40MDYyNVpNMTEuNjE3MiAxMi4xMTcyQzExLjE3NTggMTIuMTE3MiAxMC43NzU0IDEyLjA0MyAxMC40MTYgMTEuODk0NUMxMC4wNjA1IDExLjc0MjIgOS43NTM5MSAxMS41MjkzIDkuNDk2MDkgMTEuMjU1OUM5LjI0MjE5IDEwLjk4MjQgOS4wNDY4OCAxMC42NTgyIDguOTEwMTYgMTAuMjgzMkM4Ljc3MzQ0IDkuOTA4MiA4LjcwNTA4IDkuNDk4MDUgOC43MDUwOCA5LjA1MjczVjguODA2NjRDOC43MDUwOCA4LjI5MTAyIDguNzgxMjUgNy44MzIwMyA4LjkzMzU5IDcuNDI5NjlDOS4wODU5NCA3LjAyMzQ0IDkuMjkyOTcgNi42Nzk2OSA5LjU1NDY5IDYuMzk4NDRDOS44MTY0MSA2LjExNzE5IDEwLjExMzMgNS45MDQzIDEwLjQ0NTMgNS43NTk3N0MxMC43NzczIDUuNjE1MjMgMTEuMTIxMSA1LjU0Mjk3IDExLjQ3NjYgNS41NDI5N0MxMS45Mjk3IDUuNTQyOTcgMTIuMzIwMyA1LjYyMTA5IDEyLjY0ODQgNS43NzczNEMxMi45ODA1IDUuOTMzNTkgMTMuMjUyIDYuMTUyMzQgMTMuNDYyOSA2LjQzMzU5QzEzLjY3MzggNi43MTA5NCAxMy44MzAxIDcuMDM5MDYgMTMuOTMxNiA3LjQxNzk3QzE0LjAzMzIgNy43OTI5NyAxNC4wODQgOC4yMDMxMiAxNC4wODQgOC42NDg0NFY5LjEzNDc3SDkuMzQ5NjFWOC4yNUgxM1Y4LjE2Nzk3QzEyLjk4NDQgNy44ODY3MiAxMi45MjU4IDcuNjEzMjggMTIuODI0MiA3LjM0NzY2QzEyLjcyNjYgNy4wODIwMyAxMi41NzAzIDYuODYzMjggMTIuMzU1NSA2LjY5MTQxQzEyLjE0MDYgNi41MTk1MyAxMS44NDc3IDYuNDMzNTkgMTEuNDc2NiA2LjQzMzU5QzExLjIzMDUgNi40MzM1OSAxMS4wMDM5IDYuNDg2MzMgMTAuNzk2OSA2LjU5MThDMTAuNTg5OCA2LjY5MzM2IDEwLjQxMjEgNi44NDU3IDEwLjI2MzcgNy4wNDg4M0MxMC4xMTUyIDcuMjUxOTUgMTAgNy41IDkuOTE3OTcgNy43OTI5N0M5LjgzNTk0IDguMDg1OTQgOS43OTQ5MiA4LjQyMzgzIDkuNzk0OTIgOC44MDY2NFY5LjA1MjczQzkuNzk0OTIgOS4zNTM1MiA5LjgzNTk0IDkuNjM2NzIgOS45MTc5NyA5LjkwMjM0QzEwLjAwMzkgMTAuMTY0MSAxMC4xMjcgMTAuMzk0NSAxMC4yODcxIDEwLjU5MzhDMTAuNDUxMiAxMC43OTMgMTAuNjQ4NCAxMC45NDkyIDEwLjg3ODkgMTEuMDYyNUMxMS4xMTMzIDExLjE3NTggMTEuMzc4OSAxMS4yMzI0IDExLjY3NTggMTEuMjMyNEMxMi4wNTg2IDExLjIzMjQgMTIuMzgyOCAxMS4xNTQzIDEyLjY0ODQgMTAuOTk4QzEyLjkxNDEgMTAuODQxOCAxMy4xNDY1IDEwLjYzMjggMTMuMzQ1NyAxMC4zNzExTDE0LjAwMiAxMC44OTI2QzEzLjg2NTIgMTEuMDk5NiAxMy42OTE0IDExLjI5NjkgMTMuNDgwNSAxMS40ODQ0QzEzLjI2OTUgMTEuNjcxOSAxMy4wMDk4IDExLjgyNDIgMTIuNzAxMiAxMS45NDE0QzEyLjM5NjUgMTIuMDU4NiAxMi4wMzUyIDEyLjExNzIgMTEuNjE3MiAxMi4xMTcyWk0xOS4wNDEgMTAuMzE4NEMxOS4wNDEgMTAuMTYyMSAxOS4wMDU5IDEwLjAxNzYgMTguOTM1NSA5Ljg4NDc3QzE4Ljg2OTEgOS43NDgwNSAxOC43MzA1IDkuNjI1IDE4LjUxOTUgOS41MTU2MkMxOC4zMTI1IDkuNDAyMzQgMTggOS4zMDQ2OSAxNy41ODIgOS4yMjI2NkMxNy4yMzA1IDkuMTQ4NDQgMTYuOTEyMSA5LjA2MDU1IDE2LjYyNyA4Ljk1ODk4QzE2LjM0NTcgOC44NTc0MiAxNi4xMDU1IDguNzM0MzggMTUuOTA2MiA4LjU4OTg0QzE1LjcxMDkgOC40NDUzMSAxNS41NjA1IDguMjc1MzkgMTUuNDU1MSA4LjA4MDA4QzE1LjM0OTYgNy44ODQ3NyAxNS4yOTY5IDcuNjU2MjUgMTUuMjk2OSA3LjM5NDUzQzE1LjI5NjkgNy4xNDQ1MyAxNS4zNTE2IDYuOTA4MiAxNS40NjA5IDYuNjg1NTVDMTUuNTc0MiA2LjQ2Mjg5IDE1LjczMjQgNi4yNjU2MiAxNS45MzU1IDYuMDkzNzVDMTYuMTQyNiA1LjkyMTg4IDE2LjM5MDYgNS43ODcxMSAxNi42Nzk3IDUuNjg5NDVDMTYuOTY4OCA1LjU5MTggMTcuMjkxIDUuNTQyOTcgMTcuNjQ2NSA1LjU0Mjk3QzE4LjE1NDMgNS41NDI5NyAxOC41ODc5IDUuNjMyODEgMTguOTQ3MyA1LjgxMjVDMTkuMzA2NiA1Ljk5MjE5IDE5LjU4MiA2LjIzMjQyIDE5Ljc3MzQgNi41MzMyQzE5Ljk2NDggNi44MzAwOCAyMC4wNjA1IDcuMTYwMTYgMjAuMDYwNSA3LjUyMzQ0SDE4Ljk3NjZDMTguOTc2NiA3LjM0NzY2IDE4LjkyMzggNy4xNzc3MyAxOC44MTg0IDcuMDEzNjdDMTguNzE2OCA2Ljg0NTcgMTguNTY2NCA2LjcwNzAzIDE4LjM2NzIgNi41OTc2NkMxOC4xNzE5IDYuNDg4MjggMTcuOTMxNiA2LjQzMzU5IDE3LjY0NjUgNi40MzM1OUMxNy4zNDU3IDYuNDMzNTkgMTcuMTAxNiA2LjQ4MDQ3IDE2LjkxNDEgNi41NzQyMkMxNi43MzA1IDYuNjY0MDYgMTYuNTk1NyA2Ljc3OTMgMTYuNTA5OCA2LjkxOTkyQzE2LjQyNzcgNy4wNjA1NSAxNi4zODY3IDcuMjA4OTggMTYuMzg2NyA3LjM2NTIzQzE2LjM4NjcgNy40ODI0MiAxNi40MDYyIDcuNTg3ODkgMTYuNDQ1MyA3LjY4MTY0QzE2LjQ4ODMgNy43NzE0OCAxNi41NjI1IDcuODU1NDcgMTYuNjY4IDcuOTMzNTlDMTYuNzczNCA4LjAwNzgxIDE2LjkyMTkgOC4wNzgxMiAxNy4xMTMzIDguMTQ0NTNDMTcuMzA0NyA4LjIxMDk0IDE3LjU0ODggOC4yNzczNCAxNy44NDU3IDguMzQzNzVDMTguMzY1MiA4LjQ2MDk0IDE4Ljc5MyA4LjYwMTU2IDE5LjEyODkgOC43NjU2MkMxOS40NjQ4IDguOTI5NjkgMTkuNzE0OCA5LjEzMDg2IDE5Ljg3ODkgOS4zNjkxNEMyMC4wNDMgOS42MDc0MiAyMC4xMjUgOS44OTY0OCAyMC4xMjUgMTAuMjM2M0MyMC4xMjUgMTAuNTEzNyAyMC4wNjY0IDEwLjc2NzYgMTkuOTQ5MiAxMC45OThDMTkuODM1OSAxMS4yMjg1IDE5LjY2OTkgMTEuNDI3NyAxOS40NTEyIDExLjU5NTdDMTkuMjM2MyAxMS43NTk4IDE4Ljk3ODUgMTEuODg4NyAxOC42Nzc3IDExLjk4MjRDMTguMzgwOSAxMi4wNzIzIDE4LjA0NjkgMTIuMTE3MiAxNy42NzU4IDEyLjExNzJDMTcuMTE3MiAxMi4xMTcyIDE2LjY0NDUgMTIuMDE3NiAxNi4yNTc4IDExLjgxODRDMTUuODcxMSAxMS42MTkxIDE1LjU3ODEgMTEuMzYxMyAxNS4zNzg5IDExLjA0NDlDMTUuMTc5NyAxMC43Mjg1IDE1LjA4MDEgMTAuMzk0NSAxNS4wODAxIDEwLjA0M0gxNi4xNjk5QzE2LjE4NTUgMTAuMzM5OCAxNi4yNzE1IDEwLjU3NjIgMTYuNDI3NyAxMC43NTJDMTYuNTg0IDEwLjkyMzggMTYuNzc1NCAxMS4wNDY5IDE3LjAwMiAxMS4xMjExQzE3LjIyODUgMTEuMTkxNCAxNy40NTMxIDExLjIyNjYgMTcuNjc1OCAxMS4yMjY2QzE3Ljk3MjcgMTEuMjI2NiAxOC4yMjA3IDExLjE4NzUgMTguNDE5OSAxMS4xMDk0QzE4LjYyMyAxMS4wMzEyIDE4Ljc3NzMgMTAuOTIzOCAxOC44ODI4IDEwLjc4NzFDMTguOTg4MyAxMC42NTA0IDE5LjA0MSAxMC40OTQxIDE5LjA0MSAxMC4zMTg0Wk0yNS4yODcxIDEwLjkxNlY3LjY1MjM0QzI1LjI4NzEgNy40MDIzNCAyNS4yMzYzIDcuMTg1NTUgMjUuMTM0OCA3LjAwMTk1QzI1LjAzNzEgNi44MTQ0NSAyNC44ODg3IDYuNjY5OTIgMjQuNjg5NSA2LjU2ODM2QzI0LjQ5MDIgNi40NjY4IDI0LjI0NDEgNi40MTYwMiAyMy45NTEyIDYuNDE2MDJDMjMuNjc3NyA2LjQxNjAyIDIzLjQzNzUgNi40NjI4OSAyMy4yMzA1IDYuNTU2NjRDMjMuMDI3MyA2LjY1MDM5IDIyLjg2NzIgNi43NzM0NCAyMi43NSA2LjkyNTc4QzIyLjYzNjcgNy4wNzgxMiAyMi41ODAxIDcuMjQyMTkgMjIuNTgwMSA3LjQxNzk3SDIxLjQ5NjFDMjEuNDk2MSA3LjE5MTQxIDIxLjU1NDcgNi45NjY4IDIxLjY3MTkgNi43NDQxNEMyMS43ODkxIDYuNTIxNDggMjEuOTU3IDYuMzIwMzEgMjIuMTc1OCA2LjE0MDYyQzIyLjM5ODQgNS45NTcwMyAyMi42NjQxIDUuODEyNSAyMi45NzI3IDUuNzA3MDNDMjMuMjg1MiA1LjU5NzY2IDIzLjYzMjggNS41NDI5NyAyNC4wMTU2IDUuNTQyOTdDMjQuNDc2NiA1LjU0Mjk3IDI0Ljg4MjggNS42MjEwOSAyNS4yMzQ0IDUuNzc3MzRDMjUuNTg5OCA1LjkzMzU5IDI1Ljg2NzIgNi4xNjk5MiAyNi4wNjY0IDYuNDg2MzNDMjYuMjY5NSA2Ljc5ODgzIDI2LjM3MTEgNy4xOTE0MSAyNi4zNzExIDcuNjY0MDZWMTAuNjE3MkMyNi4zNzExIDEwLjgyODEgMjYuMzg4NyAxMS4wNTI3IDI2LjQyMzggMTEuMjkxQzI2LjQ2MjkgMTEuNTI5MyAyNi41MTk1IDExLjczNDQgMjYuNTkzOCAxMS45MDYyVjEySDI1LjQ2MjlDMjUuNDA4MiAxMS44NzUgMjUuMzY1MiAxMS43MDkgMjUuMzM0IDExLjUwMkMyNS4zMDI3IDExLjI5MSAyNS4yODcxIDExLjA5NTcgMjUuMjg3MSAxMC45MTZaTTI1LjQ3NDYgOC4xNTYyNUwyNS40ODYzIDguOTE3OTdIMjQuMzkwNkMyNC4wODIgOC45MTc5NyAyMy44MDY2IDguOTQzMzYgMjMuNTY0NSA4Ljk5NDE0QzIzLjMyMjMgOS4wNDEwMiAyMy4xMTkxIDkuMTEzMjggMjIuOTU1MSA5LjIxMDk0QzIyLjc5MSA5LjMwODU5IDIyLjY2NiA5LjQzMTY0IDIyLjU4MDEgOS41ODAwOEMyMi40OTQxIDkuNzI0NjEgMjIuNDUxMiA5Ljg5NDUzIDIyLjQ1MTIgMTAuMDg5OEMyMi40NTEyIDEwLjI4OTEgMjIuNDk2MSAxMC40NzA3IDIyLjU4NTkgMTAuNjM0OEMyMi42NzU4IDEwLjc5ODggMjIuODEwNSAxMC45Mjk3IDIyLjk5MDIgMTEuMDI3M0MyMy4xNzM4IDExLjEyMTEgMjMuMzk4NCAxMS4xNjggMjMuNjY0MSAxMS4xNjhDMjMuOTk2MSAxMS4xNjggMjQuMjg5MSAxMS4wOTc3IDI0LjU0MyAxMC45NTdDMjQuNzk2OSAxMC44MTY0IDI0Ljk5OCAxMC42NDQ1IDI1LjE0NjUgMTAuNDQxNEMyNS4yOTg4IDEwLjIzODMgMjUuMzgwOSAxMC4wNDEgMjUuMzkyNiA5Ljg0OTYxTDI1Ljg1NTUgMTAuMzcxMUMyNS44MjgxIDEwLjUzNTIgMjUuNzUzOSAxMC43MTY4IDI1LjYzMjggMTAuOTE2QzI1LjUxMTcgMTEuMTE1MiAyNS4zNDk2IDExLjMwNjYgMjUuMTQ2NSAxMS40OTAyQzI0Ljk0NzMgMTEuNjY5OSAyNC43MDkgMTEuODIwMyAyNC40MzE2IDExLjk0MTRDMjQuMTU4MiAxMi4wNTg2IDIzLjg0OTYgMTIuMTE3MiAyMy41MDU5IDEyLjExNzJDMjMuMDc2MiAxMi4xMTcyIDIyLjY5OTIgMTIuMDMzMiAyMi4zNzUgMTEuODY1MkMyMi4wNTQ3IDExLjY5NzMgMjEuODA0NyAxMS40NzI3IDIxLjYyNSAxMS4xOTE0QzIxLjQ0OTIgMTAuOTA2MiAyMS4zNjEzIDEwLjU4NzkgMjEuMzYxMyAxMC4yMzYzQzIxLjM2MTMgOS44OTY0OCAyMS40Mjc3IDkuNTk3NjYgMjEuNTYwNSA5LjMzOTg0QzIxLjY5MzQgOS4wNzgxMiAyMS44ODQ4IDguODYxMzMgMjIuMTM0OCA4LjY4OTQ1QzIyLjM4NDggOC41MTM2NyAyMi42ODU1IDguMzgwODYgMjMuMDM3MSA4LjI5MTAyQzIzLjM4ODcgOC4yMDExNyAyMy43ODEyIDguMTU2MjUgMjQuMjE0OCA4LjE1NjI1SDI1LjQ3NDZaTTI5LjE2MDIgNi42NTYyNVYxMkgyOC4wNzYyVjUuNjYwMTZIMjkuMTMwOUwyOS4xNjAyIDYuNjU2MjVaTTMxLjE0MDYgNS42MjVMMzEuMTM0OCA2LjYzMjgxQzMxLjA0NDkgNi42MTMyOCAzMC45NTkgNi42MDE1NiAzMC44NzcgNi41OTc2NkMzMC43OTg4IDYuNTg5ODQgMzAuNzA5IDYuNTg1OTQgMzAuNjA3NCA2LjU4NTk0QzMwLjM1NzQgNi41ODU5NCAzMC4xMzY3IDYuNjI1IDI5Ljk0NTMgNi43MDMxMkMyOS43NTM5IDYuNzgxMjUgMjkuNTkxOCA2Ljg5MDYyIDI5LjQ1OSA3LjAzMTI1QzI5LjMyNjIgNy4xNzE4OCAyOS4yMjA3IDcuMzM5ODQgMjkuMTQyNiA3LjUzNTE2QzI5LjA2ODQgNy43MjY1NiAyOS4wMTk1IDcuOTM3NSAyOC45OTYxIDguMTY3OTdMMjguNjkxNCA4LjM0Mzc1QzI4LjY5MTQgNy45NjA5NCAyOC43Mjg1IDcuNjAxNTYgMjguODAyNyA3LjI2NTYyQzI4Ljg4MDkgNi45Mjk2OSAyOSA2LjYzMjgxIDI5LjE2MDIgNi4zNzVDMjkuMzIwMyA2LjExMzI4IDI5LjUyMzQgNS45MTAxNiAyOS43Njk1IDUuNzY1NjJDMzAuMDE5NSA1LjYxNzE5IDMwLjMxNjQgNS41NDI5NyAzMC42NjAyIDUuNTQyOTdDMzAuNzM4MyA1LjU0Mjk3IDMwLjgyODEgNS41NTI3MyAzMC45Mjk3IDUuNTcyMjdDMzEuMDMxMiA1LjU4Nzg5IDMxLjEwMTYgNS42MDU0NyAzMS4xNDA2IDUuNjI1Wk0zMy4yMjY2IDYuNjU2MjVWMTJIMzIuMTQyNlY1LjY2MDE2SDMzLjE5NzNMMzMuMjI2NiA2LjY1NjI1Wk0zNS4yMDcgNS42MjVMMzUuMjAxMiA2LjYzMjgxQzM1LjExMTMgNi42MTMyOCAzNS4wMjU0IDYuNjAxNTYgMzQuOTQzNCA2LjU5NzY2QzM0Ljg2NTIgNi41ODk4NCAzNC43NzU0IDYuNTg1OTQgMzQuNjczOCA2LjU4NTk0QzM0LjQyMzggNi41ODU5NCAzNC4yMDMxIDYuNjI1IDM0LjAxMTcgNi43MDMxMkMzMy44MjAzIDYuNzgxMjUgMzMuNjU4MiA2Ljg5MDYyIDMzLjUyNTQgNy4wMzEyNUMzMy4zOTI2IDcuMTcxODggMzMuMjg3MSA3LjMzOTg0IDMzLjIwOSA3LjUzNTE2QzMzLjEzNDggNy43MjY1NiAzMy4wODU5IDcuOTM3NSAzMy4wNjI1IDguMTY3OTdMMzIuNzU3OCA4LjM0Mzc1QzMyLjc1NzggNy45NjA5NCAzMi43OTQ5IDcuNjAxNTYgMzIuODY5MSA3LjI2NTYyQzMyLjk0NzMgNi45Mjk2OSAzMy4wNjY0IDYuNjMyODEgMzMuMjI2NiA2LjM3NUMzMy4zODY3IDYuMTEzMjggMzMuNTg5OCA1LjkxMDE2IDMzLjgzNTkgNS43NjU2MkMzNC4wODU5IDUuNjE3MTkgMzQuMzgyOCA1LjU0Mjk3IDM0LjcyNjYgNS41NDI5N0MzNC44MDQ3IDUuNTQyOTcgMzQuODk0NSA1LjU1MjczIDM0Ljk5NjEgNS41NzIyN0MzNS4wOTc3IDUuNTg3ODkgMzUuMTY4IDUuNjA1NDcgMzUuMjA3IDUuNjI1Wk0zNS44MDQ3IDguOTAwMzlWOC43NjU2MkMzNS44MDQ3IDguMzA4NTkgMzUuODcxMSA3Ljg4NDc3IDM2LjAwMzkgNy40OTQxNEMzNi4xMzY3IDcuMDk5NjEgMzYuMzI4MSA2Ljc1NzgxIDM2LjU3ODEgNi40Njg3NUMzNi44MjgxIDYuMTc1NzggMzcuMTMwOSA1Ljk0OTIyIDM3LjQ4NjMgNS43ODkwNkMzNy44NDE4IDUuNjI1IDM4LjI0MDIgNS41NDI5NyAzOC42ODE2IDUuNTQyOTdDMzkuMTI3IDUuNTQyOTcgMzkuNTI3MyA1LjYyNSAzOS44ODI4IDUuNzg5MDZDNDAuMjQyMiA1Ljk0OTIyIDQwLjU0NjkgNi4xNzU3OCA0MC43OTY5IDYuNDY4NzVDNDEuMDUwOCA2Ljc1NzgxIDQxLjI0NDEgNy4wOTk2MSA0MS4zNzcgNy40OTQxNEM0MS41MDk4IDcuODg0NzcgNDEuNTc2MiA4LjMwODU5IDQxLjU3NjIgOC43NjU2MlY4LjkwMDM5QzQxLjU3NjIgOS4zNTc0MiA0MS41MDk4IDkuNzgxMjUgNDEuMzc3IDEwLjE3MTlDNDEuMjQ0MSAxMC41NjI1IDQxLjA1MDggMTAuOTA0MyA0MC43OTY5IDExLjE5NzNDNDAuNTQ2OSAxMS40ODYzIDQwLjI0NDEgMTEuNzEyOSAzOS44ODg3IDExLjg3N0MzOS41MzcxIDEyLjAzNzEgMzkuMTM4NyAxMi4xMTcyIDM4LjY5MzQgMTIuMTE3MkMzOC4yNDggMTIuMTE3MiAzNy44NDc3IDEyLjAzNzEgMzcuNDkyMiAxMS44NzdDMzcuMTM2NyAxMS43MTI5IDM2LjgzMiAxMS40ODYzIDM2LjU3ODEgMTEuMTk3M0MzNi4zMjgxIDEwLjkwNDMgMzYuMTM2NyAxMC41NjI1IDM2LjAwMzkgMTAuMTcxOUMzNS44NzExIDkuNzgxMjUgMzUuODA0NyA5LjM1NzQyIDM1LjgwNDcgOC45MDAzOVpNMzYuODg4NyA4Ljc2NTYyVjguOTAwMzlDMzYuODg4NyA5LjIxNjggMzYuOTI1OCA5LjUxNTYyIDM3IDkuNzk2ODhDMzcuMDc0MiAxMC4wNzQyIDM3LjE4NTUgMTAuMzIwMyAzNy4zMzQgMTAuNTM1MkMzNy40ODYzIDEwLjc1IDM3LjY3NTggMTAuOTE5OSAzNy45MDIzIDExLjA0NDlDMzguMTI4OSAxMS4xNjYgMzguMzkyNiAxMS4yMjY2IDM4LjY5MzQgMTEuMjI2NkMzOC45OTAyIDExLjIyNjYgMzkuMjUgMTEuMTY2IDM5LjQ3MjcgMTEuMDQ0OUMzOS42OTkyIDEwLjkxOTkgMzkuODg2NyAxMC43NSA0MC4wMzUyIDEwLjUzNTJDNDAuMTgzNiAxMC4zMjAzIDQwLjI5NDkgMTAuMDc0MiA0MC4zNjkxIDkuNzk2ODhDNDAuNDQ3MyA5LjUxNTYyIDQwLjQ4NjMgOS4yMTY4IDQwLjQ4NjMgOC45MDAzOVY4Ljc2NTYyQzQwLjQ4NjMgOC40NTMxMiA0MC40NDczIDguMTU4MiA0MC4zNjkxIDcuODgwODZDNDAuMjk0OSA3LjU5OTYxIDQwLjE4MTYgNy4zNTE1NiA0MC4wMjkzIDcuMTM2NzJDMzkuODgwOSA2LjkxNzk3IDM5LjY5MzQgNi43NDYwOSAzOS40NjY4IDYuNjIxMDlDMzkuMjQ0MSA2LjQ5NjA5IDM4Ljk4MjQgNi40MzM1OSAzOC42ODE2IDYuNDMzNTlDMzguMzg0OCA2LjQzMzU5IDM4LjEyMyA2LjQ5NjA5IDM3Ljg5NjUgNi42MjEwOUMzNy42NzM4IDYuNzQ2MDkgMzcuNDg2MyA2LjkxNzk3IDM3LjMzNCA3LjEzNjcyQzM3LjE4NTUgNy4zNTE1NiAzNy4wNzQyIDcuNTk5NjEgMzcgNy44ODA4NkMzNi45MjU4IDguMTU4MiAzNi44ODg3IDguNDUzMTIgMzYuODg4NyA4Ljc2NTYyWk00NC4xMTMzIDNWMTJINDMuMDIzNFYzSDQ0LjExMzNaTTQ3LjAzMTIgM1YxMkg0NS45NDE0VjNINDcuMDMxMlpNNTIuNTA5OCAxMC45MTZWNy42NTIzNEM1Mi41MDk4IDcuNDAyMzQgNTIuNDU5IDcuMTg1NTUgNTIuMzU3NCA3LjAwMTk1QzUyLjI1OTggNi44MTQ0NSA1Mi4xMTEzIDYuNjY5OTIgNTEuOTEyMSA2LjU2ODM2QzUxLjcxMjkgNi40NjY4IDUxLjQ2NjggNi40MTYwMiA1MS4xNzM4IDYuNDE2MDJDNTAuOTAwNCA2LjQxNjAyIDUwLjY2MDIgNi40NjI4OSA1MC40NTMxIDYuNTU2NjRDNTAuMjUgNi42NTAzOSA1MC4wODk4IDYuNzczNDQgNDkuOTcyNyA2LjkyNTc4QzQ5Ljg1OTQgNy4wNzgxMiA0OS44MDI3IDcuMjQyMTkgNDkuODAyNyA3LjQxNzk3SDQ4LjcxODhDNDguNzE4OCA3LjE5MTQxIDQ4Ljc3NzMgNi45NjY4IDQ4Ljg5NDUgNi43NDQxNEM0OS4wMTE3IDYuNTIxNDggNDkuMTc5NyA2LjMyMDMxIDQ5LjM5ODQgNi4xNDA2MkM0OS42MjExIDUuOTU3MDMgNDkuODg2NyA1LjgxMjUgNTAuMTk1MyA1LjcwNzAzQzUwLjUwNzggNS41OTc2NiA1MC44NTU1IDUuNTQyOTcgNTEuMjM4MyA1LjU0Mjk3QzUxLjY5OTIgNS41NDI5NyA1Mi4xMDU1IDUuNjIxMDkgNTIuNDU3IDUuNzc3MzRDNTIuODEyNSA1LjkzMzU5IDUzLjA4OTggNi4xNjk5MiA1My4yODkxIDYuNDg2MzNDNTMuNDkyMiA2Ljc5ODgzIDUzLjU5MzggNy4xOTE0MSA1My41OTM4IDcuNjY0MDZWMTAuNjE3MkM1My41OTM4IDEwLjgyODEgNTMuNjExMyAxMS4wNTI3IDUzLjY0NjUgMTEuMjkxQzUzLjY4NTUgMTEuNTI5MyA1My43NDIyIDExLjczNDQgNTMuODE2NCAxMS45MDYyVjEySDUyLjY4NTVDNTIuNjMwOSAxMS44NzUgNTIuNTg3OSAxMS43MDkgNTIuNTU2NiAxMS41MDJDNTIuNTI1NCAxMS4yOTEgNTIuNTA5OCAxMS4wOTU3IDUyLjUwOTggMTAuOTE2Wk01Mi42OTczIDguMTU2MjVMNTIuNzA5IDguOTE3OTdINTEuNjEzM0M1MS4zMDQ3IDguOTE3OTcgNTEuMDI5MyA4Ljk0MzM2IDUwLjc4NzEgOC45OTQxNEM1MC41NDQ5IDkuMDQxMDIgNTAuMzQxOCA5LjExMzI4IDUwLjE3NzcgOS4yMTA5NEM1MC4wMTM3IDkuMzA4NTkgNDkuODg4NyA5LjQzMTY0IDQ5LjgwMjcgOS41ODAwOEM0OS43MTY4IDkuNzI0NjEgNDkuNjczOCA5Ljg5NDUzIDQ5LjY3MzggMTAuMDg5OEM0OS42NzM4IDEwLjI4OTEgNDkuNzE4OCAxMC40NzA3IDQ5LjgwODYgMTAuNjM0OEM0OS44OTg0IDEwLjc5ODggNTAuMDMzMiAxMC45Mjk3IDUwLjIxMjkgMTEuMDI3M0M1MC4zOTY1IDExLjEyMTEgNTAuNjIxMSAxMS4xNjggNTAuODg2NyAxMS4xNjhDNTEuMjE4OCAxMS4xNjggNTEuNTExNyAxMS4wOTc3IDUxLjc2NTYgMTAuOTU3QzUyLjAxOTUgMTAuODE2NCA1Mi4yMjA3IDEwLjY0NDUgNTIuMzY5MSAxMC40NDE0QzUyLjUyMTUgMTAuMjM4MyA1Mi42MDM1IDEwLjA0MSA1Mi42MTUyIDkuODQ5NjFMNTMuMDc4MSAxMC4zNzExQzUzLjA1MDggMTAuNTM1MiA1Mi45NzY2IDEwLjcxNjggNTIuODU1NSAxMC45MTZDNTIuNzM0NCAxMS4xMTUyIDUyLjU3MjMgMTEuMzA2NiA1Mi4zNjkxIDExLjQ5MDJDNTIuMTY5OSAxMS42Njk5IDUxLjkzMTYgMTEuODIwMyA1MS42NTQzIDExLjk0MTRDNTEuMzgwOSAxMi4wNTg2IDUxLjA3MjMgMTIuMTE3MiA1MC43Mjg1IDEyLjExNzJDNTAuMjk4OCAxMi4xMTcyIDQ5LjkyMTkgMTIuMDMzMiA0OS41OTc3IDExLjg2NTJDNDkuMjc3MyAxMS42OTczIDQ5LjAyNzMgMTEuNDcyNyA0OC44NDc3IDExLjE5MTRDNDguNjcxOSAxMC45MDYyIDQ4LjU4NCAxMC41ODc5IDQ4LjU4NCAxMC4yMzYzQzQ4LjU4NCA5Ljg5NjQ4IDQ4LjY1MDQgOS41OTc2NiA0OC43ODMyIDkuMzM5ODRDNDguOTE2IDkuMDc4MTIgNDkuMTA3NCA4Ljg2MTMzIDQ5LjM1NzQgOC42ODk0NUM0OS42MDc0IDguNTEzNjcgNDkuOTA4MiA4LjM4MDg2IDUwLjI1OTggOC4yOTEwMkM1MC42MTEzIDguMjAxMTcgNTEuMDAzOSA4LjE1NjI1IDUxLjQzNzUgOC4xNTYyNUg1Mi42OTczWk01OS4yOTQ5IDEwLjc2OTVWM0g2MC4zODQ4VjEySDU5LjM4ODdMNTkuMjk0OSAxMC43Njk1Wk01NS4wMjkzIDguOTAwMzlWOC43NzczNEM1NS4wMjkzIDguMjkyOTcgNTUuMDg3OSA3Ljg1MzUyIDU1LjIwNTEgNy40NTg5OEM1NS4zMjYyIDcuMDYwNTUgNTUuNDk2MSA2LjcxODc1IDU1LjcxNDggNi40MzM1OUM1NS45Mzc1IDYuMTQ4NDQgNTYuMjAxMiA1LjkyOTY5IDU2LjUwNTkgNS43NzczNEM1Ni44MTQ1IDUuNjIxMDkgNTcuMTU4MiA1LjU0Mjk3IDU3LjUzNzEgNS41NDI5N0M1Ny45MzU1IDUuNTQyOTcgNTguMjgzMiA1LjYxMzI4IDU4LjU4MDEgNS43NTM5MUM1OC44ODA5IDUuODkwNjIgNTkuMTM0OCA2LjA5MTggNTkuMzQxOCA2LjM1NzQyQzU5LjU1MjcgNi42MTkxNCA1OS43MTg4IDYuOTM1NTUgNTkuODM5OCA3LjMwNjY0QzU5Ljk2MDkgNy42Nzc3MyA2MC4wNDQ5IDguMDk3NjYgNjAuMDkxOCA4LjU2NjQxVjkuMTA1NDdDNjAuMDQ4OCA5LjU3MDMxIDU5Ljk2NDggOS45ODgyOCA1OS44Mzk4IDEwLjM1OTRDNTkuNzE4OCAxMC43MzA1IDU5LjU1MjcgMTEuMDQ2OSA1OS4zNDE4IDExLjMwODZDNTkuMTM0OCAxMS41NzAzIDU4Ljg4MDkgMTEuNzcxNSA1OC41ODAxIDExLjkxMjFDNTguMjc5MyAxMi4wNDg4IDU3LjkyNzcgMTIuMTE3MiA1Ny41MjU0IDEyLjExNzJDNTcuMTU0MyAxMi4xMTcyIDU2LjgxNDUgMTIuMDM3MSA1Ni41MDU5IDExLjg3N0M1Ni4yMDEyIDExLjcxNjggNTUuOTM3NSAxMS40OTIyIDU1LjcxNDggMTEuMjAzMUM1NS40OTYxIDEwLjkxNDEgNTUuMzI2MiAxMC41NzQyIDU1LjIwNTEgMTAuMTgzNkM1NS4wODc5IDkuNzg5MDYgNTUuMDI5MyA5LjM2MTMzIDU1LjAyOTMgOC45MDAzOVpNNTYuMTE5MSA4Ljc3NzM0VjguOTAwMzlDNTYuMTE5MSA5LjIxNjggNTYuMTUwNCA5LjUxMzY3IDU2LjIxMjkgOS43OTEwMkM1Ni4yNzkzIDEwLjA2ODQgNTYuMzgwOSAxMC4zMTI1IDU2LjUxNzYgMTAuNTIzNEM1Ni42NTQzIDEwLjczNDQgNTYuODI4MSAxMC45MDA0IDU3LjAzOTEgMTEuMDIxNUM1Ny4yNSAxMS4xMzg3IDU3LjUwMiAxMS4xOTczIDU3Ljc5NDkgMTEuMTk3M0M1OC4xNTQzIDExLjE5NzMgNTguNDQ5MiAxMS4xMjExIDU4LjY3OTcgMTAuOTY4OEM1OC45MTQxIDEwLjgxNjQgNTkuMTAxNiAxMC42MTUyIDU5LjI0MjIgMTAuMzY1MkM1OS4zODI4IDEwLjExNTIgNTkuNDkyMiA5Ljg0Mzc1IDU5LjU3MDMgOS41NTA3OFY4LjEzODY3QzU5LjUyMzQgNy45MjM4MyA1OS40NTUxIDcuNzE2OCA1OS4zNjUyIDcuNTE3NThDNTkuMjc5MyA3LjMxNDQ1IDU5LjE2NiA3LjEzNDc3IDU5LjAyNTQgNi45Nzg1MkM1OC44ODg3IDYuODE4MzYgNTguNzE4OCA2LjY5MTQxIDU4LjUxNTYgNi41OTc2NkM1OC4zMTY0IDYuNTAzOTEgNTguMDgwMSA2LjQ1NzAzIDU3LjgwNjYgNi40NTcwM0M1Ny41MDk4IDYuNDU3MDMgNTcuMjUzOSA2LjUxOTUzIDU3LjAzOTEgNi42NDQ1M0M1Ni44MjgxIDYuNzY1NjIgNTYuNjU0MyA2LjkzMzU5IDU2LjUxNzYgNy4xNDg0NEM1Ni4zODA5IDcuMzU5MzggNTYuMjc5MyA3LjYwNTQ3IDU2LjIxMjkgNy44ODY3MkM1Ni4xNTA0IDguMTY0MDYgNTYuMTE5MSA4LjQ2MDk0IDU2LjExOTEgOC43NzczNFpNNjEuNzg1MiA4LjkwMDM5VjguNzY1NjJDNjEuNzg1MiA4LjMwODU5IDYxLjg1MTYgNy44ODQ3NyA2MS45ODQ0IDcuNDk0MTRDNjIuMTE3MiA3LjA5OTYxIDYyLjMwODYgNi43NTc4MSA2Mi41NTg2IDYuNDY4NzVDNjIuODA4NiA2LjE3NTc4IDYzLjExMTMgNS45NDkyMiA2My40NjY4IDUuNzg5MDZDNjMuODIyMyA1LjYyNSA2NC4yMjA3IDUuNTQyOTcgNjQuNjYyMSA1LjU0Mjk3QzY1LjEwNzQgNS41NDI5NyA2NS41MDc4IDUuNjI1IDY1Ljg2MzMgNS43ODkwNkM2Ni4yMjI3IDUuOTQ5MjIgNjYuNTI3MyA2LjE3NTc4IDY2Ljc3NzMgNi40Njg3NUM2Ny4wMzEyIDYuNzU3ODEgNjcuMjI0NiA3LjA5OTYxIDY3LjM1NzQgNy40OTQxNEM2Ny40OTAyIDcuODg0NzcgNjcuNTU2NiA4LjMwODU5IDY3LjU1NjYgOC43NjU2MlY4LjkwMDM5QzY3LjU1NjYgOS4zNTc0MiA2Ny40OTAyIDkuNzgxMjUgNjcuMzU3NCAxMC4xNzE5QzY3LjIyNDYgMTAuNTYyNSA2Ny4wMzEyIDEwLjkwNDMgNjYuNzc3MyAxMS4xOTczQzY2LjUyNzMgMTEuNDg2MyA2Ni4yMjQ2IDExLjcxMjkgNjUuODY5MSAxMS44NzdDNjUuNTE3NiAxMi4wMzcxIDY1LjExOTEgMTIuMTE3MiA2NC42NzM4IDEyLjExNzJDNjQuMjI4NSAxMi4xMTcyIDYzLjgyODEgMTIuMDM3MSA2My40NzI3IDExLjg3N0M2My4xMTcyIDExLjcxMjkgNjIuODEyNSAxMS40ODYzIDYyLjU1ODYgMTEuMTk3M0M2Mi4zMDg2IDEwLjkwNDMgNjIuMTE3MiAxMC41NjI1IDYxLjk4NDQgMTAuMTcxOUM2MS44NTE2IDkuNzgxMjUgNjEuNzg1MiA5LjM1NzQyIDYxLjc4NTIgOC45MDAzOVpNNjIuODY5MSA4Ljc2NTYyVjguOTAwMzlDNjIuODY5MSA5LjIxNjggNjIuOTA2MiA5LjUxNTYyIDYyLjk4MDUgOS43OTY4OEM2My4wNTQ3IDEwLjA3NDIgNjMuMTY2IDEwLjMyMDMgNjMuMzE0NSAxMC41MzUyQzYzLjQ2NjggMTAuNzUgNjMuNjU2MiAxMC45MTk5IDYzLjg4MjggMTEuMDQ0OUM2NC4xMDk0IDExLjE2NiA2NC4zNzMgMTEuMjI2NiA2NC42NzM4IDExLjIyNjZDNjQuOTcwNyAxMS4yMjY2IDY1LjIzMDUgMTEuMTY2IDY1LjQ1MzEgMTEuMDQ0OUM2NS42Nzk3IDEwLjkxOTkgNjUuODY3MiAxMC43NSA2Ni4wMTU2IDEwLjUzNTJDNjYuMTY0MSAxMC4zMjAzIDY2LjI3NTQgMTAuMDc0MiA2Ni4zNDk2IDkuNzk2ODhDNjYuNDI3NyA5LjUxNTYyIDY2LjQ2NjggOS4yMTY4IDY2LjQ2NjggOC45MDAzOVY4Ljc2NTYyQzY2LjQ2NjggOC40NTMxMiA2Ni40Mjc3IDguMTU4MiA2Ni4zNDk2IDcuODgwODZDNjYuMjc1NCA3LjU5OTYxIDY2LjE2MjEgNy4zNTE1NiA2Ni4wMDk4IDcuMTM2NzJDNjUuODYxMyA2LjkxNzk3IDY1LjY3MzggNi43NDYwOSA2NS40NDczIDYuNjIxMDlDNjUuMjI0NiA2LjQ5NjA5IDY0Ljk2MjkgNi40MzM1OSA2NC42NjIxIDYuNDMzNTlDNjQuMzY1MiA2LjQzMzU5IDY0LjEwMzUgNi40OTYwOSA2My44NzcgNi42MjEwOUM2My42NTQzIDYuNzQ2MDkgNjMuNDY2OCA2LjkxNzk3IDYzLjMxNDUgNy4xMzY3MkM2My4xNjYgNy4zNTE1NiA2My4wNTQ3IDcuNTk5NjEgNjIuOTgwNSA3Ljg4MDg2QzYyLjkwNjIgOC4xNTgyIDYyLjg2OTEgOC40NTMxMiA2Mi44NjkxIDguNzY1NjJaTTcyLjk3NjYgNi44Nzg5MVYxNC40Mzc1SDcxLjg4NjdWNS42NjAxNkg3Mi44ODI4TDcyLjk3NjYgNi44Nzg5MVpNNzcuMjQ4IDguNzc3MzRWOC45MDAzOUM3Ny4yNDggOS4zNjEzMyA3Ny4xOTM0IDkuNzg5MDYgNzcuMDg0IDEwLjE4MzZDNzYuOTc0NiAxMC41NzQyIDc2LjgxNDUgMTAuOTE0MSA3Ni42MDM1IDExLjIwMzFDNzYuMzk2NSAxMS40OTIyIDc2LjE0MDYgMTEuNzE2OCA3NS44MzU5IDExLjg3N0M3NS41MzEyIDEyLjAzNzEgNzUuMTgxNiAxMi4xMTcyIDc0Ljc4NzEgMTIuMTE3MkM3NC4zODQ4IDEyLjExNzIgNzQuMDI5MyAxMi4wNTA4IDczLjcyMDcgMTEuOTE4QzczLjQxMjEgMTEuNzg1MiA3My4xNTA0IDExLjU5MTggNzIuOTM1NSAxMS4zMzc5QzcyLjcyMDcgMTEuMDg0IDcyLjU0ODggMTAuNzc5MyA3Mi40MTk5IDEwLjQyMzhDNzIuMjk0OSAxMC4wNjg0IDcyLjIwOSA5LjY2Nzk3IDcyLjE2MjEgOS4yMjI2NlY4LjU2NjQxQzcyLjIwOSA4LjA5NzY2IDcyLjI5NjkgNy42Nzc3MyA3Mi40MjU4IDcuMzA2NjRDNzIuNTU0NyA2LjkzNTU1IDcyLjcyNDYgNi42MTkxNCA3Mi45MzU1IDYuMzU3NDJDNzMuMTUwNCA2LjA5MTggNzMuNDEwMiA1Ljg5MDYyIDczLjcxNDggNS43NTM5MUM3NC4wMTk1IDUuNjEzMjggNzQuMzcxMSA1LjU0Mjk3IDc0Ljc2OTUgNS41NDI5N0M3NS4xNjggNS41NDI5NyA3NS41MjE1IDUuNjIxMDkgNzUuODMwMSA1Ljc3NzM0Qzc2LjEzODcgNS45Mjk2OSA3Ni4zOTg0IDYuMTQ4NDQgNzYuNjA5NCA2LjQzMzU5Qzc2LjgyMDMgNi43MTg3NSA3Ni45Nzg1IDcuMDYwNTUgNzcuMDg0IDcuNDU4OThDNzcuMTkzNCA3Ljg1MzUyIDc3LjI0OCA4LjI5Mjk3IDc3LjI0OCA4Ljc3NzM0Wk03Ni4xNTgyIDguOTAwMzlWOC43NzczNEM3Ni4xNTgyIDguNDYwOTQgNzYuMTI1IDguMTY0MDYgNzYuMDU4NiA3Ljg4NjcyQzc1Ljk5MjIgNy42MDU0NyA3NS44ODg3IDcuMzU5MzggNzUuNzQ4IDcuMTQ4NDRDNzUuNjExMyA2LjkzMzU5IDc1LjQzNTUgNi43NjU2MiA3NS4yMjA3IDYuNjQ0NTNDNzUuMDA1OSA2LjUxOTUzIDc0Ljc1IDYuNDU3MDMgNzQuNDUzMSA2LjQ1NzAzQzc0LjE3OTcgNi40NTcwMyA3My45NDE0IDYuNTAzOTEgNzMuNzM4MyA2LjU5NzY2QzczLjUzOTEgNi42OTE0MSA3My4zNjkxIDYuODE4MzYgNzMuMjI4NSA2Ljk3ODUyQzczLjA4NzkgNy4xMzQ3NyA3Mi45NzI3IDcuMzE0NDUgNzIuODgyOCA3LjUxNzU4QzcyLjc5NjkgNy43MTY4IDcyLjczMjQgNy45MjM4MyA3Mi42ODk1IDguMTM4NjdWOS42NTYyNUM3Mi43Njc2IDkuOTI5NjkgNzIuODc3IDEwLjE4NzUgNzMuMDE3NiAxMC40Mjk3QzczLjE1ODIgMTAuNjY4IDczLjM0NTcgMTAuODYxMyA3My41ODAxIDExLjAwOThDNzMuODE0NSAxMS4xNTQzIDc0LjEwOTQgMTEuMjI2NiA3NC40NjQ4IDExLjIyNjZDNzQuNzU3OCAxMS4yMjY2IDc1LjAwOTggMTEuMTY2IDc1LjIyMDcgMTEuMDQ0OUM3NS40MzU1IDEwLjkxOTkgNzUuNjExMyAxMC43NSA3NS43NDggMTAuNTM1MkM3NS44ODg3IDEwLjMyMDMgNzUuOTkyMiAxMC4wNzQyIDc2LjA1ODYgOS43OTY4OEM3Ni4xMjUgOS41MTU2MiA3Ni4xNTgyIDkuMjE2OCA3Ni4xNTgyIDguOTAwMzlaTTc4LjM0MzggOC45MDAzOVY4Ljc2NTYyQzc4LjM0MzggOC4zMDg1OSA3OC40MTAyIDcuODg0NzcgNzguNTQzIDcuNDk0MTRDNzguNjc1OCA3LjA5OTYxIDc4Ljg2NzIgNi43NTc4MSA3OS4xMTcyIDYuNDY4NzVDNzkuMzY3MiA2LjE3NTc4IDc5LjY2OTkgNS45NDkyMiA4MC4wMjU0IDUuNzg5MDZDODAuMzgwOSA1LjYyNSA4MC43NzkzIDUuNTQyOTcgODEuMjIwNyA1LjU0Mjk3QzgxLjY2NiA1LjU0Mjk3IDgyLjA2NjQgNS42MjUgODIuNDIxOSA1Ljc4OTA2QzgyLjc4MTIgNS45NDkyMiA4My4wODU5IDYuMTc1NzggODMuMzM1OSA2LjQ2ODc1QzgzLjU4OTggNi43NTc4MSA4My43ODMyIDcuMDk5NjEgODMuOTE2IDcuNDk0MTRDODQuMDQ4OCA3Ljg4NDc3IDg0LjExNTIgOC4zMDg1OSA4NC4xMTUyIDguNzY1NjJWOC45MDAzOUM4NC4xMTUyIDkuMzU3NDIgODQuMDQ4OCA5Ljc4MTI1IDgzLjkxNiAxMC4xNzE5QzgzLjc4MzIgMTAuNTYyNSA4My41ODk4IDEwLjkwNDMgODMuMzM1OSAxMS4xOTczQzgzLjA4NTkgMTEuNDg2MyA4Mi43ODMyIDExLjcxMjkgODIuNDI3NyAxMS44NzdDODIuMDc2MiAxMi4wMzcxIDgxLjY3NzcgMTIuMTE3MiA4MS4yMzI0IDEyLjExNzJDODAuNzg3MSAxMi4xMTcyIDgwLjM4NjcgMTIuMDM3MSA4MC4wMzEyIDExLjg3N0M3OS42NzU4IDExLjcxMjkgNzkuMzcxMSAxMS40ODYzIDc5LjExNzIgMTEuMTk3M0M3OC44NjcyIDEwLjkwNDMgNzguNjc1OCAxMC41NjI1IDc4LjU0MyAxMC4xNzE5Qzc4LjQxMDIgOS43ODEyNSA3OC4zNDM4IDkuMzU3NDIgNzguMzQzOCA4LjkwMDM5Wk03OS40Mjc3IDguNzY1NjJWOC45MDAzOUM3OS40Mjc3IDkuMjE2OCA3OS40NjQ4IDkuNTE1NjIgNzkuNTM5MSA5Ljc5Njg4Qzc5LjYxMzMgMTAuMDc0MiA3OS43MjQ2IDEwLjMyMDMgNzkuODczIDEwLjUzNTJDODAuMDI1NCAxMC43NSA4MC4yMTQ4IDEwLjkxOTkgODAuNDQxNCAxMS4wNDQ5QzgwLjY2OCAxMS4xNjYgODAuOTMxNiAxMS4yMjY2IDgxLjIzMjQgMTEuMjI2NkM4MS41MjkzIDExLjIyNjYgODEuNzg5MSAxMS4xNjYgODIuMDExNyAxMS4wNDQ5QzgyLjIzODMgMTAuOTE5OSA4Mi40MjU4IDEwLjc1IDgyLjU3NDIgMTAuNTM1MkM4Mi43MjI3IDEwLjMyMDMgODIuODM0IDEwLjA3NDIgODIuOTA4MiA5Ljc5Njg4QzgyLjk4NjMgOS41MTU2MiA4My4wMjU0IDkuMjE2OCA4My4wMjU0IDguOTAwMzlWOC43NjU2MkM4My4wMjU0IDguNDUzMTIgODIuOTg2MyA4LjE1ODIgODIuOTA4MiA3Ljg4MDg2QzgyLjgzNCA3LjU5OTYxIDgyLjcyMDcgNy4zNTE1NiA4Mi41Njg0IDcuMTM2NzJDODIuNDE5OSA2LjkxNzk3IDgyLjIzMjQgNi43NDYwOSA4Mi4wMDU5IDYuNjIxMDlDODEuNzgzMiA2LjQ5NjA5IDgxLjUyMTUgNi40MzM1OSA4MS4yMjA3IDYuNDMzNTlDODAuOTIzOCA2LjQzMzU5IDgwLjY2MjEgNi40OTYwOSA4MC40MzU1IDYuNjIxMDlDODAuMjEyOSA2Ljc0NjA5IDgwLjAyNTQgNi45MTc5NyA3OS44NzMgNy4xMzY3MkM3OS43MjQ2IDcuMzUxNTYgNzkuNjEzMyA3LjU5OTYxIDc5LjUzOTEgNy44ODA4NkM3OS40NjQ4IDguMTU4MiA3OS40Mjc3IDguNDUzMTIgNzkuNDI3NyA4Ljc2NTYyWk04Ni41NTg2IDYuNjU2MjVWMTJIODUuNDc0NlY1LjY2MDE2SDg2LjUyOTNMODYuNTU4NiA2LjY1NjI1Wk04OC41MzkxIDUuNjI1TDg4LjUzMzIgNi42MzI4MUM4OC40NDM0IDYuNjEzMjggODguMzU3NCA2LjYwMTU2IDg4LjI3NTQgNi41OTc2NkM4OC4xOTczIDYuNTg5ODQgODguMTA3NCA2LjU4NTk0IDg4LjAwNTkgNi41ODU5NEM4Ny43NTU5IDYuNTg1OTQgODcuNTM1MiA2LjYyNSA4Ny4zNDM4IDYuNzAzMTJDODcuMTUyMyA2Ljc4MTI1IDg2Ljk5MDIgNi44OTA2MiA4Ni44NTc0IDcuMDMxMjVDODYuNzI0NiA3LjE3MTg4IDg2LjYxOTEgNy4zMzk4NCA4Ni41NDEgNy41MzUxNkM4Ni40NjY4IDcuNzI2NTYgODYuNDE4IDcuOTM3NSA4Ni4zOTQ1IDguMTY3OTdMODYuMDg5OCA4LjM0Mzc1Qzg2LjA4OTggNy45NjA5NCA4Ni4xMjcgNy42MDE1NiA4Ni4yMDEyIDcuMjY1NjJDODYuMjc5MyA2LjkyOTY5IDg2LjM5ODQgNi42MzI4MSA4Ni41NTg2IDYuMzc1Qzg2LjcxODggNi4xMTMyOCA4Ni45MjE5IDUuOTEwMTYgODcuMTY4IDUuNzY1NjJDODcuNDE4IDUuNjE3MTkgODcuNzE0OCA1LjU0Mjk3IDg4LjA1ODYgNS41NDI5N0M4OC4xMzY3IDUuNTQyOTcgODguMjI2NiA1LjU1MjczIDg4LjMyODEgNS41NzIyN0M4OC40Mjk3IDUuNTg3ODkgODguNSA1LjYwNTQ3IDg4LjUzOTEgNS42MjVaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNOTQuNzg4MyA5LjEyOTJIOTIuOTk4OFYxMi43NzQ1SDkyVjMuNTI4NDdIOTQuNzM3Qzk2LjgyNTIgMy41Mjg0NyA5Ny4yMjY1IDUuMTkxMTkgOTcuMjI2NSA1Ljk4MTgxVjYuNjU3NzZDOTcuMjI2NSA3LjQ2OTUgOTYuODIyMiA5LjEyOTIgOTQuNzg4MyA5LjEyOTJaTTk2LjIzOTggNi4wMDU5NUM5Ni4yMzk4IDQuNjk2MyA5NS4yNTMgNC41MTIyMiA5NC43MDk4IDQuNTEyMjJIOTIuOTk1OFY4LjE0NTQ1SDk0LjczNEM5NS4yNzcxIDguMTQ1NDUgOTYuMjM5OCA3Ljk0OTMxIDk2LjIzOTggNi42Mzk2NVY2LjAwNTk1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNOTkuMzY2IDEyLjc3NDVWMy41Mjg0N0gxMDQuMzZWNC41MTUyNEgxMDAuMzUzVjcuMzk0MDZIMTA0LjA2MVY4LjM4MDgzSDEwMC4zNTNWMTEuODA1OEgxMDQuMzZWMTIuNzc3NUg5OS4zNjZWMTIuNzc0NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTExMS4xNTYgMTIuNzc0NUwxMDkuMzM5IDguODY5NjhIMTA3LjgyMVYxMi43NzQ1SDEwNi44MjNWMy41Mjg0N0gxMDkuNTZDMTExLjY0OCAzLjUyODQ3IDExMi4wNjQgNS4xNzYxIDExMi4wNjQgNS45NjY3MlY2LjQwNzI5QzExMi4wNjQgNy4wOTUzMSAxMTEuNzUzIDguMzc3ODEgMTEwLjM5MiA4Ljc3OTE1TDExMi4yODggMTIuNzc0NUgxMTEuMTU2VjEyLjc3NDVaTTExMS4wNjUgNi4wMDU5NUMxMTEuMDY1IDQuNjk2MyAxMTAuMDc5IDQuNTEyMjIgMTA5LjUzNSA0LjUxMjIySDEwNy44MjFWNy44OTgwMUgxMDkuNTZDMTEwLjEwNiA3Ljg5ODAxIDExMS4wNjUgNy42ODk3OSAxMTEuMDY1IDYuMzkyMjFWNi4wMDU5NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTExNS43NjEgNC41MTIyMlY3LjQwNjEzSDExOS40NjlWOC4zOTI5SDExNS43NjFWMTIuNzc3NUgxMTQuNzc0VjMuNTI4NDdIMTE5Ljc2OFY0LjUxNTI0SDExNS43NjFWNC41MTIyMloiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTEyMS44NDEgMTIuNzc0NVYzLjUyODQ3SDEyNi44MzZWNC41MTUyNEgxMjIuODI4VjcuMzk0MDZIMTI2LjUzN1Y4LjM4MDgzSDEyMi44MjhWMTEuODA1OEgxMjYuODM2VjEyLjc3NzVIMTIxLjg0MVYxMi43NzQ1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNMTMxLjc3OCAxMi44OTIyQzEyOS43NDIgMTIuODkyMiAxMjkuMTcxIDExLjIyMDQgMTI5LjE3MSAxMC40MDI2VjUuODg4MjZDMTI5LjE3MSA1LjA5NzY0IDEyOS43MDIgMy40NTAwMSAxMzEuNzkxIDMuNDUwMDFDMTMzLjgxNSAzLjQ1MDAxIDEzNC4zOTggNS4wOTc2NCAxMzQuMzk4IDUuOTAzMzVIMTMzLjM5OUMxMzMuMzk5IDQuNjE3ODQgMTMyLjMxIDQuNDI0NzEgMTMxLjc5MSA0LjQyNDcxQzEzMS4yNTkgNC40MjQ3MSAxMzAuMTU4IDQuNjIwODUgMTMwLjE1OCA1LjkxNTQyVjEwLjQwMjZDMTMwLjE1OCAxMS43MTIzIDEzMS4yNTkgMTEuOTA4NCAxMzEuNzkxIDExLjkwODRDMTMyLjMxIDExLjkwODQgMTMzLjM5OSAxMS43MTIzIDEzMy4zOTkgMTAuNDE3N0gxMzQuMzk4QzEzNC4zOTggMTEuMjMyNSAxMzMuODUyIDEyLjg5MjIgMTMxLjc3OCAxMi44OTIyWiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNMTM5LjE5NiA0LjUyNzMxVjEyLjc3NzVIMTM4LjE5N1Y0LjUyNzMxSDEzNS45NFYzLjUyODQ3SDE0MS40NVY0LjUyNzMxSDEzOS4xOTZaIiBmaWxsPSIjREMzRDcyIi8+CjxnIG9wYWNpdHk9IjAuNyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQ2LjU1MiA1LjQ2MTUyQzE0Ni40MDkgNS40NjE1MiAxNDYuMjcyIDUuNTE4MzEgMTQ2LjE3IDUuNjE5NDFDMTQ2LjA2OSA1LjcyMDUgMTQ2LjAxMyA1Ljg1NzYxIDE0Ni4wMTMgNi4wMDA1OFYxMS45MzAzQzE0Ni4wMTMgMTIuMDczMiAxNDYuMDY5IDEyLjIxMDMgMTQ2LjE3IDEyLjMxMTRDMTQ2LjI3MiAxMi40MTI1IDE0Ni40MDkgMTIuNDY5MyAxNDYuNTUyIDEyLjQ2OTNIMTUyLjQ4MUMxNTIuNjI0IDEyLjQ2OTMgMTUyLjc2MSAxMi40MTI1IDE1Mi44NjIgMTIuMzExNEMxNTIuOTY0IDEyLjIxMDMgMTUzLjAyIDEyLjA3MzIgMTUzLjAyIDExLjkzMDNWOC42OTU4OUMxNTMuMDIgOC4zOTgxOCAxNTMuMjYyIDguMTU2ODMgMTUzLjU1OSA4LjE1NjgzQzE1My44NTcgOC4xNTY4MyAxNTQuMDk5IDguMzk4MTggMTU0LjA5OSA4LjY5NTg5VjExLjkzMDNDMTU0LjA5OSAxMi4zNTkyIDE1My45MjggMTIuNzcwNSAxNTMuNjI1IDEzLjA3MzhDMTUzLjMyMiAxMy4zNzcxIDE1Mi45MSAxMy41NDc1IDE1Mi40ODEgMTMuNTQ3NUgxNDYuNTUyQzE0Ni4xMjMgMTMuNTQ3NSAxNDUuNzExIDEzLjM3NzEgMTQ1LjQwOCAxMy4wNzM4QzE0NS4xMDUgMTIuNzcwNSAxNDQuOTM0IDEyLjM1OTIgMTQ0LjkzNCAxMS45MzAzVjYuMDAwNThDMTQ0LjkzNCA1LjU3MTY4IDE0NS4xMDUgNS4xNjAzNCAxNDUuNDA4IDQuODU3MDZDMTQ1LjcxMSA0LjU1Mzc3IDE0Ni4xMjMgNC4zODMzOSAxNDYuNTUyIDQuMzgzMzlIMTQ5Ljc4NkMxNTAuMDg0IDQuMzgzMzkgMTUwLjMyNSA0LjYyNDc0IDE1MC4zMjUgNC45MjI0NUMxNTAuMzI1IDUuMjIwMTcgMTUwLjA4NCA1LjQ2MTUyIDE0OS43ODYgNS40NjE1MkgxNDYuNTUyWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNTEuOTQyIDIuNzY2MTdDMTUxLjY0NSAyLjc2NjE3IDE1MS40MDMgMy4wMDc1MiAxNTEuNDAzIDMuMzA1MjRDMTUxLjQwMyAzLjYwMjk1IDE1MS42NDUgMy44NDQzIDE1MS45NDIgMy44NDQzSDE1My44NzVMMTQ4Ljg2NiA4Ljg1Mzc3QzE0OC42NTUgOS4wNjQyOSAxNDguNjU1IDkuNDA1NjEgMTQ4Ljg2NiA5LjYxNjEyQzE0OS4wNzYgOS44MjY2NCAxNDkuNDE4IDkuODI2NjQgMTQ5LjYyOCA5LjYxNjEyTDE1NC42MzggNC42MDY3VjYuNTM5NjFDMTU0LjYzOCA2LjgzNzMzIDE1NC44NzkgNy4wNzg2NyAxNTUuMTc3IDcuMDc4NjdDMTU1LjQ3NCA3LjA3ODY3IDE1NS43MTYgNi44MzczMyAxNTUuNzE2IDYuNTM5NjFWMy4zMTAzN0MxNTUuNzE2IDMuMzA2OTcgMTU1LjcxNiAzLjMwMzU2IDE1NS43MTYgMy4zMDAxNVYzLjIzMjUxQzE1NS43MTYgMi45MzQ3OSAxNTUuNDc0IDIuNzY2MTcgMTU1LjE3NyAyLjc2NjE3SDE1MS45NDJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8yXzMzOSIgeD0iMCIgeT0iMCIgd2lkdGg9IjE1Ny44IiBoZWlnaHQ9IjE2LjE1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHg9IjEuMTUiIGR5PSIxLjE1Ii8+CjxmZUNvbG9yTWF0cml4IHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwLjI1IDAiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3dfMl8zMzkiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMl8zMzkiIHJlc3VsdD0ic2hhcGUiLz4KPC9maWx0ZXI+CjwvZGVmcz4KPC9zdmc+Cg=="

/***/ }),

/***/ 837:
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMzIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTMzIDE2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kXzJfMjk0KSI+CjxwYXRoIG9wYWNpdHk9IjAuNyIgZD0iTTMuNTcwMzEgOC42NTQzSDEuMjkxMDJWNy43MzQzOEgzLjU3MDMxQzQuMDExNzIgNy43MzQzOCA0LjM2OTE0IDcuNjY0MDYgNC42NDI1OCA3LjUyMzQ0QzQuOTE2MDIgNy4zODI4MSA1LjExNTIzIDcuMTg3NSA1LjI0MDIzIDYuOTM3NUM1LjM2OTE0IDYuNjg3NSA1LjQzMzU5IDYuNDAyMzQgNS40MzM1OSA2LjA4MjAzQzUuNDMzNTkgNS43ODkwNiA1LjM2OTE0IDUuNTEzNjcgNS4yNDAyMyA1LjI1NTg2QzUuMTE1MjMgNC45OTgwNSA0LjkxNjAyIDQuNzkxMDIgNC42NDI1OCA0LjYzNDc3QzQuMzY5MTQgNC40NzQ2MSA0LjAxMTcyIDQuMzk0NTMgMy41NzAzMSA0LjM5NDUzSDEuNTU0NjlWMTJIMC40MjM4MjhWMy40Njg3NUgzLjU3MDMxQzQuMjE0ODQgMy40Njg3NSA0Ljc1OTc3IDMuNTgwMDggNS4yMDUwOCAzLjgwMjczQzUuNjUwMzkgNC4wMjUzOSA1Ljk4ODI4IDQuMzMzOTggNi4yMTg3NSA0LjcyODUyQzYuNDQ5MjIgNS4xMTkxNCA2LjU2NDQ1IDUuNTY2NDEgNi41NjQ0NSA2LjA3MDMxQzYuNTY0NDUgNi42MTcxOSA2LjQ0OTIyIDcuMDgzOTggNi4yMTg3NSA3LjQ3MDdDNS45ODgyOCA3Ljg1NzQyIDUuNjUwMzkgOC4xNTIzNCA1LjIwNTA4IDguMzU1NDdDNC43NTk3NyA4LjU1NDY5IDQuMjE0ODQgOC42NTQzIDMuNTcwMzEgOC42NTQzWk03LjQ2MDk0IDguOTAwMzlWOC43NjU2MkM3LjQ2MDk0IDguMzA4NTkgNy41MjczNCA3Ljg4NDc3IDcuNjYwMTYgNy40OTQxNEM3Ljc5Mjk3IDcuMDk5NjEgNy45ODQzOCA2Ljc1NzgxIDguMjM0MzggNi40Njg3NUM4LjQ4NDM4IDYuMTc1NzggOC43ODcxMSA1Ljk0OTIyIDkuMTQyNTggNS43ODkwNkM5LjQ5ODA1IDUuNjI1IDkuODk2NDggNS41NDI5NyAxMC4zMzc5IDUuNTQyOTdDMTAuNzgzMiA1LjU0Mjk3IDExLjE4MzYgNS42MjUgMTEuNTM5MSA1Ljc4OTA2QzExLjg5ODQgNS45NDkyMiAxMi4yMDMxIDYuMTc1NzggMTIuNDUzMSA2LjQ2ODc1QzEyLjcwNyA2Ljc1NzgxIDEyLjkwMDQgNy4wOTk2MSAxMy4wMzMyIDcuNDk0MTRDMTMuMTY2IDcuODg0NzcgMTMuMjMyNCA4LjMwODU5IDEzLjIzMjQgOC43NjU2MlY4LjkwMDM5QzEzLjIzMjQgOS4zNTc0MiAxMy4xNjYgOS43ODEyNSAxMy4wMzMyIDEwLjE3MTlDMTIuOTAwNCAxMC41NjI1IDEyLjcwNyAxMC45MDQzIDEyLjQ1MzEgMTEuMTk3M0MxMi4yMDMxIDExLjQ4NjMgMTEuOTAwNCAxMS43MTI5IDExLjU0NDkgMTEuODc3QzExLjE5MzQgMTIuMDM3MSAxMC43OTQ5IDEyLjExNzIgMTAuMzQ5NiAxMi4xMTcyQzkuOTA0MyAxMi4xMTcyIDkuNTAzOTEgMTIuMDM3MSA5LjE0ODQ0IDExLjg3N0M4Ljc5Mjk3IDExLjcxMjkgOC40ODgyOCAxMS40ODYzIDguMjM0MzggMTEuMTk3M0M3Ljk4NDM4IDEwLjkwNDMgNy43OTI5NyAxMC41NjI1IDcuNjYwMTYgMTAuMTcxOUM3LjUyNzM0IDkuNzgxMjUgNy40NjA5NCA5LjM1NzQyIDcuNDYwOTQgOC45MDAzOVpNOC41NDQ5MiA4Ljc2NTYyVjguOTAwMzlDOC41NDQ5MiA5LjIxNjggOC41ODIwMyA5LjUxNTYyIDguNjU2MjUgOS43OTY4OEM4LjczMDQ3IDEwLjA3NDIgOC44NDE4IDEwLjMyMDMgOC45OTAyMyAxMC41MzUyQzkuMTQyNTggMTAuNzUgOS4zMzIwMyAxMC45MTk5IDkuNTU4NTkgMTEuMDQ0OUM5Ljc4NTE2IDExLjE2NiAxMC4wNDg4IDExLjIyNjYgMTAuMzQ5NiAxMS4yMjY2QzEwLjY0NjUgMTEuMjI2NiAxMC45MDYyIDExLjE2NiAxMS4xMjg5IDExLjA0NDlDMTEuMzU1NSAxMC45MTk5IDExLjU0MyAxMC43NSAxMS42OTE0IDEwLjUzNTJDMTEuODM5OCAxMC4zMjAzIDExLjk1MTIgMTAuMDc0MiAxMi4wMjU0IDkuNzk2ODhDMTIuMTAzNSA5LjUxNTYyIDEyLjE0MjYgOS4yMTY4IDEyLjE0MjYgOC45MDAzOVY4Ljc2NTYyQzEyLjE0MjYgOC40NTMxMiAxMi4xMDM1IDguMTU4MiAxMi4wMjU0IDcuODgwODZDMTEuOTUxMiA3LjU5OTYxIDExLjgzNzkgNy4zNTE1NiAxMS42ODU1IDcuMTM2NzJDMTEuNTM3MSA2LjkxNzk3IDExLjM0OTYgNi43NDYwOSAxMS4xMjMgNi42MjEwOUMxMC45MDA0IDYuNDk2MDkgMTAuNjM4NyA2LjQzMzU5IDEwLjMzNzkgNi40MzM1OUMxMC4wNDEgNi40MzM1OSA5Ljc3OTMgNi40OTYwOSA5LjU1MjczIDYuNjIxMDlDOS4zMzAwOCA2Ljc0NjA5IDkuMTQyNTggNi45MTc5NyA4Ljk5MDIzIDcuMTM2NzJDOC44NDE4IDcuMzUxNTYgOC43MzA0NyA3LjU5OTYxIDguNjU2MjUgNy44ODA4NkM4LjU4MjAzIDguMTU4MiA4LjU0NDkyIDguNDUzMTIgOC41NDQ5MiA4Ljc2NTYyWk0xNi4xOTczIDEwLjg3NUwxNy44MjYyIDUuNjYwMTZIMTguNTQxTDE4LjQwMDQgNi42OTcyN0wxNi43NDIyIDEySDE2LjA0NDlMMTYuMTk3MyAxMC44NzVaTTE1LjEwMTYgNS42NjAxNkwxNi40OTAyIDEwLjkzMzZMMTYuNTg5OCAxMkgxNS44NTc0TDE0LjAxNzYgNS42NjAxNkgxNS4xMDE2Wk0yMC4wOTk2IDEwLjg5MjZMMjEuNDIzOCA1LjY2MDE2SDIyLjUwMkwyMC42NjIxIDEySDE5LjkzNTVMMjAuMDk5NiAxMC44OTI2Wk0xOC42OTkyIDUuNjYwMTZMMjAuMjkzIDEwLjc4NzFMMjAuNDc0NiAxMkgxOS43ODMyTDE4LjA3ODEgNi42ODU1NUwxNy45Mzc1IDUuNjYwMTZIMTguNjk5MlpNMjYuMjQ2MSAxMi4xMTcyQzI1LjgwNDcgMTIuMTE3MiAyNS40MDQzIDEyLjA0MyAyNS4wNDQ5IDExLjg5NDVDMjQuNjg5NSAxMS43NDIyIDI0LjM4MjggMTEuNTI5MyAyNC4xMjUgMTEuMjU1OUMyMy44NzExIDEwLjk4MjQgMjMuNjc1OCAxMC42NTgyIDIzLjUzOTEgMTAuMjgzMkMyMy40MDIzIDkuOTA4MiAyMy4zMzQgOS40OTgwNSAyMy4zMzQgOS4wNTI3M1Y4LjgwNjY0QzIzLjMzNCA4LjI5MTAyIDIzLjQxMDIgNy44MzIwMyAyMy41NjI1IDcuNDI5NjlDMjMuNzE0OCA3LjAyMzQ0IDIzLjkyMTkgNi42Nzk2OSAyNC4xODM2IDYuMzk4NDRDMjQuNDQ1MyA2LjExNzE5IDI0Ljc0MjIgNS45MDQzIDI1LjA3NDIgNS43NTk3N0MyNS40MDYyIDUuNjE1MjMgMjUuNzUgNS41NDI5NyAyNi4xMDU1IDUuNTQyOTdDMjYuNTU4NiA1LjU0Mjk3IDI2Ljk0OTIgNS42MjEwOSAyNy4yNzczIDUuNzc3MzRDMjcuNjA5NCA1LjkzMzU5IDI3Ljg4MDkgNi4xNTIzNCAyOC4wOTE4IDYuNDMzNTlDMjguMzAyNyA2LjcxMDk0IDI4LjQ1OSA3LjAzOTA2IDI4LjU2MDUgNy40MTc5N0MyOC42NjIxIDcuNzkyOTcgMjguNzEyOSA4LjIwMzEyIDI4LjcxMjkgOC42NDg0NFY5LjEzNDc3SDIzLjk3ODVWOC4yNUgyNy42Mjg5VjguMTY3OTdDMjcuNjEzMyA3Ljg4NjcyIDI3LjU1NDcgNy42MTMyOCAyNy40NTMxIDcuMzQ3NjZDMjcuMzU1NSA3LjA4MjAzIDI3LjE5OTIgNi44NjMyOCAyNi45ODQ0IDYuNjkxNDFDMjYuNzY5NSA2LjUxOTUzIDI2LjQ3NjYgNi40MzM1OSAyNi4xMDU1IDYuNDMzNTlDMjUuODU5NCA2LjQzMzU5IDI1LjYzMjggNi40ODYzMyAyNS40MjU4IDYuNTkxOEMyNS4yMTg4IDYuNjkzMzYgMjUuMDQxIDYuODQ1NyAyNC44OTI2IDcuMDQ4ODNDMjQuNzQ0MSA3LjI1MTk1IDI0LjYyODkgNy41IDI0LjU0NjkgNy43OTI5N0MyNC40NjQ4IDguMDg1OTQgMjQuNDIzOCA4LjQyMzgzIDI0LjQyMzggOC44MDY2NFY5LjA1MjczQzI0LjQyMzggOS4zNTM1MiAyNC40NjQ4IDkuNjM2NzIgMjQuNTQ2OSA5LjkwMjM0QzI0LjYzMjggMTAuMTY0MSAyNC43NTU5IDEwLjM5NDUgMjQuOTE2IDEwLjU5MzhDMjUuMDgwMSAxMC43OTMgMjUuMjc3MyAxMC45NDkyIDI1LjUwNzggMTEuMDYyNUMyNS43NDIyIDExLjE3NTggMjYuMDA3OCAxMS4yMzI0IDI2LjMwNDcgMTEuMjMyNEMyNi42ODc1IDExLjIzMjQgMjcuMDExNyAxMS4xNTQzIDI3LjI3NzMgMTAuOTk4QzI3LjU0MyAxMC44NDE4IDI3Ljc3NTQgMTAuNjMyOCAyNy45NzQ2IDEwLjM3MTFMMjguNjMwOSAxMC44OTI2QzI4LjQ5NDEgMTEuMDk5NiAyOC4zMjAzIDExLjI5NjkgMjguMTA5NCAxMS40ODQ0QzI3Ljg5ODQgMTEuNjcxOSAyNy42Mzg3IDExLjgyNDIgMjcuMzMwMSAxMS45NDE0QzI3LjAyNTQgMTIuMDU4NiAyNi42NjQxIDEyLjExNzIgMjYuMjQ2MSAxMi4xMTcyWk0zMS4wNjI1IDYuNjU2MjVWMTJIMjkuOTc4NVY1LjY2MDE2SDMxLjAzMzJMMzEuMDYyNSA2LjY1NjI1Wk0zMy4wNDMgNS42MjVMMzMuMDM3MSA2LjYzMjgxQzMyLjk0NzMgNi42MTMyOCAzMi44NjEzIDYuNjAxNTYgMzIuNzc5MyA2LjU5NzY2QzMyLjcwMTIgNi41ODk4NCAzMi42MTEzIDYuNTg1OTQgMzIuNTA5OCA2LjU4NTk0QzMyLjI1OTggNi41ODU5NCAzMi4wMzkxIDYuNjI1IDMxLjg0NzcgNi43MDMxMkMzMS42NTYyIDYuNzgxMjUgMzEuNDk0MSA2Ljg5MDYyIDMxLjM2MTMgNy4wMzEyNUMzMS4yMjg1IDcuMTcxODggMzEuMTIzIDcuMzM5ODQgMzEuMDQ0OSA3LjUzNTE2QzMwLjk3MDcgNy43MjY1NiAzMC45MjE5IDcuOTM3NSAzMC44OTg0IDguMTY3OTdMMzAuNTkzOCA4LjM0Mzc1QzMwLjU5MzggNy45NjA5NCAzMC42MzA5IDcuNjAxNTYgMzAuNzA1MSA3LjI2NTYyQzMwLjc4MzIgNi45Mjk2OSAzMC45MDIzIDYuNjMyODEgMzEuMDYyNSA2LjM3NUMzMS4yMjI3IDYuMTEzMjggMzEuNDI1OCA1LjkxMDE2IDMxLjY3MTkgNS43NjU2MkMzMS45MjE5IDUuNjE3MTkgMzIuMjE4OCA1LjU0Mjk3IDMyLjU2MjUgNS41NDI5N0MzMi42NDA2IDUuNTQyOTcgMzIuNzMwNSA1LjU1MjczIDMyLjgzMiA1LjU3MjI3QzMyLjkzMzYgNS41ODc4OSAzMy4wMDM5IDUuNjA1NDcgMzMuMDQzIDUuNjI1Wk0zNi41NTg2IDEyLjExNzJDMzYuMTE3MiAxMi4xMTcyIDM1LjcxNjggMTIuMDQzIDM1LjM1NzQgMTEuODk0NUMzNS4wMDIgMTEuNzQyMiAzNC42OTUzIDExLjUyOTMgMzQuNDM3NSAxMS4yNTU5QzM0LjE4MzYgMTAuOTgyNCAzMy45ODgzIDEwLjY1ODIgMzMuODUxNiAxMC4yODMyQzMzLjcxNDggOS45MDgyIDMzLjY0NjUgOS40OTgwNSAzMy42NDY1IDkuMDUyNzNWOC44MDY2NEMzMy42NDY1IDguMjkxMDIgMzMuNzIyNyA3LjgzMjAzIDMzLjg3NSA3LjQyOTY5QzM0LjAyNzMgNy4wMjM0NCAzNC4yMzQ0IDYuNjc5NjkgMzQuNDk2MSA2LjM5ODQ0QzM0Ljc1NzggNi4xMTcxOSAzNS4wNTQ3IDUuOTA0MyAzNS4zODY3IDUuNzU5NzdDMzUuNzE4OCA1LjYxNTIzIDM2LjA2MjUgNS41NDI5NyAzNi40MTggNS41NDI5N0MzNi44NzExIDUuNTQyOTcgMzcuMjYxNyA1LjYyMTA5IDM3LjU4OTggNS43NzczNEMzNy45MjE5IDUuOTMzNTkgMzguMTkzNCA2LjE1MjM0IDM4LjQwNDMgNi40MzM1OUMzOC42MTUyIDYuNzEwOTQgMzguNzcxNSA3LjAzOTA2IDM4Ljg3MyA3LjQxNzk3QzM4Ljk3NDYgNy43OTI5NyAzOS4wMjU0IDguMjAzMTIgMzkuMDI1NCA4LjY0ODQ0VjkuMTM0NzdIMzQuMjkxVjguMjVIMzcuOTQxNFY4LjE2Nzk3QzM3LjkyNTggNy44ODY3MiAzNy44NjcyIDcuNjEzMjggMzcuNzY1NiA3LjM0NzY2QzM3LjY2OCA3LjA4MjAzIDM3LjUxMTcgNi44NjMyOCAzNy4yOTY5IDYuNjkxNDFDMzcuMDgyIDYuNTE5NTMgMzYuNzg5MSA2LjQzMzU5IDM2LjQxOCA2LjQzMzU5QzM2LjE3MTkgNi40MzM1OSAzNS45NDUzIDYuNDg2MzMgMzUuNzM4MyA2LjU5MThDMzUuNTMxMiA2LjY5MzM2IDM1LjM1MzUgNi44NDU3IDM1LjIwNTEgNy4wNDg4M0MzNS4wNTY2IDcuMjUxOTUgMzQuOTQxNCA3LjUgMzQuODU5NCA3Ljc5Mjk3QzM0Ljc3NzMgOC4wODU5NCAzNC43MzYzIDguNDIzODMgMzQuNzM2MyA4LjgwNjY0VjkuMDUyNzNDMzQuNzM2MyA5LjM1MzUyIDM0Ljc3NzMgOS42MzY3MiAzNC44NTk0IDkuOTAyMzRDMzQuOTQ1MyAxMC4xNjQxIDM1LjA2ODQgMTAuMzk0NSAzNS4yMjg1IDEwLjU5MzhDMzUuMzkyNiAxMC43OTMgMzUuNTg5OCAxMC45NDkyIDM1LjgyMDMgMTEuMDYyNUMzNi4wNTQ3IDExLjE3NTggMzYuMzIwMyAxMS4yMzI0IDM2LjYxNzIgMTEuMjMyNEMzNyAxMS4yMzI0IDM3LjMyNDIgMTEuMTU0MyAzNy41ODk4IDEwLjk5OEMzNy44NTU1IDEwLjg0MTggMzguMDg3OSAxMC42MzI4IDM4LjI4NzEgMTAuMzcxMUwzOC45NDM0IDEwLjg5MjZDMzguODA2NiAxMS4wOTk2IDM4LjYzMjggMTEuMjk2OSAzOC40MjE5IDExLjQ4NDRDMzguMjEwOSAxMS42NzE5IDM3Ljk1MTIgMTEuODI0MiAzNy42NDI2IDExLjk0MTRDMzcuMzM3OSAxMi4wNTg2IDM2Ljk3NjYgMTIuMTE3MiAzNi41NTg2IDEyLjExNzJaTTQ0LjI4NzEgMTAuNzY5NVYzSDQ1LjM3N1YxMkg0NC4zODA5TDQ0LjI4NzEgMTAuNzY5NVpNNDAuMDIxNSA4LjkwMDM5VjguNzc3MzRDNDAuMDIxNSA4LjI5Mjk3IDQwLjA4MDEgNy44NTM1MiA0MC4xOTczIDcuNDU4OThDNDAuMzE4NCA3LjA2MDU1IDQwLjQ4ODMgNi43MTg3NSA0MC43MDcgNi40MzM1OUM0MC45Mjk3IDYuMTQ4NDQgNDEuMTkzNCA1LjkyOTY5IDQxLjQ5OCA1Ljc3NzM0QzQxLjgwNjYgNS42MjEwOSA0Mi4xNTA0IDUuNTQyOTcgNDIuNTI5MyA1LjU0Mjk3QzQyLjkyNzcgNS41NDI5NyA0My4yNzU0IDUuNjEzMjggNDMuNTcyMyA1Ljc1MzkxQzQzLjg3MyA1Ljg5MDYyIDQ0LjEyNyA2LjA5MTggNDQuMzM0IDYuMzU3NDJDNDQuNTQ0OSA2LjYxOTE0IDQ0LjcxMDkgNi45MzU1NSA0NC44MzIgNy4zMDY2NEM0NC45NTMxIDcuNjc3NzMgNDUuMDM3MSA4LjA5NzY2IDQ1LjA4NCA4LjU2NjQxVjkuMTA1NDdDNDUuMDQxIDkuNTcwMzEgNDQuOTU3IDkuOTg4MjggNDQuODMyIDEwLjM1OTRDNDQuNzEwOSAxMC43MzA1IDQ0LjU0NDkgMTEuMDQ2OSA0NC4zMzQgMTEuMzA4NkM0NC4xMjcgMTEuNTcwMyA0My44NzMgMTEuNzcxNSA0My41NzIzIDExLjkxMjFDNDMuMjcxNSAxMi4wNDg4IDQyLjkxOTkgMTIuMTE3MiA0Mi41MTc2IDEyLjExNzJDNDIuMTQ2NSAxMi4xMTcyIDQxLjgwNjYgMTIuMDM3MSA0MS40OTggMTEuODc3QzQxLjE5MzQgMTEuNzE2OCA0MC45Mjk3IDExLjQ5MjIgNDAuNzA3IDExLjIwMzFDNDAuNDg4MyAxMC45MTQxIDQwLjMxODQgMTAuNTc0MiA0MC4xOTczIDEwLjE4MzZDNDAuMDgwMSA5Ljc4OTA2IDQwLjAyMTUgOS4zNjEzMyA0MC4wMjE1IDguOTAwMzlaTTQxLjExMTMgOC43NzczNFY4LjkwMDM5QzQxLjExMTMgOS4yMTY4IDQxLjE0MjYgOS41MTM2NyA0MS4yMDUxIDkuNzkxMDJDNDEuMjcxNSAxMC4wNjg0IDQxLjM3MyAxMC4zMTI1IDQxLjUwOTggMTAuNTIzNEM0MS42NDY1IDEwLjczNDQgNDEuODIwMyAxMC45MDA0IDQyLjAzMTIgMTEuMDIxNUM0Mi4yNDIyIDExLjEzODcgNDIuNDk0MSAxMS4xOTczIDQyLjc4NzEgMTEuMTk3M0M0My4xNDY1IDExLjE5NzMgNDMuNDQxNCAxMS4xMjExIDQzLjY3MTkgMTAuOTY4OEM0My45MDYyIDEwLjgxNjQgNDQuMDkzOCAxMC42MTUyIDQ0LjIzNDQgMTAuMzY1MkM0NC4zNzUgMTAuMTE1MiA0NC40ODQ0IDkuODQzNzUgNDQuNTYyNSA5LjU1MDc4VjguMTM4NjdDNDQuNTE1NiA3LjkyMzgzIDQ0LjQ0NzMgNy43MTY4IDQ0LjM1NzQgNy41MTc1OEM0NC4yNzE1IDcuMzE0NDUgNDQuMTU4MiA3LjEzNDc3IDQ0LjAxNzYgNi45Nzg1MkM0My44ODA5IDYuODE4MzYgNDMuNzEwOSA2LjY5MTQxIDQzLjUwNzggNi41OTc2NkM0My4zMDg2IDYuNTAzOTEgNDMuMDcyMyA2LjQ1NzAzIDQyLjc5ODggNi40NTcwM0M0Mi41MDIgNi40NTcwMyA0Mi4yNDYxIDYuNTE5NTMgNDIuMDMxMiA2LjY0NDUzQzQxLjgyMDMgNi43NjU2MiA0MS42NDY1IDYuOTMzNTkgNDEuNTA5OCA3LjE0ODQ0QzQxLjM3MyA3LjM1OTM4IDQxLjI3MTUgNy42MDU0NyA0MS4yMDUxIDcuODg2NzJDNDEuMTQyNiA4LjE2NDA2IDQxLjExMTMgOC40NjA5NCA0MS4xMTEzIDguNzc3MzRaTTUwLjAzNTIgM0g1MS4xMjVWMTAuNzY5NUw1MS4wMzEyIDEySDUwLjAzNTJWM1pNNTUuNDA4MiA4Ljc3NzM0VjguOTAwMzlDNTUuNDA4MiA5LjM2MTMzIDU1LjM1MzUgOS43ODkwNiA1NS4yNDQxIDEwLjE4MzZDNTUuMTM0OCAxMC41NzQyIDU0Ljk3NDYgMTAuOTE0MSA1NC43NjM3IDExLjIwMzFDNTQuNTUyNyAxMS40OTIyIDU0LjI5NDkgMTEuNzE2OCA1My45OTAyIDExLjg3N0M1My42ODU1IDEyLjAzNzEgNTMuMzM1OSAxMi4xMTcyIDUyLjk0MTQgMTIuMTE3MkM1Mi41MzkxIDEyLjExNzIgNTIuMTg1NSAxMi4wNDg4IDUxLjg4MDkgMTEuOTEyMUM1MS41ODAxIDExLjc3MTUgNTEuMzI2MiAxMS41NzAzIDUxLjExOTEgMTEuMzA4NkM1MC45MTIxIDExLjA0NjkgNTAuNzQ2MSAxMC43MzA1IDUwLjYyMTEgMTAuMzU5NEM1MC41IDkuOTg4MjggNTAuNDE2IDkuNTcwMzEgNTAuMzY5MSA5LjEwNTQ3VjguNTY2NDFDNTAuNDE2IDguMDk3NjYgNTAuNSA3LjY3NzczIDUwLjYyMTEgNy4zMDY2NEM1MC43NDYxIDYuOTM1NTUgNTAuOTEyMSA2LjYxOTE0IDUxLjExOTEgNi4zNTc0MkM1MS4zMjYyIDYuMDkxOCA1MS41ODAxIDUuODkwNjIgNTEuODgwOSA1Ljc1MzkxQzUyLjE4MTYgNS42MTMyOCA1Mi41MzEyIDUuNTQyOTcgNTIuOTI5NyA1LjU0Mjk3QzUzLjMyODEgNS41NDI5NyA1My42ODE2IDUuNjIxMDkgNTMuOTkwMiA1Ljc3NzM0QzU0LjI5ODggNS45Mjk2OSA1NC41NTY2IDYuMTQ4NDQgNTQuNzYzNyA2LjQzMzU5QzU0Ljk3NDYgNi43MTg3NSA1NS4xMzQ4IDcuMDYwNTUgNTUuMjQ0MSA3LjQ1ODk4QzU1LjM1MzUgNy44NTM1MiA1NS40MDgyIDguMjkyOTcgNTUuNDA4MiA4Ljc3NzM0Wk01NC4zMTg0IDguOTAwMzlWOC43NzczNEM1NC4zMTg0IDguNDYwOTQgNTQuMjg5MSA4LjE2NDA2IDU0LjIzMDUgNy44ODY3MkM1NC4xNzE5IDcuNjA1NDcgNTQuMDc4MSA3LjM1OTM4IDUzLjk0OTIgNy4xNDg0NEM1My44MjAzIDYuOTMzNTkgNTMuNjUwNCA2Ljc2NTYyIDUzLjQzOTUgNi42NDQ1M0M1My4yMjg1IDYuNTE5NTMgNTIuOTY4OCA2LjQ1NzAzIDUyLjY2MDIgNi40NTcwM0M1Mi4zODY3IDYuNDU3MDMgNTIuMTQ4NCA2LjUwMzkxIDUxLjk0NTMgNi41OTc2NkM1MS43NDYxIDYuNjkxNDEgNTEuNTc2MiA2LjgxODM2IDUxLjQzNTUgNi45Nzg1MkM1MS4yOTQ5IDcuMTM0NzcgNTEuMTc5NyA3LjMxNDQ1IDUxLjA4OTggNy41MTc1OEM1MS4wMDM5IDcuNzE2OCA1MC45Mzk1IDcuOTIzODMgNTAuODk2NSA4LjEzODY3VjkuNTUwNzhDNTAuOTU5IDkuODI0MjIgNTEuMDYwNSAxMC4wODc5IDUxLjIwMTIgMTAuMzQxOEM1MS4zNDU3IDEwLjU5MTggNTEuNTM3MSAxMC43OTY5IDUxLjc3NTQgMTAuOTU3QzUyLjAxNzYgMTEuMTE3MiA1Mi4zMTY0IDExLjE5NzMgNTIuNjcxOSAxMS4xOTczQzUyLjk2NDggMTEuMTk3MyA1My4yMTQ4IDExLjEzODcgNTMuNDIxOSAxMS4wMjE1QzUzLjYzMjggMTAuOTAwNCA1My44MDI3IDEwLjczNDQgNTMuOTMxNiAxMC41MjM0QzU0LjA2NDUgMTAuMzEyNSA1NC4xNjIxIDEwLjA2ODQgNTQuMjI0NiA5Ljc5MTAyQzU0LjI4NzEgOS41MTM2NyA1NC4zMTg0IDkuMjE2OCA1NC4zMTg0IDguOTAwMzlaTTU4LjQ5MDIgMTEuMzQzOEw2MC4yNTM5IDUuNjYwMTZINjEuNDE0MUw1OC44NzExIDEyLjk3ODVDNTguODEyNSAxMy4xMzQ4IDU4LjczNDQgMTMuMzAyNyA1OC42MzY3IDEzLjQ4MjRDNTguNTQzIDEzLjY2NiA1OC40MjE5IDEzLjgzOTggNTguMjczNCAxNC4wMDM5QzU4LjEyNSAxNC4xNjggNTcuOTQ1MyAxNC4zMDA4IDU3LjczNDQgMTQuNDAyM0M1Ny41MjczIDE0LjUwNzggNTcuMjc5MyAxNC41NjA1IDU2Ljk5MDIgMTQuNTYwNUM1Ni45MDQzIDE0LjU2MDUgNTYuNzk0OSAxNC41NDg4IDU2LjY2MjEgMTQuNTI1NEM1Ni41MjkzIDE0LjUwMiA1Ni40MzU1IDE0LjQ4MjQgNTYuMzgwOSAxNC40NjY4TDU2LjM3NSAxMy41ODc5QzU2LjQwNjIgMTMuNTkxOCA1Ni40NTUxIDEzLjU5NTcgNTYuNTIxNSAxMy41OTk2QzU2LjU5MTggMTMuNjA3NCA1Ni42NDA2IDEzLjYxMTMgNTYuNjY4IDEzLjYxMTNDNTYuOTE0MSAxMy42MTEzIDU3LjEyMyAxMy41NzgxIDU3LjI5NDkgMTMuNTExN0M1Ny40NjY4IDEzLjQ0OTIgNTcuNjExMyAxMy4zNDE4IDU3LjcyODUgMTMuMTg5NUM1Ny44NDk2IDEzLjA0MSA1Ny45NTMxIDEyLjgzNTkgNTguMDM5MSAxMi41NzQyTDU4LjQ5MDIgMTEuMzQzOFpNNTcuMTk1MyA1LjY2MDE2TDU4Ljg0MTggMTAuNTgyTDU5LjEyMyAxMS43MjQ2TDU4LjM0MzggMTIuMTIzTDU2LjAxMTcgNS42NjAxNkg1Ny4xOTUzWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTY5Ljc4ODMgOS4xMjkySDY3Ljk5ODhWMTIuNzc0NUg2N1YzLjUyODQ3SDY5LjczN0M3MS44MjUyIDMuNTI4NDcgNzIuMjI2NSA1LjE5MTE5IDcyLjIyNjUgNS45ODE4MVY2LjY1Nzc2QzcyLjIyNjUgNy40Njk1IDcxLjgyMjIgOS4xMjkyIDY5Ljc4ODMgOS4xMjkyWk03MS4yMzk4IDYuMDA1OTVDNzEuMjM5OCA0LjY5NjMgNzAuMjUzIDQuNTEyMjIgNjkuNzA5OCA0LjUxMjIySDY3Ljk5NThWOC4xNDU0NUg2OS43MzRDNzAuMjc3MSA4LjE0NTQ1IDcxLjIzOTggNy45NDkzMSA3MS4yMzk4IDYuNjM5NjVWNi4wMDU5NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTc0LjM2NiAxMi43NzQ1VjMuNTI4NDdINzkuMzYwMlY0LjUxNTI0SDc1LjM1MjhWNy4zOTQwNkg3OS4wNjE1VjguMzgwODNINzUuMzUyOFYxMS44MDU4SDc5LjM2MDJWMTIuNzc3NUg3NC4zNjZWMTIuNzc0NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTg2LjE1NTkgMTIuNzc0NUw4NC4zMzkzIDguODY5NjhIODIuODIxNVYxMi43NzQ1SDgxLjgyMjZWMy41Mjg0N0g4NC41NTk2Qzg2LjY0NzggMy41Mjg0NyA4Ny4wNjQzIDUuMTc2MSA4Ny4wNjQzIDUuOTY2NzJWNi40MDcyOUM4Ny4wNjQzIDcuMDk1MzEgODYuNzUzNCA4LjM3NzgxIDg1LjM5MjUgOC43NzkxNUw4Ny4yODc2IDEyLjc3NDVIODYuMTU1OVYxMi43NzQ1Wk04Ni4wNjU0IDYuMDA1OTVDODYuMDY1NCA0LjY5NjMgODUuMDc4NyA0LjUxMjIyIDg0LjUzNTUgNC41MTIyMkg4Mi44MjE1VjcuODk4MDFIODQuNTU5NkM4NS4xMDU4IDcuODk4MDEgODYuMDY1NCA3LjY4OTc5IDg2LjA2NTQgNi4zOTIyMVY2LjAwNTk1WiIgZmlsbD0iI0RDM0Q3MiIvPgo8cGF0aCBkPSJNOTAuNzYwOCA0LjUxMjIyVjcuNDA2MTNIOTQuNDY5NVY4LjM5MjlIOTAuNzYwOFYxMi43Nzc1SDg5Ljc3NFYzLjUyODQ3SDk0Ljc2ODJWNC41MTUyNEg5MC43NjA4VjQuNTEyMjJaIiBmaWxsPSIjREMzRDcyIi8+CjxwYXRoIGQ9Ik05Ni44NDE0IDEyLjc3NDVWMy41Mjg0N0gxMDEuODM2VjQuNTE1MjRIOTcuODI4MlY3LjM5NDA2SDEwMS41MzdWOC4zODA4M0g5Ny44MjgyVjExLjgwNThIMTAxLjgzNlYxMi43Nzc1SDk2Ljg0MTRWMTIuNzc0NVoiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTEwNi43NzggMTIuODkyMkMxMDQuNzQyIDEyLjg5MjIgMTA0LjE3MSAxMS4yMjA0IDEwNC4xNzEgMTAuNDAyNlY1Ljg4ODI2QzEwNC4xNzEgNS4wOTc2NCAxMDQuNzAyIDMuNDUwMDEgMTA2Ljc5MSAzLjQ1MDAxQzEwOC44MTUgMy40NTAwMSAxMDkuMzk4IDUuMDk3NjQgMTA5LjM5OCA1LjkwMzM1SDEwOC4zOTlDMTA4LjM5OSA0LjYxNzg0IDEwNy4zMSA0LjQyNDcxIDEwNi43OTEgNC40MjQ3MUMxMDYuMjU5IDQuNDI0NzEgMTA1LjE1OCA0LjYyMDg1IDEwNS4xNTggNS45MTU0MlYxMC40MDI2QzEwNS4xNTggMTEuNzEyMyAxMDYuMjU5IDExLjkwODQgMTA2Ljc5MSAxMS45MDg0QzEwNy4zMSAxMS45MDg0IDEwOC4zOTkgMTEuNzEyMyAxMDguMzk5IDEwLjQxNzdIMTA5LjM5OEMxMDkuMzk4IDExLjIzMjUgMTA4Ljg1MiAxMi44OTIyIDEwNi43NzggMTIuODkyMloiIGZpbGw9IiNEQzNENzIiLz4KPHBhdGggZD0iTTExNC4xOTYgNC41MjczMVYxMi43Nzc1SDExMy4xOTdWNC41MjczMUgxMTAuOTRWMy41Mjg0N0gxMTYuNDVWNC41MjczMUgxMTQuMTk2WiIgZmlsbD0iI0RDM0Q3MiIvPgo8ZyBvcGFjaXR5PSIwLjciPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyMS41NTIgNS40NjE1MkMxMjEuNDA5IDUuNDYxNTIgMTIxLjI3MiA1LjUxODMxIDEyMS4xNyA1LjYxOTQxQzEyMS4wNjkgNS43MjA1IDEyMS4wMTMgNS44NTc2MSAxMjEuMDEzIDYuMDAwNThWMTEuOTMwM0MxMjEuMDEzIDEyLjA3MzIgMTIxLjA2OSAxMi4yMTAzIDEyMS4xNyAxMi4zMTE0QzEyMS4yNzIgMTIuNDEyNSAxMjEuNDA5IDEyLjQ2OTMgMTIxLjU1MiAxMi40NjkzSDEyNy40ODFDMTI3LjYyNCAxMi40NjkzIDEyNy43NjEgMTIuNDEyNSAxMjcuODYyIDEyLjMxMTRDMTI3Ljk2NCAxMi4yMTAzIDEyOC4wMiAxMi4wNzMyIDEyOC4wMiAxMS45MzAzVjguNjk1ODlDMTI4LjAyIDguMzk4MTggMTI4LjI2MiA4LjE1NjgzIDEyOC41NTkgOC4xNTY4M0MxMjguODU3IDguMTU2ODMgMTI5LjA5OSA4LjM5ODE4IDEyOS4wOTkgOC42OTU4OVYxMS45MzAzQzEyOS4wOTkgMTIuMzU5MiAxMjguOTI4IDEyLjc3MDUgMTI4LjYyNSAxMy4wNzM4QzEyOC4zMjIgMTMuMzc3MSAxMjcuOTEgMTMuNTQ3NSAxMjcuNDgxIDEzLjU0NzVIMTIxLjU1MkMxMjEuMTIzIDEzLjU0NzUgMTIwLjcxMSAxMy4zNzcxIDEyMC40MDggMTMuMDczOEMxMjAuMTA1IDEyLjc3MDUgMTE5LjkzNCAxMi4zNTkyIDExOS45MzQgMTEuOTMwM1Y2LjAwMDU4QzExOS45MzQgNS41NzE2OCAxMjAuMTA1IDUuMTYwMzQgMTIwLjQwOCA0Ljg1NzA2QzEyMC43MTEgNC41NTM3NyAxMjEuMTIzIDQuMzgzMzkgMTIxLjU1MiA0LjM4MzM5SDEyNC43ODZDMTI1LjA4NCA0LjM4MzM5IDEyNS4zMjUgNC42MjQ3NCAxMjUuMzI1IDQuOTIyNDVDMTI1LjMyNSA1LjIyMDE3IDEyNS4wODQgNS40NjE1MiAxMjQuNzg2IDUuNDYxNTJIMTIxLjU1MloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTI2Ljk0MiAyLjc2NjE3QzEyNi42NDUgMi43NjYxNyAxMjYuNDAzIDMuMDA3NTIgMTI2LjQwMyAzLjMwNTI0QzEyNi40MDMgMy42MDI5NSAxMjYuNjQ1IDMuODQ0MyAxMjYuOTQyIDMuODQ0M0gxMjguODc1TDEyMy44NjYgOC44NTM3N0MxMjMuNjU1IDkuMDY0MjkgMTIzLjY1NSA5LjQwNTYxIDEyMy44NjYgOS42MTYxMkMxMjQuMDc2IDkuODI2NjQgMTI0LjQxOCA5LjgyNjY0IDEyNC42MjggOS42MTYxMkwxMjkuNjM4IDQuNjA2N1Y2LjUzOTYxQzEyOS42MzggNi44MzczMyAxMjkuODc5IDcuMDc4NjcgMTMwLjE3NyA3LjA3ODY3QzEzMC40NzQgNy4wNzg2NyAxMzAuNzE2IDYuODM3MzMgMTMwLjcxNiA2LjUzOTYxVjMuMzEwMzdDMTMwLjcxNiAzLjMwNjk3IDEzMC43MTYgMy4zMDM1NiAxMzAuNzE2IDMuMzAwMTVWMy4yMzI1MUMxMzAuNzE2IDIuOTM0NzkgMTMwLjQ3NCAyLjc2NjE3IDEzMC4xNzcgMi43NjYxN0gxMjYuOTQyWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2RfMl8yOTQiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMzIuOCIgaGVpZ2h0PSIxNi4xNSIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPgo8ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9IkJhY2tncm91bmRJbWFnZUZpeCIvPgo8ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCIgcmVzdWx0PSJoYXJkQWxwaGEiLz4KPGZlT2Zmc2V0IGR4PSIxLjE1IiBkeT0iMS4xNSIvPgo8ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4yNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzJfMjk0Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93XzJfMjk0IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cjwvc3ZnPgo="

/***/ }),

/***/ 838:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getIterator2 = __webpack_require__(16);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _class, _temp, _initialiseProps;

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _venusloader = __webpack_require__(314);

var _venusloader2 = _interopRequireDefault(_venusloader);

var _lockmanager = __webpack_require__(315);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _fileUtils = __webpack_require__(137);

var _fileUtils2 = _interopRequireDefault(_fileUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _facequalitychecker = __webpack_require__(839);

var _facequalitychecker2 = _interopRequireDefault(_facequalitychecker);

var _facequalitychecker4autopd = __webpack_require__(840);

var _facequalitychecker4autopd2 = _interopRequireDefault(_facequalitychecker4autopd);

var _facequalitychecker4shadefinder = __webpack_require__(841);

var _facequalitychecker4shadefinder2 = _interopRequireDefault(_facequalitychecker4shadefinder);

var _facequalitychecker4ringautosizer = __webpack_require__(842);

var _facequalitychecker4ringautosizer2 = _interopRequireDefault(_facequalitychecker4ringautosizer);

var _shadefinder = __webpack_require__(847);

var _shadefinder2 = _interopRequireDefault(_shadefinder);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _faceaiattribute = __webpack_require__(848);

var _faceaiattribute2 = _interopRequireDefault(_faceaiattribute);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _webcam = __webpack_require__(303);

var _webcam2 = _interopRequireDefault(_webcam);

var _VideoStreamTrackWebcam = __webpack_require__(818);

var _VideoStreamTrackWebcam2 = _interopRequireDefault(_VideoStreamTrackWebcam);

var _BlobWebcam = __webpack_require__(820);

var _BlobWebcam2 = _interopRequireDefault(_BlobWebcam);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _VideoFileWebcam = __webpack_require__(819);

var _VideoFileWebcam2 = _interopRequireDefault(_VideoFileWebcam);

var _VideoImagesWebcam = __webpack_require__(850);

var _VideoImagesWebcam2 = _interopRequireDefault(_VideoImagesWebcam);

var _settings = __webpack_require__(39);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WEBCAM = void 0;
var VIDEO = void 0;
var BLOB = void 0;
var AbstractController = (_temp = _class = function AbstractController(props) {
  (0, _classCallCheck3.default)(this, AbstractController);

  _initialiseProps.call(this);

  this.frameId = props.frameId;
  this.videoId = props.videoId;
  if (props.settings.isHeadlessMode()) {
    this.videoElement = document.createElement('video');
    this.videoElement.id = 'YMK-video';
    this.videoElement.autoplay = true;
    this.videoElement.playsinline = true;
  }
  this.outputId = props.outputId;
  this.canvasId = props.canvasId;
  this.camera_width = props.cameraWidth;
  this.camera_height = props.cameraHeight;
  this.display_width = _mathUtils2.default.toEvenNumber(props.displayWidth);
  this.display_height = _mathUtils2.default.toEvenNumber(props.displayHeight);
  this.document = props.document;
  this.emitter = props.emitter;
  this.originalId = props.originalId;
  this.targetId = props.targetId;
  this.savePhotoId = props.savePhotoId;
  this.compareIndicatorId = props.compareIndicatorId;
  this.devicePixelRatio = props.devicePixelRatio;
  this.needToFlipVideoStream = props.needToFlipVideoStream;
  this.source = null;
  this.sourceType = null;
  this.renderer = null;
  this.allUpdaters = [];
  this.settings = props.settings;
  this.loaded = false;
  this.videoStreamTrack = props.videoStreamTrack;
  this.videoFile = props.videoFile;
  this.frameRate = props.frameRate;
  this.videoImages = props.videoImages;
  this.videoImagesInfo = props.videoImagesInfo;
  this.MakeupLiveFilter = null;
  this.VideoSourceLoader = null;
  this.ImageSource = null;
  this.beforeSourceInitTasks = [];
  this.afterSourceInitTasks = [];
  this.mt3dloader = null;

  this.addBeforeSourceInitTask(this.handleShadeFinderInitialization);
  this.addAfterSourceInitTask(this.handleShadeFinderFaceQualityCheckerInitialization);
  this.addAfterSourceInitTask(this.handleFaceAttributeInitialization);
  this.addAfterSourceInitTask(this.handleEyewearAutoPDInitialization);
  this.addAfterSourceInitTask(this.handleRingAutoSizerInitialization);
}, _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.addBeforeSourceInitTask = function (t) {
    return _this.beforeSourceInitTasks.push(t);
  };

  this.addAfterSourceInitTask = function (t) {
    return _this.afterSourceInitTasks.push(t);
  };

  this.setArgs = function (args) {
    _this.camera_width = args.cameraWidth;
    _this.camera_height = args.cameraHeight;
    _this.display_width = _mathUtils2.default.toEvenNumber(args.displayWidth);
    _this.display_height = _mathUtils2.default.toEvenNumber(args.displayHeight);
  };

  this.needToWaitForWebcam = function () {
    if (_browserUtils2.default.isWeixin()) {
      return true;
    }
    if ((0, _get3.default)(_this.settings, 'features.foundationOnly')) {
      return false;
    }
    if (_this.settings.functionType === _functionTypes2.default.skincare) {
      return false;
    }
    if (_this.settings.functionType === _functionTypes2.default.handar) {
      return false;
    }
    return true;
  };

  this.load = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(type, media, _skuTypes, featurePoints, mediaSource, earlobePoints, masks, leftEarlobePoints, rightEarlobePoints, removeBgMask, modelConfig) {
      var loaded;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              loaded = _this.loaded;

              if (!loaded) {
                _context2.next = 4;
                break;
              }

              _context2.next = 4;
              return _this.close();

            case 4:
              _this.loaded = true;
              _venusloader2.default.load(_this.settings, _this.emitter, function () {
                var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(m) {
                  var b;
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!loaded) {
                            _context.next = 3;
                            break;
                          }

                          _context.next = 3;
                          return (0, _lockmanager.getLockManager)().waitForResolve('controller-close');

                        case 3:
                          _this.YMKModule = m;
                          _this.emitter.trigger(_events2.default.loading, [80]);
                          _context.prev = 5;
                          b = performance.now();

                          if (!_this.needToWaitForWebcam()) {
                            _context.next = 12;
                            break;
                          }

                          _context.next = 10;
                          return _this.initWebcam(type);

                        case 10:
                          _context.next = 13;
                          break;

                        case 12:
                          _this.initWebcam(type);

                        case 13:
                          _this.emitter.trigger(_events2.default.engineLoading, ['camera', b, performance.now()]);
                          _context.next = 16;
                          return _this.init({
                            type: type,
                            media: media,
                            featurePoints: featurePoints,
                            mediaSource: mediaSource,
                            earlobePoints: earlobePoints,
                            masks: masks,
                            leftEarlobePoints: leftEarlobePoints,
                            rightEarlobePoints: rightEarlobePoints,
                            removeBgMask: removeBgMask,
                            modelConfig: modelConfig
                          });

                        case 16:
                          _context.next = 21;
                          break;

                        case 18:
                          _context.prev = 18;
                          _context.t0 = _context['catch'](5);

                          console.log(_context.t0);

                        case 21:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, _this, [[5, 18]]);
                }));

                return function (_x12) {
                  return _ref2.apply(this, arguments);
                };
              }());

            case 6:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this);
    }));

    return function (_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11) {
      return _ref.apply(this, arguments);
    };
  }();

  this.resizeVideo = function (props) {
    if (!_this.webcam) {
      return;
    }
    _this.webcam.resize(props);
  };

  this._readFile = function (file) {
    return new _promise2.default(function (resolve) {
      if (typeof file === 'string') {
        resolve(file);
      } else {
        var r = new FileReader();
        r.readAsDataURL(file);
        r.onloadend = function (event) {
          return resolve(event.target.result);
        };
      }
    });
  };

  this._getImageSize = function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(media) {
      var originalImage;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (media) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return', { width: 0, height: 0 });

            case 2:
              originalImage = new Image();
              _context3.t0 = _fileUtils2.default;
              _context3.t1 = originalImage;
              _context3.next = 7;
              return _this._readFile(media);

            case 7:
              _context3.t2 = _context3.sent;
              _context3.next = 10;
              return _context3.t0.loadImageFromFile.call(_context3.t0, _context3.t1, _context3.t2);

            case 10:
              return _context3.abrupt('return', { width: originalImage.width, height: originalImage.height });

            case 11:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x13) {
      return _ref3.apply(this, arguments);
    };
  }();

  this.createWebGLRenderer = function () {};

  this.init = function () {
    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(_ref5) {
      var type = _ref5.type,
          media = _ref5.media,
          mediaSource = _ref5.mediaSource,
          featurePoints = _ref5.featurePoints,
          earlobePoints = _ref5.earlobePoints,
          masks = _ref5.masks,
          leftEarlobePoints = _ref5.leftEarlobePoints,
          rightEarlobePoints = _ref5.rightEarlobePoints,
          removeBgMask = _ref5.removeBgMask,
          modelConfig = _ref5.modelConfig;

      var begin, _ref6, width, height, b1, b2;

      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              begin = performance.now();

              _this.switchVideoSourceLoader && _this.switchVideoSourceLoader((0, _get3.default)(_this.settings, 'skincareMode'));
              _this.comparing = false;

              if (!(0, _isFunction3.default)(_this.initMt3dLoader)) {
                _context5.next = 6;
                break;
              }

              _context5.next = 6;
              return _this.initMt3dLoader();

            case 6:
              _this.renderer = _this.createWebGLRenderer();

              if (_this.settings.isHeadlessMode()) {
                mediaSource = _settings.mediaSources.api;
              }
              _this.renderer.domElement.id = 'canvas';
              _this.sourceType = type;

              if (!(_this.settings.isFunctionTypeMakeupViewer() && _this.ViewerSource)) {
                _context5.next = 15;
                break;
              }

              _this.makeup_live_filter = new _this.MakeupLiveFilter(_this.camera_width, _this.camera_height, true, _this.renderer, _this.YMKModule, _this.settings, mediaSource, _this.mt3dloader);
              _this.source = new _this.ViewerSource({
                mediaSource: mediaSource,
                YMKModule: _this.YMKModule,
                canvasDocId: 'YMK-video-canvas',
                controller: _this,
                devicePixelRatio: _this.devicePixelRatio,
                display_height: _this.display_height,
                display_width: _this.display_width,
                document: _this.document,
                emitter: _this.emitter,
                errorCallback: _this.handleError,
                frameId: _this.frameId,
                image_height: _this.camera_height,
                image_width: _this.camera_width,
                makeup_live_filter: _this.makeup_live_filter,
                originalId: _this.originalId,
                outputId: _this.outputId,
                renderer: _this.renderer,
                settings: _this.settings,
                targetId: _this.targetId
              });
              _context5.next = 27;
              break;

            case 15:
              if (!(type === 'image' && _this.ImageSource)) {
                _context5.next = 25;
                break;
              }

              _this.makeup_live_filter = new _this.MakeupLiveFilter(_this.camera_width, _this.camera_height, true, _this.renderer, _this.YMKModule, _this.settings, mediaSource, _this.mt3dloader);
              _context5.next = 19;
              return _this._getImageSize(media);

            case 19:
              _ref6 = _context5.sent;
              width = _ref6.width;
              height = _ref6.height;

              _this.source = new _this.ImageSource({
                mediaSource: mediaSource,
                featurePoints: featurePoints,
                earlobePoints: earlobePoints,
                leftEarlobePoints: leftEarlobePoints,
                rightEarlobePoints: rightEarlobePoints,
                removeBgMask: removeBgMask,
                masks: masks,
                YMKModule: _this.YMKModule,
                canvasDocId: 'YMK-video-canvas',
                compareIndicatorId: _this.compareIndicatorId,
                controller: _this,
                devicePixelRatio: _this.devicePixelRatio,
                display_height: _this.display_height,
                display_width: _this.display_width,
                document: _this.document,
                emitter: _this.emitter,
                errorCallback: _this.handleError,
                file: media,
                frameId: _this.frameId,
                image_height: _this.camera_height,
                image_width: _this.camera_width,
                makeup_live_filter: _this.makeup_live_filter,
                originalId: _this.originalId,
                outputId: _this.outputId,
                renderer: _this.renderer,
                settings: _this.settings,
                targetId: _this.targetId,
                originalWidth: width,
                originalHeight: height,
                modelConfig: modelConfig
              });
              _context5.next = 27;
              break;

            case 25:
              _this.makeup_live_filter = new _this.MakeupLiveFilter(_this.camera_width, _this.camera_height, false, _this.renderer, _this.YMKModule, _this.settings, mediaSource, _this.mt3dloader);
              _this.source = _this.VideoSourceLoader.load({
                mediaSource: mediaSource,
                type: type,
                webcam: _this.webcam,
                YMKModule: _this.YMKModule,
                camera_height: _this.camera_height,
                camera_width: _this.camera_width,
                canvasDocId: 'YMK-video-canvas',
                compareIndicatorId: _this.compareIndicatorId,
                controller: _this,
                devicePixelRatio: _this.devicePixelRatio,
                display_height: _this.display_height,
                display_width: _this.display_width,
                document: _this.document,
                emitter: _this.emitter,
                errorCallback: _this.handleError,
                frameId: _this.frameId,
                makeup_live_filter: _this.makeup_live_filter,
                orignialId: _this.originalId,
                outputId: _this.outputId,
                renderer: _this.renderer,
                settings: _this.settings,
                targetId: _this.targetId,
                videoDocId: 'YMK-video-input',
                needToFlipVideoStream: _this.needToFlipVideoStream,
                videoElement: _this.videoElement
              });

            case 27:
              _this.emitter.trigger(_events2.default.engineLoading, ['controller-init', begin, performance.now()]);
              b1 = performance.now();
              _context5.next = 31;
              return _this._beforeSourceInit(_this.source);

            case 31:
              _this.emitter.trigger(_events2.default.engineLoading, ['before-source-init', b1, performance.now()]);
              b2 = performance.now();

              _this.source.init((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
                var b3;
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _this.emitter.trigger(_events2.default.engineLoading, ['source-init', b2, performance.now()]);
                        b3 = performance.now();
                        _context4.next = 4;
                        return _this._afterSourceInit(_this.source);

                      case 4:
                        _this.emitter.trigger(_events2.default.engineLoading, ['after-source-init', b3, performance.now()]);

                      case 5:
                      case 'end':
                        return _context4.stop();
                    }
                  }
                }, _callee4, _this);
              })));

            case 34:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this);
    }));

    return function (_x14) {
      return _ref4.apply(this, arguments);
    };
  }();

  this.initWebcam = function (type) {
    return new _promise2.default(function (resolve, reject) {
      if (type === 'image' && _this.ImageSource || _this.settings.isFunctionTypeMakeupViewer()) {
        return resolve();
      }
      if (_this.settings.getFunctionType() === _functionTypes2.default.livestream || _this.videoFile || _this.videoImages || _this.settings.isHeadlessMode() && !!(0, _get3.default)(_this.settings, 'canvasInputStreamTrack')) {
        if (!VIDEO) {
          if (_this.videoStreamTrack) {
            VIDEO = new _VideoStreamTrackWebcam2.default(_this.settings.videoId, _this.emitter, _this.videoStreamTrack, _this.videoElement);
          } else if (!!_this.videoFile) {
            VIDEO = new _VideoFileWebcam2.default(_this.settings, _this.emitter, _this.videoFile, _this.frameRate);
          } else if (!!_this.videoImages) {
            VIDEO = new _VideoImagesWebcam2.default(_this.settings, _this.emitter, _this.videoImages, _this.videoImagesInfo);
          } else if (!!(0, _get3.default)(_this.settings, 'canvasInputStreamTrack')) {
            VIDEO = new _VideoStreamTrackWebcam2.default(_this.settings.videoId, _this.emitter, _this.settings.canvasInputStreamTrack, _this.videoElement);
          }
        } else if (!!_this.settings.canvasInputStreamTrack) {
          // WCM241218P0009, need refine
          VIDEO.changeVideoSource(_this.settings.canvasInputStreamTrack);
        }
        _this.webcam = VIDEO;
        _this.webcam.init(function () {
          return resolve();
        }, function (error) {
          var rejected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          _this.emitter.trigger(_events2.default.cameraFailed, [error, rejected]);
          reject(error);
        });
        return;
      }
      if (!WEBCAM) {
        WEBCAM = new _webcam2.default(_this.settings.videoId, _this.emitter, _this.settings, _this.videoElement);
      }
      _this.webcam = WEBCAM;
      _this.webcam.init(function () {
        return resolve();
      }, function (error) {
        var rejected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        console.log(error);
        _this.emitter.trigger(_events2.default.cameraFailed, [error, rejected]);
        reject(error);
      });
    });
  };

  this.changeWebcam = function (webcamType, videoSource) {
    if (_this.webcam.type === webcamType) {
      if (_this.webcam.streams.length !== 0) {
        _this.emitter.trigger(_events2.default.webcamChanged);
        return;
      }
      _this.emitter.once(_events2.default.cameraOpened, function () {
        return _this.emitter.trigger(_events2.default.webcamChanged);
      });
      return;
    }
    _this.webcam.stop();
    if (webcamType === _webcam.TYPES.blob) {
      if (!BLOB) {
        BLOB = new _BlobWebcam2.default(_this.settings.videoId, _this.emitter, videoSource);
      }
      _this.webcam = BLOB;
      _this.webcam.setBlob(videoSource);
    }
    if (webcamType === _webcam.TYPES.webcam) {
      if (!WEBCAM) {
        WEBCAM = new _webcam2.default(_this.settings.videoId, _this.emitter, _this.settings);
      }
      _this.webcam = WEBCAM;
    }
    if (webcamType === _webcam.TYPES.videostreamtrack) {
      if (!VIDEO) {
        VIDEO = new _VideoStreamTrackWebcam2.default(_this.settings.videoId, _this.emitter, _this.videoStreamTrack);
      }
      _this.webcam = VIDEO;
    }
    _this.source.webcam = _this.webcam;
    _this.webcam.init(function () {
      return _this.emitter.trigger(_events2.default.webcamChanged);
    }, function (error) {
      var rejected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return _this.emitter.trigger(_events2.default.cameraFailed, [error, rejected]);
    });
    (0, _isFunction3.default)(_this.source.setWebcam) && _this.source.setWebcam(_this.webcam);
  };

  this.changeVideoSource = function (videoSource) {
    if (!_this.webcam) {
      return;
    }
    _this.webcam.changeVideoSource(videoSource);
  };

  this.restartCamera = function () {
    if (!_this.webcam) {
      return;
    }
    console.log(_this.webcam);

    _this.webcam.restart && _this.webcam.restart();
  };

  this.getOutputVideoStreamTrack = function () {
    var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref8$frameRate = _ref8.frameRate,
        frameRate = _ref8$frameRate === undefined ? 25 : _ref8$frameRate;

    if (!_this.renderer) {
      return;
    }
    var oldStream = _this.stream;
    var canvas = _browserUtils2.default.isSafari() ? _this.source.streamCanvas : _this.renderer.domElement;
    _this.stream = canvas.captureStream(frameRate);
    var tracks = _this.stream.getTracks();
    _this.releaseStream(oldStream);
    if (tracks && tracks.length) {
      return {
        canvas: canvas,
        track: tracks[0]
      };
    }
  };

  this.releaseStream = function () {
    var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(stream) {
      var ts;
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (stream) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt('return');

            case 2:
              _context6.next = 4;
              return _browserUtils2.default.sleep(3000);

            case 4:
              ts = stream.getTracks();

              if (!(!ts || !ts.length)) {
                _context6.next = 7;
                break;
              }

              return _context6.abrupt('return');

            case 7:
              ts[0].stop();

            case 8:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, _this);
    }));

    return function (_x19) {
      return _ref9.apply(this, arguments);
    };
  }();

  this._beforeSourceInit = function () {
    var _ref10 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(source) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, t;

      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context7.prev = 3;
              _iterator = (0, _getIterator3.default)(_this.beforeSourceInitTasks);

            case 5:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context7.next = 12;
                break;
              }

              t = _step.value;
              _context7.next = 9;
              return t(source);

            case 9:
              _iteratorNormalCompletion = true;
              _context7.next = 5;
              break;

            case 12:
              _context7.next = 18;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7['catch'](3);
              _didIteratorError = true;
              _iteratorError = _context7.t0;

            case 18:
              _context7.prev = 18;
              _context7.prev = 19;

              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }

            case 21:
              _context7.prev = 21;

              if (!_didIteratorError) {
                _context7.next = 24;
                break;
              }

              throw _iteratorError;

            case 24:
              return _context7.finish(21);

            case 25:
              return _context7.finish(18);

            case 26:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
    }));

    return function (_x20) {
      return _ref10.apply(this, arguments);
    };
  }();

  this._afterSourceInit = function () {
    var _ref11 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(source) {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, t;

      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context8.prev = 3;
              _iterator2 = (0, _getIterator3.default)(_this.afterSourceInitTasks);

            case 5:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context8.next = 12;
                break;
              }

              t = _step2.value;
              _context8.next = 9;
              return t(source);

            case 9:
              _iteratorNormalCompletion2 = true;
              _context8.next = 5;
              break;

            case 12:
              _context8.next = 18;
              break;

            case 14:
              _context8.prev = 14;
              _context8.t0 = _context8['catch'](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context8.t0;

            case 18:
              _context8.prev = 18;
              _context8.prev = 19;

              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }

            case 21:
              _context8.prev = 21;

              if (!_didIteratorError2) {
                _context8.next = 24;
                break;
              }

              throw _iteratorError2;

            case 24:
              return _context8.finish(21);

            case 25:
              return _context8.finish(18);

            case 26:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
    }));

    return function (_x21) {
      return _ref11.apply(this, arguments);
    };
  }();

  this.pause = function () {
    var stopWebcam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return _this.source && _this.source.pause(stopWebcam);
  };

  this.resume = function (restartWebcam) {
    return _this.source && _this.source.resume(restartWebcam);
  };

  this.handleError = function (message, type) {
    console.log('error', message, type);
    _this.emitter.trigger(_events2.default.toastMessage, [message]);
    _this.close().then();
  };

  this.savePhoto = function (watermark) {
    _this.source.savePhotoFlag = true;
    setTimeout(function () {
      _fileUtils2.default.savePhoto(_this.source.blob, watermark, _this.document, _this.canvasId, _this.savePhotoId, _this.sourceType).then(function (result) {
        _this.emitter.trigger(_events2.default.savePhotoResult, [result]);
        _this.source.savePhotoFlag = false;
      });
    }, 100);
  };

  this.getBlobOrBase64 = function () {
    var _ref12 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(source) {
      var imageData;
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(source === 'after')) {
                _context9.next = 2;
                break;
              }

              return _context9.abrupt('return', _this.source.blob);

            case 2:
              _context9.next = 4;
              return _this.source.getImageData();

            case 4:
              imageData = _context9.sent;
              return _context9.abrupt('return', _mediaUtils2.default.imageData2Blob(imageData, imageData.width, imageData.height, imageData.width, imageData.height, _this.document));

            case 6:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, _this);
    }));

    return function (_x23) {
      return _ref12.apply(this, arguments);
    };
  }();

  this.saveCanvas = function () {
    var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'base64';
      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'after';
      var blobOrBase64;
      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _this.source.savePhotoFlag = true;
              _this.handleHeadlessSaveCanvas();
              _context10.next = 4;
              return _browserUtils2.default.sleep(100);

            case 4:
              _context10.next = 6;
              return _this.getBlobOrBase64(source);

            case 6:
              blobOrBase64 = _context10.sent;

              if (type === 'blob') {
                if (typeof blobOrBase64 === 'string') {
                  _this.emitter.trigger(_events2.default.saveCanvasComplete, [_fileUtils2.default.base64ToBlob(blobOrBase64)]);
                } else {
                  _this.emitter.trigger(_events2.default.saveCanvasComplete, [blobOrBase64]);
                }
              } else {
                if (typeof blobOrBase64 === 'string') {
                  _this.emitter.trigger(_events2.default.saveCanvasComplete, [blobOrBase64]);
                } else {
                  _fileUtils2.default.blobToBase64(blobOrBase64, function (r) {
                    return _this.emitter.trigger(_events2.default.saveCanvasComplete, [r]);
                  });
                }
              }
              _this.source.savePhotoFlag = false;

            case 9:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, _this);
    }));

    return function () {
      return _ref13.apply(this, arguments);
    };
  }();

  this.handleHeadlessSaveCanvas = function () {
    if (_this.settings && _this.settings.isHeadlessMode() && _this.settings.canvasInputType === 'image') {
      _this.source && _this.source.render();
    }
  };

  this.takePhoto = function (callback) {
    _this.source.savePhotoFlag = true;
    setTimeout(function () {
      callback(_this.source.blob);
      if (_this.source) {
        _this.source.savePhotoFlag = false;
      }
    }, 300);
  };

  this.close = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
    var resolve;
    return _regenerator2.default.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (!((0, _get3.default)(_this, 'source.type') === 'video')) {
              _context11.next = 4;
              break;
            }

            _this.source.terminalized = true;
            _context11.next = 4;
            return _browserUtils2.default.sleep();

          case 4:
            _this.releaseStream();
            _context11.next = 7;
            return (0, _lockmanager.getLockManager)().createPromise('controller-close');

          case 7:
            resolve = _context11.sent;
            _context11.prev = 8;

            if (_this.renderer && !_this.renderer.cached) {
              _this.renderer.setSize(1, 1);
              try {
                _this.renderer.forceContextLoss();
                _this.renderer.dispose();
                _this.renderer = null;
              } catch (err) {
                console.log({ err: err });
              }
            }

            if (!_this.source) {
              _context11.next = 19;
              break;
            }

            if ((0, _isFunction3.default)(_this.source.handleBeforeCloseTasks)) {
              _this.source.handleBeforeCloseTasks();
            }
            if (_this.source.faceTrackingManager) {
              if ((0, _isFunction3.default)(_this.source.faceTrackingManager.close)) {
                _this.source.faceTrackingManager.close();
              }
            }
            // ebug: WCM250120P0001, need to check if this.settings.isHeadlessMode() is needed
            if (_this.settings.isHeadlessMode()) {
              _this.closeFaceQualityChecker();
            }
            try {
              if (_this.source.handTrackingManager) {
                if ((0, _isFunction3.default)(_this.source.handTrackingManager.close)) {
                  _this.source.handTrackingManager.close();
                }
              }
            } catch (err) {
              console.log(err);
            }
            _this.allUpdaters && _this.allUpdaters.map(function (u) {
              return u.clean && u.clean();
            });
            _context11.next = 18;
            return _this.source.freeResources();

          case 18:
            _this.source = null;

          case 19:
            if (_this.makeup_live_filter) {
              try {
                (0, _isFunction3.default)(_this.makeup_live_filter.Destroy) && _this.makeup_live_filter.Destroy();
              } catch (err) {
                console.log(err);
              }
              try {
                (0, _isFunction3.default)(_this.makeup_live_filter.disposeFilters) && _this.makeup_live_filter.disposeFilters();
              } catch (err) {
                console.log(err);
              }
              _this.makeup_live_filter = null;
            }
            delete _this.YMKModule;
            _this.YMKModule = null;

          case 22:
            _context11.prev = 22;

            resolve && resolve();
            return _context11.finish(22);

          case 25:
          case 'end':
            return _context11.stop();
        }
      }
    }, _callee11, _this, [[8,, 22, 25]]);
  }));

  this.isReadyToApply = function () {
    if (!_this.source) {
      return false;
    }
    if (_this.source.hasFace && _this.source.type === 'image') {
      // for photo mode
      return true;
    }
    // for live mode
    return !!_this.source.isLoadEngineCompleteTriggered;
  };

  this.calDeltaE = function (rgb1, rgb2) {
    return _this.source && _this.source.calDeltaE(rgb1, rgb2);
  };

  this.zoom = function (zoomLevel) {
    return _this.source && _this.source.zoom(zoomLevel);
  };

  this.record = function (fps) {
    var ms2Record = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
    var type = arguments[2];
    return _this.source && (0, _isFunction3.default)(_this.source.record) && _this.source.record(fps, ms2Record, type);
  };

  this.isLoaded = function () {
    return _this.source && _this.source.loaded;
  };

  this.getLandmarks = function (size) {
    var r = _this.source.getLandmarks(size);
    _this.emitter.trigger(_events2.default.retrieveLandmarksComplete, [r]);
    return r;
  };

  this._getFaceRect = function (size) {
    if (!_this.source) {
      return {
        top: 0,
        bottom: _this.display_height || _this.camera_height,
        left: 0,
        right: _this.display_width || _this.camera_width
      };
    }
    return _this.source.getFaceRect(size);
  };

  this.getFaceRect = function (size) {
    var faceRect = _this._getFaceRect(size);
    _this.emitter.trigger(_events2.default.getFaceRectComplete, [faceRect]);
    return faceRect;
  };

  this.getShadeFinderModeVersion = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.getShadeFinderModeVersion)) {
      return _this.source.getShadeFinderModeVersion();
    }
  };

  this.beginShadeFinder = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.beginShadeFinder)) {
      _this.source.beginShadeFinder();
    }
  };

  this.cancelShadeFinder = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.cancelShadeFinder)) {
      _this.source.cancelShadeFinder();
    }
  };

  this.resetShadeFinder = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.resetShadeFinder)) {
      _this.source.resetShadeFinder();
    }
  };

  this.openFaceQualityChecker = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.openFaceQualityChecker)) {
      _this.source.openFaceQualityChecker();
    }
  };

  this.closeFaceQualityChecker = function () {
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.closeFaceQualityChecker)) {
      _this.source.closeFaceQualityChecker();
    }
  };

  this.predictFaceAttribute = function () {
    return _this.source && _this.source.predictFaceAttribute();
  };

  this.handleShadeFinderFaceQualityCheckerInitialization = function () {
    var _ref15 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(source) {
      return _regenerator2.default.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (!(_this.settings.getFunctionType() !== _functionTypes2.default.shadefinder)) {
                _context12.next = 2;
                break;
              }

              return _context12.abrupt('return');

            case 2:
              // if (_get(this.settings, 'features.foundationOnly', false)) {
              source.faceQualityChecker = new _facequalitychecker4shadefinder2.default(_this.YMKModule, _this.source, _this.emitter);
              // } else {
              //   source.faceQualityChecker = new FaceQualityChecker(this.settings, this.emitter);
              // }
              _this.emitter.once(_events2.default.shadeFindStarted, function () {
                if (source.faceTrackingManager) {
                  source.faceTrackingManager.resume();
                }
              });
              if (source.faceTrackingManager && source.type !== 'image') {
                source.faceTrackingManager.pause();
              }
              if (_this.settings.isHeadlessMode()) {
                _this.emitter.once(_events2.default.shadeFindComplete, function () {
                  _this.closeFaceQualityChecker();
                });
              }

            case 6:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee12, _this);
    }));

    return function (_x27) {
      return _ref15.apply(this, arguments);
    };
  }();

  this.handleShadeFinderInitialization = function () {
    var _ref16 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13(source) {
      return _regenerator2.default.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (!(_this.settings.getFunctionType() !== _functionTypes2.default.shadefinder)) {
                _context13.next = 2;
                break;
              }

              return _context13.abrupt('return');

            case 2:
              source.shadefinder = new _shadefinder2.default({ settings: _this.settings, emitter: _this.emitter });

              if (!(_this.source.type === 'image')) {
                _context13.next = 9;
                break;
              }

              source.shadefinder.beginShadeFinder();
              _context13.next = 7;
              return _browserUtils2.default.sleep();

            case 7:
              _context13.next = 13;
              break;

            case 9:
              _context13.next = 11;
              return _browserUtils2.default.sleep();

            case 11:
              _context13.next = 13;
              return source.shadefinder.beginShadeFinder();

            case 13:
            case 'end':
              return _context13.stop();
          }
        }
      }, _callee13, _this);
    }));

    return function (_x28) {
      return _ref16.apply(this, arguments);
    };
  }();

  this.handleFaceAttributeInitialization = function () {
    var _ref17 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(source) {
      return _regenerator2.default.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (!(_this.settings.getFunctionType() !== _functionTypes2.default.faceattribute)) {
                _context14.next = 2;
                break;
              }

              return _context14.abrupt('return');

            case 2:
              source.faceaiattribute = new _faceaiattribute2.default(_this.settings, _this.emitter, _this.document, source);
              if (_this.settings.enableEyewearAutoPD) {
                source.faceQualityChecker = new _facequalitychecker4autopd2.default(_this.YMKModule, _this.source, _this.emitter, _this.settings);
              } else {
                source.faceQualityChecker = new _facequalitychecker2.default(_this.settings, _this.emitter, _this.tfjs);
              }
              if ((0, _get3.default)(_this.settings, 'faceAttributeFeatures.color')) {
                source.shadefinder = new _shadefinder2.default({ settings: _this.settings, emitter: _this.emitter, triggerEvents: false });
              }

            case 5:
            case 'end':
              return _context14.stop();
          }
        }
      }, _callee14, _this);
    }));

    return function (_x29) {
      return _ref17.apply(this, arguments);
    };
  }();

  this.handleEyewearAutoPDInitialization = function () {
    var _ref18 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(source) {
      return _regenerator2.default.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (!(_this.settings.getFunctionType() !== _functionTypes2.default.makeup && _this.settings.getFunctionType() !== _functionTypes2.default.livestream)) {
                _context15.next = 2;
                break;
              }

              return _context15.abrupt('return');

            case 2:
              if (_this.settings.enableEyewearAutoPD) {
                _context15.next = 4;
                break;
              }

              return _context15.abrupt('return');

            case 4:
              source.faceQualityChecker = new _facequalitychecker4autopd2.default(_this.YMKModule, _this.source, _this.emitter, _this.settings);

            case 5:
            case 'end':
              return _context15.stop();
          }
        }
      }, _callee15, _this);
    }));

    return function (_x30) {
      return _ref18.apply(this, arguments);
    };
  }();

  this.handleRingAutoSizerInitialization = function () {
    var _ref19 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(source) {
      return _regenerator2.default.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (_this.settings.isRing()) {
                _context16.next = 2;
                break;
              }

              return _context16.abrupt('return');

            case 2:
              if (_this.settings.isAutoRingSizerEnabled()) {
                _context16.next = 4;
                break;
              }

              return _context16.abrupt('return');

            case 4:
              source.faceQualityChecker = new _facequalitychecker4ringautosizer2.default(_this.YMKModule, _this.source, _this.emitter);

            case 5:
            case 'end':
              return _context16.stop();
          }
        }
      }, _callee16, _this);
    }));

    return function (_x31) {
      return _ref19.apply(this, arguments);
    };
  }();

  this.analyzeSkin = function () {
    return _this.source && (0, _isFunction3.default)(_this.source.analyzeSkin) && _this.source.analyzeSkin();
  };

  this.changeEyewearPD = function () {
    return _this.source && (0, _isFunction3.default)(_this.source.changeEyewearPD) && _this.source.changeEyewearPD();
  };

  this.applyEmulation = function () {};

  this.getFrameDocument = function (document, frameId) {
    var frame = document.getElementById(frameId);
    return frame.contentDocument || frame.contentWindow.document;
  };

  this.updateSkinSmooth = function () {
    if (!_this.source) {
      return;
    }
    if (!(0, _isFunction3.default)(_this.source.updateSkinSmooth)) {
      return;
    }
    _this.source.updateSkinSmooth();
  };

  this.setDebugOccluder = function () {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return _this.makeup_live_filter && (0, _isFunction3.default)(_this.makeup_live_filter.SetObject3DShowOccluder) && _this.makeup_live_filter.SetObject3DShowOccluder(enabled);
  };

  this.setBackgroundColor = function (color) {
    if (_this.settings.getFunctionType() !== _functionTypes2.default.pbrviewer && !_this.settings.isFunctionTypeMakeupViewer()) {
      return;
    }
    if (!_this.source) {
      return;
    }
    if ((0, _isFunction3.default)(_this.source.setBackgroundColor)) {
      _this.source.setBackgroundColor(color);
    }
  };

  this.setTfjs = function (tfjs) {
    return _this.tfjs = tfjs;
  };

  this.handleMouseDown = function (drag) {
    if (!_this.source) {
      return;
    }
    if (!(0, _isFunction3.default)(_this.source.handleMouseDown)) {
      return;
    }
    _this.source.handleMouseDown(drag);
  };

  this.handleMouseUp = function (drag) {
    if (!_this.source) {
      return;
    }
    if (!(0, _isFunction3.default)(_this.source.handleMouseUp)) {
      return;
    }
    _this.source.handleMouseUp(drag);
  };

  this.handleMouseMove = function (dxRate, dyRate) {
    if (!_this.source) {
      return;
    }
    if (!(0, _isFunction3.default)(_this.source.handleMouseMove)) {
      return;
    }
    _this.source.handleMouseMove(dxRate, dyRate);
  };

  this.handleMouseWheel = function (up) {
    if (!_this.source) {
      return;
    }
    if (!(0, _isFunction3.default)(_this.source.handleMouseWheel)) {
      return;
    }
    _this.source.handleMouseWheel(up);
  };
}, _temp);
exports.default = AbstractController;
module.exports = exports['default'];

/***/ }),

/***/ 839:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _slice2 = __webpack_require__(310);

var _slice3 = _interopRequireDefault(_slice2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialResult = { face_quality: false, face_rect_data: false, face_align_data: false, face_check_result: false };

var FaceQualityChecker = function FaceQualityChecker(settings, emitter, tfjs) {
  var _this = this;

  (0, _classCallCheck3.default)(this, FaceQualityChecker);
  this.open = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    var Controller;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!_this.opened) {
              _context.next = 2;
              break;
            }

            return _context.abrupt('return');

          case 2:
            _this.opened = true;
            _this.lastQualifieds = [];
            _context.next = 6;
            return __webpack_require__.e/* import() */(188).then(__webpack_require__.bind(null, 1014));

          case 6:
            Controller = _context.sent;

            _this.loaded = false;
            _this.controller = new Controller({
              settings: _this.settings,
              emitter: _this.emitter,
              isShadeFinder: _this.settings.functionType === _functionTypes2.default.shadefinder,
              isFaceAttribute: _this.settings.functionType === _functionTypes2.default.faceattribute,
              onLoad: function onLoad() {
                _this.loaded = true;
                _this.loadResolve && _this.loadResolve();
              },
              tfjs: _this.tfjs
            });

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.close = function () {
    _this.opened = false;
    _this.loaded = false;
    if (!_this.controller) {
      return;
    }
    setTimeout(function () {
      _this.controller && _this.controller.close();
      _this.controller = null;
      _this.lastQualified = {};
    });
  };

  this.warmUp = function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(imageData) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this.loadPromise;

            case 2:
              _context2.next = 4;
              return _this.controller.checkFaceQuality(imageData);

            case 4:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.checkFaceQuality = function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(imageData) {
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (_this.loaded) {
                _context3.next = 3;
                break;
              }

              _this.result = initialResult;
              return _context3.abrupt('return', _this.result);

            case 3:
              _context3.t0 = _this;
              _context3.next = 6;
              return _this.controller.checkFaceQuality(imageData);

            case 6:
              _context3.t1 = _context3.sent;
              _this.result = _context3.t0._adjustAngleIfNecessary.call(_context3.t0, _context3.t1);

              _this._setLastQualified(_this.result, imageData);
              return _context3.abrupt('return', _this.result);

            case 10:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x2) {
      return _ref3.apply(this, arguments);
    };
  }();

  this._adjustAngleIfNecessary = function (result) {
    if (_this.settings.secondaryFunctionType === _functionTypes2.default.makeup) {
      return result;
    }
    var faceangle = (0, _get3.default)(result, 'face_quality.faceangle');
    if (faceangle === 'leftward') {
      faceangle = 'rightward';
    } else if (faceangle === 'rightward') {
      faceangle = 'leftward';
    }
    return (0, _extends3.default)({}, result, {
      face_quality: (0, _extends3.default)({}, result.face_quality, {
        faceangle: faceangle
      })
    });
  };

  this._setLastQualified = function (result, imageData) {
    if (!imageData || !result) {
      return;
    }
    if (!(0, _get3.default)(result, 'face_quality.hasFace', false)) {
      return;
    }
    var lq = {
      result: result,
      imageData: imageData
    };
    _this.lastQualified = lq;
    _this.lastQualifieds.unshift(lq);
    _this.lastQualifieds = (0, _slice3.default)(_this.lastQualifieds, 0, 5);
  };

  this.getLastQualified = function () {
    return _this.lastQualified;
  };

  this.getLastQualifieds = function () {
    return _this.lastQualifieds;
  };

  this.settings = settings;
  this.emitter = emitter;
  this.tfjs = tfjs;
  this.controller = null;
  this.loaded = false;
  this.opened = false;
  this.result = initialResult;
  this.lastQualified = {};
  this.lastQualifieds = [];
  this.loadPromise = new _promise2.default(function (resolve) {
    return _this.loadResolve = resolve;
  });
  this.open().then();
};

exports.default = FaceQualityChecker;
module.exports = exports['default'];

/***/ }),

/***/ 840:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _slice2 = __webpack_require__(310);

var _slice3 = _interopRequireDefault(_slice2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialResult = { face_quality: false, face_rect_data: false, face_align_data: false, face_check_result: false };
var FACE_THRESHOLD = 10;
var PD_THRESHOLD = 5;

var FaceQualityChecker4AutoPD = function FaceQualityChecker4AutoPD(YMKModule, source, emitter, settings) {
  var _this = this;

  (0, _classCallCheck3.default)(this, FaceQualityChecker4AutoPD);

  this.open = function () {
    _this.pds = 0;
    _this.opened = true;
    _this.lastQualifieds = [];
    _this.venus_makeup_live.EnableCheckForEstimatingPD(true);
  };

  this.close = function () {
    _this.opened = false;
    _this.lastQualified = {};
    _this.venus_makeup_live.EnableCheckForEstimatingPD(false);
  };

  this.warmUp = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.checkFaceQuality = function (imageData) {
    if (!_this.opened) {
      return;
    }
    _this.result = (0, _extends3.default)({}, _this._checkFaceQuality());
    if (_this.isFaceQualityQualified(_this.result)) {
      _this.faces++;
      if (_this.faces === FACE_THRESHOLD) {
        _this.venus_makeup_live.RestartEstimatingPupilDistance(0);
      }
      if (_this.faces > FACE_THRESHOLD) {
        _this.venus_makeup_live.GetEstimatedPupilDistance(0, _this.estimatedPDInfo);
        _this.handlePDEstimation(_this.estimatedPDInfo);
      }
    } else {
      _this.faces = 0;
    }
    _this._setLastQualified(_this.result, imageData);
    return _this.result;
  };

  this.isPDEstimationQualified = function (r) {
    if (!r.is_success) {
      return false;
    }
    if (r.is_success) {
      _this.pds++;
    }
    return _this.pds > PD_THRESHOLD;
  };

  this.handlePDEstimation = function (r) {
    if (!_this.isPDEstimationQualified(r)) {
      return;
    }
    _this.emitter.trigger(_events2.default.eyewearPDEstimated, [{
      pd: (0, _toInteger3.default)(r.pd)
    }]);
  };

  this.isFaceQualityQualified = function (result) {
    var fq = result.face_quality;
    return fq.area === 'good' && (fq.lighting === 'good' || fq.lighting === 'ok') && fq.frontal === 'good' && fq.nakedeye === 'good';
  };

  this._checkFaceQuality = function () {
    _this.venus_makeup_live.GetEstimatingPDCheckResult(_this.estimatingPDCheckResult);
    if (_this.settings.isFaceAttribute()) {
      _this.venus_makeup_live.GetShadeFinderCheckResult(_this.shadefinderCheckResult);
    }

    return {
      face_quality: _mediaUtils2.default.getFaceQuality(_this._mergeResults(_this.estimatingPDCheckResult, _this.shadefinderCheckResult), _this.temp_bool.get(0), _this.settings.isFaceAttribute(), _this.settings.isFacialRatioEnabled, _this.settings.isFaceAttribute()),
      face_rect_data: _this.source.face_rect_data,
      face_align_data: _this.flipHorizontal(_this.source.face_align_data_vec.get(0)),
      face_check_result: _this.toPlainShadeFinderCheckResult(_this.shadefinderCheckResult)
    };
  };

  this._mergeResults = function (r1, r2) {
    return {
      m_face_area_quality: {
        value: r1 && r1.m_face_area_quality.value
      },
      m_naked_eye_quality: {
        value: r1 && r1.m_naked_eye_quality.value
      },
      m_lighting_quality: {
        value: r1 && r1.m_lighting_quality.value
      },
      m_face_frontal_quality: {
        value: r1 && r1.m_face_frontal_quality.value
      },
      m_pitch: r2 && r2.m_pitch,
      m_roll: r2 && r2.m_roll,
      m_yaw: r2 && r2.m_yaw
    };
  };

  this.flipHorizontal = function (face_align_data) {
    if (!face_align_data || !face_align_data.points) {
      return face_align_data;
    }
    return {
      points: face_align_data.points.map(function (p) {
        return {
          x: 1 - p.x,
          y: p.y
        };
      })
    };
  };

  this.toPlainShadeFinderCheckResult = function (native) {
    return {
      face_area: native.m_face_area_quality.value,
      face_frontal: native.m_face_frontal_quality.value,
      lighting: native.m_lighting_quality.value,
      naked_eye: native.m_naked_eye_quality.value,
      white_level: native.m_white_level,
      black_level: native.m_black_level,
      lighting_ratio: native.m_lighting_ratio
    };
  };

  this._setLastQualified = function (result, imageData) {
    if (!imageData || !result) {
      return;
    }
    if (!(0, _get3.default)(result, 'face_quality.hasFace', false)) {
      return;
    }
    var lq = {
      result: result,
      imageData: imageData
    };
    _this.lastQualified = lq;
    _this.lastQualifieds.unshift(lq);
    _this.lastQualifieds = (0, _slice3.default)(_this.lastQualifieds, 0, 5);
  };

  this.getLastQualified = function () {
    return _this.lastQualified;
  };

  this.getLastQualifieds = function () {
    return _this.lastQualifieds;
  };

  this.YMKModule = YMKModule;
  this.source = source;
  this.settings = settings;
  this.estimatingPDCheckResult = source.estimatingPDCheckResult;
  this.shadefinderCheckResult = source.shadefinderCheckResult;
  this.estimatedPDInfo = source.estimatedPDInfo;
  this.venus_makeup_live = source.venus_makeup_live;
  this.temp_bool = source.temp_bool;
  this.result = initialResult;
  this.emitter = emitter;
  this.lastQualified = {};
  this.lastQualifieds = [];
  this.pds = 0;
  this.faces = 0;
  this.opened = false;
};

exports.default = FaceQualityChecker4AutoPD;
module.exports = exports['default'];

/***/ }),

/***/ 841:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialResult = { face_quality: false, face_rect_data: false, face_align_data: false, face_check_result: false };

var FacequalityChecker4ShadeFinder = function FacequalityChecker4ShadeFinder(YMKModule, source, emitter) {
  var _this = this;

  (0, _classCallCheck3.default)(this, FacequalityChecker4ShadeFinder);

  this.open = function () {
    _this.pds = 0;
    _this.opened = true;
    _this.venus_makeup_live.EnableCheckForShadeFinder(true);
  };

  this.close = function () {
    _this.opened = false;
    _this.lastQualified = {};
    _this.venus_makeup_live.EnableCheckForShadeFinder(false);
  };

  this.warmUp = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.checkFaceQuality = function (imageData) {
    if (!_this.opened) {
      return;
    }
    _this.result = (0, _extends3.default)({}, _this._checkFaceQuality());
    _this._setLastQualified(_this.result, imageData);
    return _this.result;
  };

  this._checkFaceQuality = function () {
    _this.venus_makeup_live.GetShadeFinderCheckResult(_this.shadefinderCheckResult);
    return {
      face_quality: _mediaUtils2.default.getFaceQuality(_this.shadefinderCheckResult, !!_this.temp_bool.get(0), false, false, false, _functionTypes2.default.shadefinder),
      face_rect_data: _this.source.face_rect_data,
      face_align_data: _this.flipHorizontal(_this.source.face_align_data_vec.get(0)),
      face_check_result: _this.toPlainShadeFinderCheckResult(_this.shadefinderCheckResult)
    };
  };

  this.flipHorizontal = function (face_align_data) {
    if (!face_align_data || !face_align_data.points) {
      return face_align_data;
    }
    return {
      points: face_align_data.points.map(function (p) {
        return {
          x: 1 - p.x,
          y: p.y
        };
      })
    };
  };

  this.toPlainShadeFinderCheckResult = function (native) {
    return {
      face_area: native.m_face_area_quality.value,
      face_frontal: native.m_face_frontal_quality.value,
      lighting: native.m_lighting_quality.value,
      naked_eye: native.m_naked_eye_quality.value,
      white_level: native.m_white_level,
      black_level: native.m_black_level,
      lighting_ratio: native.m_lighting_ratio
    };
  };

  this._setLastQualified = function (result, imageData) {
    if (!imageData || !result) {
      return;
    }
    if (!(0, _get3.default)(result, 'face_quality.hasFace', false)) {
      return;
    }
    _this.lastQualified = {
      result: result,
      imageData: imageData
    };
  };

  this.getLastQualified = function () {
    return _this.lastQualified;
  };

  this.YMKModule = YMKModule;
  this.shadefinderCheckResult = source.shadefinderCheckResult;
  this.venus_makeup_live = source.venus_makeup_live;
  this.temp_bool = source.temp_bool;
  this.source = source;
  this.result = initialResult;
  this.emitter = emitter;
  this.lastQualified = {};
  this.faces = 0;
  this.opened = false;
};

exports.default = FacequalityChecker4ShadeFinder;
module.exports = exports['default'];

/***/ }),

/***/ 842:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _isNumber2 = __webpack_require__(136);

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _round2 = __webpack_require__(186);

var _round3 = _interopRequireDefault(_round2);

var _tfjsloader = __webpack_require__(193);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IS_COMPARING = false;
var IS_RESET_TRACKING = false;
var IS_CAMERA_FRONT = true;
var IS_PHOT_MODE = false;
var FACE_THRESHOLD = 10;
var PD_THRESHOLD = 5;
var MIRRORED_EYE_FOR_NAKED_EYE = false;
var FACE_TRACKING_MANAGER = void 0;
var MAX_QUEUE_SIZE = 30;

var FaceQualityChecker4RingAutoSizer = function FaceQualityChecker4RingAutoSizer(YMKModule, source, emitter) {
  var _this = this;

  (0, _classCallCheck3.default)(this, FaceQualityChecker4RingAutoSizer);
  this.open = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    var FaceTrackingManager, tfjs, cropBufferSize;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _this.pds = 0;

            if (FACE_TRACKING_MANAGER) {
              _context.next = 11;
              break;
            }

            _context.next = 4;
            return __webpack_require__.e/* import() */(105).then(__webpack_require__.bind(null, 1024));

          case 4:
            FaceTrackingManager = _context.sent;
            tfjs = (0, _tfjsloader.getTfjsLoader)();
            _context.next = 8;
            return tfjs.load();

          case 8:
            FACE_TRACKING_MANAGER = new FaceTrackingManager(tfjs);
            _context.next = 11;
            return FACE_TRACKING_MANAGER.init();

          case 11:
            _this.temp_float = new _this.YMKModule.FloatObject();
            _this.estimatedRingSize = new _this.YMKModule.FloatObject();
            _this.estimatedRingSizeRefine = new _this.YMKModule.FloatObject();
            _this.faceTrackingManager = FACE_TRACKING_MANAGER;
            _this.faceTrackingManager.setVenusMakeupLive(_this.venus_makeup_live);
            _this.ring_size_queue = _this.YMKModule.CreateVector_float(MAX_QUEUE_SIZE);
            _this.ring_size_queue_refine = _this.YMKModule.CreateVector_float(MAX_QUEUE_SIZE);
            _this.estimatingPDCheckResult = new _this.YMKModule.EstimatingPDCheckResult();
            _this.estimatedPDInfo = new _this.YMKModule.VN_EstimatedPDInfo();
            if (!!_this.venus_crop_buffer) {
              _this.YMKModule._free(_this.venus_crop_buffer);
              _this.web_crop_buffer = null;
            }
            if (!_this.makeup_metadata_array) {
              _this.makeup_metadata_array = _this.YMKModule.CreateVector_WebMakeupMetadata(_this.YMKModule.MAX_DETECTED_FACE_COUNT);
            }
            if (!_this.frame_information_array) {
              _this.frame_information_array = _this.YMKModule.CreateVector_WebFrameInformation(_this.YMKModule.MAX_DETECTED_FACE_COUNT);
              _this.frame_information0 = new _this.YMKModule.WebFrameInformation();
              _this.frame_information1 = new _this.YMKModule.WebFrameInformation();
              _this.frame_information_array.set(0, _this.frame_information0);
              _this.frame_information_array.set(1, _this.frame_information1);
            }
            cropBufferSize = _this.faceTrackingManager.getCropBufferSize();

            _this.venus_crop_buffer = _this.YMKModule._malloc(cropBufferSize);
            _this.web_crop_buffer = new Uint8Array(_this.YMKModule.HEAPU8.buffer, _this.venus_crop_buffer, cropBufferSize);
            _this.venus_makeup_live.EnableCheckForEstimatingPD(true);
            _this.venus_makeup_live.RestartEstimatingPupilDistance(0);
            _this.venus_makeup_live.ResetNailDetectionSmooth();
            _this.venus_makeup_live.ResetRingProcessStatus();
            _this.venus_makeup_live.ResetEstimatedRingSize();
            _this.estimatedRingSize.value = 0.0;
            _this.estimatedRingSizeRefine.value = 0.0;
            _this.faces = 0;
            _this.opened = true;

          case 35:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.close = function () {
    _this.opened = false;
    _this.lastQualified = {};
    _this.venus_makeup_live.EnableCheckForEstimatingPD(false);
    _this.venus_makeup_live.ResetNailDetectionSmooth();
    _this.venus_makeup_live.ResetRingProcessStatus();
    _this.venus_makeup_live.ResetEstimatedRingSize();
    if (!!_this.temp_float) {
      _this.temp_float.delete();
      _this.temp_float = null;
    }
    if (!!_this.estimatedRingSize) {
      _this.estimatedRingSize.delete();
      _this.estimatedRingSize = null;
    }
    if (!!_this.estimatedRingSizeRefine) {
      _this.estimatedRingSizeRefine.delete();
      _this.estimatedRingSizeRefine = null;
    }
    if (!!_this.ring_size_queue) {
      _this.ring_size_queue.delete();
      _this.ring_size_queue = null;
    }
    if (!!_this.ring_size_queue_refine) {
      _this.ring_size_queue_refine.delete();
      _this.ring_size_queue_refine = null;
    }
    if (!!_this.estimatingPDCheckResult) {
      _this.estimatingPDCheckResult.delete();
      _this.estimatingPDCheckResult = null;
    }
    if (!!_this.estimatedPDInfo) {
      _this.estimatedPDInfo.delete();
      _this.estimatedPDInfo = null;
    }
  };

  this.cleanUp = function () {
    if (!!_this.temp_float) {
      _this.temp_float.delete();
      _this.temp_float = null;
    }
    if (!!_this.estimatedRingSize) {
      _this.estimatedRingSize.delete();
      _this.estimatedRingSize = null;
    }
    if (!!_this.estimatedRingSizeRefine) {
      _this.estimatedRingSizeRefine.delete();
      _this.estimatedRingSizeRefine = null;
    }
    if (!!_this.estimatingPDCheckResult) {
      _this.YMKModule._free(_this.estimatingPDCheckResult);
      _this.estimatingPDCheckResult = null;
    }
    if (!!_this.estimatedPDInfo) {
      _this.YMKModule._free(_this.estimatedPDInfo);
      _this.estimatedPDInfo = null;
    }
    if (!!_this.venus_crop_buffer) {
      _this.YMKModule._free(_this.venus_crop_buffer);
      _this.web_crop_buffer = null;
    }
    if (!_this.makeup_metadata_array) {
      _this.makeup_metadata_array = _this.YMKModule.CreateVector_WebMakeupMetadata(_this.YMKModule.MAX_DETECTED_FACE_COUNT);
    }
    if (!!_this.frame_information0) {
      _this.frame_information0.delete();
      _this.frame_information0 = null;
    }
    if (!!_this.frame_information1) {
      _this.frame_information1.delete();
      _this.frame_information1 = null;
    }
    if (!!_this.frame_information_array) {
      _this.frame_information_array.delete();
      _this.frame_information_array = null;
    }
    if (!!_this.makeup_metadata_array) {
      _this.makeup_metadata_array.delete();
      _this.makeup_metadata_array = null;
    }
    if (!!_this.venus_crop_buffer) {
      _this.YMKModule._free(_this.venus_crop_buffer);
      _this.venus_crop_buffer = null;
      _this.web_crop_buffer = null;
    }
    if (_this.ring_size_queue) {
      _this.ring_size_queue.delete();
      _this.ring_size_queue = null;
    }
    if (_this.ring_size_queue_refine) {
      _this.ring_size_queue_refine.delete();
      _this.ring_size_queue_refine = null;
    }
    if (_this.estimatingPDCheckResult) {
      _this.estimatingPDCheckResult.delete();
      _this.estimatingPDCheckResult = null;
    }
    if (_this.estimatedPDInfo) {
      _this.estimatedPDInfo.delete();
      _this.estimatedPDInfo = null;
    }
  };

  this.warmUp = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  this.checkFaceQuality = function () {
    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(imageData) {
      var bool_array, is_metadata_valid, is_palm_detected, is_finger_opened, is_need_hand_roll_more, is_need_hand_roll_less;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (_this.opened) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return');

            case 2:
              _context3.next = 4;
              return _this.faceTrackingManager.doTracking(_this.source.venus_frame_buffer, _this.source.web_frame_buffer, _this.venus_crop_buffer, _this.web_crop_buffer, _this.source.camera_width, _this.source.camera_height, false);

            case 4:

              _this.venus_makeup_live.TrackFrameRGBA(_this.source.venus_frame_buffer, _this.source.camera_width, _this.source.camera_height, _this.source.camera_width * 4, 0, IS_CAMERA_FRONT, IS_PHOT_MODE, IS_RESET_TRACKING, IS_COMPARING);
              bool_array = _this.YMKModule.CreateVector_BOOL(_this.YMKModule.MAX_DETECTED_FACE_COUNT, false);

              _this.venus_makeup_live.GetWebMakeupMetadata(bool_array, _this.makeup_metadata_array, _this.frame_information_array, _this.YMKModule.MAX_DETECTED_FACE_COUNT);
              is_metadata_valid = bool_array.get(0);

              bool_array.delete();
              _this.venus_makeup_live.SetRingRefinedByHandMaskEnable(true);
              _this.venus_makeup_live.SetWristRefinedByHandMaskEnable(false);
              _this.venus_makeup_live.SetMaxDetectedFaceNumber(1);
              _this.venus_makeup_live.EnableCheckForEstimatingPD(true);
              _this.venus_makeup_live.SetIsMirroredEyeForNakedEye(MIRRORED_EYE_FOR_NAKED_EYE);
              _this.venus_makeup_live.GetHandPoseRollValueForRingSize(_this.temp_float);
              _this.result = (0, _extends3.default)({}, _this._checkFaceQuality(is_metadata_valid, _this.temp_float.value));
              if (_this.source.hand_ar_metadata.is_palm_detected) {
                _this.venus_makeup_live.StoreEstimatedRingSize(_this.source.hand_ar_metadata.ring_finger_circles);
                _this.venus_makeup_live.RecordEstimatedRingSize(_this.ring_size_queue);

                _this.venus_makeup_live.StoreEstimatedRingSizeRefine(_this.source.hand_ar_metadata.ring_finger_patch_boundary_points);
                _this.venus_makeup_live.RecordEstimatedRingSizeRefine(_this.ring_size_queue_refine);

                _this.venus_makeup_live.GetEstimatedRingSize(_this.estimatedRingSize, _this.estimatedPDInfo, _this.source.hand_ar_metadata.frame_width, _this.source.hand_ar_metadata.frame_height, _this.source.hand_ar_metadata.ring_finger_circles);

                _this.venus_makeup_live.GetEstimatedRingSizeRefine(_this.estimatedRingSizeRefine, _this.estimatedPDInfo, _this.source.hand_ar_metadata.frame_width, _this.source.hand_ar_metadata.frame_height, _this.source.hand_ar_metadata.ring_finger_patch_boundary_points);
                is_palm_detected = _this.source.hand_ar_metadata.is_palm_detected;
                is_finger_opened = _this.venus_makeup_live.GetIsFingerOpenedByNailDetection() == 0;
                is_need_hand_roll_more = _this.venus_makeup_live.IsHandPoseValidForRingSize() != 0 && _this.venus_makeup_live.IsNeedHandPoseRollMoreForRingSize() == 0;
                is_need_hand_roll_less = _this.venus_makeup_live.IsHandPoseValidForRingSize() != 0 && _this.venus_makeup_live.IsNeedHandPoseRollLessForRingSize() == 0;

                _this.result = (0, _extends3.default)({}, _this.result, {
                  face_quality: (0, _extends3.default)({}, _this.result.face_quality, { is_palm_detected: is_palm_detected, is_finger_opened: is_finger_opened, is_need_hand_roll_more: is_need_hand_roll_more, is_need_hand_roll_less: is_need_hand_roll_less })
                });
                _this.handleEstimation({ ringSize: _this.estimatedRingSizeRefine.value || _this.estimatedRingSize.value });
              }
              if (_this.isFaceQualityQualified(_this.result)) {
                _this.faces++;
                if (_this.faces === FACE_THRESHOLD) {
                  _this.venus_makeup_live.RestartEstimatingPupilDistance(0);
                }
                if (_this.faces > FACE_THRESHOLD) {
                  _this.venus_makeup_live.GetEstimatedPupilDistance(0, _this.estimatedPDInfo);
                  _this.handlePDEstimation(_this.estimatedPDInfo);
                }
              } else {
                _this.faces = 0;
              }
              _this._setLastQualified(_this.result, imageData);
              return _context3.abrupt('return', _this.result);

            case 20:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  this.isPDEstimationQualified = function (r) {
    if (!r.is_success) {
      return false;
    }
    if (r.is_success) {
      _this.pds++;
    }
    return _this.pds > PD_THRESHOLD;
  };

  this.handlePDEstimation = function (r) {
    if (!_this.isPDEstimationQualified(r)) {
      return;
    }
    _this.emitter.trigger(_events2.default.eyewearPDEstimated, [{
      pd: (0, _toInteger3.default)(r.pd)
    }]);
  };

  this.isEstimationQualified = function () {
    var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return r.ringSize && (0, _isNumber3.default)(r.ringSize);
  };

  this.handleEstimation = function (r) {
    return _this.isEstimationQualified(r) && _this.emitter.trigger(_events2.default.ringSizeEstimated, [{
      ringSize: (0, _round3.default)((0, _get3.default)(r, 'ringSize', 0), 2)
    }]);
  };

  this.isFaceQualityQualified = function (result) {
    var fq = result.face_quality;
    return fq.area === 'good' && (fq.lighting === 'good' || fq.lighting === 'ok') && fq.frontal === 'good' && fq.nakedeye === 'good';
  };

  this._checkFaceQuality = function (hasFace, roll) {
    _this.venus_makeup_live.GetEstimatingPDCheckResult(_this.estimatingPDCheckResult);
    return {
      face_quality: (0, _extends3.default)({}, _mediaUtils2.default.getFaceQuality(_this.estimatingPDCheckResult, hasFace), { roll: roll })
    };
  };

  this._setLastQualified = function (result, imageData) {
    if (!imageData || !result) {
      return;
    }
    if (!(0, _get3.default)(result, 'face_quality.hasFace', false)) {
      return;
    }
    _this.lastQualified = {
      result: result,
      imageData: imageData
    };
  };

  this.getLastQualified = function () {
    return _this.lastQualified;
  };

  this.YMKModule = YMKModule;
  this.source = source;
  this.venus_makeup_live = source.venus_makeup_live;
  this.result = { face_quality: false, face_rect_data: false, face_align_data: false, face_check_result: false };
  this.emitter = emitter;
  this.lastQualified = {};
  this.pds = 0;
  this.faces = 0;
  this.opened = false;
};

exports.default = FaceQualityChecker4RingAutoSizer;
module.exports = exports['default'];

/***/ }),

/***/ 847:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = __webpack_require__(134);

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShadeFinder = function ShadeFinder(_ref) {
  var _this = this;

  var settings = _ref.settings,
      emitter = _ref.emitter,
      _ref$triggerEvents = _ref.triggerEvents,
      triggerEvents = _ref$triggerEvents === undefined ? true : _ref$triggerEvents;
  (0, _classCallCheck3.default)(this, ShadeFinder);

  this.findShade = function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(_ref3) {
      var image_data = _ref3.image_data,
          face_quality = _ref3.face_quality,
          face_check_result = _ref3.face_check_result,
          face_rect_data = _ref3.face_rect_data,
          face_align_data = _ref3.face_align_data;
      var image_width, image_height;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.promise;

            case 2:
              if (_this.enabled) {
                _context.next = 4;
                break;
              }

              return _context.abrupt('return');

            case 4:
              if ((0, _get3.default)(face_quality, 'hasFace', false)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt('return');

            case 6:
              image_width = image_data.width;
              image_height = image_data.height;


              _this.controller.findShade({ image_data: image_data, image_width: image_width, image_height: image_height, face_rect_data: face_rect_data, face_align_data: face_align_data, face_check_result: face_check_result, face_quality: face_quality });

            case 9:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.handleControllerInitilization = function (Controller) {
    if (!Controller) {
      _this.triggerEvents && _this.emitter.trigger(_events2.default.shadeFindStarted);
      _this.controller.beginShadeFinder();
      _this.enabled = true;
      _this.resolve && _this.resolve();
      return;
    }
    var t = new Controller(_this.settings, function () {
      _this.controller = t;
      _this.triggerEvents && _this.emitter.trigger(_events2.default.shadeFindStarted);
      _this.controller.beginShadeFinder();
      _this.enabled = true;
      _this.resolve && _this.resolve();
      _this.report = null;
    }, function (results) {
      _this.enabled = false;
      _this.report = _this.convertToShadeFinderReport(results);
      _this.emitter.once(_events2.default.shadeFinderUndertoneChanged, function (undertone) {
        return _this.controller.updateUndertone(undertone);
      });
      _this.emitter.on(_events2.default.closeEngine, function () {
        return _this.controller && _this.controller.close();
      });
      _this.triggerEvents && _this.emitter.trigger(_events2.default.shadeFindComplete, [_this.report]);
    });
  };

  this.beginShadeFinder = function () {
    if (!_this.controller) {
      if (!_this.promiseOfControllerImport) {
        _this.promiseOfControllerImport = __webpack_require__.e/* import() */(156).then(__webpack_require__.bind(null, 1025)).then(_this.handleControllerInitilization);
      }
    } else {
      _this.handleControllerInitilization();
    }
  };

  this.cancelShadeFinder = function () {
    return _this.enabled = false;
  };

  this.toPlainShadeFinderCheckResult = function (native) {
    return {
      face_area: native.m_face_area_quality.value,
      face_frontal: native.m_face_frontal_quality.value,
      lighting: native.m_lighting_quality.value,
      naked_eye: native.m_naked_eye_quality.value,
      white_level: native.m_white_level,
      black_level: native.m_black_level,
      lighting_ratio: native.m_lighting_ratio
    };
  };

  this.toSavePhoto = function (image_data, canvas) {
    if (!!image_data) {
      return {
        width: image_data.width,
        height: image_data.height,
        after: _mediaUtils2.default.imageData2Blob(image_data, image_data.width, image_data.height, image_data.width, image_data.height, document)
      };
    }
    return {
      width: canvas.width,
      height: canvas.height,
      after: _mediaUtils2.default.canvas2Blob(canvas)
    };
  };

  this.convertToShadeFinderReport = function (report) {
    var image_data = report.image_data,
        results = (0, _objectWithoutProperties3.default)(report, ['image_data']);

    if (!_this.settings.shadeFinderDebug) {
      return results;
    }
    return (0, _extends3.default)({}, results, {
      savePhoto: _this.toSavePhoto(image_data, _this.canvas)
    });
  };

  this.settings = settings;
  this.emitter = emitter;
  this.enabled = false;
  this.controller = null;
  this.report = null;
  this.triggerEvents = triggerEvents;
  this.promise = new _promise2.default(function (resolve) {
    return _this.resolve = resolve;
  });
};

exports.default = ShadeFinder;
module.exports = exports['default'];

/***/ }),

/***/ 848:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _forEach2 = __webpack_require__(59);

var _forEach3 = _interopRequireDefault(_forEach2);

var _round2 = __webpack_require__(186);

var _round3 = _interopRequireDefault(_round2);

var _replace2 = __webpack_require__(77);

var _replace3 = _interopRequireDefault(_replace2);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _utils = __webpack_require__(849);

var _utils2 = _interopRequireDefault(_utils);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _keys2 = __webpack_require__(26);

var _keys3 = _interopRequireDefault(_keys2);

var _filter2 = __webpack_require__(44);

var _filter3 = _interopRequireDefault(_filter2);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _isNumber2 = __webpack_require__(136);

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _map2 = __webpack_require__(75);

var _map3 = _interopRequireDefault(_map2);

var _isArray2 = __webpack_require__(7);

var _isArray3 = _interopRequireDefault(_isArray2);

var _min2 = __webpack_require__(187);

var _min3 = _interopRequireDefault(_min2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FaceAIAttribute = function FaceAIAttribute(settings, emitter, document, source) {
  var _this = this;

  (0, _classCallCheck3.default)(this, FaceAIAttribute);

  this.setExternalResults = function (v) {
    return _this.externalResults = v;
  };

  this.initializeAttribute = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    var FaceAIAttributeController;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return __webpack_require__.e/* import() */(189).then(__webpack_require__.bind(null, 1026));

          case 2:
            FaceAIAttributeController = _context.sent;

            _this.attributeController = new FaceAIAttributeController(_this.settings.faceAttributeFeatures, _this.handleAttributeEvent);

          case 4:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  }));

  this.handleAttributeEvent = function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(event) {
      var r, rr;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(!event || !event.data)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt('return');

            case 2:
              _context2.t0 = (0, _get3.default)(event, 'data.type');
              _context2.next = _context2.t0 === 'initialized' ? 5 : _context2.t0 === 'processImage' ? 7 : _context2.t0 === 'predicted' ? 9 : 19;
              break;

            case 5:
              _this.attributeResolve();
              return _context2.abrupt('break', 19);

            case 7:
              _this.attributeController.sendImageProcessed(_this.processImage(event.data));
              return _context2.abrupt('return');

            case 9:
              r = {
                predictors: event.data.predictors,
                timed: performance.now() - _this.begin,
                results: _this.convertResults(event.data.results),
                imageData: _this.imageData
              };

              if (_this.settings.debug) {
                r.landmarks = _this.landmarks;
                r.faceRect = _this.faceRect;
                r.trichion = (0, _get3.default)(event.data.results, 'trichion');
              }
              _context2.t1 = (0, _get3.default)(_this.imageData, 'width', _this.settings.displayWidth) / _this.settings.displayWidth;
              _context2.t2 = _this.labeledLandmarks;
              _context2.next = 15;
              return _mediaUtils2.default.blob2ImageData(_this.source.blob, _this.document);

            case 15:
              _context2.t3 = _context2.sent;
              rr = {
                scale: _context2.t1,
                labeledLandmarks: _context2.t2,
                processedImageData: _context2.t3
              };

              _this.emitter.trigger(_events2.default.faceAttributePredicted, [r, rr]);
              return _context2.abrupt('break', 19);

            case 19:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.processImage = function (data) {
    var op = (0, _get3.default)(data, 'op');
    var imageData = (0, _get3.default)(data, 'imageData');
    var arg0 = (0, _get3.default)(data, 'arg0');
    var arg1 = (0, _get3.default)(data, 'arg1');
    return _utils2.default[op](imageData, arg0, arg1);
  };

  this.convertResults = function (results) {
    var r = {};
    (0, _forEach3.default)(results, function (v, k) {
      return r[k] = _this.convertResult(v, k);
    });
    if (_this.settings.isFacialRatioEnabled) {
      var supported = (0, _filter3.default)((0, _keys3.default)(_this.settings.faceAttributeResultAttributes), function (k) {
        return _this.settings.faceAttributeResultAttributes[k];
      });
      return (0, _extends3.default)({}, r, {
        facialratio: _this.getFacialRatioResults(supported, _this.flipFaceRectIfNeeded(_this.faceRect), _this.flipLandmarksIfNeeded(_this.landmarks), (0, _get3.default)(results, 'trichion'))
      });
    }
    return r;
  };

  this.getFullFaceRect = function (faceRect, trichion) {
    if (!(0, _get3.default)(faceRect, 'length') || !(0, _isNumber3.default)((0, _get3.default)(trichion, 'y'))) {
      return faceRect;
    }
    var x1 = faceRect[0];
    var y1 = trichion.y;
    var width = faceRect[2];
    var height = faceRect[3] + (faceRect[1] - trichion.y);
    return { x1: x1, y1: y1, x2: x1 + width, y2: y1 + height };
  };

  this.convertAlignmentIndex = function (index) {
    return _mediaUtils2.default.convertAlignmentIndex(index, _this.isFlipped);
  };

  this.flipFaceRectIfNeeded = function (faceRect) {
    if (!_this.isFlipped) {
      return faceRect;
    }
    return [Math.abs(_this.imageData.width - faceRect[0] - faceRect[2]), faceRect[1], faceRect[2], faceRect[3]];
  };

  this.flipLandmarksIfNeeded = function (landmarks) {
    if (!_this.isFlipped) {
      return landmarks;
    }
    var r = [];
    for (var i = 0; i < landmarks.length; i++) {
      var lm = landmarks[_this.convertAlignmentIndex(i, _this.isFlipped)];
      if (_this.isFlipped) {
        lm = (0, _extends3.default)({}, lm, { x: _this.imageData.width - lm.x });
      }
      r[i] = lm;
    }
    return r;
  };

  this.getFacialRatioResults = function (supported) {
    var faceRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var landmarks = arguments[2];
    var trichion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var r = {};
    if ((0, _get3.default)(landmarks, 'length') < 83) {
      return r;
    }
    var fullFaceRect = _this.getFullFaceRect(faceRect, trichion);
    var leftEyeRect = { x1: landmarks[5].x, x2: landmarks[7].x, y1: landmarks[6].y, y2: landmarks[8].y };
    var rightEyeRect = { x1: landmarks[20].x, x2: landmarks[22].x, y1: landmarks[21].y, y2: landmarks[23].y };
    var noseRect = { x1: landmarks[37].x, x2: landmarks[38].x, y1: landmarks[30].y, y2: landmarks[35].y };
    var upperLipRect = { x1: landmarks[39].x, x2: landmarks[43].x, y1: (0, _min3.default)([landmarks[40].y, landmarks[42].y]), y2: landmarks[58].y };
    var lowerLipRect = { x1: landmarks[39].x, x2: landmarks[43].x, y1: landmarks[62].y, y2: landmarks[50].y };

    _this.labeledLandmarks = {};
    (0, _forEach3.default)(supported, function (k) {
      switch (k) {
        case 'horizontalThird':
          {
            var p = {
              fullFaceRect: fullFaceRect,
              trichion: trichion,
              leftEyebrowStart: landmarks[4],
              rightEyebrowStart: landmarks[15],
              noseTip: landmarks[35],
              chinTip: landmarks[73]
            };
            p.eyebrowStartsCenter = _this.getCenterPoint(p.leftEyebrowStart, p.rightEyebrowStart);
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, p);
            var totalY = p.chinTip.y - p.trichion.y;
            var r1 = (0, _round3.default)((p.eyebrowStartsCenter.y - p.trichion.y) / totalY * 100);
            var r2 = (0, _round3.default)((p.noseTip.y - p.eyebrowStartsCenter.y) / totalY * 100);
            r['horizontal_third'] = [r1, r2, 100 - r1 - r2];
            return;
          }
        case 'verticalFifth':
          {
            var _p = {
              fullFaceRect: fullFaceRect,
              faceRectLeftPoint: landmarks[65],
              leftEyeEnd: landmarks[5],
              leftEyeStart: landmarks[7],
              rightEyeStart: landmarks[20],
              rightEyeEnd: landmarks[22],
              faceRectRightPoint: landmarks[81]
            };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p);
            var totalX = _p.faceRectRightPoint.x - _p.faceRectLeftPoint.x;
            var _r = (0, _round3.default)((_p.leftEyeEnd.x - _p.faceRectLeftPoint.x) / totalX * 100);
            var _r2 = (0, _round3.default)((_p.leftEyeStart.x - _p.leftEyeEnd.x) / totalX * 100);
            var r3 = (0, _round3.default)((_p.rightEyeStart.x - _p.leftEyeStart.x) / totalX * 100);
            var r4 = (0, _round3.default)((_p.rightEyeEnd.x - _p.rightEyeStart.x) / totalX * 100);
            r['vertical_fifth'] = [_r, _r2, r3, r4, 100 - _r - _r2 - r3 - r4];
            return;
          }
        case 'faceAspectRatio':
          {
            var _p2 = { fullFaceRect: fullFaceRect };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p2);
            r['face_aspect_ratio'] = [1, _this.roundRatio((_p2.fullFaceRect.y2 - _p2.fullFaceRect.y1) / (_p2.fullFaceRect.x2 - _p2.fullFaceRect.x1))];
            return;
          }
        case 'eyeAspectRatio':
          {
            var _p3 = { leftEyeRect: leftEyeRect, rightEyeRect: rightEyeRect };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p3);
            r['left_eye_aspect_ratio'] = [1, _this.roundRatio((_p3.leftEyeRect.x2 - _p3.leftEyeRect.x1) / (_p3.leftEyeRect.y2 - _p3.leftEyeRect.y1))];
            r['right_eye_aspect_ratio'] = [1, _this.roundRatio((_p3.rightEyeRect.x2 - _p3.rightEyeRect.x1) / (_p3.rightEyeRect.y2 - _p3.rightEyeRect.y1))];
            return;
          }
        case 'eyebrowPosition':
          {
            var _p4 = {
              leftEyebrowEnd: landmarks[0],
              leftEyebrowArch: landmarks[2],
              leftEyebrowStart: landmarks[4],
              leftNoseWing: landmarks[37],
              rightNoseWing: landmarks[38],
              rightEyebrowStart: landmarks[15],
              rightEyebrowArch: landmarks[17],
              rightEyebrowEnd: landmarks[19]
            };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p4);
            return;
          }
        case 'eyebrowArch':
          {
            var _p5 = {
              leftEyeRect: leftEyeRect,
              leftEyebrowEnd: landmarks[0],
              leftEyebrowArch: landmarks[2],
              leftEyebrowStart: landmarks[4],
              rightEyeRect: rightEyeRect,
              rightEyebrowStart: landmarks[15],
              rightEyebrowArch: landmarks[17],
              rightEyebrowEnd: landmarks[19]
            };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p5);
            r['left_eyebrow_arch_to_eyebrow_width'] = [1, _this.roundRatio((_p5.leftEyebrowEnd.x - _p5.leftEyebrowStart.x) / (_p5.leftEyebrowArch.x - _p5.leftEyebrowStart.x))];
            r['right_eyebrow_arch_to_eyebrow_width'] = [1, _this.roundRatio((_p5.rightEyebrowEnd.x - _p5.rightEyebrowStart.x) / (_p5.rightEyebrowArch.x - _p5.rightEyebrowStart.x))];
            return;
          }
        case 'eyeHeightToEyebrowDistance':
          {
            var _p6 = {
              leftEyebrowArch: landmarks[2],
              rightEyebrowArch: landmarks[17],
              leftEyeRect: leftEyeRect,
              rightEyeRect: rightEyeRect,
              fullFaceRect: fullFaceRect
            };
            _p6.eyebrowArchesCenter = _this.getCenterPoint(_p6.leftEyebrowArch, _p6.rightEyebrowArch);
            _p6.eyeTopsCenter = _this.getCenterPoint({ x: _p6.leftEyeRect.x1, y: _p6.leftEyeRect.y1 }, { x: _p6.rightEyeRect.x1, y: _p6.rightEyeRect.y1 });
            _p6.eyeBottomsCenter = _this.getCenterPoint({ x: _p6.leftEyeRect.x2, y: _p6.leftEyeRect.y2 }, { x: _p6.rightEyeRect.x2, y: _p6.rightEyeRect.y2 });
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p6);
            r['left_eye_height_to_eyebrow_distance'] = [1, _this.roundRatio((_p6.leftEyeRect.y1 - _p6.leftEyebrowArch.y) / (_p6.leftEyeRect.y2 - _p6.leftEyeRect.y1))];
            r['right_eye_height_to_eyebrow_distance'] = [1, _this.roundRatio((_p6.rightEyeRect.y1 - _p6.rightEyebrowArch.y) / (_p6.rightEyeRect.y2 - _p6.rightEyeRect.y1))];
            r['overall_eye_height_to_eyebrow_distance'] = [1, _this.roundRatio((_p6.eyeTopsCenter.y - _p6.eyebrowArchesCenter.y) / (_p6.eyeBottomsCenter.y - _p6.eyeTopsCenter.y))];
            return;
          }
        case 'noseAspectRatio':
          {
            var _p7 = { noseRect: noseRect };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p7);
            r['nose_aspect_ratio'] = [1, _this.roundRatio((_p7.noseRect.y2 - _p7.noseRect.y1) / (_p7.noseRect.x2 - _p7.noseRect.x1))];
            return;
          }
        case 'noseWidthToMouthWidth':
          {
            var _p8 = {
              noseRect: noseRect,
              noseTip: landmarks[35],
              leftNoseWing: landmarks[37],
              rightNoseWing: landmarks[38],
              upperLipRect: upperLipRect,
              lowerLipRect: lowerLipRect
            };
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p8);
            r['nose_width_to_mouth_width'] = [1, _this.roundRatio((_p8.upperLipRect.x2 - _p8.upperLipRect.x1) / (_p8.noseRect.x2 - _p8.noseRect.x1))];
            return;
          }
        case 'noseToLipToChin':
          {
            var _p9 = {
              noseTip: landmarks[35],
              upperLipBottom: landmarks[58],
              lowerLipTop: landmarks[62],
              chinTip: landmarks[73],
              upperLipRect: upperLipRect,
              lowerLipRect: lowerLipRect
            };
            _p9.lipsCenter = _this.getCenterPoint(_p9.upperLipBottom, _p9.lowerLipTop);
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p9);
            r['nose_to_lip_to_chin'] = [1, _this.roundRatio((_p9.chinTip.y - _p9.lipsCenter.y) / (_p9.lipsCenter.y - _p9.noseTip.y))];
            return;
          }
        case 'upperLipToLowerLip':
          {
            var _p10 = {
              leftLipPeak: landmarks[40],
              rightLipPeak: landmarks[42],
              upperLipBottom: landmarks[58],
              lowerLipTop: landmarks[62],
              lowerLipBottom: landmarks[50],
              upperLipRect: upperLipRect,
              lowerLipRect: lowerLipRect
            };
            _p10.lipsCenter = _this.getCenterPoint(_p10.upperLipBottom, _p10.lowerLipTop);
            _this.labeledLandmarks = (0, _extends3.default)({}, _this.labeledLandmarks, _p10);
            r['upper_lip_to_lower_lip'] = [1, _this.roundRatio((_p10.lowerLipRect.y2 - _p10.lipsCenter.y) / (_p10.lipsCenter.y - _p10.upperLipRect.y1))];
            return;
          }
      }
    });
    return r;
  };

  this.convertResult = function (v, k) {
    var supported = _this.settings.faceAttributeResultAttributes;
    var left = _this.isFlipped ? 'right' : 'left';
    var right = _this.isFlipped ? 'left' : 'right';

    switch (k) {
      case 'cheekbone':
        return supported.cheekbones ? {
          left: (0, _get3.default)(v, left + '.cheekbone_class_name'),
          right: (0, _get3.default)(v, right + '.cheekbone_class_name'),
          overrall: (0, _get3.default)(v, 'overall.cheekbone_class_name')
        } : {};
      case 'eyebrow':
        var eyebrow = {};
        if (supported.eyebrowDistance) {
          eyebrow['gap'] = (0, _get3.default)(v, 'gap_class_name');
        }
        if (supported.eyebrowShape) {
          eyebrow['left_shape'] = (0, _get3.default)(v, left + '.shape_name');
          eyebrow['right_shape'] = (0, _get3.default)(v, right + '.shape_name');
        }
        if (supported.eyebrowThickness) {
          eyebrow['left_body_thickness'] = (0, _get3.default)(v, left + '.body_thickness_name');
          eyebrow['left_tail_thickness'] = (0, _get3.default)(v, left + '.tail_thickness_name');
          eyebrow['left_thinness'] = (0, _get3.default)(v, left + '.thinness_' + left + '_class_name');
          eyebrow['right_body_thickness'] = (0, _get3.default)(v, right + '.body_thickness_name');
          eyebrow['right_tail_thickness'] = (0, _get3.default)(v, right + '.tail_thickness_name');
          eyebrow['right_thinness'] = (0, _get3.default)(v, right + '.thinness_' + right + '_class_name');
        }
        if (supported.eyebrowShortness) {
          eyebrow['left_shortness'] = (0, _get3.default)(v, left + '.shortness_' + left + '_class_name');
          eyebrow['right_shortness'] = (0, _get3.default)(v, right + '.shortness_' + right + '_class_name');
        }
        return eyebrow;
      case 'eyelid':
        var eyelid = {};
        if (supported.eyelid) {
          eyelid['left_eyelid'] = _this.replaceHoodedLidIfNecessary((0, _get3.default)(v, left + '.eyelid_name'));
          eyelid['right_eyelid'] = _this.replaceHoodedLidIfNecessary((0, _get3.default)(v, right + '.eyelid_name'));
        }
        if (supported.eyeAngle) {
          eyelid['left_angle'] = (0, _get3.default)(v, left + '.angle_name');
          eyelid['right_angle'] = (0, _get3.default)(v, right + '.angle_name');
        }
        if (supported.eyeShape) {
          eyelid['left_shape'] = (0, _get3.default)(v, left + '.shape_name');
          eyelid['right_shape'] = (0, _get3.default)(v, right + '.shape_name');
        }
        if (supported.eyeDistance) {
          eyelid['setting'] = (0, _get3.default)(v, 'eye_set_name');
        }
        if (supported.eyeSize) {
          eyelid['size'] = (0, _get3.default)(v, 'eye_size_name');
        }
        return eyelid;
      case 'faceshape':
        return supported.faceShape ? (0, _get3.default)(v, 'faceshape') : undefined;
      case 'lipshape':
        return supported.lipShape ? (0, _get3.default)(v, 'lipAttr') : undefined;
      case 'color':
        var color = {};
        if (supported.eyeColor) {
          color['eye_color'] = _mathUtils2.default.lab2Hex((0, _get3.default)(v, 'eye_lab_color'));
          color['eye_color_name'] = (0, _get3.default)(v, 'eye_color_name');
        }
        if (supported.lipColor && !!(0, _get3.default)(v, 'lip_lab_color')) {
          color['lip_color'] = _mathUtils2.default.lab2Hex((0, _get3.default)(v, 'lip_lab_color'));
        }
        if (supported.eyebrowColor && !!(0, _get3.default)(_this.externalResults, 'eyebrowColor')) {
          color['eyebrow_color'] = (0, _get3.default)(_this.externalResults, 'eyebrowColor');
        }
        if (supported.skinTone && !!(0, _get3.default)(_this.externalResults, 'skinColor')) {
          color['skin_color'] = (0, _get3.default)(_this.externalResults, 'skinColor');
        }
        if (supported.hairColor && !!(0, _get3.default)(_this.externalResults, 'hairColor')) {
          color['hair_color'] = (0, _get3.default)(_this.externalResults, 'hairColor.hex');
          color['hair_color_name'] = (0, _get3.default)(_this.externalResults, 'hairColor.name');
        }
        return color;
      case 'nose':
        var nose = {};
        if (supported.noseWidth) {
          nose['width'] = (0, _get3.default)(v, 'width_name');
        }
        if (supported.noseLength) {
          nose['length'] = (0, _get3.default)(v, 'length_name');
        }
        return nose;
      case 'agegender':
        var agegender = {};
        if (supported.age) {
          agegender['age'] = (0, _get3.default)(v, 'age');
        }
        if (supported.gender) {
          agegender['gender'] = (0, _get3.default)(v, 'gender');
        }
        return agegender;
    }
  };

  this.replaceHoodedLidIfNecessary = function (value) {
    if (_this.faceAttributeResultVersion === 'v2') {
      return value;
    }
    return (0, _replace3.default)(value, 'Hooded', 'Single');
  };

  this.round = function (v) {
    return (0, _round3.default)(v, 2);
  };

  this.roundRatio = function (v) {
    return (0, _round3.default)(v, 3);
  };

  this.getCenterPoint = function () {
    var p1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { x: 0, y: 0 };
    var p2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { x: 0, y: 0 };
    return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
  };

  this.convertLandmarks4Display = function (landmark) {
    var scale = _this.settings.displayWidth / (0, _get3.default)(_this.imageData, 'width', _this.settings.displayWidth);
    return (0, _isArray3.default)(landmark) ? (0, _map3.default)(landmark, function (l) {
      return _this.convertLandmark(l, scale);
    }) : _this.convertLandmark(landmark, scale);
  };

  this.convertLandmark = function (point) {
    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.settings.displayWidth / (0, _get3.default)(_this.imageData, 'width', _this.settings.displayWidth);

    if (!point || (0, _isNumber3.default)(point)) {
      return point;
    }
    var r = (0, _extends3.default)({}, point);
    !(0, _isUndefined3.default)(r.x) && (r.x = r.x * scale);
    !(0, _isUndefined3.default)(r.x1) && (r.x1 = r.x1 * scale);
    !(0, _isUndefined3.default)(r.x2) && (r.x2 = r.x2 * scale);
    !(0, _isUndefined3.default)(r.y) && (r.y = r.y * scale);
    !(0, _isUndefined3.default)(r.y1) && (r.y1 = r.y1 * scale);
    !(0, _isUndefined3.default)(r.y2) && (r.y2 = r.y2 * scale);
    return r;
  };

  this.convertFaceRect = function (fr) {
    return [_this.round(fr.left), _this.round(fr.top), _this.round(fr.right - fr.left), _this.round(fr.bottom - fr.top)];
  };

  this.convertAlignment = function (lastQualified) {
    var w = lastQualified.imageData.width;
    var h = lastQualified.imageData.height;
    return lastQualified.result.face_align_data.points.map(function (_ref3) {
      var x = _ref3.x,
          y = _ref3.y;
      return { x: x * w, y: y * h };
    });
  };

  this.predict = function () {
    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(lastQualified, lastQualifieds) {
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this.initializeAttribute();

            case 2:
              _context3.next = 4;
              return _this.attributePromise;

            case 4:
              if (!(!lastQualified || !lastQualified.imageData)) {
                _context3.next = 6;
                break;
              }

              return _context3.abrupt('return');

            case 6:
              _this.imageData = lastQualified.imageData;
              _this.faceRect = _this.convertFaceRect(lastQualified.result.face_rect_data);
              _this.landmarks = _this.convertAlignment(lastQualified);
              _this.begin = performance.now();
              _this.attributeController.predict(_this.imageData, _this.landmarks, _this.faceRect, _this._convertFaces(lastQualifieds));

            case 11:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x7, _x8) {
      return _ref4.apply(this, arguments);
    };
  }();

  this._convertFaces = function (lastQualifieds) {
    if (!lastQualifieds) {
      return false;
    }
    if (!lastQualifieds.length) {
      return false;
    }
    return lastQualifieds.map(function (lq) {
      return _this._convertFace(lq);
    });
  };

  this._convertFace = function (lastQualified) {
    return {
      imageData: lastQualified.imageData,
      faceRect: _this.convertFaceRect(lastQualified.result.face_rect_data),
      landmarks: _this.convertAlignment(lastQualified)
    };
  };

  this.getImageData = function () {
    return _this.imageData;
  };

  this.emitter = emitter;
  this.settings = settings;
  this.document = document;
  this.source = source;
  this.imageData = null;
  this.faceAttributeResultVersion = settings.faceAttributeResultVersion;
  this.attributePromise = new _promise2.default(function (resolve) {
    return _this.attributeResolve = resolve;
  });
  this.externalResults = {};
  this.isFlipped = false;
  if (source && source.type !== 'image') {
    this.isFlipped = settings.secondaryFunctionType === _functionTypes2.default.makeup;
  }
} // for facial ratio (some golden ratio is 1:1.618)

;

exports.default = FaceAIAttribute;
module.exports = exports['default'];

/***/ }),

/***/ 849:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__(309);

var _from2 = _interopRequireDefault(_from);

var _toConsumableArray2 = __webpack_require__(184);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = __webpack_require__(58);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _isNaN = __webpack_require__(135);

var _isNaN2 = _interopRequireDefault(_isNaN);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = {
  newCanvas: function newCanvas(w, h) {
    if (_browserUtils2.default.isOfflineCanvasSupported() && _browserUtils2.default.isInWebWorker()) {
      return new OffscreenCanvas(w, h);
    }
    var c = document.createElement('canvas');
    c.width = w;
    c.h = h;
    return c;
  },
  normalize_resolution: function normalize_resolution(img_data) {
    var tgt_h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
    var tgt_w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 96;

    var w = img_data.width;
    var h = img_data.height;
    var canvas = utils.newCanvas(tgt_w, tgt_h);
    canvas.width = tgt_w;
    canvas.height = tgt_h;
    var ctx = canvas.getContext('2d');
    ctx.fillRect(0, 0, tgt_w, tgt_h);

    if (h / w >= tgt_h / tgt_w) {
      var tgt_ratio = tgt_h / h;
      var resized_w = parseInt(w * tgt_ratio);
      var padding_left = parseInt((tgt_w - resized_w) / 2);
      ctx.putImageData(img_data, padding_left, 0, 0, 0, resized_w, tgt_h);
    } else {
      var _tgt_ratio = tgt_w / w;
      var resized_h = parseInt(h * _tgt_ratio);
      var padding_top = parseInt((tgt_h - resized_h) / 2);
      ctx.putImageData(img_data, 0, padding_top, 0, 0, tgt_w, resized_h);
    }
    var result = ctx.getImageData(0, 0, tgt_w, tgt_h);
    _mediaUtils2.default.releaseCanvas(canvas);
    // canvas.remove();
    return result;
  },
  resize_image_data: function resize_image_data(img_data, tgt_w, tgt_h) {
    var img_w = img_data.width;
    var img_h = img_data.height;

    var canvas1 = utils.newCanvas(img_w, img_h);
    canvas1.width = img_w;
    canvas1.height = img_h;
    var ctx1 = canvas1.getContext('2d');
    ctx1.putImageData(img_data, 0, 0);

    var canvas2 = utils.newCanvas(tgt_w, tgt_h);
    canvas2.width = tgt_w;
    canvas2.height = tgt_h;
    var ctx2 = canvas2.getContext('2d');
    ctx2.save();
    ctx2.scale(tgt_w / img_w, tgt_h / img_h);
    ctx2.drawImage(canvas1, 0, 0);
    ctx2.restore();
    var resized_img_data = ctx2.getImageData(0, 0, tgt_w, tgt_h);

    _mediaUtils2.default.releaseCanvas(canvas1);
    _mediaUtils2.default.releaseCanvas(canvas2);
    // canvas1.remove();
    // canvas2.remove();
    return resized_img_data;
  },
  crop_image_data: function crop_image_data(img_data, _ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 4),
        l = _ref2[0],
        t = _ref2[1],
        r = _ref2[2],
        b = _ref2[3];

    if ((0, _isNaN2.default)(l) || (0, _isNaN2.default)(t) || (0, _isNaN2.default)(r) || (0, _isNaN2.default)(b)) {
      return new ImageData(10, 10);
    }
    var canvas = utils.newCanvas(img_data.width, img_data.height);
    canvas.width = img_data.width;
    canvas.height = img_data.height;
    var ctx = canvas.getContext('2d');
    ctx.putImageData(img_data, 0, 0);
    var cropped_img_data = ctx.getImageData(Math.max(l, 0), Math.max(t, 0), Math.max(r - l, 1), Math.max(b - t, 1));
    // canvas.remove();
    _mediaUtils2.default.releaseCanvas(canvas);
    return cropped_img_data;
  },
  flip_image_data: function flip_image_data(img_data) {
    var flip_lr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var flip_tb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var img_w = img_data.width;
    var img_h = img_data.height;

    var canvas1 = utils.newCanvas(img_w, img_h);
    canvas1.width = img_w;
    canvas1.height = img_h;
    var ctx1 = canvas1.getContext('2d');
    ctx1.putImageData(img_data, 0, 0);

    var scale_h = flip_lr ? -1 : 1;
    var scale_v = flip_tb ? -1 : 1;
    var pos_x = flip_lr ? img_w * -1 : 0;
    var pos_y = flip_tb ? img_h * -1 : 0;

    var canvas2 = utils.newCanvas(img_w, img_h);
    canvas2.width = img_w;
    canvas2.height = img_h;
    var ctx2 = canvas2.getContext('2d');
    ctx2.save();
    ctx2.scale(scale_h, scale_v);
    ctx2.drawImage(canvas1, pos_x, pos_y);
    ctx2.restore();
    var flipped_img_data = ctx2.getImageData(0, 0, img_data.width, img_data.height);

    // canvas1.remove();
    // canvas2.remove();
    _mediaUtils2.default.releaseCanvas(canvas1);
    _mediaUtils2.default.releaseCanvas(canvas2);
    return flipped_img_data;
  },

  rotate_image_data: function rotate_image_data(img_data, angle_radian, _ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
        c_x = _ref4[0],
        c_y = _ref4[1];

    var img_w = img_data.width;
    var img_h = img_data.height;

    var canvas1 = utils.newCanvas(img_w, img_h);
    canvas1.width = img_w;
    canvas1.height = img_h;
    var ctx1 = canvas1.getContext('2d');
    ctx1.putImageData(img_data, 0, 0);

    var canvas2 = utils.newCanvas(img_w, img_h);
    canvas2.width = img_w;
    canvas2.height = img_h;
    var ctx2 = canvas2.getContext('2d');
    ctx2.save();
    ctx2.translate(c_x, c_y);
    ctx2.rotate(-angle_radian);
    ctx2.drawImage(canvas1, -c_x, -c_y);
    ctx2.restore();
    var rotated_img_data = ctx2.getImageData(0, 0, img_data.width, img_data.height);
    // canvas1.remove();
    // canvas2.remove();
    _mediaUtils2.default.releaseCanvas(canvas1);
    _mediaUtils2.default.releaseCanvas(canvas2);
    return rotated_img_data;
  },

  rotate_landmarks: function rotate_landmarks(landmarks, angle_radian, _ref5) {
    var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
        c_x = _ref6[0],
        c_y = _ref6[1];

    var cos = Math.cos(angle_radian);
    var sin = Math.sin(angle_radian);
    var results = [];
    landmarks.forEach(function (_ref7) {
      var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),
          p_x = _ref8[0],
          p_y = _ref8[1];

      var r_x = cos * (p_x - c_x) + sin * (p_y - c_y) + c_x;
      var r_y = -sin * (p_x - c_x) + cos * (p_y - c_y) + c_y;
      results.push([parseInt(r_x), parseInt(r_y)]);
    });
    return results;
  },

  get_bounding_box: function get_bounding_box(feat_points, feat_indexes) {
    var padding_ratio_lr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var padding_ratio_tb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var selected_pt_x = utils.get_values(feat_points, feat_indexes, 0);
    var selected_pt_y = utils.get_values(feat_points, feat_indexes, 1);
    var l = Math.min.apply(Math, (0, _toConsumableArray3.default)(selected_pt_x));
    var t = Math.min.apply(Math, (0, _toConsumableArray3.default)(selected_pt_y));
    var r = Math.max.apply(Math, (0, _toConsumableArray3.default)(selected_pt_x));
    var b = Math.max.apply(Math, (0, _toConsumableArray3.default)(selected_pt_y));
    // proportionally expand the region
    var padding_lr = parseInt((r - l) * padding_ratio_lr);
    var padding_tb = parseInt((b - t) * padding_ratio_tb);
    l = l - padding_lr;
    t = t - padding_tb;
    r = r + padding_lr;
    b = b + padding_tb;
    return [l, t, r, b];
  },
  softmax: function softmax(arr) {
    if (Array.isArray(arr) == false) {
      arr = (0, _from2.default)(arr);
    }
    return arr.map(function (value, index) {
      return Math.exp(value) / arr.map(function (y) {
        return Math.exp(y);
      }).reduce(function (a, b) {
        return a + b;
      });
    });
  },

  argmax: function argmax(arr) {
    if (Array.isArray(arr) == false) {
      arr = (0, _from2.default)(arr);
    }
    return arr.map(function (x, i) {
      return [x, i];
    }).reduce(function (r, a) {
      return a[0] > r[0] ? a : r;
    })[1];
  },
  get_values: function get_values(pts, indexes, vIdx) {
    var values = [];
    indexes.forEach(function (ptIdx, i) {
      values.push(pts[ptIdx][vIdx]);
    });
    return (0, _from2.default)(values);
  },

  transform_image_data: function transform_image_data(img_data, params, target_size) {
    var img_w = img_data.width;
    var img_h = img_data.height;
    var tgt_w = target_size;
    var tgt_h = target_size;
    var res_r = target_size / 112;

    var canvas1 = utils.newCanvas(img_w, img_h);
    canvas1.width = img_w;
    canvas1.height = img_h;
    var ctx1 = canvas1.getContext('2d');
    ctx1.putImageData(img_data, 0, 0);

    var canvas2 = utils.newCanvas(tgt_w, tgt_h);
    canvas2.width = tgt_w;
    canvas2.height = tgt_h;
    var ctx2 = canvas2.getContext('2d');
    ctx2.save();
    ctx2.setTransform(params[0], params[1], params[2], params[3], params[4], params[5]);
    ctx2.setTransform(params[0] * res_r, params[1] * res_r, params[2] * res_r, params[3] * res_r, params[4] * res_r, params[5] * res_r);
    ctx2.drawImage(canvas1, 0, 0);
    ctx2.restore();
    var resized_img_data = ctx2.getImageData(0, 0, tgt_w, tgt_h);

    _mediaUtils2.default.releaseCanvas(canvas1);
    _mediaUtils2.default.releaseCanvas(canvas2);
    return resized_img_data;
  }
};

exports.default = utils;
module.exports = exports['default'];

/***/ }),

/***/ 850:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _keys = __webpack_require__(33);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _assign = __webpack_require__(304);

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _isUndefined2 = __webpack_require__(40);

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VideoImagesWebcam = function VideoImagesWebcam(settings, emitter, videoImages, videoImagesInfo) {
  var _this = this;

  (0, _classCallCheck3.default)(this, VideoImagesWebcam);

  this.isFlipped = function () {
    return false;
  };

  this.isVideoImages = function () {
    return true;
  };

  this.init = function (successCallback) {
    _this.video = {};
    _this.video.ready = false;
    _this.video.oncanplaythrough = function () {
      return _this.video.ready = true;
    };
    _this.video.onerror = function () {};
    _this.needReload = true;
    _this.video.onpause = function () {
      return _this.isPaused = true;
    };
    _this.video.onplay = function () {
      if (!_this.isPaused) {
        return;
      }
      _this.isPaused = false;
      if (!_this.needReload) {
        return;
      }
      _this.needReload = true;
    };
    _this.isPaused = false;
    _this.successCallback = successCallback;

    _this.autoTestFrameIndex = 0;
    _this.autoTestSnapshotIndexes.length = 0;
    _this.autoTestSnapshotResult = {};
    _this.gotStream();
  };

  this.getImageData = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(sx, sy, w, h) {
      var unit8, imageURL, image, context;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              unit8 = new Uint8Array(_this.videoImages[_this.autoTestFrameIndex]);
              imageURL = URL.createObjectURL(new Blob([unit8], { type: 'image/png' }));
              image = (0, _assign2.default)(new Image(), { src: imageURL });
              _context.next = 5;
              return new _promise2.default(function (resolve) {
                return image.addEventListener('load', function () {
                  return resolve();
                });
              });

            case 5:
              context = (0, _assign2.default)(document.createElement('canvas'), {
                width: w,
                height: h
              }).getContext('2d');

              context.imageSmoothingEnabled = false;
              context.drawImage(image, sx || 0, sy || 0, w, h, 0, 0, w, h);

              return _context.abrupt('return', context.getImageData(0, 0, w, h));

            case 9:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();

  this.gotStream = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _this.video.src = '';
            _this.video.ready = true;
            _this.video.pause = false;
            _this.video.videoWidth = _this.videoImagesWidth;
            _this.video.videoHeight = _this.videoImagesHeight;
            _this.video.muted = true;
            _this.emitter.trigger(_events2.default.cameraOpened);
            _this.successCallback && _this.successCallback();
            _this.successCallback = null;

          case 9:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  this.changeVideoSource = function () {};

  this.delayPerFrame = function (delay) {
    return new _promise2.default(function (resolve) {
      setTimeout(function () {
        resolve();
      }, delay);
    });
  };

  this.goToNextFrame = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _this.autoTestFrameIndex = (_this.autoTestFrameIndex + 1) % _this.videoImages.length;
            _context3.next = 3;
            return _this.delayPerFrame(_this.videoImagesFrameDelay);

          case 3:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, _this);
  }));

  this.handleSnapshotVideoFrame = function (frameIndexes) {
    if (!_this.settings.videoAutoTesting) {
      _this.emitter.trigger(_events2.default.snapshotVideoFrameComplete, [false]);
      return;
    }
    _this.autoTestSnapshotIndexes = frameIndexes;
  };

  this.handleSnapshotVideoFrameComplete = function (renderer) {
    if ((0, _isUndefined3.default)(_this.autoTestSnapshotResult[_this.autoTestFrameIndex])) {
      _this.autoTestSnapshotResult[_this.autoTestFrameIndex] = _mediaUtils2.default.result2Blob(renderer);
    }
    if ((0, _keys2.default)(_this.autoTestSnapshotResult).length === _this.autoTestSnapshotIndexes.length) {
      _this.emitter.trigger(_events2.default.snapshotVideoFrameComplete, [_this.autoTestSnapshotResult]);
      _this.autoTestSnapshotIndexes.length = 0;
      _this.autoTestSnapshotResult = {};
    }
  };

  this.snapshot4AutoTest = function (renderer) {
    if (_this.autoTestFrameIndex >= 0 && _this.autoTestSnapshotIndexes.includes(_this.autoTestFrameIndex)) {
      _this.handleSnapshotVideoFrameComplete(renderer);
    }
  };

  this.isStopped = function () {
    return false;
  };

  this.stop = function () {};

  this.resume = function () {};

  this.emitter = emitter;
  this.streams = [];
  this.settings = settings;
  this.docId = settings.videoId;
  this.video = {};
  this.videoImages = videoImages;
  this.videoImagesWidth = videoImagesInfo.width;
  this.videoImagesHeight = videoImagesInfo.height;
  this.videoImagesFrameDelay = videoImagesInfo.frameDelay;
  this.facingMode = this.settings.videoTestingFacingMode;
  this.settings.facingMode = this.settings.videoTestingFacingMode;

  // for auto-test
  this.autoTestFrameIndex = -1;
  this.autoTestSnapshotIndexes = [];
  this.autoTestSnapshotResult = {};
  this.emitter.on(_events2.default.snapshotVideoFrame, this.handleSnapshotVideoFrame);
};

exports.default = VideoImagesWebcam;
module.exports = exports['default'];

/***/ }),

/***/ 851:
/***/ (function(module, exports, __webpack_require__) {

var _0xa3af=['uniforms','geometry','fragmentShader','depthTest','m_four_way_index','clearScene','dispose','SetProcessRange','length','ResetWidthHeight','vertexShader','m_height','material','forEach','Mesh','clearMaterial','m_camera','Camera','clearObject','m_scene','value','defineProperty','render','Destroy','DisposeTexture','process_end_x','ShaderMaterial','type','process_start_x','children','RenderFrame','depthWrite','SetInputTexture','m_geometry','__esModule','default','m_is_four_way','m_mesh','m_target','m_material','WebGLRenderTarget','LinearFilter','call','SetFourWayInfo'];(function(_0x5bbad2,_0xa3afbb){var _0x52ef34=function(_0x496fd0){while(--_0x496fd0){_0x5bbad2['push'](_0x5bbad2['shift']());}};_0x52ef34(++_0xa3afbb);}(_0xa3af,0x1e5));var _0x52ef=function(_0x5bbad2,_0xa3afbb){_0x5bbad2=_0x5bbad2-0x0;var _0x52ef34=_0xa3af[_0x5bbad2];return _0x52ef34;};'use strict';Object[_0x52ef('0x14')](exports,_0x52ef('0x21'),{'value':!![]}),exports['default']=undefined;var _keys=__webpack_require__(33),_keys2=_interopRequireDefault(_keys),_classCallCheck2=__webpack_require__(1),_classCallCheck3=_interopRequireDefault(_classCallCheck2),_class,_temp,_initialiseProps,_three=__webpack_require__(705),_shader=__webpack_require__(3343),_shader2=_interopRequireDefault(_shader);function _interopRequireDefault(_0x2d2aaf){return _0x2d2aaf&&_0x2d2aaf['__esModule']?_0x2d2aaf:{'default':_0x2d2aaf};}var BaseFilter=(_temp=_class=function BaseFilter(_0x458946,_0x3e9e0a){(0x0,_classCallCheck3[_0x52ef('0x22')])(this,BaseFilter),_initialiseProps[_0x52ef('0x29')](this),this['m_width']=_0x458946,this[_0x52ef('0xa')]=_0x3e9e0a,this[_0x52ef('0xf')]=new _three[(_0x52ef('0x10'))](),this[_0x52ef('0x25')]=new _three[(_0x52ef('0x27'))](_0x458946,_0x3e9e0a,{'minFilter':_three[_0x52ef('0x28')],'magFilter':_three[_0x52ef('0x28')],'format':_three['RGBAFormat']}),this[_0x52ef('0x20')]=new _three['PlaneGeometry'](0x2,0x2);var _0x40fb4f=new _shader2[(_0x52ef('0x22'))](),_0x3056c9=new _three[(_0x52ef('0x19'))]({'uniforms':_0x40fb4f['input_uniforms'],'vertexShader':_0x40fb4f['vertexShader'],'fragmentShader':_0x40fb4f['fragmentShader']});this[_0x52ef('0x24')]=new _three[(_0x52ef('0xd'))](this[_0x52ef('0x20')],_0x3056c9),this[_0x52ef('0x24')][_0x52ef('0xb')][_0x52ef('0x2')]=![],this[_0x52ef('0x24')][_0x52ef('0xb')][_0x52ef('0x1e')]=![],this[_0x52ef('0x12')]=new _three['Scene'](),this[_0x52ef('0x12')]['add'](this[_0x52ef('0x24')]),this[_0x52ef('0x23')]=![],this[_0x52ef('0x3')]=0x0;},_initialiseProps=function _initialiseProps(){var _0x298b90=this;this[_0x52ef('0x1f')]=function(_0x2a5173){return _0x298b90[_0x52ef('0x24')]['material']['uniforms']['inputImageTexture'][_0x52ef('0x13')]=_0x2a5173;},this[_0x52ef('0x1d')]=function(_0x33d3ac,_0x1c8758){_0x1c8758?_0x33d3ac[_0x52ef('0x15')](_0x298b90[_0x52ef('0x12')],_0x298b90[_0x52ef('0xf')],_0x298b90[_0x52ef('0x25')],!![]):_0x33d3ac[_0x52ef('0x15')](_0x298b90[_0x52ef('0x12')],_0x298b90[_0x52ef('0xf')]);},this[_0x52ef('0x8')]=function(_0x3b8914,_0x4ad90c){_0x298b90[_0x52ef('0x25')]!=null&&_0x298b90[_0x52ef('0x25')][_0x52ef('0x5')](),_0x298b90['m_width']=_0x3b8914,_0x298b90['m_height']=_0x4ad90c,_0x298b90[_0x52ef('0x25')]=new _three[(_0x52ef('0x27'))](_0x3b8914,_0x4ad90c,{'minFilter':_three['LinearFilter'],'magFilter':_three[_0x52ef('0x28')],'format':_three['RGBAFormat']});},this[_0x52ef('0x17')]=function(){},this[_0x52ef('0x2a')]=function(_0x53a3c0,_0x11d304){_0x298b90[_0x52ef('0x23')]=_0x53a3c0,_0x298b90[_0x52ef('0x3')]=_0x11d304;},this[_0x52ef('0x6')]=function(_0x2d6355,_0x47c464,_0x51e1c6,_0x3e9f2a){_0x298b90[_0x52ef('0x24')][_0x52ef('0xb')]['uniforms'][_0x52ef('0x1b')][_0x52ef('0x13')]=_0x2d6355,_0x298b90[_0x52ef('0x24')][_0x52ef('0xb')][_0x52ef('0x2b')][_0x52ef('0x18')][_0x52ef('0x13')]=_0x47c464,_0x298b90[_0x52ef('0x24')][_0x52ef('0xb')][_0x52ef('0x2b')]['process_start_y'][_0x52ef('0x13')]=_0x51e1c6,_0x298b90['m_mesh']['material'][_0x52ef('0x2b')]['process_end_y'][_0x52ef('0x13')]=_0x3e9f2a;},this[_0x52ef('0xe')]=function(_0xef41b0){if(!_0xef41b0)return;(0x0,_keys2[_0x52ef('0x22')])(_0xef41b0['uniforms'])[_0x52ef('0xc')](function(_0x5da70f){var _0x12c821=_0xef41b0[_0x52ef('0x2b')][_0x5da70f];_0x12c821[_0x52ef('0x1a')]=='t'&&!!_0x12c821[_0x52ef('0x13')]&&(_0x12c821[_0x52ef('0x13')]['dispose'](),_0x12c821[_0x52ef('0x13')]=null);}),_0xef41b0[_0x52ef('0x5')](),_0xef41b0[_0x52ef('0x1')]=null,_0xef41b0[_0x52ef('0x9')]=null,_0xef41b0=null;},this[_0x52ef('0x11')]=function(_0x5b268e){_0x5b268e[_0x52ef('0x0')]&&_0x5b268e[_0x52ef('0x0')][_0x52ef('0x5')](),_0x298b90[_0x52ef('0xe')](_0x5b268e[_0x52ef('0xb')]),_0x5b268e[_0x52ef('0x1c')][_0x52ef('0xc')](_0x298b90[_0x52ef('0x11')]),_0x5b268e[_0x52ef('0x1c')][_0x52ef('0x7')]=0x0;},this[_0x52ef('0x4')]=function(_0x54efe9){while(_0x54efe9['children']['length']>0x0){var _0x3ae1b8=_0x54efe9[_0x52ef('0x1c')][0x0];_0x298b90[_0x52ef('0x11')](_0x3ae1b8),_0x54efe9['remove'](_0x3ae1b8);}},this[_0x52ef('0x16')]=function(){_0x298b90['m_scene']!=null&&(_0x298b90[_0x52ef('0x4')](_0x298b90[_0x52ef('0x12')]),_0x298b90['m_scene']=null),_0x298b90[_0x52ef('0x24')]!=null&&(_0x298b90['clearObject'](_0x298b90['m_mesh']),_0x298b90[_0x52ef('0x24')]=null),_0x298b90[_0x52ef('0x25')]!=null&&(_0x298b90[_0x52ef('0x25')][_0x52ef('0x5')](),_0x298b90[_0x52ef('0x25')]=null),_0x298b90[_0x52ef('0x20')]!=null&&(_0x298b90[_0x52ef('0x20')]['dispose'](),_0x298b90[_0x52ef('0x20')]=null),_0x298b90[_0x52ef('0x26')]&&(_0x298b90[_0x52ef('0xe')](_0x298b90[_0x52ef('0x26')]),_0x298b90[_0x52ef('0x26')]=null);};},_temp);exports[_0x52ef('0x22')]=BaseFilter,module['exports']=exports['default'];

/***/ }),

/***/ 872:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _mediaUtils = __webpack_require__(74);

var _mediaUtils2 = _interopRequireDefault(_mediaUtils);

var _fileUtils = __webpack_require__(137);

var _fileUtils2 = _interopRequireDefault(_fileUtils);

var _mathUtils = __webpack_require__(76);

var _mathUtils2 = _interopRequireDefault(_mathUtils);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _isNaN2 = __webpack_require__(135);

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _isFunction2 = __webpack_require__(15);

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _toInteger2 = __webpack_require__(4);

var _toInteger3 = _interopRequireDefault(_toInteger2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _settings = __webpack_require__(39);

var _floor2 = __webpack_require__(305);

var _floor3 = _interopRequireDefault(_floor2);

var _max2 = __webpack_require__(306);

var _max3 = _interopRequireDefault(_max2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (superclass) {
  return function (_superclass) {
    (0, _inherits3.default)(_class2, _superclass);

    function _class2(params) {
      var _this2 = this;

      (0, _classCallCheck3.default)(this, _class2);

      var _this = (0, _possibleConstructorReturn3.default)(this, (_class2.__proto__ || (0, _getPrototypeOf2.default)(_class2)).call(this, params));

      _this.getWaitOfThrottle = function () {
        if (_browserUtils2.default.isEdge()) {
          return 200;
        }
        if (_browserUtils2.default.isIE()) {
          return 400;
        }
        return 50;
      };

      _this._isTooSmall = function (_ref) {
        var top = _ref.top,
            left = _ref.left,
            right = _ref.right,
            bottom = _ref.bottom,
            width = _ref.width,
            height = _ref.height;

        var area = (right - left) * (bottom - top);
        var total = width * height;
        return area / total < 0.1;
      };

      _this.beforeInit = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));
      _this.afterInit = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this2);
      }));

      _this.init = function () {
        var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(callback) {
          var trgetWidth, width, flippedOriginalImage, _width, face_rect_data, args, new_face_rect_data;

          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this.resized = false;
                  _context3.next = 3;
                  return _this.beforeInit();

                case 3:
                  _this.eyebrowPoints = false;
                  _this.zoomLevel = 0;
                  _this.comparing = false;
                  _this.splitFourWayEnabled = false;
                  _this.splitFourWayBlobs = [];
                  _this.imageData = null;
                  _this.m_compare_parameter = _this.settings.compareMode === _settings.compareModes.split ? 0.5 : 1.0;
                  if (_this.outputDiv) {
                    _this.outputDiv.appendChild(_this.renderer.domElement);
                  } else {
                    _this.getFrameDocument(_this.document, _this.frameId).getElementById(_this.outputId).innerHTML = '';
                    _this.getFrameDocument(_this.document, _this.frameId).getElementById(_this.outputId).appendChild(_this.renderer.domElement);
                  }
                  _this.renderer.domElement.style.display = 'block';
                  _this.hasFace = false;
                  _this.x = 0;
                  _context3.t0 = _this;
                  _context3.t1 = _this.originalImage;
                  _context3.next = 18;
                  return _this.readFile(_this.file);

                case 18:
                  _context3.t2 = _context3.sent;
                  _context3.next = 21;
                  return _context3.t0.loadImage.call(_context3.t0, _context3.t1, _context3.t2);

                case 21:
                  _this.cropLeftOfModel = 0;

                  if (!_this._needToAdjustOriginalImage(_this.originalImage)) {
                    _context3.next = 28;
                    break;
                  }

                  trgetWidth = _mathUtils2.default.toEvenNumber(_this.settings.displayWidth / _this.settings.displayHeight * _this.originalImage.height);

                  _this.cropLeftOfModel = (0, _floor3.default)((_this.originalImage.width - trgetWidth) / 2);
                  _context3.next = 27;
                  return _mediaUtils2.default.resizeAndAddBackgroundToImage(_this.originalImage, trgetWidth, _this.originalImage.height, _this.cropLeftOfModel, _this._getModelBgColor && _this._getModelBgColor(), _this.document);

                case 27:
                  _this.originalImage = _context3.sent;

                case 28:
                  width = _mathUtils2.default.toEvenNumber(_this.originalImage.width);

                  _this._resize(width, _mathUtils2.default.toEvenNumber(_this.originalImage.height));
                  _this.AllocateResources();

                  if (!_this._needToFlipImage()) {
                    _context3.next = 37;
                    break;
                  }

                  _context3.next = 34;
                  return _mediaUtils2.default.flipImage(_this.originalImage, _this.document);

                case 34:
                  _context3.t3 = _context3.sent;
                  _context3.next = 38;
                  break;

                case 37:
                  _context3.t3 = _this.originalImage;

                case 38:
                  flippedOriginalImage = _context3.t3;

                  _this.imageData = _this.extractImageData({
                    image: flippedOriginalImage,
                    x: 0,
                    y: 0,
                    w: _this.originalImage.width,
                    h: _this.originalImage.height,
                    width: _this.render_width,
                    height: _this.render_height
                  });
                  _context3.t4 = callback;

                  if (!_context3.t4) {
                    _context3.next = 44;
                    break;
                  }

                  _context3.next = 44;
                  return callback();

                case 44:
                  if (_this._needToCropImage()) {
                    _context3.next = 52;
                    break;
                  }

                  _width = _mathUtils2.default.toEvenNumber(_this.display_height * _this.originalImage.width / _this.originalImage.height);

                  _this._resize(_width, _mathUtils2.default.toEvenNumber(_this.display_height));
                  _this._AllocateFrameBuffer();
                  _this.imageScale = _this.render_width / _this.originalImage.width;
                  _this.imageData = _this.extractImageData({
                    image: flippedOriginalImage,
                    x: 0,
                    y: 0,
                    w: _this.originalImage.width,
                    h: _this.originalImage.height,
                    width: _this.render_width,
                    height: _this.render_height
                  });
                  _context3.next = 66;
                  break;

                case 52:
                  _this._AllocateFrameBuffer();
                  _context3.next = 55;
                  return _this.extractFaceRect();

                case 55:
                  face_rect_data = _context3.sent;

                  _this._resize(_mathUtils2.default.toEvenNumber(_this.display_width), _mathUtils2.default.toEvenNumber(_this.display_height));
                  _this._AllocateFrameBuffer();
                  if (!face_rect_data) {
                    _this.imageData = _this.extractImageData({
                      image: flippedOriginalImage,
                      x: 0,
                      y: 0,
                      w: _this.originalImage.width,
                      h: _this.originalImage.height,
                      width: _this.render_width,
                      height: _this.render_height
                    });
                  }

                  if (!face_rect_data) {
                    _context3.next = 66;
                    break;
                  }

                  args = (0, _extends3.default)({}, face_rect_data, {
                    width: _this.render_width,
                    height: _this.render_height,
                    originalWidth: _this.originalImage.width,
                    originalHeight: _this.originalImage.height,
                    targetWidth: _this.render_width,
                    targetHeight: _this.render_height
                  });

                  _this.imageData = _this.extractImageData((0, _extends3.default)({}, _mediaUtils2.default.calRect2FitWidthOrHeight(args), {
                    image: flippedOriginalImage,
                    width: _this.render_width,
                    height: _this.render_height
                  }));
                  _context3.next = 64;
                  return _this.extractFaceRect();

                case 64:
                  new_face_rect_data = _context3.sent;

                  if (!new_face_rect_data || _this._isTooSmall((0, _extends3.default)({}, new_face_rect_data, {
                    width: _this.render_width,
                    height: _this.render_height
                  }))) {
                    // no-face or too-small
                    _this.imageData = _this.extractImageData((0, _extends3.default)({}, _mediaUtils2.default.calRect2ExtendFaceRect(args), {
                      image: flippedOriginalImage,
                      width: _this.render_width,
                      height: _this.render_height
                    }));
                  }

                case 66:
                  _this.frame_array = new Uint8Array(_this.imageData.data);
                  _context3.next = 69;
                  return _this.update();

                case 69:
                  _this.targetContainer.appendChild(_this.targetImage);
                  _context3.next = 72;
                  return _this.afterInit();

                case 72:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, _this2);
        }));

        return function (_x) {
          return _ref4.apply(this, arguments);
        };
      }();

      _this._resize = function (width, height) {
        _this.canvas.width = width;
        _this.canvas.height = height;
        _this.render_width = width;
        _this.render_height = height;
        _this.window_width = width;
        _this.window_height = height;
        if (_this.settings.compareMode === _settings.compareModes.split) {
          _this.m_smoothed_center_x = width / 2;
        } else {
          _this.m_smoothed_center_x = width;
        }
        _this.renderer.setSize(width, height);
        _this.makeup_live_filter.ResetWidthHeight(width, height);
        _this.image_texture = _this.makeup_live_filter.createImageTexture(width, height);
        _this.makeup_live_filter.SetInputTexture(_this.image_texture);
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothStrength)) {
          _this.makeup_live_filter.SetSkinSmoothStrength(_this.settings.skinSmoothStrength);
        }
        if ((0, _isFunction3.default)(_this.makeup_live_filter.SetSkinSmoothColorIntensity)) {
          _this.makeup_live_filter.SetSkinSmoothColorIntensity(_this.settings.skinSmoothColorIntensity);
        }
        _this.marginLeft = Math.round((_this.display_width - width) / (2 * _this.devicePixelRatio));
        _this.renderer.domElement.style.marginLeft = _this.marginLeft + 'px';
        _this.targetImage.style.width = _this.render_width / _this.devicePixelRatio + 'px';
        _this.targetImage.style.height = _this.render_height / _this.devicePixelRatio + 'px';
        _this.targetImage.style.marginLeft = _this.marginLeft + 'px';
        _this.targetImage.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        if (_this.compareImage) {
          _this.compareImage.style.width = _this.render_width / _this.devicePixelRatio + 'px';
          _this.compareImage.style.height = _this.render_height / _this.devicePixelRatio + 'px';
          _this.compareImage.style.marginLeft = _this.marginLeft + 'px';
        }
        _this.renderer.domElement.style.visibility = 'hidden';
        _this.resized = true;
      };

      _this.extractImageData = function (args) {
        return _mediaUtils2.default.extractImageData((0, _extends3.default)({}, args, { document: _this.document }));
      };

      _this._needToFlipImage = function () {
        if (_this.settings.isNail()) {
          return _this.mediaSource === 'choosemodel' && _this.isValidFeaturePoints();
        }
        return true;
      };

      _this._needToAdjustOriginalImage = function (image) {
        if (!_this.settings.isNail()) {
          return false;
        }
        if (_this.mediaSource !== 'choosemodel') {
          return false;
        }
        if (!_this.isValidFeaturePoints()) {
          return false;
        }
        if (_mathUtils2.default.toEvenNumber(image.width) / _mathUtils2.default.toEvenNumber(image.height) === _mathUtils2.default.toEvenNumber(_this.settings.displayWidth) / _mathUtils2.default.toEvenNumber(_this.settings.displayHeight)) {
          return false;
        }

        return (0, _isFunction3.default)(_this._getModelBgColor) && !!_this._getModelBgColor();
      };

      _this._needToCropImage = function () {
        if (!(0, _isFunction3.default)(_this.extractFaceRect)) {
          return false;
        }
        if (_this.mediaSource === 'api') {
          return true;
        }
        if (_this.mediaSource === 'uploadphoto') {
          return true;
        }
        if (true) {
          return false;
        }
        return _this.mediaSource === 'choosemodel' && !_this.isValidFeaturePoints();
      };

      _this.isValidFeaturePoints = function () {
        return !!_this.featurePoints;
      };

      _this._update = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(_this.terminalized || _this.updating)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt('return');

              case 2:
                _this.updating = true;
                _context4.next = 5;
                return _this.render();

              case 5:
                _this.blob = _context4.sent;
                _context4.t0 = _this;
                _context4.t1 = _this.targetImage;
                _context4.next = 10;
                return _this.readFile(_this.blob);

              case 10:
                _context4.t2 = _context4.sent;
                _context4.next = 13;
                return _context4.t0.loadImage.call(_context4.t0, _context4.t1, _context4.t2);

              case 13:
                _this.updating = false;

              case 14:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, _this2);
      }));

      _this.readFile = function (file) {
        return new _promise2.default(function (resolve) {
          if (typeof file === 'string') {
            resolve(file);
          } else {
            var r = new FileReader();
            r.readAsDataURL(file);
            r.onloadend = function (event) {
              return resolve(event.target.result);
            };
          }
        });
      };

      _this._AllocateFrameBuffer = function () {
        if (_this.frame_buffer) {
          _this.YMKModule._free(_this.frame_buffer);
          _this.frame_buffer = null;
        }
        if (_this._isSmallImage(_this.canvas.width, _this.canvas.height, _this.display_width, _this.display_height)) {
          _this.frame_buffer = _this.YMKModule._malloc(_this.display_width * _this.display_height * 4);
        } else {
          _this.frame_buffer = _this.YMKModule._malloc(_this.canvas.width * _this.canvas.height * 4);
        }
      };

      _this._isSmallImage = function (w, h, ww, hh) {
        if (!w || !h) {
          return false;
        }
        try {
          return w * h < ww * hh;
        } catch (err) {}
        return false;
      };

      _this.loadImage = _fileUtils2.default.loadImageFromFile;

      _this._result2Blob = function () {
        return _mediaUtils2.default.result2Blob(_this.renderer, 'image/png');
      };

      _this.getFormattedFeaturePoints = function () {
        if (!_this.featurePoints) {
          return false;
        }
        if (!_this.YMKModule.MKL_LANDMARK_AMOUNT) {
          return false;
        }
        if (_this.featurePoints.length !== _this.YMKModule.MKL_LANDMARK_AMOUNT) {
          return false;
        }
        return _this.featurePoints.map(function (_ref6) {
          var x = _ref6.x,
              y = _ref6.y;
          return { x: x * _this.imageScale, y: y * _this.imageScale };
        });
      };

      _this.getFormattedEarlobePoints = function () {
        if (!_this.earlobePoints) {
          return false;
        }
        if (_this.earlobePoints.length !== 2) {
          return false;
        }
        return _this.earlobePoints.map(function (_ref7) {
          var x = _ref7.x,
              y = _ref7.y;
          return { x: x * _this.imageScale, y: y * _this.imageScale };
        });
      };

      _this.getFormattedEarlobePoints4Earbone = function () {
        if (!_this.leftEarlobePoints || !_this.rightEarlobePoints) {
          return false;
        }
        var r = {
          left_points: [],
          right_points: [],
          left_visibility: [],
          right_visibility: []
        };
        for (var i = 0; i < _this.leftEarlobePoints.length; i++) {
          var p = _this.leftEarlobePoints[i];
          r.left_points[i] = {
            x: parseFloat(p[0]) * _this.imageScale,
            y: parseFloat(p[1]) * _this.imageScale
          };
          r.left_visibility[i] = 1 - p[2];
        }
        for (var _i = 0; _i < _this.rightEarlobePoints.length; _i++) {
          var _p = _this.rightEarlobePoints[_i];
          r.right_points[_i] = {
            x: parseFloat(_p[0]) * _this.imageScale,
            y: parseFloat(_p[1]) * _this.imageScale
          };
          r.right_visibility[_i] = 1 - _p[2];
        }
        return r;
      };

      _this.getEyebrowPoints = function () {
        return _mediaUtils2.default.getEyebrowPoints(_this.face_align_data_vec, _this.render_width, _this.render_height);
      };

      _this.setEyebrowPoints = function (points) {
        return _this.eyebrowPoints = { is_valid: true, points: points };
      };

      _this._isFaceAlignDataValid = function (data) {
        var points = (0, _get3.default)(data, 'points');
        if (!points) {
          return false;
        }
        return (0, _max3.default)(points.map(function (p) {
          return p.x;
        })) > 0;
      };

      _this._flipPoints = function (data) {
        var points = (0, _get3.default)(data, 'points', []);

        return {
          points: points.map(function (_ref8) {
            var x = _ref8.x,
                y = _ref8.y;
            return {
              x: 1 - x,
              y: y
            };
          })
        };
      };

      _this.getLandmarks = function (size) {
        var align_data_vec = _this.settings.landmarkVersion === 'v2' ? _this.new_face_align_data_vec : _this.face_align_data_vec;
        var face_align_data = [];
        var tmp_align_data = align_data_vec && align_data_vec.get(0);
        if (_this._isFaceAlignDataValid(tmp_align_data)) {
          face_align_data = tmp_align_data;
        } else {
          if (_this.face_align_data_of_face_quality_checker) {
            face_align_data = _this._flipPoints(_this.face_align_data_of_face_quality_checker);
          }
        }
        if (size === 'display') {
          var marginLeft = _this.marginLeft * _this.display_width / _this.devicePixelRatio / _this.render_width;
          return _mediaUtils2.default.getLandmarks(face_align_data, _this.display_width / _this.devicePixelRatio - marginLeft * 2, _this.display_height / _this.devicePixelRatio, marginLeft);
        }
        return _mediaUtils2.default.getLandmarks(face_align_data, _this.render_width, _this.render_height, 0);
      };

      _this.getFaceRect = function (size) {
        var face_rect = _this.face_rect_vec.get(0);
        if (size === 'display') {
          return _this._getFaceRect(face_rect, _this.devicePixelRatio, _this.marginLeft);
        }
        return _this._getFaceRect(face_rect, _this.devicePixelRatio, 0);
      };

      _this._getFaceRect = function (faceRect, ratio, marginLeft) {
        if (!faceRect) {
          return [];
        }
        return {
          top: (0, _toInteger3.default)(faceRect.top / ratio),
          bottom: (0, _toInteger3.default)(faceRect.bottom / ratio),
          left: (0, _toInteger3.default)((_this.display_width - faceRect.right) / ratio - marginLeft),
          right: (0, _toInteger3.default)((_this.display_width - faceRect.left) / ratio - marginLeft)
        };
      };

      _this.freeResources = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _this.terminalized = true;
                _this.hasFace = false;
                _this.resized = false;
                _context5.next = 5;
                return _browserUtils2.default.sleep(1000);

              case 5:
                if (_this.image_texture && _this.image_texture.image && _this.image_texture.image.data) {
                  delete _this.image_texture.image.data;
                  delete _this.image_texture.image;
                  (0, _isFunction3.default)(_this.image_texture.dispose) && _this.image_texture.dispose();
                  _this.image_texture = null;
                }
                _this.splitFourWayBlobs = [];
                _this.blob = null;
                _this.imageData = null;
                _this.originalImage = null;
                _this.targetContainer.removeChild(_this.targetImage);
                _this.targetImage = null;
                _this.previousImage = null;
                _this.compareImage = null;
                if (_this.frame_buffer) {
                  _this.YMKModule._free(_this.frame_buffer);
                  _this.frame_buffer = null;
                }
                _context5.next = 17;
                return _this.FreeResources();

              case 17:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, _this2);
      }));

      _this.dragCompareIndicator = function (x) {
        if ((0, _isNaN3.default)(x)) {
          return;
        }
        if (_this.settings.compareMode === _settings.compareModes.replace) {
          return;
        }
        _this.x = x;
        var w = _this.render_width / _this.devicePixelRatio * _mediaUtils2.default.getZoomRatio(_this.zoomLevel);
        _this.m_compare_parameter = (x + w / 2) / w;
        _this.throttledUpdate();
      };

      _this.savePhoto = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
        var after, tempFeatures, before;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(_this.settings.savePhotoType === 'watermark')) {
                  _context6.next = 7;
                  break;
                }

                _context6.next = 3;
                return _this.render();

              case 3:
                _context6.t0 = _context6.sent;
                _context6.t1 = _this.render_width;
                _context6.t2 = _this.render_height;
                return _context6.abrupt('return', {
                  after: _context6.t0,
                  width: _context6.t1,
                  height: _context6.t2
                });

              case 7:
                _context6.next = 9;
                return _this.render();

              case 9:
                after = _context6.sent;
                tempFeatures = (0, _extends3.default)({}, _this.m_feature_enable_arrays);

                _this.controller.reset(null, 0, false);
                _context6.next = 14;
                return _this.render();

              case 14:
                before = _context6.sent;

                _this.m_feature_enable_arrays = tempFeatures;
                _context6.next = 18;
                return _this.render();

              case 18:
                return _context6.abrupt('return', { before: before, after: after, width: _this.render_width, height: _this.render_height });

              case 19:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, _this2);
      }));

      _this.handleNoFace = function () {
        _this.emitter.trigger(_events2.default.noFaceInPhoto);
        if ((0, _get3.default)(_this, 'settings.functionType') === _functionTypes2.default.productrecommendation) {
          return;
        }
        _this.emitter.trigger(_events2.default.toastMessage, [_this.settings.i18n.getMessage('error.no.face.detected'), 'error']);
        setTimeout(function () {
          return _this.emitter.trigger(_events2.default.closeEngine);
        });
      };

      _this.handleTooSmall = function () {
        _this.emitter.trigger(_events2.default.toastMessage, [_this.settings.i18n.getMessage('error.face.too.small'), 'error', 'toast', 4000]);
        setTimeout(function () {
          return _this.emitter.trigger(_events2.default.closeEngine);
        });
      };

      _this.handleNotFrontal = function () {
        _this.emitter.trigger(_events2.default.toastMessage, [_this.settings.i18n.getMessage('error.face.not.frontal'), 'error', 'toast', 4000]);
        setTimeout(function () {
          return _this.emitter.trigger(_events2.default.closeEngine);
        });
      };

      _this.handleOutOfBoundary = function () {
        _this.emitter.trigger(_events2.default.toastMessage, [_this.settings.i18n.getMessage('error.face.out.of.boundary'), 'error', 'toast', 4000]);
        setTimeout(function () {
          return _this.emitter.trigger(_events2.default.closeEngine);
        });
      };

      _this.getImageData = function () {
        return _this.imageData;
      };

      _this.estimateEyewearPD = function () {
        if (!_this.settings.enableEyewearAutoPD) {
          return;
        }
        _this.venus_makeup_live.EnableCheckForEstimatingPD(true);
        _this.venus_makeup_live.RestartEstimatingPupilDistance(true);
        for (var i = 0; i < 20; i++) {
          _this.venus_makeup_live.GetEstimatedPupilDistance(0, _this.estimatedPDInfo);
        }
        _this.venus_makeup_live.EnableCheckForEstimatingPD(false);
        if (_this.estimatedPDInfo && _this.estimatedPDInfo.pd) {
          _this.emitter.trigger(_events2.default.eyewearPDEstimated, [{
            pd: (0, _toInteger3.default)(_this.estimatedPDInfo.pd)
          }]);
        }
      };

      _this.updateSkinSmooth = function () {
        return _this.throttledUpdate && _this.throttledUpdate();
      };

      _this.type = 'image';
      _this.mediaSource = params.mediaSource;
      _this.settings = params.settings;
      _this.maxLooks = 2;
      _this.image_width = params.image_width;
      _this.image_height = params.image_height;
      if (_this.mediaSource === 'choosemodel' || _this._isSmallImage(params.originalWidth, params.originalHeight, params.display_width, params.display_height) || params.display_width > 414) {
        if (_browserUtils2.default.isIpad()) {
          _this.devicePixelRatio = 2;
        } else {
          _this.devicePixelRatio = 1;
        }
      } else {
        _this.devicePixelRatio = params.devicePixelRatio;
      }
      _this.render_width = params.render_width * _this.devicePixelRatio;
      _this.render_height = params.render_height * _this.devicePixelRatio;
      _this.display_width = params.display_width * _this.devicePixelRatio;
      _this.display_height = params.display_height * _this.devicePixelRatio;
      _this.file = params.file;
      _this.featurePoints = params.featurePoints;
      _this.earlobePoints = params.earlobePoints;
      _this.leftEarlobePoints = params.leftEarlobePoints;
      _this.rightEarlobePoints = params.rightEarlobePoints;
      _this.modelConfig = params.modelConfig;
      _this.removeBgMask = params.removeBgMask;
      _this.masks = params.masks;
      _this.originalImage = new Image();
      _this.targetImage = new Image();
      _this.previousImage = new Image();
      _this.compareImage = new Image();
      if (params.settings.isHeadlessMode()) {
        _this.targetContainer = document.createElement('div');
        _this.outputDiv = document.createElement('div');
      } else {
        _this.targetContainer = _this.getFrameDocument(_this.document, _this.frameId).getElementById(params.targetId);
      }

      _this.hasFace = false;
      _this.imageData = null;
      _this.eyebrowPoints = false;
      _this.comparing = false;
      _this.resized = false;
      _this.updating = false;
      _this.terminalized = false;
      _this.tutorialTimeSpentPerRender = 0;
      return _this;
    }

    // left eye points: [15,16,17,18,19,83]
    // right eye points: [0,1,2,3,4,82]


    return _class2;
  }(superclass);
};

module.exports = exports['default'];

/***/ }),

/***/ 908:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = __webpack_require__(12);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(5);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(6);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(57);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(1);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(55);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(56);

var _inherits3 = _interopRequireDefault(_inherits2);

var _isArray2 = __webpack_require__(7);

var _isArray3 = _interopRequireDefault(_isArray2);

var _events = __webpack_require__(11);

var _events2 = _interopRequireDefault(_events);

var _currenteffectsholder = __webpack_require__(23);

var _currenteffectsholder2 = _interopRequireDefault(_currenteffectsholder);

var _AbstractController2 = __webpack_require__(838);

var _AbstractController3 = _interopRequireDefault(_AbstractController2);

var _featureenum = __webpack_require__(733);

var _featureenum2 = _interopRequireDefault(_featureenum);

var _browserUtils = __webpack_require__(8);

var _browserUtils2 = _interopRequireDefault(_browserUtils);

var _get2 = __webpack_require__(2);

var _get3 = _interopRequireDefault(_get2);

var _functionTypes = __webpack_require__(42);

var _functionTypes2 = _interopRequireDefault(_functionTypes);

var _skuUtils = __webpack_require__(60);

var _skuUtils2 = _interopRequireDefault(_skuUtils);

var _difference2 = __webpack_require__(912);

var _difference3 = _interopRequireDefault(_difference2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FACE_TRACKING_MANAGER = void 0;

var AbstractMakeupController = function (_AbstractController) {
  (0, _inherits3.default)(AbstractMakeupController, _AbstractController);

  function AbstractMakeupController(props) {
    var _this2 = this;

    (0, _classCallCheck3.default)(this, AbstractMakeupController);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AbstractMakeupController.__proto__ || (0, _getPrototypeOf2.default)(AbstractMakeupController)).call(this, props));

    _this.getUpdater = function (type, faceIndex) {
      if ((0, _isArray3.default)(_this.updaters[type])) {
        return _this.updaters[type][faceIndex];
      }
      return _this.updaters[type];
    };

    _this.calDeltaE = function (rgb1, rgb2) {
      return _this.source && _this.source.calDeltaE(rgb1, rgb2);
    };

    _this.dragCompareIndicator = function (x) {
      return _this.source && _this.source.dragCompareIndicator(x);
    };

    _this.setFourWayFaceIndex = function () {};

    _this.splitFourWay = function () {
      return _this.source && _this.source.splitFourWay();
    };

    _this.splitFourWayOff = function () {
      return _this.source && _this.source.splitFourWayOff();
    };

    _this.getEyebrowPoints = function () {
      return _this.source.getEyebrowPoints();
    };

    _this.setEyebrowPoints = function (points) {
      return _this.source.setEyebrowPoints(points);
    };

    _this.getSkuTypeByFeature = function (feature) {
      switch (feature) {
        case _featureenum2.default.FEATURE_BLUSH:
        case _featureenum2.default.FEATURE_BLUSH3D:
        case _featureenum2.default.FEATURE_BLUSH3D_V2:
          return 'blush';
        case _featureenum2.default.FEATURE_EYELASH:
          return 'eyelash';
        case _featureenum2.default.FEATURE_EYELINER:
          return 'eyeliner';
        case _featureenum2.default.FEATURE_EYESHADOW:
          return 'eyeshadow';
        case _featureenum2.default.FEATURE_FOUNDATION:
          return 'foundation';
        case _featureenum2.default.FEATURE_LIP:
          return 'lipstick';
        case _featureenum2.default.FEATURE_LIPLINER:
          return 'lipliner';
        case _featureenum2.default.FEATURE_EYE_CONTACT:
          return 'eyecontact';
        case _featureenum2.default.FEATURE_HAIR_DYE:
          return 'hairdye';
        case _featureenum2.default.FEATURE_EYEBROW:
          return 'eyebrow';
        case _featureenum2.default.FEATURE_FACE_ART:
          return 'face_art';
        case _featureenum2.default.FEATURE_FACE_ART_LAYER2:
          return 'face_art_layer2';
        case _featureenum2.default.FEATURE_FACE_CONTOUR:
          return 'face_contour';
        case _featureenum2.default.FEATURE_OBJECT3D:
        case _featureenum2.default.FEATURE_AR_GLASSES:
          return 'eye_wear';
        case _featureenum2.default.FEATURE_EARRING:
          return 'earrings';
        case _featureenum2.default.FEATURE_CONCEALER:
          return 'concealer';
        case _featureenum2.default.FEATURE_BRONZER:
          return 'bronzer';
      }
    };

    _this.getFeature = function (type, skuItem, patterns) {
      switch (type) {
        case 'facereshape':
          return _featureenum2.default.FEATURE_FACE_RESHAPE;
        case 'background':
          return _featureenum2.default.FEATURE_BACKGROUND;
        case 'blush':
          if (_skuUtils2.default.isMultipleColorBlushSupported(skuItem)) {
            return _featureenum2.default.FEATURE_BLUSH3D_V2;
          }
          if (!!skuItem && !!skuItem.textures) {
            return _featureenum2.default.FEATURE_BLUSH3D;
          }
          return _featureenum2.default.FEATURE_BLUSH;
        case 'eyelash':
          return _featureenum2.default.FEATURE_EYELASH;
        case 'mascara':
          return _featureenum2.default.FEATURE_EYELASH;
        case 'eyeliner':
          return _featureenum2.default.FEATURE_EYELINER;
        case 'eyeshadow':
          return _featureenum2.default.FEATURE_EYESHADOW;
        case 'foundation':
          return _featureenum2.default.FEATURE_FOUNDATION;
        case 'lipliner':
          return _featureenum2.default.FEATURE_LIPLINER;
        case 'lipstick':
          return _featureenum2.default.FEATURE_LIP;
        case 'eyecontact':
          return _featureenum2.default.FEATURE_EYE_CONTACT;
        case 'eyebrow':
          return _featureenum2.default.FEATURE_EYEBROW;
        case 'hairdye':
          return _featureenum2.default.FEATURE_HAIR_DYE;
        case 'bearddye':
        case 'beard_dye':
          return _featureenum2.default.FEATURE_BEARD_DYE;
        case 'watch':
        case 'bracelet':
        case 'nail':
        case 'ring':
        case 'eye_wear':
        case 'eyewear':
          if ((0, _get3.default)(patterns, 'pattern.texture_supported_mode', '').indexOf('cube_eyewear') !== -1) {
            return _featureenum2.default.FEATURE_AR_GLASSES;
          }
          return _featureenum2.default.FEATURE_OBJECT3D;
        case 'face_art':
          return _featureenum2.default.FEATURE_FACE_ART;
        case 'face_art_layer2':
          return _featureenum2.default.FEATURE_FACE_ART_LAYER2;
        case 'face_contour':
          return _featureenum2.default.FEATURE_FACE_CONTOUR;
        case 'concealer':
          return _featureenum2.default.FEATURE_CONCEALER;
        case 'bronzer':
          return _featureenum2.default.FEATURE_BRONZER;
        case 'earrings':
        case 'earring':
          return _featureenum2.default.FEATURE_EARRING;
        case 'necklace':
          return _featureenum2.default.FEATURE_NECKLACE;
        default:
          return _featureenum2.default.FEATURE_LIP;
      }
    };

    _this.getProtectMaskFeature = function (type, skuItem) {
      switch (type) {
        case 'eyeliner':
          return _featureenum2.default.FEATURE_EYELINER_PROTECT_MASK;
        case 'eyeshadow':
          return _featureenum2.default.FEATURE_EYESHADOW_PROTECT_MASK;
        case 'facecontour':
        case 'face_contour':
          return _featureenum2.default.FEATURE_FACE_CONTOUR_PROTECT_MASK;
        case 'blush':
          if (!skuItem) {
            return [_featureenum2.default.FEATURE_BLUSH_PROTECT_MASK, _featureenum2.default.FEATURE_BLUSH3D_PROTECT_MASK];
          }
          return _skuUtils2.default.isMultipleColorBlushSupported(skuItem) ? _featureenum2.default.FEATURE_BLUSH3D_PROTECT_MASK : _featureenum2.default.FEATURE_BLUSH_PROTECT_MASK;
      }
    };

    _this._getEffectsToBeReset = function (currentEffects, newEffects, lookBuiltInPatterns, results) {
      var b = [];
      for (var i = 1; i < _featureenum2.default.FEATURE_SIZE - 3; i++) {
        if (currentEffects[i]) {
          b.push(i);
        }
      }
      var a = [];
      newEffects.map(function (e, i) {
        if (!results[i]) {
          return;
        }
        var skuItem = _skuUtils2.default.getSkuItemByEffect(e);
        var patternInfo = _skuUtils2.default.getSkuPatternsByEffect(e, lookBuiltInPatterns);
        a.push(_this.getFeature(e.sku_type, skuItem, patternInfo));
      });
      return (0, _difference3.default)(b, a);
    };

    _this.isBackgroundFeatureEnabled = function () {
      return (0, _get3.default)(_this, 'settings.features.background', false);
    };

    _this.setFaceTrackingManagerLoaderInstance = function (instance) {
      return _this.faceTrackingManagerLoaderInstance = instance;
    };

    _this.initFaceTrackingManager = function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(source) {
        var FaceTrackingManager, b;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (_browserUtils2.default.isAIFaceTrackingSupported((0, _get3.default)(_this.settings, 'features'), (0, _get3.default)(_this.settings, 'forceUseAIFaceTracking'))) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return');

              case 2:
                if (FACE_TRACKING_MANAGER) {
                  _context.next = 11;
                  break;
                }

                _context.next = 5;
                return _this.faceTrackingManagerLoaderInstance.getFaceTrackingManager();

              case 5:
                FaceTrackingManager = _context.sent;

                FACE_TRACKING_MANAGER = new FaceTrackingManager(_this.settings, _this.faceTrackingManagerLoaderInstance, _this.tfjs);
                b = performance.now();
                _context.next = 10;
                return FACE_TRACKING_MANAGER.init();

              case 10:
                _this.emitter.trigger(_events2.default.engineLoading, ['download-model', b, performance.now()]);
                // } else {
                //   const FaceTrackingManagerMnn = await import(/* webpackChunkName: "FaceTrackingManagerMnn" */ '../../tfjs/facetrackingmnn/FaceTrackingManagerMnn');
                //   FACE_TRACKING_MANAGER = new FaceTrackingManagerMnn(this.settings);
                //   let b = performance.now();
                //   await FACE_TRACKING_MANAGER.init();
                //   this.emitter.trigger(events.engineLoading, ['download-model', b, performance.now()]);
                // }

              case 11:
                if (_this.settings.functionType === _functionTypes2.default.faceattribute && source.type !== 'image' && !_this.settings.enableEyewearAutoPD) {
                  try {
                    FACE_TRACKING_MANAGER.pause();
                    _this.emitter.once(_events2.default.faceAttributePredictorsInitialized, function () {
                      return FACE_TRACKING_MANAGER.pause();
                    });
                    _this.emitter.once(_events2.default.faceAttributePredicted, function () {
                      return FACE_TRACKING_MANAGER.resume();
                    });
                  } catch (err) {
                    console.log(err);
                  }
                }
                if (_this.settings.functionType === _functionTypes2.default.shadefinder && source.type !== 'image') {
                  try {
                    //FACE_TRACKING_MANAGER.pause();
                    //this.emitter.once(events.shadeFindStarted, () => FACE_TRACKING_MANAGER.pause());
                    _this.emitter.once(_events2.default.shadeFindComplete, function () {
                      return FACE_TRACKING_MANAGER.resume();
                    });
                  } catch (err) {
                    console.log(err);
                  }
                }
                FACE_TRACKING_MANAGER.reset();
                source.faceTrackingManager = FACE_TRACKING_MANAGER;

              case 15:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    _this.applyMakeupByProductRecommendation = function (lookGuid, patterns, inputEffects) {
      if ((0, _get3.default)(_this, 'settings.functionType') !== _functionTypes2.default.productrecommendation) {
        return;
      }
      if (!(0, _get3.default)(_this, 'settings.features.aitransfer', false)) {
        return;
      }
      var effects = _skuUtils2.default.filterEffects(_this.settings.features, inputEffects, patterns, inputEffects);
      _this.applyMakeupByLook(lookGuid, patterns, effects.map(function (effect) {
        return (0, _extends3.default)({}, effect, { sku_type: _skuUtils2.default.convertSkuType(effect.effect_type) });
      }));
    };

    _this.comparing = false;
    _this.currentEffectsHolder = new _currenteffectsholder2.default(_this.emitter, _events2.default, props);
    _this.allUpdaters = [];
    _this.updaters = [];
    return _this;
  }

  return AbstractMakeupController;
}(_AbstractController3.default);

exports.default = AbstractMakeupController;
module.exports = exports['default'];

/***/ }),

/***/ 912:
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(913),
    baseFlatten = __webpack_require__(311),
    baseRest = __webpack_require__(188),
    isArrayLikeObject = __webpack_require__(319);

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;


/***/ }),

/***/ 913:
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(194),
    arrayIncludes = __webpack_require__(320),
    arrayIncludesWith = __webpack_require__(321),
    arrayMap = __webpack_require__(101),
    baseUnary = __webpack_require__(102),
    cacheHas = __webpack_require__(195);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;


/***/ }),

/***/ 938:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _log = __webpack_require__(973);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * hdrpng.js - support for Radiance .HDR and RGBE / RGB9_E5 images in PNG.
 * @author Enki
 * @desc load/save Radiance .HDR, RGBE in PNG and RGB9_E5 in PNG for HTML5, webGL, webGL2.
 */
(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition();else if (true) __webpack_require__(771)(name, definition);else context[name] = definition();
})('HDRImage', undefined, function () {
  /**
   * HDRImage - wrapper that exposes default Image like interface for HDR imgaes. (till extending HTMLCanvasElement actually works ..)
   * @returns {HDRImage} a html HDR image element
   */
  function HDRImage() {
    var res = document.createElement('canvas'),
        HDRsrc = 't',
        HDRexposure = 1.0,
        HDRgamma = 2.2,
        HDRdata = null,
        context,
        HDRD;
    res.__defineGetter__('exposure', function () {
      return HDRexposure;
    });
    res.__defineSetter__('exposure', function (val) {
      HDRexposure = val;
      if (HDRdata) {
        rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
        context.putImageData(HDRD, 0, 0);
      }
    });
    res.__defineGetter__('gamma', function () {
      return HDRgamma;
    });
    res.__defineSetter__('gamma', function (val) {
      HDRgamma = val;
      if (HDRdata) {
        rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
        context.putImageData(HDRD, 0, 0);
      }
    });
    res.__defineGetter__('dataFloat', function () {
      return rgbeToFloat(HDRdata);
    });
    res.__defineGetter__('dataRGBE', function () {
      return HDRdata;
    });
    res.toHDRBlob = function (cb, m, q) {
      // Array to image.. slightly more involved.
      function createShader(gl, source, type) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }
      function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
        var program = gl.createProgram(),
            vs,
            fs;
        gl.attachShader(program, vs = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER));
        gl.attachShader(program, fs = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER));
        gl.linkProgram(program);
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        return program;
      }
      var ar = m && m.match(/rgb9_e5/i) ? new Uint8Array(floatToRgb9_e5(rgbeToFloat(HDRdata)).buffer) : new Uint8Array(HDRdata.buffer);
      var vs2 = 'precision highp float;\nattribute vec3 position;\nvarying vec2 tex;\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }';
      var fs2 = 'precision highp float;\nprecision highp sampler2D;\nuniform sampler2D tx;\nvarying vec2 tex;\nvoid main() { gl_FragColor = texture2D(tx,tex); }';
      var x = this.width,
          y = this.height;
      if (x * y * 4 < ar.byteLength) return console.error('not big enough.');
      var c = document.createElement('canvas');
      c.width = x;
      c.height = y;
      var gl = c.getContext('webgl', { antialias: false, alpha: true, premultipliedAlpha: false, preserveDrawingBuffer: true });

      var texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, x, y, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(ar.buffer));

      var program = createProgram(gl, vs2, fs2),
          uniformTexLocation = gl.getUniformLocation(program, 'tx');

      var positions = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0]),
          vertexPosBuffer = gl.createBuffer();
      gl.enableVertexAttribArray(0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      gl.useProgram(program);
      gl.uniform1i(uniformTexLocation, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      gl.deleteTexture(texture);
      gl.deleteProgram(program);

      if (cb) return c.toBlob(cb);
    };
    res.__defineGetter__('src', function () {
      return HDRsrc;
    });
    res.__defineSetter__('src', function (val) {
      var _this = this;

      HDRsrc = val;
      context && context.clearRect(0, 0, this.width, this.height);
      if (val.match(/\.hdr/i)) loadHDR(val, function (img, width, height) {
        try {
          HDRdata = img;
          this.width = this.style.width = width;
          this.height = this.style.height = height;
          context = this.getContext('2d');
          HDRD = context.getImageData(0, 0, width, height);
          rgbeToLDR(img, HDRexposure, HDRgamma, HDRD.data);
          context.putImageData(HDRD, 0, 0);
          this.onload && this.onload();
        } catch (e) {
          console.error('HDRImage loadHDR', e);
          this.onerror && this.onerror(e);
        }
      }.bind(res));else if (val.match(/\.rgb9_e5\.png$/i)) {
        var i = new Image();
        i.src = val;
        i.onerror = function (e) {
          console.error('HDRImage rgb9_e5', e);
          _this.onerror && _this.onerror(e);
        };
        i.onload = function () {
          var c = document.createElement('canvas'),
              x = this.width = this.style.width = c.width = i.width,
              y = this.height = this.style.height = c.height = i.height,
              gl = c.getContext('webgl');

          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);

          fb = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

          var res = new Uint8Array(x * y * 4);
          gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res);

          gl.deleteTexture(texture);
          gl.deleteFramebuffer(fb);

          this.dataRAW = new Uint32Array(res.buffer);
          HDRdata = floatToRgbe(rgb9_e5ToFloat(this.dataRAW));
          context = this.getContext('2d');
          HDRD = context.getImageData(0, 0, x, y);
          rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
          context.putImageData(HDRD, 0, 0);
          this.onload && this.onload();
        }.bind(res);
      } else if (val.match(/\.hdr\.png$|\.rgbe\.png/i)) {
        var i = new Image();
        i.crossOrigin = 'anonymous';
        i.src = val;
        i.onerror = function (e) {
          console.error('HDRImage .hdr.png|.rgbe.png', e);
          _this.onerror && _this.onerror(e);
        };
        i.onload = function () {
          var c = document.createElement('canvas'),
              x = this.width = this.style.width = c.width = i.width,
              y = this.height = this.style.height = c.height = i.height,
              gl = c.getContext('webgl');

          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);

          fb = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

          var res = new Uint8Array(x * y * 4);
          gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res);

          gl.deleteTexture(texture);
          gl.deleteFramebuffer(fb);

          HDRdata = res;
          context = this.getContext('2d');
          HDRD = context.getImageData(0, 0, x, y);
          rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
          context.putImageData(HDRD, 0, 0);
          this.onload && this.onload();
        }.bind(res);
      } else {
        try {
          loadHDRDataURI(val, function (img, width, height) {
            HDRdata = img;
            this.width = this.style.width = width;
            this.height = this.style.height = height;
            context = this.getContext('2d');
            HDRD = context.getImageData(0, 0, width, height);
            rgbeToLDR(img, HDRexposure, HDRgamma, HDRD.data);
            context.putImageData(HDRD, 0, 0);
            this.onload && this.onload();
          }.bind(res));
        } catch (e) {
          console.error('HDRImage loadHDRDataURI', e);
          this.onerror && this.onerror(e);
        }
      }
    });
    return res;
  }

  function convertDataURIToBinary(dataURI) {
    var BASE64_MARKER = ';base64,';
    var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
    var base64 = dataURI.substring(base64Index);
    var raw = window.atob(base64);
    var rawLength = raw.length;
    var array = new Uint8Array(new ArrayBuffer(rawLength));
    for (i = 0; i < rawLength; i++) {
      array[i] = raw.charCodeAt(i);
    }
    return array;
  }

  function parseHDRUint8Array(array, completion) {
    var d8 = array;
    var header = '',
        pos = 0,
        format = void 0;
    // read header.
    while (!header.match(/\n\n[^\n]+\n/g)) {
      header += String.fromCharCode(d8[pos++]);
    } // check format.
    format = header.match(/FORMAT=(.*)$/m)[1];
    if (format != '32-bit_rle_rgbe') return console.warn('unknown format : ' + format), this.onerror();
    // parse resolution
    var rez = header.split(/\n/).reverse()[1].split(' '),
        width = rez[3] * 1,
        height = rez[1] * 1;
    // Create image.
    var img = new Uint8Array(width * height * 4),
        ipos = 0;
    // Read all scanlines
    for (var j = 0; j < height; j++) {
      var rgbe = d8.slice(pos, pos += 4),
          scanline = [];
      if (rgbe[0] != 2 || rgbe[1] != 2 || rgbe[2] & 0x80) {
        var len = width,
            rs = 0;
        pos -= 4;
        while (len > 0) {
          img.set(d8.slice(pos, pos += 4), ipos);
          if (img[ipos] == 1 && img[ipos + 1] == 1 && img[ipos + 2] == 1) {
            for (img[ipos + 3] << rs; i > 0; i--) {
              img.set(img.slice(ipos - 4, ipos), ipos);
              ipos += 4;
              len--;
            }
            rs += 8;
          } else {
            len--;
            ipos += 4;
            rs = 0;
          }
        }
      } else {
        if ((rgbe[2] << 8) + rgbe[3] != width) return console.warn('HDR line mismatch ..'), this.onerror();
        for (var _i = 0; _i < 4; _i++) {
          var ptr = _i * width,
              ptr_end = (_i + 1) * width,
              buf = void 0,
              count = void 0;
          while (ptr < ptr_end) {
            buf = d8.slice(pos, pos += 2);
            if (buf[0] > 128) {
              count = buf[0] - 128;
              while (count-- > 0) {
                scanline[ptr++] = buf[1];
              }
            } else {
              count = buf[0] - 1;
              scanline[ptr++] = buf[1];
              while (count-- > 0) {
                scanline[ptr++] = d8[pos++];
              }
            }
          }
        }
        for (var _i2 = 0; _i2 < width; _i2++) {
          img[ipos++] = scanline[_i2];
          img[ipos++] = scanline[_i2 + width];
          img[ipos++] = scanline[_i2 + 2 * width];
          img[ipos++] = scanline[_i2 + 3 * width];
        }
      }
    }
    completion && completion(img, width, height);
  }

  function loadHDRDataURI(data_uri, completion) {
    var d8 = convertDataURIToBinary(data_uri);
    parseHDRUint8Array(d8, completion);
  }

  function m(a, b) {
    for (var i in b) {
      a[i] = b[i];
    }return a;
  }

  /** Load and parse a Radiance .HDR file. It completes with a 32bit RGBE buffer.
   * @param {URL} url location of .HDR file to load.
   * @param {function} completion completion callback.
   * @returns {XMLHttpRequest} the XMLHttpRequest used to download the file.
   */
  function loadHDR(url, completion) {
    var req = m(new XMLHttpRequest(), { responseType: 'arraybuffer' });
    req.onerror = completion.bind(req, false);
    req.onload = function () {
      if (this.status >= 400) return this.onerror();
      var d8 = new Uint8Array(this.response);
      parseHDRUint8Array(d8, completion);
    };
    req.open('GET', url, true);
    req.send(null);
    return req;
  }

  /** Convert a float buffer to a RGB9_E5 buffer. (ref https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt)
   * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).
   * @param {Uint32Array} [res] Optional output buffer with 32 bit RGB9_E5 per pixel.
   * @returns {Uint32Array} A 32bit uint32 array in RGB9_E5
   */
  function floatToRgb9_e5(buffer, res) {
    var r,
        g,
        b,
        v,
        maxColor,
        ExpShared,
        denom,
        s,
        l = buffer.byteLength / 12 | 0,
        res = res || new Uint32Array(l);
    for (var i = 0; i < l; i++) {
      r = Math.min(32768.0, buffer[i * 3]);
      g = Math.min(32768.0, buffer[i * 3 + 1]);
      b = Math.min(32768.0, buffer[i * 3 + 2]);
      maxColor = Math.max(Math.max(r, g), b);
      ExpShared = Math.max(-16, Math.floor((0, _log2.default)(maxColor))) + 16;
      denom = Math.pow(2, ExpShared - 24);
      if (Math.floor(maxColor / denom + 0.5) == 511) {
        denom *= 2;
        ExpShared += 1;
      }
      res[i] = (Math.floor(r / denom + 0.5) << 23) + (Math.floor(g / denom + 0.5) << 14) + (Math.floor(b / denom + 0.5) << 5) + (ExpShared | 0);
    }
    return res;
  }

  /** Convert an RGB9_E5 buffer to a Float buffer.
   * @param {Uint32Array} Buffer in RGB9_E5 format. (Uint32 buffer).
   * @param {Float32Array} [res] Optional float output buffer.
   * @returns {Float32Array} A Float32Array.
   */
  function rgb9_e5ToFloat(buffer, res) {
    var v,
        s,
        l = buffer.byteLength >> 2,
        res = res || new Float32Array(l * 3);
    for (var i = 0; i < l; i++) {
      v = buffer[i];
      s = Math.pow(2, (v & 31) - 24);
      res[i * 3] = (v >>> 23) * s;
      res[i * 3 + 1] = (v >>> 14 & 511) * s;
      res[i * 3 + 2] = (v >>> 5 & 511) * s;
    }
    return res;
  }

  /** Convert a float buffer to a RGBE buffer.
   * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).
   * @param {Uint8Array} [res] Optional output buffer with 32 bit RGBE per pixel.
   * @returns {Uint8Array} A 32bit uint8 array in RGBE
   */
  function floatToRgbe(buffer, res) {
    var r,
        g,
        b,
        v,
        s,
        l = buffer.byteLength / 12 | 0,
        res = res || new Uint8Array(l * 4);
    for (var i = 0; i < l; i++) {
      r = buffer[i * 3];
      g = buffer[i * 3 + 1];
      b = buffer[i * 3 + 2];
      v = Math.max(Math.max(r, g), b);
      e = Math.ceil((0, _log2.default)(v));
      s = Math.pow(2, e - 8);
      res[i * 4] = r / s | 0;
      res[i * 4 + 1] = g / s | 0;
      res[i * 4 + 2] = b / s | 0;
      res[i * 4 + 3] = e + 128;
    }
    return res;
  }

  /** Convert an RGBE buffer to a Float buffer.
   * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)
   * @param {Float32Array} [res] Optional result buffer containing 3 floats per pixel.
   * @returns {Float32Array} A floating point buffer with 96 bits per pixel (32 per channel, 3 channels).
   */
  function rgbeToFloat(buffer, res) {
    var s,
        l = buffer.byteLength >> 2,
        res = res || new Float32Array(l * 3);
    for (var i = 0; i < l; i++) {
      s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
      res[i * 3] = buffer[i * 4] * s;
      res[i * 3 + 1] = buffer[i * 4 + 1] * s;
      res[i * 3 + 2] = buffer[i * 4 + 2] * s;
    }
    return res;
  }

  /** Convert an RGBE buffer to LDR with given exposure and display gamma.
   * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)
   * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)
   * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)
   * @param {Array} [res] res Optional result buffer.
   */
  function rgbeToLDR(buffer, exposure, gamma, res) {
    exposure = Math.pow(2, exposure === undefined ? 1 : exposure) / 2;
    if (gamma === undefined) gamma = 2.2;
    var one_over_gamma = 1 / gamma,
        s,
        l = buffer.byteLength >> 2,
        res = res || new Uint8ClampedArray(l * 4);
    for (var i = 0; i < l; i++) {
      s = exposure * Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
      res[i * 4] = 255 * Math.pow(buffer[i * 4] * s, one_over_gamma);
      res[i * 4 + 1] = 255 * Math.pow(buffer[i * 4 + 1] * s, one_over_gamma);
      res[i * 4 + 2] = 255 * Math.pow(buffer[i * 4 + 2] * s, one_over_gamma);
      res[i * 4 + 3] = 255;
    }
    return res;
  }

  /** Convert an float buffer to LDR with given exposure and display gamma.
   * @param {Float32Array} buffer The input buffer in floating point format.
   * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)
   * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)
   * @param {Array} [res] res Optional result buffer.
   */
  function floatToLDR(buffer, exposure, gamma, res) {
    exposure = Math.pow(2, exposure === undefined ? 1 : exposure) / 2;
    if (gamma === undefined) gamma = 2.2;
    var one_over_gamma = 1 / gamma,
        s,
        l = buffer.byteLength / 12 | 0,
        res = res || new Uint8ClampedArray(l * 4);
    for (var i = 0; i < l; i++) {
      res[i * 4] = 255 * Math.pow(buffer[i * 3] * exposure, one_over_gamma);
      res[i * 4 + 1] = 255 * Math.pow(buffer[i * 3 + 1] * exposure, one_over_gamma);
      res[i * 4 + 2] = 255 * Math.pow(buffer[i * 3 + 2] * exposure, one_over_gamma);
      res[i * 4 + 3] = 255;
    }
    return res;
  }

  // Float/RGBE conversions.
  HDRImage.floatToRgbe = floatToRgbe;
  HDRImage.rgbeToFloat = rgbeToFloat;

  // Float/RGB9_E5 conversions.
  HDRImage.floatToRgb9_e5 = floatToRgb9_e5;
  HDRImage.rgb9_e5ToFloat = rgb9_e5ToFloat;

  // x to LDR conversion.
  HDRImage.rgbeToLDR = rgbeToLDR;
  HDRImage.floatToLDR = floatToLDR;

  return HDRImage;
});

/***/ }),

/***/ 973:
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(1011), __esModule: true };

/***/ })

});
